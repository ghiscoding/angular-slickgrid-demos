{"version":3,"sources":["../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/directive_matching.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/core.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/compiler_facade_interface.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/i18n/digest.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/output/output_ast.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/constant_pool.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/render3/r3_identifiers.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/util.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/output/source_map.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/output/abstract_emitter.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/render3/util.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/render3/r3_factory.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/expression_parser/ast.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/ml_parser/tags.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/render3/r3_ast.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/i18n/i18n_ast.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/i18n/serializers/serializer.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/i18n/serializers/xml_helper.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/i18n/serializers/xmb.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/render3/view/i18n/util.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/render3/view/util.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/injectable_compiler_2.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/assertions.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/ml_parser/defaults.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/chars.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/parse_util.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/output/abstract_js_emitter.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/output/output_jit_trusted_types.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/output/output_jit.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/render3/r3_injector_compiler.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/render3/r3_jit.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/render3/r3_module_compiler.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/render3/r3_pipe_compiler.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/render3/view/api.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/shadow_css.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/ir/src/enums.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/ir/src/traits.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/ir/src/ops/shared.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/ir/src/ops/update.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/ir/src/expression.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/ir/src/operations.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/ir/src/handle.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/ir/src/ops/create.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/ir/src/ops/host.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/ir/src/variable.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/compilation.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/any_cast.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/apply_i18n_expressions.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/assign_i18n_slot_dependencies.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/attach_source_locations.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/util/elements.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/attribute_extraction.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/util/attributes.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/binding_specialization.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/chaining.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/collapse_singleton_interpolations.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/conditionals.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/conversion.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/const_collection.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/convert_animations.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/convert_i18n_bindings.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/create_i18n_contexts.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/deduplicate_text_bindings.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/defer_configs.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/defer_resolve_targets.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/empty_elements.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/expand_safe_reads.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/extract_i18n_messages.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/generate_advance.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/generate_local_let_references.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/generate_projection_def.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/generate_variables.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/has_const_expression_collection.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/host_style_property_parsing.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/output/map_util.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/render3/view/i18n/icu_serializer.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/ml_parser/ast.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/ml_parser/entities.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/ml_parser/lexer.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/ml_parser/parser.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/ml_parser/html_whitespaces.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/expression_parser/lexer.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/expression_parser/parser.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/expression_parser/serializer.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/schema/dom_security_schema.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/schema/element_schema_registry.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/schema/dom_element_schema_registry.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/ml_parser/html_tags.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/i18n/serializers/placeholder.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/i18n/i18n_parser.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/schema/trusted_types_sinks.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/render3/view/i18n/meta.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/render3/view/i18n/get_msg_utils.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/render3/view/i18n/localize_utils.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/i18n_const_collection.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/i18n_text_extraction.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/local_refs.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/namespace.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/parse_extracted_styles.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/naming.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/next_context_merging.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/ng_container.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/nonbindable.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/ordering.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/phase_remove_content_selectors.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/pipe_creation.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/pipe_variadic.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/propagate_i18n_blocks.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/pure_function_extraction.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/pure_literal_structures.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/instruction.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/reify.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/remove_empty_bindings.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/remove_i18n_contexts.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/remove_illegal_let_references.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/remove_unused_i18n_attrs.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/resolve_contexts.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/resolve_defer_deps_fns.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/resolve_dollar_event.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/resolve_i18n_element_placeholders.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/resolve_i18n_expression_placeholders.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/resolve_names.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/resolve_sanitizers.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/save_restore_view.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/slot_allocation.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/store_let_optimization.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/strip_nonrequired_parentheses.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/style_binding_specialization.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/temporary_variables.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/track_fn_optimization.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/track_variables.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/transform_two_way_binding_set.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/var_counting.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/variable_optimization.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/phases/wrap_icus.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/emit.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template/pipeline/src/ingest.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/render3/view/config.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/render3/view/query_generation.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/ml_parser/html_parser.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template_parser/binding_parser.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/style_url_resolver.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/template_parser/template_preparser.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/render3/r3_control_flow.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/render3/r3_deferred_triggers.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/render3/r3_deferred_blocks.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/render3/r3_template_transform.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/render3/view/template.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/render3/view/compiler.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/combined_visitor.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/render3/view/t2_binder.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/resource_loader.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/jit_compiler_facade.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/config.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/i18n/extractor_merger.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/ml_parser/xml_tags.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/ml_parser/xml_parser.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/i18n/serializers/xliff.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/i18n/serializers/xliff2.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/i18n/serializers/xtb.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/i18n/translation_bundle.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/i18n/i18n_html_parser.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/i18n/message_bundle.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/render3/r3_class_metadata_compiler.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/render3/partial/class_metadata.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/render3/partial/util.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/render3/partial/directive.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/render3/partial/component.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/render3/partial/factory.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/render3/partial/injectable.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/render3/partial/injector.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/render3/partial/ng_module.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/render3/partial/pipe.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/render3/r3_class_debug_info_compiler.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/render3/r3_hmr_compiler.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/version.ts","../k8-fastbuild-ST-199a4f3c4e20/bin/packages/compiler/src/compiler.ts","node_modules/zone.js/fesm2015/zone.js"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nconst _SELECTOR_REGEXP = new RegExp(\n  '(\\\\:not\\\\()|' + // 1: \":not(\"\n    '(([\\\\.\\\\#]?)[-\\\\w]+)|' + // 2: \"tag\"; 3: \".\"/\"#\";\n    // \"-\" should appear first in the regexp below as FF31 parses \"[.-\\w]\" as a range\n    // 4: attribute; 5: attribute_string; 6: attribute_value\n    '(?:\\\\[([-.\\\\w*\\\\\\\\$]+)(?:=([\"\\']?)([^\\\\]\"\\']*)\\\\5)?\\\\])|' + // \"[name]\", \"[name=value]\",\n    // \"[name=\"value\"]\",\n    // \"[name='value']\"\n    '(\\\\))|' + // 7: \")\"\n    '(\\\\s*,\\\\s*)', // 8: \",\"\n  'g',\n);\n\n/**\n * These offsets should match the match-groups in `_SELECTOR_REGEXP` offsets.\n */\nconst enum SelectorRegexp {\n  ALL = 0, // The whole match\n  NOT = 1,\n  TAG = 2,\n  PREFIX = 3,\n  ATTRIBUTE = 4,\n  ATTRIBUTE_STRING = 5,\n  ATTRIBUTE_VALUE = 6,\n  NOT_END = 7,\n  SEPARATOR = 8,\n}\n/**\n * A css selector contains an element name,\n * css classes and attribute/value pairs with the purpose\n * of selecting subsets out of them.\n */\nexport class CssSelector {\n  element: string | null = null;\n  classNames: string[] = [];\n  /**\n   * The selectors are encoded in pairs where:\n   * - even locations are attribute names\n   * - odd locations are attribute values.\n   *\n   * Example:\n   * Selector: `[key1=value1][key2]` would parse to:\n   * ```\n   * ['key1', 'value1', 'key2', '']\n   * ```\n   */\n  attrs: string[] = [];\n  notSelectors: CssSelector[] = [];\n\n  static parse(selector: string): CssSelector[] {\n    const results: CssSelector[] = [];\n    const _addResult = (res: CssSelector[], cssSel: CssSelector) => {\n      if (\n        cssSel.notSelectors.length > 0 &&\n        !cssSel.element &&\n        cssSel.classNames.length == 0 &&\n        cssSel.attrs.length == 0\n      ) {\n        cssSel.element = '*';\n      }\n      res.push(cssSel);\n    };\n    let cssSelector = new CssSelector();\n    let match: string[] | null;\n    let current = cssSelector;\n    let inNot = false;\n    _SELECTOR_REGEXP.lastIndex = 0;\n    while ((match = _SELECTOR_REGEXP.exec(selector))) {\n      if (match[SelectorRegexp.NOT]) {\n        if (inNot) {\n          throw new Error('Nesting :not in a selector is not allowed');\n        }\n        inNot = true;\n        current = new CssSelector();\n        cssSelector.notSelectors.push(current);\n      }\n      const tag = match[SelectorRegexp.TAG];\n      if (tag) {\n        const prefix = match[SelectorRegexp.PREFIX];\n        if (prefix === '#') {\n          // #hash\n          current.addAttribute('id', tag.slice(1));\n        } else if (prefix === '.') {\n          // Class\n          current.addClassName(tag.slice(1));\n        } else {\n          // Element\n          current.setElement(tag);\n        }\n      }\n      const attribute = match[SelectorRegexp.ATTRIBUTE];\n\n      if (attribute) {\n        current.addAttribute(\n          current.unescapeAttribute(attribute),\n          match[SelectorRegexp.ATTRIBUTE_VALUE],\n        );\n      }\n      if (match[SelectorRegexp.NOT_END]) {\n        inNot = false;\n        current = cssSelector;\n      }\n      if (match[SelectorRegexp.SEPARATOR]) {\n        if (inNot) {\n          throw new Error('Multiple selectors in :not are not supported');\n        }\n        _addResult(results, cssSelector);\n        cssSelector = current = new CssSelector();\n      }\n    }\n    _addResult(results, cssSelector);\n    return results;\n  }\n\n  /**\n   * Unescape `\\$` sequences from the CSS attribute selector.\n   *\n   * This is needed because `$` can have a special meaning in CSS selectors,\n   * but we might want to match an attribute that contains `$`.\n   * [MDN web link for more\n   * info](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors).\n   * @param attr the attribute to unescape.\n   * @returns the unescaped string.\n   */\n  unescapeAttribute(attr: string): string {\n    let result = '';\n    let escaping = false;\n    for (let i = 0; i < attr.length; i++) {\n      const char = attr.charAt(i);\n      if (char === '\\\\') {\n        escaping = true;\n        continue;\n      }\n      if (char === '$' && !escaping) {\n        throw new Error(\n          `Error in attribute selector \"${attr}\". ` +\n            `Unescaped \"$\" is not supported. Please escape with \"\\\\$\".`,\n        );\n      }\n      escaping = false;\n      result += char;\n    }\n    return result;\n  }\n\n  /**\n   * Escape `$` sequences from the CSS attribute selector.\n   *\n   * This is needed because `$` can have a special meaning in CSS selectors,\n   * with this method we are escaping `$` with `\\$'.\n   * [MDN web link for more\n   * info](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors).\n   * @param attr the attribute to escape.\n   * @returns the escaped string.\n   */\n  escapeAttribute(attr: string): string {\n    return attr.replace(/\\\\/g, '\\\\\\\\').replace(/\\$/g, '\\\\$');\n  }\n\n  isElementSelector(): boolean {\n    return (\n      this.hasElementSelector() &&\n      this.classNames.length == 0 &&\n      this.attrs.length == 0 &&\n      this.notSelectors.length === 0\n    );\n  }\n\n  hasElementSelector(): boolean {\n    return !!this.element;\n  }\n\n  setElement(element: string | null = null) {\n    this.element = element;\n  }\n\n  getAttrs(): string[] {\n    const result: string[] = [];\n    if (this.classNames.length > 0) {\n      result.push('class', this.classNames.join(' '));\n    }\n    return result.concat(this.attrs);\n  }\n\n  addAttribute(name: string, value: string = '') {\n    this.attrs.push(name, (value && value.toLowerCase()) || '');\n  }\n\n  addClassName(name: string) {\n    this.classNames.push(name.toLowerCase());\n  }\n\n  toString(): string {\n    let res: string = this.element || '';\n    if (this.classNames) {\n      this.classNames.forEach((klass) => (res += `.${klass}`));\n    }\n    if (this.attrs) {\n      for (let i = 0; i < this.attrs.length; i += 2) {\n        const name = this.escapeAttribute(this.attrs[i]);\n        const value = this.attrs[i + 1];\n        res += `[${name}${value ? '=' + value : ''}]`;\n      }\n    }\n    this.notSelectors.forEach((notSelector) => (res += `:not(${notSelector})`));\n    return res;\n  }\n}\n\n/**\n * Reads a list of CssSelectors and allows to calculate which ones\n * are contained in a given CssSelector.\n */\nexport class SelectorMatcher<T = any> {\n  static createNotMatcher(notSelectors: CssSelector[]): SelectorMatcher<null> {\n    const notMatcher = new SelectorMatcher<null>();\n    notMatcher.addSelectables(notSelectors, null);\n    return notMatcher;\n  }\n\n  private _elementMap = new Map<string, SelectorContext<T>[]>();\n  private _elementPartialMap = new Map<string, SelectorMatcher<T>>();\n  private _classMap = new Map<string, SelectorContext<T>[]>();\n  private _classPartialMap = new Map<string, SelectorMatcher<T>>();\n  private _attrValueMap = new Map<string, Map<string, SelectorContext<T>[]>>();\n  private _attrValuePartialMap = new Map<string, Map<string, SelectorMatcher<T>>>();\n  private _listContexts: SelectorListContext[] = [];\n\n  addSelectables(cssSelectors: CssSelector[], callbackCtxt?: T) {\n    let listContext: SelectorListContext = null!;\n    if (cssSelectors.length > 1) {\n      listContext = new SelectorListContext(cssSelectors);\n      this._listContexts.push(listContext);\n    }\n    for (let i = 0; i < cssSelectors.length; i++) {\n      this._addSelectable(cssSelectors[i], callbackCtxt as T, listContext);\n    }\n  }\n\n  /**\n   * Add an object that can be found later on by calling `match`.\n   * @param cssSelector A css selector\n   * @param callbackCtxt An opaque object that will be given to the callback of the `match` function\n   */\n  private _addSelectable(\n    cssSelector: CssSelector,\n    callbackCtxt: T,\n    listContext: SelectorListContext,\n  ) {\n    let matcher: SelectorMatcher<T> = this;\n    const element = cssSelector.element;\n    const classNames = cssSelector.classNames;\n    const attrs = cssSelector.attrs;\n    const selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);\n\n    if (element) {\n      const isTerminal = attrs.length === 0 && classNames.length === 0;\n      if (isTerminal) {\n        this._addTerminal(matcher._elementMap, element, selectable);\n      } else {\n        matcher = this._addPartial(matcher._elementPartialMap, element);\n      }\n    }\n\n    if (classNames) {\n      for (let i = 0; i < classNames.length; i++) {\n        const isTerminal = attrs.length === 0 && i === classNames.length - 1;\n        const className = classNames[i];\n        if (isTerminal) {\n          this._addTerminal(matcher._classMap, className, selectable);\n        } else {\n          matcher = this._addPartial(matcher._classPartialMap, className);\n        }\n      }\n    }\n\n    if (attrs) {\n      for (let i = 0; i < attrs.length; i += 2) {\n        const isTerminal = i === attrs.length - 2;\n        const name = attrs[i];\n        const value = attrs[i + 1];\n        if (isTerminal) {\n          const terminalMap = matcher._attrValueMap;\n          let terminalValuesMap = terminalMap.get(name);\n          if (!terminalValuesMap) {\n            terminalValuesMap = new Map<string, SelectorContext<T>[]>();\n            terminalMap.set(name, terminalValuesMap);\n          }\n          this._addTerminal(terminalValuesMap, value, selectable);\n        } else {\n          const partialMap = matcher._attrValuePartialMap;\n          let partialValuesMap = partialMap.get(name);\n          if (!partialValuesMap) {\n            partialValuesMap = new Map<string, SelectorMatcher<T>>();\n            partialMap.set(name, partialValuesMap);\n          }\n          matcher = this._addPartial(partialValuesMap, value);\n        }\n      }\n    }\n  }\n\n  private _addTerminal(\n    map: Map<string, SelectorContext<T>[]>,\n    name: string,\n    selectable: SelectorContext<T>,\n  ) {\n    let terminalList = map.get(name);\n    if (!terminalList) {\n      terminalList = [];\n      map.set(name, terminalList);\n    }\n    terminalList.push(selectable);\n  }\n\n  private _addPartial(map: Map<string, SelectorMatcher<T>>, name: string): SelectorMatcher<T> {\n    let matcher = map.get(name);\n    if (!matcher) {\n      matcher = new SelectorMatcher<T>();\n      map.set(name, matcher);\n    }\n    return matcher;\n  }\n\n  /**\n   * Find the objects that have been added via `addSelectable`\n   * whose css selector is contained in the given css selector.\n   * @param cssSelector A css selector\n   * @param matchedCallback This callback will be called with the object handed into `addSelectable`\n   * @return boolean true if a match was found\n   */\n  match(\n    cssSelector: CssSelector,\n    matchedCallback: ((c: CssSelector, a: T) => void) | null,\n  ): boolean {\n    let result = false;\n    const element = cssSelector.element!;\n    const classNames = cssSelector.classNames;\n    const attrs = cssSelector.attrs;\n\n    for (let i = 0; i < this._listContexts.length; i++) {\n      this._listContexts[i].alreadyMatched = false;\n    }\n\n    result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;\n    result =\n      this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) || result;\n\n    if (classNames) {\n      for (let i = 0; i < classNames.length; i++) {\n        const className = classNames[i];\n        result =\n          this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;\n        result =\n          this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) ||\n          result;\n      }\n    }\n\n    if (attrs) {\n      for (let i = 0; i < attrs.length; i += 2) {\n        const name = attrs[i];\n        const value = attrs[i + 1];\n\n        const terminalValuesMap = this._attrValueMap.get(name)!;\n        if (value) {\n          result =\n            this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;\n        }\n        result =\n          this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;\n\n        const partialValuesMap = this._attrValuePartialMap.get(name)!;\n        if (value) {\n          result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;\n        }\n        result =\n          this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;\n      }\n    }\n    return result;\n  }\n\n  /** @internal */\n  _matchTerminal(\n    map: Map<string, SelectorContext<T>[]>,\n    name: string,\n    cssSelector: CssSelector,\n    matchedCallback: ((c: CssSelector, a: any) => void) | null,\n  ): boolean {\n    if (!map || typeof name !== 'string') {\n      return false;\n    }\n\n    let selectables: SelectorContext<T>[] = map.get(name) || [];\n    const starSelectables: SelectorContext<T>[] = map.get('*')!;\n    if (starSelectables) {\n      selectables = selectables.concat(starSelectables);\n    }\n    if (selectables.length === 0) {\n      return false;\n    }\n    let selectable: SelectorContext<T>;\n    let result = false;\n    for (let i = 0; i < selectables.length; i++) {\n      selectable = selectables[i];\n      result = selectable.finalize(cssSelector, matchedCallback) || result;\n    }\n    return result;\n  }\n\n  /** @internal */\n  _matchPartial(\n    map: Map<string, SelectorMatcher<T>>,\n    name: string,\n    cssSelector: CssSelector,\n    matchedCallback: ((c: CssSelector, a: any) => void) | null,\n  ): boolean {\n    if (!map || typeof name !== 'string') {\n      return false;\n    }\n\n    const nestedSelector = map.get(name);\n    if (!nestedSelector) {\n      return false;\n    }\n    // TODO(perf): get rid of recursion and measure again\n    // TODO(perf): don't pass the whole selector into the recursion,\n    // but only the not processed parts\n    return nestedSelector.match(cssSelector, matchedCallback);\n  }\n}\n\nexport class SelectorListContext {\n  alreadyMatched: boolean = false;\n\n  constructor(public selectors: CssSelector[]) {}\n}\n\n// Store context to pass back selector and context when a selector is matched\nexport class SelectorContext<T = any> {\n  notSelectors: CssSelector[];\n\n  constructor(\n    public selector: CssSelector,\n    public cbContext: T,\n    public listContext: SelectorListContext,\n  ) {\n    this.notSelectors = selector.notSelectors;\n  }\n\n  finalize(cssSelector: CssSelector, callback: ((c: CssSelector, a: T) => void) | null): boolean {\n    let result = true;\n    if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {\n      const notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);\n      result = !notMatcher.match(cssSelector, null);\n    }\n    if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {\n      if (this.listContext) {\n        this.listContext.alreadyMatched = true;\n      }\n      callback(this.selector, this.cbContext);\n    }\n    return result;\n  }\n}\n\nexport class SelectorlessMatcher<T = unknown> {\n  constructor(private registry: Map<string, T[]>) {}\n\n  match(name: string): T[] {\n    return this.registry.has(name) ? this.registry.get(name)! : [];\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n// Attention:\n// This file duplicates types and values from @angular/core\n// so that we are able to make @angular/compiler independent of @angular/core.\n// This is important to prevent a build cycle, as @angular/core needs to\n// be compiled with the compiler.\n\nimport {CssSelector} from './directive_matching';\n\n// Stores the default value of `emitDistinctChangesOnly` when the `emitDistinctChangesOnly` is not\n// explicitly set.\nexport const emitDistinctChangesOnlyDefaultValue = true;\n\nexport enum ViewEncapsulation {\n  Emulated = 0,\n  // Historically the 1 value was for `Native` encapsulation which has been removed as of v11.\n  None = 2,\n  ShadowDom = 3,\n}\n\nexport enum ChangeDetectionStrategy {\n  OnPush = 0,\n  Default = 1,\n}\n\nexport interface Input {\n  alias?: string;\n  required?: boolean;\n  transform?: (value: any) => any;\n  // Note: This field is marked as `internal` in `@angular/core`, but in the compiler\n  // we rely on it for JIT processing at runtime.\n  isSignal: boolean;\n}\n\n/** Flags describing an input for a directive. */\nexport enum InputFlags {\n  None = 0,\n  SignalBased = 1 << 0,\n  HasDecoratorInputTransform = 1 << 1,\n}\n\nexport interface Output {\n  alias?: string;\n}\n\nexport interface HostBinding {\n  hostPropertyName?: string;\n}\n\nexport interface HostListener {\n  eventName?: string;\n  args?: string[];\n}\n\nexport interface SchemaMetadata {\n  name: string;\n}\n\nexport const CUSTOM_ELEMENTS_SCHEMA: SchemaMetadata = {\n  name: 'custom-elements',\n};\n\nexport const NO_ERRORS_SCHEMA: SchemaMetadata = {\n  name: 'no-errors-schema',\n};\n\nexport interface Type extends Function {\n  new (...args: any[]): any;\n}\nexport const Type = Function;\n\nexport enum SecurityContext {\n  NONE = 0,\n  HTML = 1,\n  STYLE = 2,\n  SCRIPT = 3,\n  URL = 4,\n  RESOURCE_URL = 5,\n}\n\n/**\n * Injection flags for DI.\n */\nexport const enum InjectFlags {\n  Default = 0,\n\n  /**\n   * Specifies that an injector should retrieve a dependency from any injector until reaching the\n   * host element of the current component. (Only used with Element Injector)\n   */\n  Host = 1 << 0,\n  /** Don't descend into ancestors of the node requesting injection. */\n  Self = 1 << 1,\n  /** Skip the node that is requesting injection. */\n  SkipSelf = 1 << 2,\n  /** Inject `defaultValue` instead if token not found. */\n  Optional = 1 << 3,\n  /**\n   * This token is being injected into a pipe.\n   * @internal\n   */\n  ForPipe = 1 << 4,\n}\n\nexport enum MissingTranslationStrategy {\n  Error = 0,\n  Warning = 1,\n  Ignore = 2,\n}\n\n/**\n * Flags used to generate R3-style CSS Selectors. They are pasted from\n * core/src/render3/projection.ts because they cannot be referenced directly.\n */\nexport const enum SelectorFlags {\n  /** Indicates this is the beginning of a new negative selector */\n  NOT = 0b0001,\n\n  /** Mode for matching attributes */\n  ATTRIBUTE = 0b0010,\n\n  /** Mode for matching tag names */\n  ELEMENT = 0b0100,\n\n  /** Mode for matching class names */\n  CLASS = 0b1000,\n}\n\n// These are a copy the CSS types from core/src/render3/interfaces/projection.ts\n// They are duplicated here as they cannot be directly referenced from core.\nexport type R3CssSelector = (string | SelectorFlags)[];\nexport type R3CssSelectorList = R3CssSelector[];\n\nfunction parserSelectorToSimpleSelector(selector: CssSelector): R3CssSelector {\n  const classes =\n    selector.classNames && selector.classNames.length\n      ? [SelectorFlags.CLASS, ...selector.classNames]\n      : [];\n  const elementName = selector.element && selector.element !== '*' ? selector.element : '';\n  return [elementName, ...selector.attrs, ...classes];\n}\n\nfunction parserSelectorToNegativeSelector(selector: CssSelector): R3CssSelector {\n  const classes =\n    selector.classNames && selector.classNames.length\n      ? [SelectorFlags.CLASS, ...selector.classNames]\n      : [];\n\n  if (selector.element) {\n    return [\n      SelectorFlags.NOT | SelectorFlags.ELEMENT,\n      selector.element,\n      ...selector.attrs,\n      ...classes,\n    ];\n  } else if (selector.attrs.length) {\n    return [SelectorFlags.NOT | SelectorFlags.ATTRIBUTE, ...selector.attrs, ...classes];\n  } else {\n    return selector.classNames && selector.classNames.length\n      ? [SelectorFlags.NOT | SelectorFlags.CLASS, ...selector.classNames]\n      : [];\n  }\n}\n\nfunction parserSelectorToR3Selector(selector: CssSelector): R3CssSelector {\n  const positive = parserSelectorToSimpleSelector(selector);\n\n  const negative: R3CssSelectorList =\n    selector.notSelectors && selector.notSelectors.length\n      ? selector.notSelectors.map((notSelector) => parserSelectorToNegativeSelector(notSelector))\n      : [];\n\n  return positive.concat(...negative);\n}\n\nexport function parseSelectorToR3Selector(selector: string | null): R3CssSelectorList {\n  return selector ? CssSelector.parse(selector).map(parserSelectorToR3Selector) : [];\n}\n\n// Pasted from render3/interfaces/definition since it cannot be referenced directly\n/**\n * Flags passed into template functions to determine which blocks (i.e. creation, update)\n * should be executed.\n *\n * Typically, a template runs both the creation block and the update block on initialization and\n * subsequent runs only execute the update block. However, dynamically created views require that\n * the creation block be executed separately from the update block (for backwards compat).\n */\nexport const enum RenderFlags {\n  /* Whether to run the creation block (e.g. create elements and directives) */\n  Create = 0b01,\n\n  /* Whether to run the update block (e.g. refresh bindings) */\n  Update = 0b10,\n}\n\n// Pasted from render3/interfaces/node.ts\n/**\n * A set of marker values to be used in the attributes arrays. These markers indicate that some\n * items are not regular attributes and the processing should be adapted accordingly.\n */\nexport const enum AttributeMarker {\n  /**\n   * Marker indicates that the following 3 values in the attributes array are:\n   * namespaceUri, attributeName, attributeValue\n   * in that order.\n   */\n  NamespaceURI = 0,\n\n  /**\n   * Signals class declaration.\n   *\n   * Each value following `Classes` designates a class name to include on the element.\n   * ## Example:\n   *\n   * Given:\n   * ```html\n   * <div class=\"foo bar baz\">...</div>\n   * ```\n   *\n   * the generated code is:\n   * ```ts\n   * var _c1 = [AttributeMarker.Classes, 'foo', 'bar', 'baz'];\n   * ```\n   */\n  Classes = 1,\n\n  /**\n   * Signals style declaration.\n   *\n   * Each pair of values following `Styles` designates a style name and value to include on the\n   * element.\n   * ## Example:\n   *\n   * Given:\n   * ```html\n   * <div style=\"width:100px; height:200px; color:red\">...</div>\n   * ```\n   *\n   * the generated code is:\n   * ```ts\n   * var _c1 = [AttributeMarker.Styles, 'width', '100px', 'height'. '200px', 'color', 'red'];\n   * ```\n   */\n  Styles = 2,\n\n  /**\n   * Signals that the following attribute names were extracted from input or output bindings.\n   *\n   * For example, given the following HTML:\n   *\n   * ```html\n   * <div moo=\"car\" [foo]=\"exp\" (bar)=\"doSth()\">\n   * ```\n   *\n   * the generated code is:\n   *\n   * ```ts\n   * var _c1 = ['moo', 'car', AttributeMarker.Bindings, 'foo', 'bar'];\n   * ```\n   */\n  Bindings = 3,\n\n  /**\n   * Signals that the following attribute names were hoisted from an inline-template declaration.\n   *\n   * For example, given the following HTML:\n   *\n   * ```html\n   * <div *ngFor=\"let value of values; trackBy:trackBy\" dirA [dirB]=\"value\">\n   * ```\n   *\n   * the generated code for the `template()` instruction would include:\n   *\n   * ```\n   * ['dirA', '', AttributeMarker.Bindings, 'dirB', AttributeMarker.Template, 'ngFor', 'ngForOf',\n   * 'ngForTrackBy', 'let-value']\n   * ```\n   *\n   * while the generated code for the `element()` instruction inside the template function would\n   * include:\n   *\n   * ```\n   * ['dirA', '', AttributeMarker.Bindings, 'dirB']\n   * ```\n   */\n  Template = 4,\n\n  /**\n   * Signals that the following attribute is `ngProjectAs` and its value is a parsed `CssSelector`.\n   *\n   * For example, given the following HTML:\n   *\n   * ```html\n   * <h1 attr=\"value\" ngProjectAs=\"[title]\">\n   * ```\n   *\n   * the generated code for the `element()` instruction would include:\n   *\n   * ```\n   * ['attr', 'value', AttributeMarker.ProjectAs, ['', 'title', '']]\n   * ```\n   */\n  ProjectAs = 5,\n\n  /**\n   * Signals that the following attribute will be translated by runtime i18n\n   *\n   * For example, given the following HTML:\n   *\n   * ```html\n   * <div moo=\"car\" foo=\"value\" i18n-foo [bar]=\"binding\" i18n-bar>\n   * ```\n   *\n   * the generated code is:\n   *\n   * ```ts\n   * var _c1 = ['moo', 'car', AttributeMarker.I18n, 'foo', 'bar'];\n   * ```\n   */\n  I18n = 6,\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/**\n * A set of interfaces which are shared between `@angular/core` and `@angular/compiler` to allow\n * for late binding of `@angular/compiler` for JIT purposes.\n *\n * This file has two copies. Please ensure that they are in sync:\n *  - packages/compiler/src/compiler_facade_interface.ts          (main)\n *  - packages/core/src/compiler/compiler_facade_interface.ts     (replica)\n *\n * Please ensure that the two files are in sync using this command:\n * ```shell\n * cp packages/compiler/src/compiler_facade_interface.ts \\\n *    packages/core/src/compiler/compiler_facade_interface.ts\n * ```\n */\n\nexport interface ExportedCompilerFacade {\n  ɵcompilerFacade: CompilerFacade;\n}\n\nexport interface CompilerFacade {\n  compilePipe(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    meta: R3PipeMetadataFacade,\n  ): any;\n  compilePipeDeclaration(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    declaration: R3DeclarePipeFacade,\n  ): any;\n  compileInjectable(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    meta: R3InjectableMetadataFacade,\n  ): any;\n  compileInjectableDeclaration(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    meta: R3DeclareInjectableFacade,\n  ): any;\n  compileInjector(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    meta: R3InjectorMetadataFacade,\n  ): any;\n  compileInjectorDeclaration(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    declaration: R3DeclareInjectorFacade,\n  ): any;\n  compileNgModule(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    meta: R3NgModuleMetadataFacade,\n  ): any;\n  compileNgModuleDeclaration(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    declaration: R3DeclareNgModuleFacade,\n  ): any;\n  compileDirective(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    meta: R3DirectiveMetadataFacade,\n  ): any;\n  compileDirectiveDeclaration(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    declaration: R3DeclareDirectiveFacade,\n  ): any;\n  compileComponent(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    meta: R3ComponentMetadataFacade,\n  ): any;\n  compileComponentDeclaration(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    declaration: R3DeclareComponentFacade,\n  ): any;\n  compileFactory(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    meta: R3FactoryDefMetadataFacade,\n  ): any;\n  compileFactoryDeclaration(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    meta: R3DeclareFactoryFacade,\n  ): any;\n\n  createParseSourceSpan(kind: string, typeName: string, sourceUrl: string): ParseSourceSpan;\n\n  FactoryTarget: typeof FactoryTarget;\n  // Note that we do not use `{new(): ResourceLoader}` here because\n  // the resource loader class is abstract and not constructable.\n  ResourceLoader: Function & {prototype: ResourceLoader};\n}\n\nexport interface CoreEnvironment {\n  [name: string]: unknown;\n}\n\nexport type ResourceLoader = {\n  get(url: string): Promise<string> | string;\n};\n\nexport type Provider = unknown;\nexport type Type = Function;\nexport type OpaqueValue = unknown;\n\nexport enum FactoryTarget {\n  Directive = 0,\n  Component = 1,\n  Injectable = 2,\n  Pipe = 3,\n  NgModule = 4,\n}\n\nexport interface R3DependencyMetadataFacade {\n  token: OpaqueValue;\n  attribute: string | null;\n  host: boolean;\n  optional: boolean;\n  self: boolean;\n  skipSelf: boolean;\n}\n\nexport interface R3DeclareDependencyMetadataFacade {\n  token: OpaqueValue;\n  attribute?: boolean;\n  host?: boolean;\n  optional?: boolean;\n  self?: boolean;\n  skipSelf?: boolean;\n}\n\nexport interface R3PipeMetadataFacade {\n  name: string;\n  type: Type;\n  pipeName: string | null;\n  pure: boolean;\n  isStandalone: boolean;\n}\n\nexport interface R3InjectableMetadataFacade {\n  name: string;\n  type: Type;\n  typeArgumentCount: number;\n  providedIn?: Type | 'root' | 'platform' | 'any' | null;\n  useClass?: OpaqueValue;\n  useFactory?: OpaqueValue;\n  useExisting?: OpaqueValue;\n  useValue?: OpaqueValue;\n  deps?: R3DependencyMetadataFacade[];\n}\n\nexport interface R3NgModuleMetadataFacade {\n  type: Type;\n  bootstrap: Function[];\n  declarations: Function[];\n  imports: Function[];\n  exports: Function[];\n  schemas: {name: string}[] | null;\n  id: string | null;\n}\n\nexport interface R3InjectorMetadataFacade {\n  name: string;\n  type: Type;\n  providers: Provider[];\n  imports: OpaqueValue[];\n}\n\nexport interface R3HostDirectiveMetadataFacade {\n  directive: Type;\n  inputs?: string[];\n  outputs?: string[];\n}\n\nexport interface R3DirectiveMetadataFacade {\n  name: string;\n  type: Type;\n  typeSourceSpan: ParseSourceSpan;\n  selector: string | null;\n  queries: R3QueryMetadataFacade[];\n  host: {[key: string]: string};\n  propMetadata: {[key: string]: OpaqueValue[]};\n  lifecycle: {usesOnChanges: boolean};\n  inputs: (string | {name: string; alias?: string; required?: boolean})[];\n  outputs: string[];\n  usesInheritance: boolean;\n  exportAs: string[] | null;\n  providers: Provider[] | null;\n  viewQueries: R3QueryMetadataFacade[];\n  isStandalone: boolean;\n  hostDirectives: R3HostDirectiveMetadataFacade[] | null;\n  isSignal: boolean;\n}\n\nexport interface R3ComponentMetadataFacade extends R3DirectiveMetadataFacade {\n  template: string;\n  preserveWhitespaces: boolean;\n  animations: OpaqueValue[] | undefined;\n  declarations: R3TemplateDependencyFacade[];\n  styles: string[];\n  encapsulation: ViewEncapsulation;\n  viewProviders: Provider[] | null;\n  interpolation?: [string, string];\n  changeDetection?: ChangeDetectionStrategy;\n  hasDirectiveDependencies: boolean;\n}\n\n// TODO(legacy-partial-output-inputs): Remove in v18.\n// https://github.com/angular/angular/blob/d4b423690210872b5c32a322a6090beda30b05a3/packages/core/src/compiler/compiler_facade_interface.ts#L197-L199\nexport type LegacyInputPartialMapping =\n  | string\n  | [bindingPropertyName: string, classPropertyName: string, transformFunction?: Function];\n\nexport interface R3DeclareDirectiveFacade {\n  selector?: string;\n  type: Type;\n  version: string;\n  inputs?: {\n    [fieldName: string]:\n      | {\n          classPropertyName: string;\n          publicName: string;\n          isSignal: boolean;\n          isRequired: boolean;\n          transformFunction: Function | null;\n        }\n      | LegacyInputPartialMapping;\n  };\n  outputs?: {[classPropertyName: string]: string};\n  host?: {\n    attributes?: {[key: string]: OpaqueValue};\n    listeners?: {[key: string]: string};\n    properties?: {[key: string]: string};\n    classAttribute?: string;\n    styleAttribute?: string;\n  };\n  queries?: R3DeclareQueryMetadataFacade[];\n  viewQueries?: R3DeclareQueryMetadataFacade[];\n  providers?: OpaqueValue;\n  exportAs?: string[];\n  usesInheritance?: boolean;\n  usesOnChanges?: boolean;\n  isStandalone?: boolean;\n  isSignal?: boolean;\n  hostDirectives?: R3HostDirectiveMetadataFacade[] | null;\n}\n\nexport interface R3DeclareComponentFacade extends R3DeclareDirectiveFacade {\n  template: string;\n  isInline?: boolean;\n  styles?: string[];\n\n  // Post-standalone libraries use a unified dependencies field.\n  dependencies?: R3DeclareTemplateDependencyFacade[];\n\n  // Pre-standalone libraries have separate component/directive/pipe fields:\n  components?: R3DeclareDirectiveDependencyFacade[];\n  directives?: R3DeclareDirectiveDependencyFacade[];\n  pipes?: {[pipeName: string]: OpaqueValue | (() => OpaqueValue)};\n\n  deferBlockDependencies?: (() => Promise<Type> | null)[];\n  viewProviders?: OpaqueValue;\n  animations?: OpaqueValue;\n  changeDetection?: ChangeDetectionStrategy;\n  encapsulation?: ViewEncapsulation;\n  interpolation?: [string, string];\n  preserveWhitespaces?: boolean;\n}\n\nexport type R3DeclareTemplateDependencyFacade = {\n  kind: string;\n} & (\n  | R3DeclareDirectiveDependencyFacade\n  | R3DeclarePipeDependencyFacade\n  | R3DeclareNgModuleDependencyFacade\n);\n\nexport interface R3DeclareDirectiveDependencyFacade {\n  kind?: 'directive' | 'component';\n  selector: string;\n  type: OpaqueValue | (() => OpaqueValue);\n  inputs?: string[];\n  outputs?: string[];\n  exportAs?: string[];\n}\n\nexport interface R3DeclarePipeDependencyFacade {\n  kind?: 'pipe';\n  name: string;\n  type: OpaqueValue | (() => OpaqueValue);\n}\n\nexport interface R3DeclareNgModuleDependencyFacade {\n  kind: 'ngmodule';\n  type: OpaqueValue | (() => OpaqueValue);\n}\n\nexport enum R3TemplateDependencyKind {\n  Directive = 0,\n  Pipe = 1,\n  NgModule = 2,\n}\n\nexport interface R3TemplateDependencyFacade {\n  kind: R3TemplateDependencyKind;\n  type: OpaqueValue | (() => OpaqueValue);\n}\nexport interface R3FactoryDefMetadataFacade {\n  name: string;\n  type: Type;\n  typeArgumentCount: number;\n  deps: R3DependencyMetadataFacade[] | null;\n  target: FactoryTarget;\n}\n\nexport interface R3DeclareFactoryFacade {\n  type: Type;\n  deps: R3DeclareDependencyMetadataFacade[] | 'invalid' | null;\n  target: FactoryTarget;\n}\n\nexport interface R3DeclareInjectableFacade {\n  type: Type;\n  providedIn?: Type | 'root' | 'platform' | 'any' | null;\n  useClass?: OpaqueValue;\n  useFactory?: OpaqueValue;\n  useExisting?: OpaqueValue;\n  useValue?: OpaqueValue;\n  deps?: R3DeclareDependencyMetadataFacade[];\n}\n\nexport enum ViewEncapsulation {\n  Emulated = 0,\n  // Historically the 1 value was for `Native` encapsulation which has been removed as of v11.\n  None = 2,\n  ShadowDom = 3,\n}\n\nexport type ChangeDetectionStrategy = number;\n\nexport interface R3QueryMetadataFacade {\n  propertyName: string;\n  first: boolean;\n  predicate: OpaqueValue | string[];\n  descendants: boolean;\n  emitDistinctChangesOnly: boolean;\n  read: OpaqueValue | null;\n  static: boolean;\n  isSignal: boolean;\n}\n\nexport interface R3DeclareQueryMetadataFacade {\n  propertyName: string;\n  first?: boolean;\n  predicate: OpaqueValue | string[];\n  descendants?: boolean;\n  read?: OpaqueValue;\n  static?: boolean;\n  emitDistinctChangesOnly?: boolean;\n  isSignal?: boolean;\n}\n\nexport interface R3DeclareInjectorFacade {\n  type: Type;\n  imports?: OpaqueValue[];\n  providers?: OpaqueValue[];\n}\n\nexport interface R3DeclareNgModuleFacade {\n  type: Type;\n  bootstrap?: OpaqueValue[] | (() => OpaqueValue[]);\n  declarations?: OpaqueValue[] | (() => OpaqueValue[]);\n  imports?: OpaqueValue[] | (() => OpaqueValue[]);\n  exports?: OpaqueValue[] | (() => OpaqueValue[]);\n  schemas?: OpaqueValue[];\n  id?: OpaqueValue;\n}\n\nexport interface R3DeclarePipeFacade {\n  type: Type;\n  version: string;\n  name: string;\n  pure?: boolean;\n  isStandalone?: boolean;\n}\n\nexport interface ParseSourceSpan {\n  start: any;\n  end: any;\n  details: any;\n  fullStart: any;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Byte} from '../util';\n\nimport * as i18n from './i18n_ast';\n\n/**\n * A lazily created TextEncoder instance for converting strings into UTF-8 bytes\n */\nlet textEncoder: TextEncoder | undefined;\n\n/**\n * Return the message id or compute it using the XLIFF1 digest.\n */\nexport function digest(message: i18n.Message): string {\n  return message.id || computeDigest(message);\n}\n\n/**\n * Compute the message id using the XLIFF1 digest.\n */\nexport function computeDigest(message: i18n.Message): string {\n  return sha1(serializeNodes(message.nodes).join('') + `[${message.meaning}]`);\n}\n\n/**\n * Return the message id or compute it using the XLIFF2/XMB/$localize digest.\n */\nexport function decimalDigest(message: i18n.Message): string {\n  return message.id || computeDecimalDigest(message);\n}\n\n/**\n * Compute the message id using the XLIFF2/XMB/$localize digest.\n */\nexport function computeDecimalDigest(message: i18n.Message): string {\n  const visitor = new _SerializerIgnoreIcuExpVisitor();\n  const parts = message.nodes.map((a) => a.visit(visitor, null));\n  return computeMsgId(parts.join(''), message.meaning);\n}\n\n/**\n * Serialize the i18n ast to something xml-like in order to generate an UID.\n *\n * The visitor is also used in the i18n parser tests\n *\n * @internal\n */\nclass _SerializerVisitor implements i18n.Visitor {\n  visitText(text: i18n.Text, context: any): any {\n    return text.value;\n  }\n\n  visitContainer(container: i18n.Container, context: any): any {\n    return `[${container.children.map((child) => child.visit(this)).join(', ')}]`;\n  }\n\n  visitIcu(icu: i18n.Icu, context: any): any {\n    const strCases = Object.keys(icu.cases).map(\n      (k: string) => `${k} {${icu.cases[k].visit(this)}}`,\n    );\n    return `{${icu.expression}, ${icu.type}, ${strCases.join(', ')}}`;\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context: any): any {\n    return ph.isVoid\n      ? `<ph tag name=\"${ph.startName}\"/>`\n      : `<ph tag name=\"${ph.startName}\">${ph.children\n          .map((child) => child.visit(this))\n          .join(', ')}</ph name=\"${ph.closeName}\">`;\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context: any): any {\n    return ph.value ? `<ph name=\"${ph.name}\">${ph.value}</ph>` : `<ph name=\"${ph.name}\"/>`;\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): any {\n    return `<ph icu name=\"${ph.name}\">${ph.value.visit(this)}</ph>`;\n  }\n\n  visitBlockPlaceholder(ph: i18n.BlockPlaceholder, context: any): any {\n    return `<ph block name=\"${ph.startName}\">${ph.children\n      .map((child) => child.visit(this))\n      .join(', ')}</ph name=\"${ph.closeName}\">`;\n  }\n}\n\nconst serializerVisitor = new _SerializerVisitor();\n\nexport function serializeNodes(nodes: i18n.Node[]): string[] {\n  return nodes.map((a) => a.visit(serializerVisitor, null));\n}\n\n/**\n * Serialize the i18n ast to something xml-like in order to generate an UID.\n *\n * Ignore the ICU expressions so that message IDs stays identical if only the expression changes.\n *\n * @internal\n */\nclass _SerializerIgnoreIcuExpVisitor extends _SerializerVisitor {\n  override visitIcu(icu: i18n.Icu): string {\n    let strCases = Object.keys(icu.cases).map((k: string) => `${k} {${icu.cases[k].visit(this)}}`);\n    // Do not take the expression into account\n    return `{${icu.type}, ${strCases.join(', ')}}`;\n  }\n}\n\n/**\n * Compute the SHA1 of the given string\n *\n * see https://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf\n *\n * WARNING: this function has not been designed not tested with security in mind.\n *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.\n */\nexport function sha1(str: string): string {\n  textEncoder ??= new TextEncoder();\n  const utf8 = [...textEncoder.encode(str)];\n  const words32 = bytesToWords32(utf8, Endian.Big);\n  const len = utf8.length * 8;\n\n  const w = new Uint32Array(80);\n  let a = 0x67452301,\n    b = 0xefcdab89,\n    c = 0x98badcfe,\n    d = 0x10325476,\n    e = 0xc3d2e1f0;\n\n  words32[len >> 5] |= 0x80 << (24 - (len % 32));\n  words32[(((len + 64) >> 9) << 4) + 15] = len;\n\n  for (let i = 0; i < words32.length; i += 16) {\n    const h0 = a,\n      h1 = b,\n      h2 = c,\n      h3 = d,\n      h4 = e;\n\n    for (let j = 0; j < 80; j++) {\n      if (j < 16) {\n        w[j] = words32[i + j];\n      } else {\n        w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);\n      }\n\n      const fkVal = fk(j, b, c, d);\n      const f = fkVal[0];\n      const k = fkVal[1];\n      const temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);\n      e = d;\n      d = c;\n      c = rol32(b, 30);\n      b = a;\n      a = temp;\n    }\n    a = add32(a, h0);\n    b = add32(b, h1);\n    c = add32(c, h2);\n    d = add32(d, h3);\n    e = add32(e, h4);\n  }\n\n  // Convert the output parts to a 160-bit hexadecimal string\n  return toHexU32(a) + toHexU32(b) + toHexU32(c) + toHexU32(d) + toHexU32(e);\n}\n\n/**\n * Convert and format a number as a string representing a 32-bit unsigned hexadecimal number.\n * @param value The value to format as a string.\n * @returns A hexadecimal string representing the value.\n */\nfunction toHexU32(value: number): string {\n  // unsigned right shift of zero ensures an unsigned 32-bit number\n  return (value >>> 0).toString(16).padStart(8, '0');\n}\n\nfunction fk(index: number, b: number, c: number, d: number): [number, number] {\n  if (index < 20) {\n    return [(b & c) | (~b & d), 0x5a827999];\n  }\n\n  if (index < 40) {\n    return [b ^ c ^ d, 0x6ed9eba1];\n  }\n\n  if (index < 60) {\n    return [(b & c) | (b & d) | (c & d), 0x8f1bbcdc];\n  }\n\n  return [b ^ c ^ d, 0xca62c1d6];\n}\n\n/**\n * Compute the fingerprint of the given string\n *\n * The output is 64 bit number encoded as a decimal string\n *\n * based on:\n * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/GoogleJsMessageIdGenerator.java\n */\nexport function fingerprint(str: string): bigint {\n  textEncoder ??= new TextEncoder();\n  const utf8 = textEncoder.encode(str);\n  const view = new DataView(utf8.buffer, utf8.byteOffset, utf8.byteLength);\n\n  let hi = hash32(view, utf8.length, 0);\n  let lo = hash32(view, utf8.length, 102072);\n\n  if (hi == 0 && (lo == 0 || lo == 1)) {\n    hi = hi ^ 0x130f9bef;\n    lo = lo ^ -0x6b5f56d8;\n  }\n\n  return (BigInt.asUintN(32, BigInt(hi)) << BigInt(32)) | BigInt.asUintN(32, BigInt(lo));\n}\n\nexport function computeMsgId(msg: string, meaning: string = ''): string {\n  let msgFingerprint = fingerprint(msg);\n\n  if (meaning) {\n    // Rotate the 64-bit message fingerprint one bit to the left and then add the meaning\n    // fingerprint.\n    msgFingerprint =\n      BigInt.asUintN(64, msgFingerprint << BigInt(1)) |\n      ((msgFingerprint >> BigInt(63)) & BigInt(1));\n    msgFingerprint += fingerprint(meaning);\n  }\n\n  return BigInt.asUintN(63, msgFingerprint).toString();\n}\n\nfunction hash32(view: DataView, length: number, c: number): number {\n  let a = 0x9e3779b9,\n    b = 0x9e3779b9;\n  let index = 0;\n\n  const end = length - 12;\n  for (; index <= end; index += 12) {\n    a += view.getUint32(index, true);\n    b += view.getUint32(index + 4, true);\n    c += view.getUint32(index + 8, true);\n    const res = mix(a, b, c);\n    (a = res[0]), (b = res[1]), (c = res[2]);\n  }\n\n  const remainder = length - index;\n\n  // the first byte of c is reserved for the length\n  c += length;\n\n  if (remainder >= 4) {\n    a += view.getUint32(index, true);\n    index += 4;\n\n    if (remainder >= 8) {\n      b += view.getUint32(index, true);\n      index += 4;\n\n      // Partial 32-bit word for c\n      if (remainder >= 9) {\n        c += view.getUint8(index++) << 8;\n      }\n      if (remainder >= 10) {\n        c += view.getUint8(index++) << 16;\n      }\n      if (remainder === 11) {\n        c += view.getUint8(index++) << 24;\n      }\n    } else {\n      // Partial 32-bit word for b\n      if (remainder >= 5) {\n        b += view.getUint8(index++);\n      }\n      if (remainder >= 6) {\n        b += view.getUint8(index++) << 8;\n      }\n      if (remainder === 7) {\n        b += view.getUint8(index++) << 16;\n      }\n    }\n  } else {\n    // Partial 32-bit word for a\n    if (remainder >= 1) {\n      a += view.getUint8(index++);\n    }\n    if (remainder >= 2) {\n      a += view.getUint8(index++) << 8;\n    }\n    if (remainder === 3) {\n      a += view.getUint8(index++) << 16;\n    }\n  }\n\n  return mix(a, b, c)[2];\n}\n\nfunction mix(a: number, b: number, c: number): [number, number, number] {\n  a -= b;\n  a -= c;\n  a ^= c >>> 13;\n  b -= c;\n  b -= a;\n  b ^= a << 8;\n  c -= a;\n  c -= b;\n  c ^= b >>> 13;\n  a -= b;\n  a -= c;\n  a ^= c >>> 12;\n  b -= c;\n  b -= a;\n  b ^= a << 16;\n  c -= a;\n  c -= b;\n  c ^= b >>> 5;\n  a -= b;\n  a -= c;\n  a ^= c >>> 3;\n  b -= c;\n  b -= a;\n  b ^= a << 10;\n  c -= a;\n  c -= b;\n  c ^= b >>> 15;\n  return [a, b, c];\n}\n\n// Utils\n\nenum Endian {\n  Little,\n  Big,\n}\n\nfunction add32(a: number, b: number): number {\n  return add32to64(a, b)[1];\n}\n\nfunction add32to64(a: number, b: number): [number, number] {\n  const low = (a & 0xffff) + (b & 0xffff);\n  const high = (a >>> 16) + (b >>> 16) + (low >>> 16);\n  return [high >>> 16, (high << 16) | (low & 0xffff)];\n}\n\n// Rotate a 32b number left `count` position\nfunction rol32(a: number, count: number): number {\n  return (a << count) | (a >>> (32 - count));\n}\n\nfunction bytesToWords32(bytes: Byte[], endian: Endian): number[] {\n  const size = (bytes.length + 3) >>> 2;\n  const words32 = [];\n\n  for (let i = 0; i < size; i++) {\n    words32[i] = wordAt(bytes, i * 4, endian);\n  }\n\n  return words32;\n}\n\nfunction byteAt(bytes: Byte[], index: number): Byte {\n  return index >= bytes.length ? 0 : bytes[index];\n}\n\nfunction wordAt(bytes: Byte[], index: number, endian: Endian): number {\n  let word = 0;\n  if (endian === Endian.Big) {\n    for (let i = 0; i < 4; i++) {\n      word += byteAt(bytes, index + i) << (24 - 8 * i);\n    }\n  } else {\n    for (let i = 0; i < 4; i++) {\n      word += byteAt(bytes, index + i) << (8 * i);\n    }\n  }\n  return word;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computeMsgId} from '../i18n/digest';\nimport {Message} from '../i18n/i18n_ast';\nimport {ParseSourceSpan} from '../parse_util';\nimport type {I18nMeta} from '../render3/view/i18n/meta';\n\n//// Types\nexport enum TypeModifier {\n  None = 0,\n  Const = 1 << 0,\n}\n\nexport abstract class Type {\n  constructor(public modifiers: TypeModifier = TypeModifier.None) {}\n  abstract visitType(visitor: TypeVisitor, context: any): any;\n\n  hasModifier(modifier: TypeModifier): boolean {\n    return (this.modifiers & modifier) !== 0;\n  }\n}\n\nexport enum BuiltinTypeName {\n  Dynamic,\n  Bool,\n  String,\n  Int,\n  Number,\n  Function,\n  Inferred,\n  None,\n}\n\nexport class BuiltinType extends Type {\n  constructor(\n    public name: BuiltinTypeName,\n    modifiers?: TypeModifier,\n  ) {\n    super(modifiers);\n  }\n  override visitType(visitor: TypeVisitor, context: any): any {\n    return visitor.visitBuiltinType(this, context);\n  }\n}\n\nexport class ExpressionType extends Type {\n  constructor(\n    public value: Expression,\n    modifiers?: TypeModifier,\n    public typeParams: Type[] | null = null,\n  ) {\n    super(modifiers);\n  }\n  override visitType(visitor: TypeVisitor, context: any): any {\n    return visitor.visitExpressionType(this, context);\n  }\n}\n\nexport class ArrayType extends Type {\n  constructor(\n    public of: Type,\n    modifiers?: TypeModifier,\n  ) {\n    super(modifiers);\n  }\n  override visitType(visitor: TypeVisitor, context: any): any {\n    return visitor.visitArrayType(this, context);\n  }\n}\n\nexport class MapType extends Type {\n  public valueType: Type | null;\n  constructor(valueType: Type | null | undefined, modifiers?: TypeModifier) {\n    super(modifiers);\n    this.valueType = valueType || null;\n  }\n  override visitType(visitor: TypeVisitor, context: any): any {\n    return visitor.visitMapType(this, context);\n  }\n}\n\nexport class TransplantedType<T> extends Type {\n  constructor(\n    readonly type: T,\n    modifiers?: TypeModifier,\n  ) {\n    super(modifiers);\n  }\n  override visitType(visitor: TypeVisitor, context: any): any {\n    return visitor.visitTransplantedType(this, context);\n  }\n}\n\nexport const DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);\nexport const INFERRED_TYPE = new BuiltinType(BuiltinTypeName.Inferred);\nexport const BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);\nexport const INT_TYPE = new BuiltinType(BuiltinTypeName.Int);\nexport const NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);\nexport const STRING_TYPE = new BuiltinType(BuiltinTypeName.String);\nexport const FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);\nexport const NONE_TYPE = new BuiltinType(BuiltinTypeName.None);\n\nexport interface TypeVisitor {\n  visitBuiltinType(type: BuiltinType, context: any): any;\n  visitExpressionType(type: ExpressionType, context: any): any;\n  visitArrayType(type: ArrayType, context: any): any;\n  visitMapType(type: MapType, context: any): any;\n  visitTransplantedType(type: TransplantedType<unknown>, context: any): any;\n}\n\n///// Expressions\n\nexport enum UnaryOperator {\n  Minus,\n  Plus,\n}\n\nexport enum BinaryOperator {\n  Equals,\n  NotEquals,\n  Assign,\n  Identical,\n  NotIdentical,\n  Minus,\n  Plus,\n  Divide,\n  Multiply,\n  Modulo,\n  And,\n  Or,\n  BitwiseOr,\n  BitwiseAnd,\n  Lower,\n  LowerEquals,\n  Bigger,\n  BiggerEquals,\n  NullishCoalesce,\n  Exponentiation,\n  In,\n  AdditionAssignment,\n  SubtractionAssignment,\n  MultiplicationAssignment,\n  DivisionAssignment,\n  RemainderAssignment,\n  ExponentiationAssignment,\n  AndAssignment,\n  OrAssignment,\n  NullishCoalesceAssignment,\n}\n\nexport function nullSafeIsEquivalent<T extends {isEquivalent(other: T): boolean}>(\n  base: T | null,\n  other: T | null,\n) {\n  if (base == null || other == null) {\n    return base == other;\n  }\n  return base.isEquivalent(other);\n}\n\nfunction areAllEquivalentPredicate<T>(\n  base: T[],\n  other: T[],\n  equivalentPredicate: (baseElement: T, otherElement: T) => boolean,\n) {\n  const len = base.length;\n  if (len !== other.length) {\n    return false;\n  }\n  for (let i = 0; i < len; i++) {\n    if (!equivalentPredicate(base[i], other[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function areAllEquivalent<T extends {isEquivalent(other: T): boolean}>(\n  base: T[],\n  other: T[],\n) {\n  return areAllEquivalentPredicate(base, other, (baseElement: T, otherElement: T) =>\n    baseElement.isEquivalent(otherElement),\n  );\n}\n\nexport abstract class Expression {\n  public type: Type | null;\n  public sourceSpan: ParseSourceSpan | null;\n\n  constructor(type: Type | null | undefined, sourceSpan?: ParseSourceSpan | null) {\n    this.type = type || null;\n    this.sourceSpan = sourceSpan || null;\n  }\n\n  abstract visitExpression(visitor: ExpressionVisitor, context: any): any;\n\n  /**\n   * Calculates whether this expression produces the same value as the given expression.\n   * Note: We don't check Types nor ParseSourceSpans nor function arguments.\n   */\n  abstract isEquivalent(e: Expression): boolean;\n\n  /**\n   * Return true if the expression is constant.\n   */\n  abstract isConstant(): boolean;\n\n  abstract clone(): Expression;\n\n  prop(name: string, sourceSpan?: ParseSourceSpan | null): ReadPropExpr {\n    return new ReadPropExpr(this, name, null, sourceSpan);\n  }\n\n  key(index: Expression, type?: Type | null, sourceSpan?: ParseSourceSpan | null): ReadKeyExpr {\n    return new ReadKeyExpr(this, index, type, sourceSpan);\n  }\n\n  callFn(\n    params: Expression[],\n    sourceSpan?: ParseSourceSpan | null,\n    pure?: boolean,\n  ): InvokeFunctionExpr {\n    return new InvokeFunctionExpr(this, params, null, sourceSpan, pure);\n  }\n\n  instantiate(\n    params: Expression[],\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ): InstantiateExpr {\n    return new InstantiateExpr(this, params, type, sourceSpan);\n  }\n\n  conditional(\n    trueCase: Expression,\n    falseCase: Expression | null = null,\n    sourceSpan?: ParseSourceSpan | null,\n  ): ConditionalExpr {\n    return new ConditionalExpr(this, trueCase, falseCase, null, sourceSpan);\n  }\n\n  equals(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs, null, sourceSpan);\n  }\n  notEquals(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs, null, sourceSpan);\n  }\n  identical(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs, null, sourceSpan);\n  }\n  notIdentical(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs, null, sourceSpan);\n  }\n  minus(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs, null, sourceSpan);\n  }\n  plus(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs, null, sourceSpan);\n  }\n  divide(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs, null, sourceSpan);\n  }\n  multiply(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs, null, sourceSpan);\n  }\n  modulo(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs, null, sourceSpan);\n  }\n  power(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Exponentiation, this, rhs, null, sourceSpan);\n  }\n  and(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.And, this, rhs, null, sourceSpan);\n  }\n  bitwiseOr(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.BitwiseOr, this, rhs, null, sourceSpan);\n  }\n  bitwiseAnd(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.BitwiseAnd, this, rhs, null, sourceSpan);\n  }\n  or(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs, null, sourceSpan);\n  }\n  lower(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs, null, sourceSpan);\n  }\n  lowerEquals(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs, null, sourceSpan);\n  }\n  bigger(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs, null, sourceSpan);\n  }\n  biggerEquals(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs, null, sourceSpan);\n  }\n  isBlank(sourceSpan?: ParseSourceSpan | null): Expression {\n    // Note: We use equals by purpose here to compare to null and undefined in JS.\n    // We use the typed null to allow strictNullChecks to narrow types.\n    return this.equals(TYPED_NULL_EXPR, sourceSpan);\n  }\n  nullishCoalesce(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.NullishCoalesce, this, rhs, null, sourceSpan);\n  }\n\n  toStmt(): Statement {\n    return new ExpressionStatement(this, null);\n  }\n}\n\nexport class ReadVarExpr extends Expression {\n  constructor(\n    public name: string,\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof ReadVarExpr && this.name === e.name;\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitReadVarExpr(this, context);\n  }\n\n  override clone(): ReadVarExpr {\n    return new ReadVarExpr(this.name, this.type, this.sourceSpan);\n  }\n\n  set(value: Expression): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Assign, this, value, null, this.sourceSpan);\n  }\n}\n\nexport class TypeofExpr extends Expression {\n  constructor(\n    public expr: Expression,\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any) {\n    return visitor.visitTypeofExpr(this, context);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof TypeofExpr && e.expr.isEquivalent(this.expr);\n  }\n\n  override isConstant(): boolean {\n    return this.expr.isConstant();\n  }\n\n  override clone(): TypeofExpr {\n    return new TypeofExpr(this.expr.clone());\n  }\n}\n\nexport class VoidExpr extends Expression {\n  constructor(\n    public expr: Expression,\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any) {\n    return visitor.visitVoidExpr(this, context);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof VoidExpr && e.expr.isEquivalent(this.expr);\n  }\n\n  override isConstant(): boolean {\n    return this.expr.isConstant();\n  }\n\n  override clone(): VoidExpr {\n    return new VoidExpr(this.expr.clone());\n  }\n}\n\nexport class WrappedNodeExpr<T> extends Expression {\n  constructor(\n    public node: T,\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof WrappedNodeExpr && this.node === e.node;\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitWrappedNodeExpr(this, context);\n  }\n\n  override clone(): WrappedNodeExpr<T> {\n    return new WrappedNodeExpr(this.node, this.type, this.sourceSpan);\n  }\n}\n\nexport class InvokeFunctionExpr extends Expression {\n  constructor(\n    public fn: Expression,\n    public args: Expression[],\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n    public pure = false,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  // An alias for fn, which allows other logic to handle calls and property reads together.\n  get receiver(): Expression {\n    return this.fn;\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return (\n      e instanceof InvokeFunctionExpr &&\n      this.fn.isEquivalent(e.fn) &&\n      areAllEquivalent(this.args, e.args) &&\n      this.pure === e.pure\n    );\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitInvokeFunctionExpr(this, context);\n  }\n\n  override clone(): InvokeFunctionExpr {\n    return new InvokeFunctionExpr(\n      this.fn.clone(),\n      this.args.map((arg) => arg.clone()),\n      this.type,\n      this.sourceSpan,\n      this.pure,\n    );\n  }\n}\n\nexport class TaggedTemplateLiteralExpr extends Expression {\n  constructor(\n    public tag: Expression,\n    public template: TemplateLiteralExpr,\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return (\n      e instanceof TaggedTemplateLiteralExpr &&\n      this.tag.isEquivalent(e.tag) &&\n      this.template.isEquivalent(e.template)\n    );\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitTaggedTemplateLiteralExpr(this, context);\n  }\n\n  override clone(): TaggedTemplateLiteralExpr {\n    return new TaggedTemplateLiteralExpr(\n      this.tag.clone(),\n      this.template.clone(),\n      this.type,\n      this.sourceSpan,\n    );\n  }\n}\n\nexport class InstantiateExpr extends Expression {\n  constructor(\n    public classExpr: Expression,\n    public args: Expression[],\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return (\n      e instanceof InstantiateExpr &&\n      this.classExpr.isEquivalent(e.classExpr) &&\n      areAllEquivalent(this.args, e.args)\n    );\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitInstantiateExpr(this, context);\n  }\n\n  override clone(): InstantiateExpr {\n    return new InstantiateExpr(\n      this.classExpr.clone(),\n      this.args.map((arg) => arg.clone()),\n      this.type,\n      this.sourceSpan,\n    );\n  }\n}\n\nexport class LiteralExpr extends Expression {\n  constructor(\n    public value: number | string | boolean | null | undefined,\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof LiteralExpr && this.value === e.value;\n  }\n\n  override isConstant() {\n    return true;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitLiteralExpr(this, context);\n  }\n\n  override clone(): LiteralExpr {\n    return new LiteralExpr(this.value, this.type, this.sourceSpan);\n  }\n}\n\nexport class TemplateLiteralExpr extends Expression {\n  constructor(\n    public elements: TemplateLiteralElementExpr[],\n    public expressions: Expression[],\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(null, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return (\n      e instanceof TemplateLiteralExpr &&\n      areAllEquivalentPredicate(this.elements, e.elements, (a, b) => a.text === b.text) &&\n      areAllEquivalent(this.expressions, e.expressions)\n    );\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitTemplateLiteralExpr(this, context);\n  }\n\n  override clone(): TemplateLiteralExpr {\n    return new TemplateLiteralExpr(\n      this.elements.map((el) => el.clone()),\n      this.expressions.map((expr) => expr.clone()),\n    );\n  }\n}\nexport class TemplateLiteralElementExpr extends Expression {\n  readonly rawText: string;\n\n  constructor(\n    readonly text: string,\n    sourceSpan?: ParseSourceSpan | null,\n    rawText?: string,\n  ) {\n    super(STRING_TYPE, sourceSpan);\n\n    // If `rawText` is not provided, \"fake\" the raw string by escaping the following sequences:\n    // - \"\\\" would otherwise indicate that the next character is a control character.\n    // - \"`\" and \"${\" are template string control sequences that would otherwise prematurely\n    // indicate the end of the template literal element.\n    // Note that we can't rely on the `sourceSpan` here, because it may be incorrect (see\n    // https://github.com/angular/angular/pull/60267#discussion_r1986402524).\n    this.rawText = rawText ?? escapeForTemplateLiteral(escapeSlashes(text));\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any) {\n    return visitor.visitTemplateLiteralElementExpr(this, context);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return (\n      e instanceof TemplateLiteralElementExpr && e.text === this.text && e.rawText === this.rawText\n    );\n  }\n\n  override isConstant(): boolean {\n    return true;\n  }\n\n  override clone(): TemplateLiteralElementExpr {\n    return new TemplateLiteralElementExpr(this.text, this.sourceSpan, this.rawText);\n  }\n}\n\nexport class LiteralPiece {\n  constructor(\n    public text: string,\n    public sourceSpan: ParseSourceSpan,\n  ) {}\n}\nexport class PlaceholderPiece {\n  /**\n   * Create a new instance of a `PlaceholderPiece`.\n   *\n   * @param text the name of this placeholder (e.g. `PH_1`).\n   * @param sourceSpan the location of this placeholder in its localized message the source code.\n   * @param associatedMessage reference to another message that this placeholder is associated with.\n   * The `associatedMessage` is mainly used to provide a relationship to an ICU message that has\n   * been extracted out from the message containing the placeholder.\n   */\n  constructor(\n    public text: string,\n    public sourceSpan: ParseSourceSpan,\n    public associatedMessage?: Message,\n  ) {}\n}\n\nexport type MessagePiece = LiteralPiece | PlaceholderPiece;\n\nconst MEANING_SEPARATOR = '|';\nconst ID_SEPARATOR = '@@';\nconst LEGACY_ID_INDICATOR = '␟';\n\nexport class LocalizedString extends Expression {\n  constructor(\n    readonly metaBlock: I18nMeta,\n    readonly messageParts: LiteralPiece[],\n    readonly placeHolderNames: PlaceholderPiece[],\n    readonly expressions: Expression[],\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(STRING_TYPE, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    // return e instanceof LocalizedString && this.message === e.message;\n    return false;\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitLocalizedString(this, context);\n  }\n\n  override clone(): LocalizedString {\n    return new LocalizedString(\n      this.metaBlock,\n      this.messageParts,\n      this.placeHolderNames,\n      this.expressions.map((expr) => expr.clone()),\n      this.sourceSpan,\n    );\n  }\n\n  /**\n   * Serialize the given `meta` and `messagePart` into \"cooked\" and \"raw\" strings that can be used\n   * in a `$localize` tagged string. The format of the metadata is the same as that parsed by\n   * `parseI18nMeta()`.\n   *\n   * @param meta The metadata to serialize\n   * @param messagePart The first part of the tagged string\n   */\n  serializeI18nHead(): CookedRawString {\n    let metaBlock = this.metaBlock.description || '';\n    if (this.metaBlock.meaning) {\n      metaBlock = `${this.metaBlock.meaning}${MEANING_SEPARATOR}${metaBlock}`;\n    }\n    if (this.metaBlock.customId) {\n      metaBlock = `${metaBlock}${ID_SEPARATOR}${this.metaBlock.customId}`;\n    }\n    if (this.metaBlock.legacyIds) {\n      this.metaBlock.legacyIds.forEach((legacyId) => {\n        metaBlock = `${metaBlock}${LEGACY_ID_INDICATOR}${legacyId}`;\n      });\n    }\n    return createCookedRawString(\n      metaBlock,\n      this.messageParts[0].text,\n      this.getMessagePartSourceSpan(0),\n    );\n  }\n\n  getMessagePartSourceSpan(i: number): ParseSourceSpan | null {\n    return this.messageParts[i]?.sourceSpan ?? this.sourceSpan;\n  }\n\n  getPlaceholderSourceSpan(i: number): ParseSourceSpan {\n    return (\n      this.placeHolderNames[i]?.sourceSpan ?? this.expressions[i]?.sourceSpan ?? this.sourceSpan\n    );\n  }\n\n  /**\n   * Serialize the given `placeholderName` and `messagePart` into \"cooked\" and \"raw\" strings that\n   * can be used in a `$localize` tagged string.\n   *\n   * The format is `:<placeholder-name>[@@<associated-id>]:`.\n   *\n   * The `associated-id` is the message id of the (usually an ICU) message to which this placeholder\n   * refers.\n   *\n   * @param partIndex The index of the message part to serialize.\n   */\n  serializeI18nTemplatePart(partIndex: number): CookedRawString {\n    const placeholder = this.placeHolderNames[partIndex - 1];\n    const messagePart = this.messageParts[partIndex];\n    let metaBlock = placeholder.text;\n    if (placeholder.associatedMessage?.legacyIds.length === 0) {\n      metaBlock += `${ID_SEPARATOR}${computeMsgId(\n        placeholder.associatedMessage.messageString,\n        placeholder.associatedMessage.meaning,\n      )}`;\n    }\n    return createCookedRawString(\n      metaBlock,\n      messagePart.text,\n      this.getMessagePartSourceSpan(partIndex),\n    );\n  }\n}\n\n/**\n * A structure to hold the cooked and raw strings of a template literal element, along with its\n * source-span range.\n */\nexport interface CookedRawString {\n  cooked: string;\n  raw: string;\n  range: ParseSourceSpan | null;\n}\n\nconst escapeSlashes = (str: string): string => str.replace(/\\\\/g, '\\\\\\\\');\nconst escapeStartingColon = (str: string): string => str.replace(/^:/, '\\\\:');\nconst escapeColons = (str: string): string => str.replace(/:/g, '\\\\:');\nconst escapeForTemplateLiteral = (str: string): string =>\n  str.replace(/`/g, '\\\\`').replace(/\\${/g, '$\\\\{');\n\n/**\n * Creates a `{cooked, raw}` object from the `metaBlock` and `messagePart`.\n *\n * The `raw` text must have various character sequences escaped:\n * * \"\\\" would otherwise indicate that the next character is a control character.\n * * \"`\" and \"${\" are template string control sequences that would otherwise prematurely indicate\n *   the end of a message part.\n * * \":\" inside a metablock would prematurely indicate the end of the metablock.\n * * \":\" at the start of a messagePart with no metablock would erroneously indicate the start of a\n *   metablock.\n *\n * @param metaBlock Any metadata that should be prepended to the string\n * @param messagePart The message part of the string\n */\nfunction createCookedRawString(\n  metaBlock: string,\n  messagePart: string,\n  range: ParseSourceSpan | null,\n): CookedRawString {\n  if (metaBlock === '') {\n    return {\n      cooked: messagePart,\n      raw: escapeForTemplateLiteral(escapeStartingColon(escapeSlashes(messagePart))),\n      range,\n    };\n  } else {\n    return {\n      cooked: `:${metaBlock}:${messagePart}`,\n      raw: escapeForTemplateLiteral(\n        `:${escapeColons(escapeSlashes(metaBlock))}:${escapeSlashes(messagePart)}`,\n      ),\n      range,\n    };\n  }\n}\n\nexport class ExternalExpr extends Expression {\n  constructor(\n    public value: ExternalReference,\n    type?: Type | null,\n    public typeParams: Type[] | null = null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return (\n      e instanceof ExternalExpr &&\n      this.value.name === e.value.name &&\n      this.value.moduleName === e.value.moduleName\n    );\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitExternalExpr(this, context);\n  }\n\n  override clone(): ExternalExpr {\n    return new ExternalExpr(this.value, this.type, this.typeParams, this.sourceSpan);\n  }\n}\n\nexport class ExternalReference {\n  constructor(\n    public moduleName: string | null,\n    public name: string | null,\n  ) {}\n  // Note: no isEquivalent method here as we use this as an interface too.\n}\n\nexport class ConditionalExpr extends Expression {\n  public trueCase: Expression;\n\n  constructor(\n    public condition: Expression,\n    trueCase: Expression,\n    public falseCase: Expression | null = null,\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type || trueCase.type, sourceSpan);\n    this.trueCase = trueCase;\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return (\n      e instanceof ConditionalExpr &&\n      this.condition.isEquivalent(e.condition) &&\n      this.trueCase.isEquivalent(e.trueCase) &&\n      nullSafeIsEquivalent(this.falseCase, e.falseCase)\n    );\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitConditionalExpr(this, context);\n  }\n\n  override clone(): ConditionalExpr {\n    return new ConditionalExpr(\n      this.condition.clone(),\n      this.trueCase.clone(),\n      this.falseCase?.clone(),\n      this.type,\n      this.sourceSpan,\n    );\n  }\n}\n\nexport class DynamicImportExpr extends Expression {\n  constructor(\n    public url: string | Expression,\n    sourceSpan?: ParseSourceSpan | null,\n    public urlComment?: string,\n  ) {\n    super(null, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof DynamicImportExpr && this.url === e.url && this.urlComment === e.urlComment;\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitDynamicImportExpr(this, context);\n  }\n\n  override clone(): DynamicImportExpr {\n    return new DynamicImportExpr(\n      typeof this.url === 'string' ? this.url : this.url.clone(),\n      this.sourceSpan,\n      this.urlComment,\n    );\n  }\n}\n\nexport class NotExpr extends Expression {\n  constructor(\n    public condition: Expression,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(BOOL_TYPE, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof NotExpr && this.condition.isEquivalent(e.condition);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitNotExpr(this, context);\n  }\n\n  override clone(): NotExpr {\n    return new NotExpr(this.condition.clone(), this.sourceSpan);\n  }\n}\n\nexport class FnParam {\n  constructor(\n    public name: string,\n    public type: Type | null = null,\n  ) {}\n\n  isEquivalent(param: FnParam): boolean {\n    return this.name === param.name;\n  }\n\n  clone(): FnParam {\n    return new FnParam(this.name, this.type);\n  }\n}\n\nexport class FunctionExpr extends Expression {\n  constructor(\n    public params: FnParam[],\n    public statements: Statement[],\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n    public name?: string | null,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression | Statement): boolean {\n    return (\n      (e instanceof FunctionExpr || e instanceof DeclareFunctionStmt) &&\n      areAllEquivalent(this.params, e.params) &&\n      areAllEquivalent(this.statements, e.statements)\n    );\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitFunctionExpr(this, context);\n  }\n\n  toDeclStmt(name: string, modifiers?: StmtModifier): DeclareFunctionStmt {\n    return new DeclareFunctionStmt(\n      name,\n      this.params,\n      this.statements,\n      this.type,\n      modifiers,\n      this.sourceSpan,\n    );\n  }\n\n  override clone(): FunctionExpr {\n    // TODO: Should we deep clone statements?\n    return new FunctionExpr(\n      this.params.map((p) => p.clone()),\n      this.statements,\n      this.type,\n      this.sourceSpan,\n      this.name,\n    );\n  }\n}\n\nexport class ArrowFunctionExpr extends Expression {\n  // Note that `body: Expression` represents `() => expr` whereas\n  // `body: Statement[]` represents `() => { expr }`.\n\n  constructor(\n    public params: FnParam[],\n    public body: Expression | Statement[],\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    if (!(e instanceof ArrowFunctionExpr) || !areAllEquivalent(this.params, e.params)) {\n      return false;\n    }\n\n    if (this.body instanceof Expression && e.body instanceof Expression) {\n      return this.body.isEquivalent(e.body);\n    }\n\n    if (Array.isArray(this.body) && Array.isArray(e.body)) {\n      return areAllEquivalent(this.body, e.body);\n    }\n\n    return false;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any) {\n    return visitor.visitArrowFunctionExpr(this, context);\n  }\n\n  override clone(): Expression {\n    // TODO: Should we deep clone statements?\n    return new ArrowFunctionExpr(\n      this.params.map((p) => p.clone()),\n      Array.isArray(this.body) ? this.body : this.body.clone(),\n      this.type,\n      this.sourceSpan,\n    );\n  }\n\n  toDeclStmt(name: string, modifiers?: StmtModifier): DeclareVarStmt {\n    return new DeclareVarStmt(name, this, INFERRED_TYPE, modifiers, this.sourceSpan);\n  }\n}\n\nexport class UnaryOperatorExpr extends Expression {\n  constructor(\n    public operator: UnaryOperator,\n    public expr: Expression,\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n    public parens: boolean = true,\n  ) {\n    super(type || NUMBER_TYPE, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return (\n      e instanceof UnaryOperatorExpr &&\n      this.operator === e.operator &&\n      this.expr.isEquivalent(e.expr)\n    );\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitUnaryOperatorExpr(this, context);\n  }\n\n  override clone(): UnaryOperatorExpr {\n    return new UnaryOperatorExpr(\n      this.operator,\n      this.expr.clone(),\n      this.type,\n      this.sourceSpan,\n      this.parens,\n    );\n  }\n}\n\nexport class ParenthesizedExpr extends Expression {\n  constructor(\n    public expr: Expression,\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any) {\n    return visitor.visitParenthesizedExpr(this, context);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    // TODO: should this ignore paren depth? i.e. is `(1)` equivalent to `1`?\n    return e instanceof ParenthesizedExpr && e.expr.isEquivalent(this.expr);\n  }\n\n  override isConstant(): boolean {\n    return this.expr.isConstant();\n  }\n\n  override clone(): ParenthesizedExpr {\n    return new ParenthesizedExpr(this.expr.clone());\n  }\n}\n\nexport class BinaryOperatorExpr extends Expression {\n  public lhs: Expression;\n  constructor(\n    public operator: BinaryOperator,\n    lhs: Expression,\n    public rhs: Expression,\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type || lhs.type, sourceSpan);\n    this.lhs = lhs;\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return (\n      e instanceof BinaryOperatorExpr &&\n      this.operator === e.operator &&\n      this.lhs.isEquivalent(e.lhs) &&\n      this.rhs.isEquivalent(e.rhs)\n    );\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitBinaryOperatorExpr(this, context);\n  }\n\n  override clone(): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(\n      this.operator,\n      this.lhs.clone(),\n      this.rhs.clone(),\n      this.type,\n      this.sourceSpan,\n    );\n  }\n\n  isAssignment(): boolean {\n    const op = this.operator;\n    return (\n      op === BinaryOperator.Assign ||\n      op === BinaryOperator.AdditionAssignment ||\n      op === BinaryOperator.SubtractionAssignment ||\n      op === BinaryOperator.MultiplicationAssignment ||\n      op === BinaryOperator.DivisionAssignment ||\n      op === BinaryOperator.RemainderAssignment ||\n      op === BinaryOperator.ExponentiationAssignment ||\n      op === BinaryOperator.AndAssignment ||\n      op === BinaryOperator.OrAssignment ||\n      op === BinaryOperator.NullishCoalesceAssignment\n    );\n  }\n}\n\nexport class ReadPropExpr extends Expression {\n  constructor(\n    public receiver: Expression,\n    public name: string,\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  // An alias for name, which allows other logic to handle property reads and keyed reads together.\n  get index() {\n    return this.name;\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return (\n      e instanceof ReadPropExpr && this.receiver.isEquivalent(e.receiver) && this.name === e.name\n    );\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitReadPropExpr(this, context);\n  }\n\n  set(value: Expression): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(\n      BinaryOperator.Assign,\n      this.receiver.prop(this.name),\n      value,\n      null,\n      this.sourceSpan,\n    );\n  }\n\n  override clone(): ReadPropExpr {\n    return new ReadPropExpr(this.receiver.clone(), this.name, this.type, this.sourceSpan);\n  }\n}\n\nexport class ReadKeyExpr extends Expression {\n  constructor(\n    public receiver: Expression,\n    public index: Expression,\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return (\n      e instanceof ReadKeyExpr &&\n      this.receiver.isEquivalent(e.receiver) &&\n      this.index.isEquivalent(e.index)\n    );\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitReadKeyExpr(this, context);\n  }\n\n  set(value: Expression): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(\n      BinaryOperator.Assign,\n      this.receiver.key(this.index),\n      value,\n      null,\n      this.sourceSpan,\n    );\n  }\n\n  override clone(): ReadKeyExpr {\n    return new ReadKeyExpr(this.receiver.clone(), this.index.clone(), this.type, this.sourceSpan);\n  }\n}\n\nexport class LiteralArrayExpr extends Expression {\n  public entries: Expression[];\n  constructor(entries: Expression[], type?: Type | null, sourceSpan?: ParseSourceSpan | null) {\n    super(type, sourceSpan);\n    this.entries = entries;\n  }\n\n  override isConstant() {\n    return this.entries.every((e) => e.isConstant());\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof LiteralArrayExpr && areAllEquivalent(this.entries, e.entries);\n  }\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitLiteralArrayExpr(this, context);\n  }\n\n  override clone(): LiteralArrayExpr {\n    return new LiteralArrayExpr(\n      this.entries.map((e) => e.clone()),\n      this.type,\n      this.sourceSpan,\n    );\n  }\n}\n\nexport class LiteralMapEntry {\n  constructor(\n    public key: string,\n    public value: Expression,\n    public quoted: boolean,\n  ) {}\n  isEquivalent(e: LiteralMapEntry): boolean {\n    return this.key === e.key && this.value.isEquivalent(e.value);\n  }\n\n  clone(): LiteralMapEntry {\n    return new LiteralMapEntry(this.key, this.value.clone(), this.quoted);\n  }\n}\n\nexport class LiteralMapExpr extends Expression {\n  public valueType: Type | null = null;\n  constructor(\n    public entries: LiteralMapEntry[],\n    type?: MapType | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type, sourceSpan);\n    if (type) {\n      this.valueType = type.valueType;\n    }\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof LiteralMapExpr && areAllEquivalent(this.entries, e.entries);\n  }\n\n  override isConstant() {\n    return this.entries.every((e) => e.value.isConstant());\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitLiteralMapExpr(this, context);\n  }\n\n  override clone(): LiteralMapExpr {\n    const entriesClone = this.entries.map((entry) => entry.clone());\n    return new LiteralMapExpr(entriesClone, this.type as MapType | null, this.sourceSpan);\n  }\n}\n\nexport class CommaExpr extends Expression {\n  constructor(\n    public parts: Expression[],\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(parts[parts.length - 1].type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof CommaExpr && areAllEquivalent(this.parts, e.parts);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitCommaExpr(this, context);\n  }\n\n  override clone(): CommaExpr {\n    return new CommaExpr(this.parts.map((p) => p.clone()));\n  }\n}\n\nexport interface ExpressionVisitor {\n  visitReadVarExpr(ast: ReadVarExpr, context: any): any;\n  visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: any): any;\n  visitTaggedTemplateLiteralExpr(ast: TaggedTemplateLiteralExpr, context: any): any;\n  visitTemplateLiteralExpr(ast: TemplateLiteralExpr, context: any): any;\n  visitTemplateLiteralElementExpr(ast: TemplateLiteralElementExpr, context: any): any;\n  visitInstantiateExpr(ast: InstantiateExpr, context: any): any;\n  visitLiteralExpr(ast: LiteralExpr, context: any): any;\n  visitLocalizedString(ast: LocalizedString, context: any): any;\n  visitExternalExpr(ast: ExternalExpr, context: any): any;\n  visitConditionalExpr(ast: ConditionalExpr, context: any): any;\n  visitDynamicImportExpr(ast: DynamicImportExpr, context: any): any;\n  visitNotExpr(ast: NotExpr, context: any): any;\n  visitFunctionExpr(ast: FunctionExpr, context: any): any;\n  visitUnaryOperatorExpr(ast: UnaryOperatorExpr, context: any): any;\n  visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: any): any;\n  visitReadPropExpr(ast: ReadPropExpr, context: any): any;\n  visitReadKeyExpr(ast: ReadKeyExpr, context: any): any;\n  visitLiteralArrayExpr(ast: LiteralArrayExpr, context: any): any;\n  visitLiteralMapExpr(ast: LiteralMapExpr, context: any): any;\n  visitCommaExpr(ast: CommaExpr, context: any): any;\n  visitWrappedNodeExpr(ast: WrappedNodeExpr<any>, context: any): any;\n  visitTypeofExpr(ast: TypeofExpr, context: any): any;\n  visitVoidExpr(ast: VoidExpr, context: any): any;\n  visitArrowFunctionExpr(ast: ArrowFunctionExpr, context: any): any;\n  visitParenthesizedExpr(ast: ParenthesizedExpr, context: any): any;\n}\n\nexport const NULL_EXPR = new LiteralExpr(null, null, null);\nexport const TYPED_NULL_EXPR = new LiteralExpr(null, INFERRED_TYPE, null);\n\n//// Statements\nexport enum StmtModifier {\n  None = 0,\n  Final = 1 << 0,\n  Private = 1 << 1,\n  Exported = 1 << 2,\n  Static = 1 << 3,\n}\n\nexport class LeadingComment {\n  constructor(\n    public text: string,\n    public multiline: boolean,\n    public trailingNewline: boolean,\n  ) {}\n  toString() {\n    return this.multiline ? ` ${this.text} ` : this.text;\n  }\n}\nexport class JSDocComment extends LeadingComment {\n  constructor(public tags: JSDocTag[]) {\n    super('', /* multiline */ true, /* trailingNewline */ true);\n  }\n  override toString(): string {\n    return serializeTags(this.tags);\n  }\n}\n\nexport abstract class Statement {\n  constructor(\n    public modifiers: StmtModifier = StmtModifier.None,\n    public sourceSpan: ParseSourceSpan | null = null,\n    public leadingComments?: LeadingComment[],\n  ) {}\n  /**\n   * Calculates whether this statement produces the same value as the given statement.\n   * Note: We don't check Types nor ParseSourceSpans nor function arguments.\n   */\n  abstract isEquivalent(stmt: Statement): boolean;\n\n  abstract visitStatement(visitor: StatementVisitor, context: any): any;\n\n  hasModifier(modifier: StmtModifier): boolean {\n    return (this.modifiers & modifier) !== 0;\n  }\n\n  addLeadingComment(leadingComment: LeadingComment): void {\n    this.leadingComments = this.leadingComments ?? [];\n    this.leadingComments.push(leadingComment);\n  }\n}\n\nexport class DeclareVarStmt extends Statement {\n  public type: Type | null;\n  constructor(\n    public name: string,\n    public value?: Expression,\n    type?: Type | null,\n    modifiers?: StmtModifier,\n    sourceSpan?: ParseSourceSpan | null,\n    leadingComments?: LeadingComment[],\n  ) {\n    super(modifiers, sourceSpan, leadingComments);\n    this.type = type || (value && value.type) || null;\n  }\n  override isEquivalent(stmt: Statement): boolean {\n    return (\n      stmt instanceof DeclareVarStmt &&\n      this.name === stmt.name &&\n      (this.value ? !!stmt.value && this.value.isEquivalent(stmt.value) : !stmt.value)\n    );\n  }\n  override visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitDeclareVarStmt(this, context);\n  }\n}\n\nexport class DeclareFunctionStmt extends Statement {\n  public type: Type | null;\n  constructor(\n    public name: string,\n    public params: FnParam[],\n    public statements: Statement[],\n    type?: Type | null,\n    modifiers?: StmtModifier,\n    sourceSpan?: ParseSourceSpan | null,\n    leadingComments?: LeadingComment[],\n  ) {\n    super(modifiers, sourceSpan, leadingComments);\n    this.type = type || null;\n  }\n  override isEquivalent(stmt: Statement): boolean {\n    return (\n      stmt instanceof DeclareFunctionStmt &&\n      areAllEquivalent(this.params, stmt.params) &&\n      areAllEquivalent(this.statements, stmt.statements)\n    );\n  }\n  override visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitDeclareFunctionStmt(this, context);\n  }\n}\n\nexport class ExpressionStatement extends Statement {\n  constructor(\n    public expr: Expression,\n    sourceSpan?: ParseSourceSpan | null,\n    leadingComments?: LeadingComment[],\n  ) {\n    super(StmtModifier.None, sourceSpan, leadingComments);\n  }\n  override isEquivalent(stmt: Statement): boolean {\n    return stmt instanceof ExpressionStatement && this.expr.isEquivalent(stmt.expr);\n  }\n  override visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitExpressionStmt(this, context);\n  }\n}\n\nexport class ReturnStatement extends Statement {\n  constructor(\n    public value: Expression,\n    sourceSpan: ParseSourceSpan | null = null,\n    leadingComments?: LeadingComment[],\n  ) {\n    super(StmtModifier.None, sourceSpan, leadingComments);\n  }\n  override isEquivalent(stmt: Statement): boolean {\n    return stmt instanceof ReturnStatement && this.value.isEquivalent(stmt.value);\n  }\n  override visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitReturnStmt(this, context);\n  }\n}\n\nexport class IfStmt extends Statement {\n  constructor(\n    public condition: Expression,\n    public trueCase: Statement[],\n    public falseCase: Statement[] = [],\n    sourceSpan?: ParseSourceSpan | null,\n    leadingComments?: LeadingComment[],\n  ) {\n    super(StmtModifier.None, sourceSpan, leadingComments);\n  }\n  override isEquivalent(stmt: Statement): boolean {\n    return (\n      stmt instanceof IfStmt &&\n      this.condition.isEquivalent(stmt.condition) &&\n      areAllEquivalent(this.trueCase, stmt.trueCase) &&\n      areAllEquivalent(this.falseCase, stmt.falseCase)\n    );\n  }\n  override visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitIfStmt(this, context);\n  }\n}\n\nexport interface StatementVisitor {\n  visitDeclareVarStmt(stmt: DeclareVarStmt, context: any): any;\n  visitDeclareFunctionStmt(stmt: DeclareFunctionStmt, context: any): any;\n  visitExpressionStmt(stmt: ExpressionStatement, context: any): any;\n  visitReturnStmt(stmt: ReturnStatement, context: any): any;\n  visitIfStmt(stmt: IfStmt, context: any): any;\n}\n\nexport class RecursiveAstVisitor implements StatementVisitor, ExpressionVisitor {\n  visitType(ast: Type, context: any): any {\n    return ast;\n  }\n  visitExpression(ast: Expression, context: any): any {\n    if (ast.type) {\n      ast.type.visitType(this, context);\n    }\n    return ast;\n  }\n  visitBuiltinType(type: BuiltinType, context: any): any {\n    return this.visitType(type, context);\n  }\n  visitExpressionType(type: ExpressionType, context: any): any {\n    type.value.visitExpression(this, context);\n    if (type.typeParams !== null) {\n      type.typeParams.forEach((param) => this.visitType(param, context));\n    }\n    return this.visitType(type, context);\n  }\n  visitArrayType(type: ArrayType, context: any): any {\n    return this.visitType(type, context);\n  }\n  visitMapType(type: MapType, context: any): any {\n    return this.visitType(type, context);\n  }\n  visitTransplantedType(type: TransplantedType<unknown>, context: any): any {\n    return type;\n  }\n  visitWrappedNodeExpr(ast: WrappedNodeExpr<any>, context: any): any {\n    return ast;\n  }\n  visitReadVarExpr(ast: ReadVarExpr, context: any): any {\n    return this.visitExpression(ast, context);\n  }\n  visitDynamicImportExpr(ast: DynamicImportExpr, context: any) {\n    return this.visitExpression(ast, context);\n  }\n  visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: any): any {\n    ast.fn.visitExpression(this, context);\n    this.visitAllExpressions(ast.args, context);\n    return this.visitExpression(ast, context);\n  }\n  visitTaggedTemplateLiteralExpr(ast: TaggedTemplateLiteralExpr, context: any): any {\n    ast.tag.visitExpression(this, context);\n    ast.template.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitInstantiateExpr(ast: InstantiateExpr, context: any): any {\n    ast.classExpr.visitExpression(this, context);\n    this.visitAllExpressions(ast.args, context);\n    return this.visitExpression(ast, context);\n  }\n  visitLiteralExpr(ast: LiteralExpr, context: any): any {\n    return this.visitExpression(ast, context);\n  }\n  visitLocalizedString(ast: LocalizedString, context: any): any {\n    return this.visitExpression(ast, context);\n  }\n  visitExternalExpr(ast: ExternalExpr, context: any): any {\n    if (ast.typeParams) {\n      ast.typeParams.forEach((type) => type.visitType(this, context));\n    }\n    return this.visitExpression(ast, context);\n  }\n  visitConditionalExpr(ast: ConditionalExpr, context: any): any {\n    ast.condition.visitExpression(this, context);\n    ast.trueCase.visitExpression(this, context);\n    ast.falseCase!.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitNotExpr(ast: NotExpr, context: any): any {\n    ast.condition.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitFunctionExpr(ast: FunctionExpr, context: any): any {\n    this.visitAllStatements(ast.statements, context);\n    return this.visitExpression(ast, context);\n  }\n  visitArrowFunctionExpr(ast: ArrowFunctionExpr, context: any): any {\n    if (Array.isArray(ast.body)) {\n      this.visitAllStatements(ast.body, context);\n    } else {\n      // Note: `body.visitExpression`, rather than `this.visitExpressiont(body)`,\n      // because the latter won't recurse into the sub-expressions.\n      ast.body.visitExpression(this, context);\n    }\n\n    return this.visitExpression(ast, context);\n  }\n  visitUnaryOperatorExpr(ast: UnaryOperatorExpr, context: any): any {\n    ast.expr.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitTypeofExpr(ast: TypeofExpr, context: any): any {\n    ast.expr.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitVoidExpr(ast: VoidExpr, context: any) {\n    ast.expr.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: any): any {\n    ast.lhs.visitExpression(this, context);\n    ast.rhs.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitReadPropExpr(ast: ReadPropExpr, context: any): any {\n    ast.receiver.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitReadKeyExpr(ast: ReadKeyExpr, context: any): any {\n    ast.receiver.visitExpression(this, context);\n    ast.index.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitLiteralArrayExpr(ast: LiteralArrayExpr, context: any): any {\n    this.visitAllExpressions(ast.entries, context);\n    return this.visitExpression(ast, context);\n  }\n  visitLiteralMapExpr(ast: LiteralMapExpr, context: any): any {\n    ast.entries.forEach((entry) => entry.value.visitExpression(this, context));\n    return this.visitExpression(ast, context);\n  }\n  visitCommaExpr(ast: CommaExpr, context: any): any {\n    this.visitAllExpressions(ast.parts, context);\n    return this.visitExpression(ast, context);\n  }\n  visitTemplateLiteralExpr(ast: TemplateLiteralExpr, context: any) {\n    this.visitAllExpressions(ast.elements, context);\n    this.visitAllExpressions(ast.expressions, context);\n    return this.visitExpression(ast, context);\n  }\n  visitTemplateLiteralElementExpr(ast: TemplateLiteralElementExpr, context: any) {\n    return this.visitExpression(ast, context);\n  }\n  visitParenthesizedExpr(ast: ParenthesizedExpr, context: any) {\n    ast.expr.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitAllExpressions(exprs: Expression[], context: any): void {\n    exprs.forEach((expr) => expr.visitExpression(this, context));\n  }\n\n  visitDeclareVarStmt(stmt: DeclareVarStmt, context: any): any {\n    if (stmt.value) {\n      stmt.value.visitExpression(this, context);\n    }\n    if (stmt.type) {\n      stmt.type.visitType(this, context);\n    }\n    return stmt;\n  }\n  visitDeclareFunctionStmt(stmt: DeclareFunctionStmt, context: any): any {\n    this.visitAllStatements(stmt.statements, context);\n    if (stmt.type) {\n      stmt.type.visitType(this, context);\n    }\n    return stmt;\n  }\n  visitExpressionStmt(stmt: ExpressionStatement, context: any): any {\n    stmt.expr.visitExpression(this, context);\n    return stmt;\n  }\n  visitReturnStmt(stmt: ReturnStatement, context: any): any {\n    stmt.value.visitExpression(this, context);\n    return stmt;\n  }\n  visitIfStmt(stmt: IfStmt, context: any): any {\n    stmt.condition.visitExpression(this, context);\n    this.visitAllStatements(stmt.trueCase, context);\n    this.visitAllStatements(stmt.falseCase, context);\n    return stmt;\n  }\n  visitAllStatements(stmts: Statement[], context: any): void {\n    stmts.forEach((stmt) => stmt.visitStatement(this, context));\n  }\n}\n\nexport function leadingComment(\n  text: string,\n  multiline: boolean = false,\n  trailingNewline: boolean = true,\n): LeadingComment {\n  return new LeadingComment(text, multiline, trailingNewline);\n}\n\nexport function jsDocComment(tags: JSDocTag[] = []): JSDocComment {\n  return new JSDocComment(tags);\n}\n\nexport function variable(\n  name: string,\n  type?: Type | null,\n  sourceSpan?: ParseSourceSpan | null,\n): ReadVarExpr {\n  return new ReadVarExpr(name, type, sourceSpan);\n}\n\nexport function importExpr(\n  id: ExternalReference,\n  typeParams: Type[] | null = null,\n  sourceSpan?: ParseSourceSpan | null,\n): ExternalExpr {\n  return new ExternalExpr(id, null, typeParams, sourceSpan);\n}\n\nexport function importType(\n  id: ExternalReference,\n  typeParams?: Type[] | null,\n  typeModifiers?: TypeModifier,\n): ExpressionType | null {\n  return id != null ? expressionType(importExpr(id, typeParams, null), typeModifiers) : null;\n}\n\nexport function expressionType(\n  expr: Expression,\n  typeModifiers?: TypeModifier,\n  typeParams?: Type[] | null,\n): ExpressionType {\n  return new ExpressionType(expr, typeModifiers, typeParams);\n}\n\nexport function transplantedType<T>(type: T, typeModifiers?: TypeModifier): TransplantedType<T> {\n  return new TransplantedType(type, typeModifiers);\n}\n\nexport function typeofExpr(expr: Expression) {\n  return new TypeofExpr(expr);\n}\n\nexport function literalArr(\n  values: Expression[],\n  type?: Type | null,\n  sourceSpan?: ParseSourceSpan | null,\n): LiteralArrayExpr {\n  return new LiteralArrayExpr(values, type, sourceSpan);\n}\n\nexport function literalMap(\n  values: {key: string; quoted: boolean; value: Expression}[],\n  type: MapType | null = null,\n): LiteralMapExpr {\n  return new LiteralMapExpr(\n    values.map((e) => new LiteralMapEntry(e.key, e.value, e.quoted)),\n    type,\n    null,\n  );\n}\n\nexport function unary(\n  operator: UnaryOperator,\n  expr: Expression,\n  type?: Type,\n  sourceSpan?: ParseSourceSpan | null,\n): UnaryOperatorExpr {\n  return new UnaryOperatorExpr(operator, expr, type, sourceSpan);\n}\n\nexport function not(expr: Expression, sourceSpan?: ParseSourceSpan | null): NotExpr {\n  return new NotExpr(expr, sourceSpan);\n}\n\nexport function fn(\n  params: FnParam[],\n  body: Statement[],\n  type?: Type | null,\n  sourceSpan?: ParseSourceSpan | null,\n  name?: string | null,\n): FunctionExpr {\n  return new FunctionExpr(params, body, type, sourceSpan, name);\n}\n\nexport function arrowFn(\n  params: FnParam[],\n  body: Expression | Statement[],\n  type?: Type | null,\n  sourceSpan?: ParseSourceSpan | null,\n) {\n  return new ArrowFunctionExpr(params, body, type, sourceSpan);\n}\n\nexport function ifStmt(\n  condition: Expression,\n  thenClause: Statement[],\n  elseClause?: Statement[],\n  sourceSpan?: ParseSourceSpan,\n  leadingComments?: LeadingComment[],\n) {\n  return new IfStmt(condition, thenClause, elseClause, sourceSpan, leadingComments);\n}\n\nexport function taggedTemplate(\n  tag: Expression,\n  template: TemplateLiteralExpr,\n  type?: Type | null,\n  sourceSpan?: ParseSourceSpan | null,\n): TaggedTemplateLiteralExpr {\n  return new TaggedTemplateLiteralExpr(tag, template, type, sourceSpan);\n}\n\nexport function literal(\n  value: any,\n  type?: Type | null,\n  sourceSpan?: ParseSourceSpan | null,\n): LiteralExpr {\n  return new LiteralExpr(value, type, sourceSpan);\n}\n\nexport function localizedString(\n  metaBlock: I18nMeta,\n  messageParts: LiteralPiece[],\n  placeholderNames: PlaceholderPiece[],\n  expressions: Expression[],\n  sourceSpan?: ParseSourceSpan | null,\n): LocalizedString {\n  return new LocalizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan);\n}\n\nexport function isNull(exp: Expression): boolean {\n  return exp instanceof LiteralExpr && exp.value === null;\n}\n\n// The list of JSDoc tags that we currently support. Extend it if needed.\nexport const enum JSDocTagName {\n  Desc = 'desc',\n  Id = 'id',\n  Meaning = 'meaning',\n  Suppress = 'suppress',\n}\n\n/*\n * TypeScript has an API for JSDoc already, but it's not exposed.\n * https://github.com/Microsoft/TypeScript/issues/7393\n * For now we create types that are similar to theirs so that migrating\n * to their API will be easier. See e.g. `ts.JSDocTag` and `ts.JSDocComment`.\n */\nexport type JSDocTag =\n  | {\n      // `tagName` is e.g. \"param\" in an `@param` declaration\n      tagName: JSDocTagName | string;\n      // Any remaining text on the tag, e.g. the description\n      text?: string;\n    }\n  | {\n      // no `tagName` for plain text documentation that occurs before any `@param` lines\n      tagName?: undefined;\n      text: string;\n    };\n\n/*\n * Serializes a `Tag` into a string.\n * Returns a string like \" @foo {bar} baz\" (note the leading whitespace before `@foo`).\n */\nfunction tagToString(tag: JSDocTag): string {\n  let out = '';\n  if (tag.tagName) {\n    out += ` @${tag.tagName}`;\n  }\n  if (tag.text) {\n    if (tag.text.match(/\\/\\*|\\*\\//)) {\n      throw new Error('JSDoc text cannot contain \"/*\" and \"*/\"');\n    }\n    out += ' ' + tag.text.replace(/@/g, '\\\\@');\n  }\n  return out;\n}\n\nfunction serializeTags(tags: JSDocTag[]): string {\n  if (tags.length === 0) return '';\n\n  if (tags.length === 1 && tags[0].tagName && !tags[0].text) {\n    // The JSDOC comment is a single simple tag: e.g `/** @tagname */`.\n    return `*${tagToString(tags[0])} `;\n  }\n\n  let out = '*\\n';\n  for (const tag of tags) {\n    out += ' *';\n    // If the tagToString is multi-line, insert \" * \" prefixes on lines.\n    out += tagToString(tag).replace(/\\n/g, '\\n * ');\n    out += '\\n';\n  }\n  out += ' ';\n  return out;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from './output/output_ast';\n\nconst CONSTANT_PREFIX = '_c';\n\n/**\n * `ConstantPool` tries to reuse literal factories when two or more literals are identical.\n * We determine whether literals are identical by creating a key out of their AST using the\n * `KeyVisitor`. This constant is used to replace dynamic expressions which can't be safely\n * converted into a key. E.g. given an expression `{foo: bar()}`, since we don't know what\n * the result of `bar` will be, we create a key that looks like `{foo: <unknown>}`. Note\n * that we use a variable, rather than something like `null` in order to avoid collisions.\n */\nconst UNKNOWN_VALUE_KEY = o.variable('<unknown>');\n\n/**\n * Context to use when producing a key.\n *\n * This ensures we see the constant not the reference variable when producing\n * a key.\n */\nconst KEY_CONTEXT = {};\n\n/**\n * Generally all primitive values are excluded from the `ConstantPool`, but there is an exclusion\n * for strings that reach a certain length threshold. This constant defines the length threshold for\n * strings.\n */\nconst POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS = 50;\n\n/**\n * A node that is a place-holder that allows the node to be replaced when the actual\n * node is known.\n *\n * This allows the constant pool to change an expression from a direct reference to\n * a constant to a shared constant. It returns a fix-up node that is later allowed to\n * change the referenced expression.\n */\nclass FixupExpression extends o.Expression {\n  private original: o.Expression;\n\n  shared = false;\n\n  constructor(public resolved: o.Expression) {\n    super(resolved.type);\n    this.original = resolved;\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): any {\n    if (context === KEY_CONTEXT) {\n      // When producing a key we want to traverse the constant not the\n      // variable used to refer to it.\n      return this.original.visitExpression(visitor, context);\n    } else {\n      return this.resolved.visitExpression(visitor, context);\n    }\n  }\n\n  override isEquivalent(e: o.Expression): boolean {\n    return e instanceof FixupExpression && this.resolved.isEquivalent(e.resolved);\n  }\n\n  override isConstant() {\n    return true;\n  }\n\n  override clone(): FixupExpression {\n    throw new Error(`Not supported.`);\n  }\n\n  fixup(expression: o.Expression) {\n    this.resolved = expression;\n    this.shared = true;\n  }\n}\n\n/**\n * A constant pool allows a code emitter to share constant in an output context.\n *\n * The constant pool also supports sharing access to ivy definitions references.\n */\nexport class ConstantPool {\n  statements: o.Statement[] = [];\n  private literals = new Map<string, FixupExpression>();\n  private literalFactories = new Map<string, o.Expression>();\n  private sharedConstants = new Map<string, o.Expression>();\n\n  /**\n   * Constant pool also tracks claimed names from {@link uniqueName}.\n   * This is useful to avoid collisions if variables are intended to be\n   * named a certain way- but may conflict. We wouldn't want to always suffix\n   * them with unique numbers.\n   */\n  private _claimedNames = new Map<string, number>();\n\n  private nextNameIndex = 0;\n\n  constructor(private readonly isClosureCompilerEnabled: boolean = false) {}\n\n  getConstLiteral(literal: o.Expression, forceShared?: boolean): o.Expression {\n    if (\n      (literal instanceof o.LiteralExpr && !isLongStringLiteral(literal)) ||\n      literal instanceof FixupExpression\n    ) {\n      // Do no put simple literals into the constant pool or try to produce a constant for a\n      // reference to a constant.\n      return literal;\n    }\n    const key = GenericKeyFn.INSTANCE.keyOf(literal);\n    let fixup = this.literals.get(key);\n    let newValue = false;\n    if (!fixup) {\n      fixup = new FixupExpression(literal);\n      this.literals.set(key, fixup);\n      newValue = true;\n    }\n\n    if ((!newValue && !fixup.shared) || (newValue && forceShared)) {\n      // Replace the expression with a variable\n      const name = this.freshName();\n      let value: o.Expression;\n      let usage: o.Expression;\n      if (this.isClosureCompilerEnabled && isLongStringLiteral(literal)) {\n        // For string literals, Closure will **always** inline the string at\n        // **all** usages, duplicating it each time. For large strings, this\n        // unnecessarily bloats bundle size. To work around this restriction, we\n        // wrap the string in a function, and call that function for each usage.\n        // This tricks Closure into using inline logic for functions instead of\n        // string literals. Function calls are only inlined if the body is small\n        // enough to be worth it. By doing this, very large strings will be\n        // shared across multiple usages, rather than duplicating the string at\n        // each usage site.\n        //\n        // const myStr = function() { return \"very very very long string\"; };\n        // const usage1 = myStr();\n        // const usage2 = myStr();\n        value = new o.FunctionExpr(\n          [], // Params.\n          [\n            // Statements.\n            new o.ReturnStatement(literal),\n          ],\n        );\n        usage = o.variable(name).callFn([]);\n      } else {\n        // Just declare and use the variable directly, without a function call\n        // indirection. This saves a few bytes and avoids an unnecessary call.\n        value = literal;\n        usage = o.variable(name);\n      }\n\n      this.statements.push(\n        new o.DeclareVarStmt(name, value, o.INFERRED_TYPE, o.StmtModifier.Final),\n      );\n      fixup.fixup(usage);\n    }\n\n    return fixup;\n  }\n\n  getSharedConstant(def: SharedConstantDefinition, expr: o.Expression): o.Expression {\n    const key = def.keyOf(expr);\n    if (!this.sharedConstants.has(key)) {\n      const id = this.freshName();\n      this.sharedConstants.set(key, o.variable(id));\n      this.statements.push(def.toSharedConstantDeclaration(id, expr));\n    }\n    return this.sharedConstants.get(key)!;\n  }\n\n  getLiteralFactory(literal: o.LiteralArrayExpr | o.LiteralMapExpr): {\n    literalFactory: o.Expression;\n    literalFactoryArguments: o.Expression[];\n  } {\n    // Create a pure function that builds an array of a mix of constant and variable expressions\n    if (literal instanceof o.LiteralArrayExpr) {\n      const argumentsForKey = literal.entries.map((e) => (e.isConstant() ? e : UNKNOWN_VALUE_KEY));\n      const key = GenericKeyFn.INSTANCE.keyOf(o.literalArr(argumentsForKey));\n      return this._getLiteralFactory(key, literal.entries, (entries) => o.literalArr(entries));\n    } else {\n      const expressionForKey = o.literalMap(\n        literal.entries.map((e) => ({\n          key: e.key,\n          value: e.value.isConstant() ? e.value : UNKNOWN_VALUE_KEY,\n          quoted: e.quoted,\n        })),\n      );\n      const key = GenericKeyFn.INSTANCE.keyOf(expressionForKey);\n      return this._getLiteralFactory(\n        key,\n        literal.entries.map((e) => e.value),\n        (entries) =>\n          o.literalMap(\n            entries.map((value, index) => ({\n              key: literal.entries[index].key,\n              value,\n              quoted: literal.entries[index].quoted,\n            })),\n          ),\n      );\n    }\n  }\n\n  // TODO: useUniqueName(false) is necessary for naming compatibility with\n  // TemplateDefinitionBuilder, but should be removed once Template Pipeline is the default.\n  getSharedFunctionReference(\n    fn: o.Expression,\n    prefix: string,\n    useUniqueName: boolean = true,\n  ): o.Expression {\n    const isArrow = fn instanceof o.ArrowFunctionExpr;\n\n    for (const current of this.statements) {\n      // Arrow functions are saved as variables so we check if the\n      // value of the variable is the same as the arrow function.\n      if (isArrow && current instanceof o.DeclareVarStmt && current.value?.isEquivalent(fn)) {\n        return o.variable(current.name);\n      }\n\n      // Function declarations are saved as function statements\n      // so we compare them directly to the passed-in function.\n      if (\n        !isArrow &&\n        current instanceof o.DeclareFunctionStmt &&\n        fn instanceof o.FunctionExpr &&\n        fn.isEquivalent(current)\n      ) {\n        return o.variable(current.name);\n      }\n    }\n\n    // Otherwise declare the function.\n    const name = useUniqueName ? this.uniqueName(prefix) : prefix;\n    this.statements.push(\n      fn instanceof o.FunctionExpr\n        ? fn.toDeclStmt(name, o.StmtModifier.Final)\n        : new o.DeclareVarStmt(name, fn, o.INFERRED_TYPE, o.StmtModifier.Final, fn.sourceSpan),\n    );\n    return o.variable(name);\n  }\n\n  private _getLiteralFactory(\n    key: string,\n    values: o.Expression[],\n    resultMap: (parameters: o.Expression[]) => o.Expression,\n  ): {literalFactory: o.Expression; literalFactoryArguments: o.Expression[]} {\n    let literalFactory = this.literalFactories.get(key);\n    const literalFactoryArguments = values.filter((e) => !e.isConstant());\n    if (!literalFactory) {\n      const resultExpressions = values.map((e, index) =>\n        e.isConstant() ? this.getConstLiteral(e, true) : o.variable(`a${index}`),\n      );\n      const parameters = resultExpressions\n        .filter(isVariable)\n        .map((e) => new o.FnParam(e.name!, o.DYNAMIC_TYPE));\n      const pureFunctionDeclaration = o.arrowFn(\n        parameters,\n        resultMap(resultExpressions),\n        o.INFERRED_TYPE,\n      );\n      const name = this.freshName();\n      this.statements.push(\n        new o.DeclareVarStmt(name, pureFunctionDeclaration, o.INFERRED_TYPE, o.StmtModifier.Final),\n      );\n      literalFactory = o.variable(name);\n      this.literalFactories.set(key, literalFactory);\n    }\n    return {literalFactory, literalFactoryArguments};\n  }\n\n  /**\n   * Produce a unique name in the context of this pool.\n   *\n   * The name might be unique among different prefixes if any of the prefixes end in\n   * a digit so the prefix should be a constant string (not based on user input) and\n   * must not end in a digit.\n   */\n  uniqueName(name: string, alwaysIncludeSuffix = true): string {\n    const count = this._claimedNames.get(name) ?? 0;\n    const result = count === 0 && !alwaysIncludeSuffix ? `${name}` : `${name}${count}`;\n\n    this._claimedNames.set(name, count + 1);\n    return result;\n  }\n\n  private freshName(): string {\n    return this.uniqueName(CONSTANT_PREFIX);\n  }\n}\n\nexport interface ExpressionKeyFn {\n  keyOf(expr: o.Expression): string;\n}\n\nexport interface SharedConstantDefinition extends ExpressionKeyFn {\n  toSharedConstantDeclaration(declName: string, keyExpr: o.Expression): o.Statement;\n}\n\nexport class GenericKeyFn implements ExpressionKeyFn {\n  static readonly INSTANCE = new GenericKeyFn();\n\n  keyOf(expr: o.Expression): string {\n    if (expr instanceof o.LiteralExpr && typeof expr.value === 'string') {\n      return `\"${expr.value}\"`;\n    } else if (expr instanceof o.LiteralExpr) {\n      return String(expr.value);\n    } else if (expr instanceof o.LiteralArrayExpr) {\n      const entries: string[] = [];\n      for (const entry of expr.entries) {\n        entries.push(this.keyOf(entry));\n      }\n      return `[${entries.join(',')}]`;\n    } else if (expr instanceof o.LiteralMapExpr) {\n      const entries: string[] = [];\n      for (const entry of expr.entries) {\n        let key = entry.key;\n        if (entry.quoted) {\n          key = `\"${key}\"`;\n        }\n        entries.push(key + ':' + this.keyOf(entry.value));\n      }\n      return `{${entries.join(',')}}`;\n    } else if (expr instanceof o.ExternalExpr) {\n      return `import(\"${expr.value.moduleName}\", ${expr.value.name})`;\n    } else if (expr instanceof o.ReadVarExpr) {\n      return `read(${expr.name})`;\n    } else if (expr instanceof o.TypeofExpr) {\n      return `typeof(${this.keyOf(expr.expr)})`;\n    } else {\n      throw new Error(\n        `${this.constructor.name} does not handle expressions of type ${expr.constructor.name}`,\n      );\n    }\n  }\n}\n\nfunction isVariable(e: o.Expression): e is o.ReadVarExpr {\n  return e instanceof o.ReadVarExpr;\n}\n\nfunction isLongStringLiteral(expr: o.Expression): boolean {\n  return (\n    expr instanceof o.LiteralExpr &&\n    typeof expr.value === 'string' &&\n    expr.value.length >= POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS\n  );\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../output/output_ast';\n\nconst CORE = '@angular/core';\n\nexport class Identifiers {\n  /* Methods */\n  static NEW_METHOD = 'factory';\n  static TRANSFORM_METHOD = 'transform';\n  static PATCH_DEPS = 'patchedDeps';\n\n  static core: o.ExternalReference = {name: null, moduleName: CORE};\n\n  /* Instructions */\n  static namespaceHTML: o.ExternalReference = {name: 'ɵɵnamespaceHTML', moduleName: CORE};\n\n  static namespaceMathML: o.ExternalReference = {name: 'ɵɵnamespaceMathML', moduleName: CORE};\n\n  static namespaceSVG: o.ExternalReference = {name: 'ɵɵnamespaceSVG', moduleName: CORE};\n\n  static element: o.ExternalReference = {name: 'ɵɵelement', moduleName: CORE};\n\n  static elementStart: o.ExternalReference = {name: 'ɵɵelementStart', moduleName: CORE};\n\n  static elementEnd: o.ExternalReference = {name: 'ɵɵelementEnd', moduleName: CORE};\n\n  static domElement: o.ExternalReference = {name: 'ɵɵdomElement', moduleName: CORE};\n  static domElementStart: o.ExternalReference = {name: 'ɵɵdomElementStart', moduleName: CORE};\n  static domElementEnd: o.ExternalReference = {name: 'ɵɵdomElementEnd', moduleName: CORE};\n  static domElementContainer: o.ExternalReference = {\n    name: 'ɵɵdomElementContainer',\n    moduleName: CORE,\n  };\n  static domElementContainerStart: o.ExternalReference = {\n    name: 'ɵɵdomElementContainerStart',\n    moduleName: CORE,\n  };\n  static domElementContainerEnd: o.ExternalReference = {\n    name: 'ɵɵdomElementContainerEnd',\n    moduleName: CORE,\n  };\n  static domTemplate: o.ExternalReference = {name: 'ɵɵdomTemplate', moduleName: CORE};\n  static domListener: o.ExternalReference = {name: 'ɵɵdomListener', moduleName: CORE};\n\n  static advance: o.ExternalReference = {name: 'ɵɵadvance', moduleName: CORE};\n\n  static syntheticHostProperty: o.ExternalReference = {\n    name: 'ɵɵsyntheticHostProperty',\n    moduleName: CORE,\n  };\n\n  static syntheticHostListener: o.ExternalReference = {\n    name: 'ɵɵsyntheticHostListener',\n    moduleName: CORE,\n  };\n\n  static attribute: o.ExternalReference = {name: 'ɵɵattribute', moduleName: CORE};\n\n  static classProp: o.ExternalReference = {name: 'ɵɵclassProp', moduleName: CORE};\n\n  static elementContainerStart: o.ExternalReference = {\n    name: 'ɵɵelementContainerStart',\n    moduleName: CORE,\n  };\n\n  static elementContainerEnd: o.ExternalReference = {\n    name: 'ɵɵelementContainerEnd',\n    moduleName: CORE,\n  };\n\n  static elementContainer: o.ExternalReference = {name: 'ɵɵelementContainer', moduleName: CORE};\n\n  static styleMap: o.ExternalReference = {name: 'ɵɵstyleMap', moduleName: CORE};\n\n  static classMap: o.ExternalReference = {name: 'ɵɵclassMap', moduleName: CORE};\n\n  static styleProp: o.ExternalReference = {name: 'ɵɵstyleProp', moduleName: CORE};\n\n  static interpolate: o.ExternalReference = {\n    name: 'ɵɵinterpolate',\n    moduleName: CORE,\n  };\n  static interpolate1: o.ExternalReference = {\n    name: 'ɵɵinterpolate1',\n    moduleName: CORE,\n  };\n  static interpolate2: o.ExternalReference = {\n    name: 'ɵɵinterpolate2',\n    moduleName: CORE,\n  };\n  static interpolate3: o.ExternalReference = {\n    name: 'ɵɵinterpolate3',\n    moduleName: CORE,\n  };\n  static interpolate4: o.ExternalReference = {\n    name: 'ɵɵinterpolate4',\n    moduleName: CORE,\n  };\n  static interpolate5: o.ExternalReference = {\n    name: 'ɵɵinterpolate5',\n    moduleName: CORE,\n  };\n  static interpolate6: o.ExternalReference = {\n    name: 'ɵɵinterpolate6',\n    moduleName: CORE,\n  };\n  static interpolate7: o.ExternalReference = {\n    name: 'ɵɵinterpolate7',\n    moduleName: CORE,\n  };\n  static interpolate8: o.ExternalReference = {\n    name: 'ɵɵinterpolate8',\n    moduleName: CORE,\n  };\n  static interpolateV: o.ExternalReference = {\n    name: 'ɵɵinterpolateV',\n    moduleName: CORE,\n  };\n\n  static nextContext: o.ExternalReference = {name: 'ɵɵnextContext', moduleName: CORE};\n\n  static resetView: o.ExternalReference = {name: 'ɵɵresetView', moduleName: CORE};\n\n  static templateCreate: o.ExternalReference = {name: 'ɵɵtemplate', moduleName: CORE};\n\n  static defer: o.ExternalReference = {name: 'ɵɵdefer', moduleName: CORE};\n  static deferWhen: o.ExternalReference = {name: 'ɵɵdeferWhen', moduleName: CORE};\n  static deferOnIdle: o.ExternalReference = {name: 'ɵɵdeferOnIdle', moduleName: CORE};\n  static deferOnImmediate: o.ExternalReference = {name: 'ɵɵdeferOnImmediate', moduleName: CORE};\n  static deferOnTimer: o.ExternalReference = {name: 'ɵɵdeferOnTimer', moduleName: CORE};\n  static deferOnHover: o.ExternalReference = {name: 'ɵɵdeferOnHover', moduleName: CORE};\n  static deferOnInteraction: o.ExternalReference = {name: 'ɵɵdeferOnInteraction', moduleName: CORE};\n  static deferOnViewport: o.ExternalReference = {name: 'ɵɵdeferOnViewport', moduleName: CORE};\n  static deferPrefetchWhen: o.ExternalReference = {name: 'ɵɵdeferPrefetchWhen', moduleName: CORE};\n  static deferPrefetchOnIdle: o.ExternalReference = {\n    name: 'ɵɵdeferPrefetchOnIdle',\n    moduleName: CORE,\n  };\n  static deferPrefetchOnImmediate: o.ExternalReference = {\n    name: 'ɵɵdeferPrefetchOnImmediate',\n    moduleName: CORE,\n  };\n  static deferPrefetchOnTimer: o.ExternalReference = {\n    name: 'ɵɵdeferPrefetchOnTimer',\n    moduleName: CORE,\n  };\n  static deferPrefetchOnHover: o.ExternalReference = {\n    name: 'ɵɵdeferPrefetchOnHover',\n    moduleName: CORE,\n  };\n  static deferPrefetchOnInteraction: o.ExternalReference = {\n    name: 'ɵɵdeferPrefetchOnInteraction',\n    moduleName: CORE,\n  };\n  static deferPrefetchOnViewport: o.ExternalReference = {\n    name: 'ɵɵdeferPrefetchOnViewport',\n    moduleName: CORE,\n  };\n  static deferHydrateWhen: o.ExternalReference = {name: 'ɵɵdeferHydrateWhen', moduleName: CORE};\n  static deferHydrateNever: o.ExternalReference = {name: 'ɵɵdeferHydrateNever', moduleName: CORE};\n  static deferHydrateOnIdle: o.ExternalReference = {\n    name: 'ɵɵdeferHydrateOnIdle',\n    moduleName: CORE,\n  };\n  static deferHydrateOnImmediate: o.ExternalReference = {\n    name: 'ɵɵdeferHydrateOnImmediate',\n    moduleName: CORE,\n  };\n  static deferHydrateOnTimer: o.ExternalReference = {\n    name: 'ɵɵdeferHydrateOnTimer',\n    moduleName: CORE,\n  };\n  static deferHydrateOnHover: o.ExternalReference = {\n    name: 'ɵɵdeferHydrateOnHover',\n    moduleName: CORE,\n  };\n  static deferHydrateOnInteraction: o.ExternalReference = {\n    name: 'ɵɵdeferHydrateOnInteraction',\n    moduleName: CORE,\n  };\n  static deferHydrateOnViewport: o.ExternalReference = {\n    name: 'ɵɵdeferHydrateOnViewport',\n    moduleName: CORE,\n  };\n  static deferEnableTimerScheduling: o.ExternalReference = {\n    name: 'ɵɵdeferEnableTimerScheduling',\n    moduleName: CORE,\n  };\n\n  static conditionalCreate: o.ExternalReference = {name: 'ɵɵconditionalCreate', moduleName: CORE};\n  static conditionalBranchCreate: o.ExternalReference = {\n    name: 'ɵɵconditionalBranchCreate',\n    moduleName: CORE,\n  };\n  static conditional: o.ExternalReference = {name: 'ɵɵconditional', moduleName: CORE};\n  static repeater: o.ExternalReference = {name: 'ɵɵrepeater', moduleName: CORE};\n  static repeaterCreate: o.ExternalReference = {name: 'ɵɵrepeaterCreate', moduleName: CORE};\n  static repeaterTrackByIndex: o.ExternalReference = {\n    name: 'ɵɵrepeaterTrackByIndex',\n    moduleName: CORE,\n  };\n  static repeaterTrackByIdentity: o.ExternalReference = {\n    name: 'ɵɵrepeaterTrackByIdentity',\n    moduleName: CORE,\n  };\n  static componentInstance: o.ExternalReference = {name: 'ɵɵcomponentInstance', moduleName: CORE};\n\n  static text: o.ExternalReference = {name: 'ɵɵtext', moduleName: CORE};\n\n  static enableBindings: o.ExternalReference = {name: 'ɵɵenableBindings', moduleName: CORE};\n\n  static disableBindings: o.ExternalReference = {name: 'ɵɵdisableBindings', moduleName: CORE};\n\n  static getCurrentView: o.ExternalReference = {name: 'ɵɵgetCurrentView', moduleName: CORE};\n\n  static textInterpolate: o.ExternalReference = {name: 'ɵɵtextInterpolate', moduleName: CORE};\n  static textInterpolate1: o.ExternalReference = {name: 'ɵɵtextInterpolate1', moduleName: CORE};\n  static textInterpolate2: o.ExternalReference = {name: 'ɵɵtextInterpolate2', moduleName: CORE};\n  static textInterpolate3: o.ExternalReference = {name: 'ɵɵtextInterpolate3', moduleName: CORE};\n  static textInterpolate4: o.ExternalReference = {name: 'ɵɵtextInterpolate4', moduleName: CORE};\n  static textInterpolate5: o.ExternalReference = {name: 'ɵɵtextInterpolate5', moduleName: CORE};\n  static textInterpolate6: o.ExternalReference = {name: 'ɵɵtextInterpolate6', moduleName: CORE};\n  static textInterpolate7: o.ExternalReference = {name: 'ɵɵtextInterpolate7', moduleName: CORE};\n  static textInterpolate8: o.ExternalReference = {name: 'ɵɵtextInterpolate8', moduleName: CORE};\n  static textInterpolateV: o.ExternalReference = {name: 'ɵɵtextInterpolateV', moduleName: CORE};\n\n  static restoreView: o.ExternalReference = {name: 'ɵɵrestoreView', moduleName: CORE};\n\n  static pureFunction0: o.ExternalReference = {name: 'ɵɵpureFunction0', moduleName: CORE};\n  static pureFunction1: o.ExternalReference = {name: 'ɵɵpureFunction1', moduleName: CORE};\n  static pureFunction2: o.ExternalReference = {name: 'ɵɵpureFunction2', moduleName: CORE};\n  static pureFunction3: o.ExternalReference = {name: 'ɵɵpureFunction3', moduleName: CORE};\n  static pureFunction4: o.ExternalReference = {name: 'ɵɵpureFunction4', moduleName: CORE};\n  static pureFunction5: o.ExternalReference = {name: 'ɵɵpureFunction5', moduleName: CORE};\n  static pureFunction6: o.ExternalReference = {name: 'ɵɵpureFunction6', moduleName: CORE};\n  static pureFunction7: o.ExternalReference = {name: 'ɵɵpureFunction7', moduleName: CORE};\n  static pureFunction8: o.ExternalReference = {name: 'ɵɵpureFunction8', moduleName: CORE};\n  static pureFunctionV: o.ExternalReference = {name: 'ɵɵpureFunctionV', moduleName: CORE};\n\n  static pipeBind1: o.ExternalReference = {name: 'ɵɵpipeBind1', moduleName: CORE};\n  static pipeBind2: o.ExternalReference = {name: 'ɵɵpipeBind2', moduleName: CORE};\n  static pipeBind3: o.ExternalReference = {name: 'ɵɵpipeBind3', moduleName: CORE};\n  static pipeBind4: o.ExternalReference = {name: 'ɵɵpipeBind4', moduleName: CORE};\n  static pipeBindV: o.ExternalReference = {name: 'ɵɵpipeBindV', moduleName: CORE};\n\n  static domProperty: o.ExternalReference = {name: 'ɵɵdomProperty', moduleName: CORE};\n\n  static ariaProperty: o.ExternalReference = {name: 'ɵɵariaProperty', moduleName: CORE};\n  static property: o.ExternalReference = {name: 'ɵɵproperty', moduleName: CORE};\n\n  static animationEnterListener: o.ExternalReference = {\n    name: 'ɵɵanimateEnterListener',\n    moduleName: CORE,\n  };\n  static animationLeaveListener: o.ExternalReference = {\n    name: 'ɵɵanimateLeaveListener',\n    moduleName: CORE,\n  };\n  static animationEnter: o.ExternalReference = {name: 'ɵɵanimateEnter', moduleName: CORE};\n  static animationLeave: o.ExternalReference = {name: 'ɵɵanimateLeave', moduleName: CORE};\n\n  static i18n: o.ExternalReference = {name: 'ɵɵi18n', moduleName: CORE};\n  static i18nAttributes: o.ExternalReference = {name: 'ɵɵi18nAttributes', moduleName: CORE};\n  static i18nExp: o.ExternalReference = {name: 'ɵɵi18nExp', moduleName: CORE};\n  static i18nStart: o.ExternalReference = {name: 'ɵɵi18nStart', moduleName: CORE};\n  static i18nEnd: o.ExternalReference = {name: 'ɵɵi18nEnd', moduleName: CORE};\n  static i18nApply: o.ExternalReference = {name: 'ɵɵi18nApply', moduleName: CORE};\n  static i18nPostprocess: o.ExternalReference = {name: 'ɵɵi18nPostprocess', moduleName: CORE};\n\n  static pipe: o.ExternalReference = {name: 'ɵɵpipe', moduleName: CORE};\n\n  static projection: o.ExternalReference = {name: 'ɵɵprojection', moduleName: CORE};\n  static projectionDef: o.ExternalReference = {name: 'ɵɵprojectionDef', moduleName: CORE};\n\n  static reference: o.ExternalReference = {name: 'ɵɵreference', moduleName: CORE};\n\n  static inject: o.ExternalReference = {name: 'ɵɵinject', moduleName: CORE};\n\n  static injectAttribute: o.ExternalReference = {name: 'ɵɵinjectAttribute', moduleName: CORE};\n\n  static directiveInject: o.ExternalReference = {name: 'ɵɵdirectiveInject', moduleName: CORE};\n  static invalidFactory: o.ExternalReference = {name: 'ɵɵinvalidFactory', moduleName: CORE};\n  static invalidFactoryDep: o.ExternalReference = {name: 'ɵɵinvalidFactoryDep', moduleName: CORE};\n\n  static templateRefExtractor: o.ExternalReference = {\n    name: 'ɵɵtemplateRefExtractor',\n    moduleName: CORE,\n  };\n\n  static forwardRef: o.ExternalReference = {name: 'forwardRef', moduleName: CORE};\n  static resolveForwardRef: o.ExternalReference = {name: 'resolveForwardRef', moduleName: CORE};\n\n  static replaceMetadata: o.ExternalReference = {name: 'ɵɵreplaceMetadata', moduleName: CORE};\n  static getReplaceMetadataURL: o.ExternalReference = {\n    name: 'ɵɵgetReplaceMetadataURL',\n    moduleName: CORE,\n  };\n\n  static ɵɵdefineInjectable: o.ExternalReference = {name: 'ɵɵdefineInjectable', moduleName: CORE};\n  static declareInjectable: o.ExternalReference = {name: 'ɵɵngDeclareInjectable', moduleName: CORE};\n  static InjectableDeclaration: o.ExternalReference = {\n    name: 'ɵɵInjectableDeclaration',\n    moduleName: CORE,\n  };\n\n  static resolveWindow: o.ExternalReference = {name: 'ɵɵresolveWindow', moduleName: CORE};\n  static resolveDocument: o.ExternalReference = {name: 'ɵɵresolveDocument', moduleName: CORE};\n  static resolveBody: o.ExternalReference = {name: 'ɵɵresolveBody', moduleName: CORE};\n\n  static getComponentDepsFactory: o.ExternalReference = {\n    name: 'ɵɵgetComponentDepsFactory',\n    moduleName: CORE,\n  };\n\n  static defineComponent: o.ExternalReference = {name: 'ɵɵdefineComponent', moduleName: CORE};\n  static declareComponent: o.ExternalReference = {name: 'ɵɵngDeclareComponent', moduleName: CORE};\n\n  static setComponentScope: o.ExternalReference = {name: 'ɵɵsetComponentScope', moduleName: CORE};\n\n  static ChangeDetectionStrategy: o.ExternalReference = {\n    name: 'ChangeDetectionStrategy',\n    moduleName: CORE,\n  };\n  static ViewEncapsulation: o.ExternalReference = {\n    name: 'ViewEncapsulation',\n    moduleName: CORE,\n  };\n\n  static ComponentDeclaration: o.ExternalReference = {\n    name: 'ɵɵComponentDeclaration',\n    moduleName: CORE,\n  };\n\n  static FactoryDeclaration: o.ExternalReference = {\n    name: 'ɵɵFactoryDeclaration',\n    moduleName: CORE,\n  };\n  static declareFactory: o.ExternalReference = {name: 'ɵɵngDeclareFactory', moduleName: CORE};\n  static FactoryTarget: o.ExternalReference = {name: 'ɵɵFactoryTarget', moduleName: CORE};\n\n  static defineDirective: o.ExternalReference = {name: 'ɵɵdefineDirective', moduleName: CORE};\n  static declareDirective: o.ExternalReference = {name: 'ɵɵngDeclareDirective', moduleName: CORE};\n\n  static DirectiveDeclaration: o.ExternalReference = {\n    name: 'ɵɵDirectiveDeclaration',\n    moduleName: CORE,\n  };\n\n  static InjectorDef: o.ExternalReference = {name: 'ɵɵInjectorDef', moduleName: CORE};\n  static InjectorDeclaration: o.ExternalReference = {\n    name: 'ɵɵInjectorDeclaration',\n    moduleName: CORE,\n  };\n\n  static defineInjector: o.ExternalReference = {name: 'ɵɵdefineInjector', moduleName: CORE};\n  static declareInjector: o.ExternalReference = {name: 'ɵɵngDeclareInjector', moduleName: CORE};\n\n  static NgModuleDeclaration: o.ExternalReference = {\n    name: 'ɵɵNgModuleDeclaration',\n    moduleName: CORE,\n  };\n\n  static ModuleWithProviders: o.ExternalReference = {\n    name: 'ModuleWithProviders',\n    moduleName: CORE,\n  };\n\n  static defineNgModule: o.ExternalReference = {name: 'ɵɵdefineNgModule', moduleName: CORE};\n  static declareNgModule: o.ExternalReference = {name: 'ɵɵngDeclareNgModule', moduleName: CORE};\n  static setNgModuleScope: o.ExternalReference = {name: 'ɵɵsetNgModuleScope', moduleName: CORE};\n  static registerNgModuleType: o.ExternalReference = {\n    name: 'ɵɵregisterNgModuleType',\n    moduleName: CORE,\n  };\n\n  static PipeDeclaration: o.ExternalReference = {name: 'ɵɵPipeDeclaration', moduleName: CORE};\n\n  static definePipe: o.ExternalReference = {name: 'ɵɵdefinePipe', moduleName: CORE};\n  static declarePipe: o.ExternalReference = {name: 'ɵɵngDeclarePipe', moduleName: CORE};\n\n  static declareClassMetadata: o.ExternalReference = {\n    name: 'ɵɵngDeclareClassMetadata',\n    moduleName: CORE,\n  };\n  static declareClassMetadataAsync: o.ExternalReference = {\n    name: 'ɵɵngDeclareClassMetadataAsync',\n    moduleName: CORE,\n  };\n  static setClassMetadata: o.ExternalReference = {name: 'ɵsetClassMetadata', moduleName: CORE};\n  static setClassMetadataAsync: o.ExternalReference = {\n    name: 'ɵsetClassMetadataAsync',\n    moduleName: CORE,\n  };\n  static setClassDebugInfo: o.ExternalReference = {name: 'ɵsetClassDebugInfo', moduleName: CORE};\n  static queryRefresh: o.ExternalReference = {name: 'ɵɵqueryRefresh', moduleName: CORE};\n  static viewQuery: o.ExternalReference = {name: 'ɵɵviewQuery', moduleName: CORE};\n  static loadQuery: o.ExternalReference = {name: 'ɵɵloadQuery', moduleName: CORE};\n  static contentQuery: o.ExternalReference = {name: 'ɵɵcontentQuery', moduleName: CORE};\n\n  // Signal queries\n  static viewQuerySignal: o.ExternalReference = {name: 'ɵɵviewQuerySignal', moduleName: CORE};\n  static contentQuerySignal: o.ExternalReference = {name: 'ɵɵcontentQuerySignal', moduleName: CORE};\n  static queryAdvance: o.ExternalReference = {name: 'ɵɵqueryAdvance', moduleName: CORE};\n\n  // Two-way bindings\n  static twoWayProperty: o.ExternalReference = {name: 'ɵɵtwoWayProperty', moduleName: CORE};\n  static twoWayBindingSet: o.ExternalReference = {name: 'ɵɵtwoWayBindingSet', moduleName: CORE};\n  static twoWayListener: o.ExternalReference = {name: 'ɵɵtwoWayListener', moduleName: CORE};\n\n  static declareLet: o.ExternalReference = {name: 'ɵɵdeclareLet', moduleName: CORE};\n  static storeLet: o.ExternalReference = {name: 'ɵɵstoreLet', moduleName: CORE};\n  static readContextLet: o.ExternalReference = {name: 'ɵɵreadContextLet', moduleName: CORE};\n\n  static attachSourceLocations: o.ExternalReference = {\n    name: 'ɵɵattachSourceLocations',\n    moduleName: CORE,\n  };\n\n  static NgOnChangesFeature: o.ExternalReference = {name: 'ɵɵNgOnChangesFeature', moduleName: CORE};\n\n  static InheritDefinitionFeature: o.ExternalReference = {\n    name: 'ɵɵInheritDefinitionFeature',\n    moduleName: CORE,\n  };\n\n  static CopyDefinitionFeature: o.ExternalReference = {\n    name: 'ɵɵCopyDefinitionFeature',\n    moduleName: CORE,\n  };\n\n  static ProvidersFeature: o.ExternalReference = {name: 'ɵɵProvidersFeature', moduleName: CORE};\n\n  static HostDirectivesFeature: o.ExternalReference = {\n    name: 'ɵɵHostDirectivesFeature',\n    moduleName: CORE,\n  };\n\n  static ExternalStylesFeature: o.ExternalReference = {\n    name: 'ɵɵExternalStylesFeature',\n    moduleName: CORE,\n  };\n\n  static listener: o.ExternalReference = {name: 'ɵɵlistener', moduleName: CORE};\n\n  static getInheritedFactory: o.ExternalReference = {\n    name: 'ɵɵgetInheritedFactory',\n    moduleName: CORE,\n  };\n\n  // sanitization-related functions\n  static sanitizeHtml: o.ExternalReference = {name: 'ɵɵsanitizeHtml', moduleName: CORE};\n  static sanitizeStyle: o.ExternalReference = {name: 'ɵɵsanitizeStyle', moduleName: CORE};\n  static sanitizeResourceUrl: o.ExternalReference = {\n    name: 'ɵɵsanitizeResourceUrl',\n    moduleName: CORE,\n  };\n  static sanitizeScript: o.ExternalReference = {name: 'ɵɵsanitizeScript', moduleName: CORE};\n  static sanitizeUrl: o.ExternalReference = {name: 'ɵɵsanitizeUrl', moduleName: CORE};\n  static sanitizeUrlOrResourceUrl: o.ExternalReference = {\n    name: 'ɵɵsanitizeUrlOrResourceUrl',\n    moduleName: CORE,\n  };\n  static trustConstantHtml: o.ExternalReference = {name: 'ɵɵtrustConstantHtml', moduleName: CORE};\n  static trustConstantResourceUrl: o.ExternalReference = {\n    name: 'ɵɵtrustConstantResourceUrl',\n    moduleName: CORE,\n  };\n  static validateIframeAttribute: o.ExternalReference = {\n    name: 'ɵɵvalidateIframeAttribute',\n    moduleName: CORE,\n  };\n\n  // Decorators\n  static inputDecorator: o.ExternalReference = {name: 'Input', moduleName: CORE};\n  static outputDecorator: o.ExternalReference = {name: 'Output', moduleName: CORE};\n  static viewChildDecorator: o.ExternalReference = {name: 'ViewChild', moduleName: CORE};\n  static viewChildrenDecorator: o.ExternalReference = {name: 'ViewChildren', moduleName: CORE};\n  static contentChildDecorator: o.ExternalReference = {name: 'ContentChild', moduleName: CORE};\n  static contentChildrenDecorator: o.ExternalReference = {\n    name: 'ContentChildren',\n    moduleName: CORE,\n  };\n\n  // type-checking\n  static InputSignalBrandWriteType = {name: 'ɵINPUT_SIGNAL_BRAND_WRITE_TYPE', moduleName: CORE};\n  static UnwrapDirectiveSignalInputs = {name: 'ɵUnwrapDirectiveSignalInputs', moduleName: CORE};\n  static unwrapWritableSignal = {name: 'ɵunwrapWritableSignal', moduleName: CORE};\n  static assertType = {name: 'ɵassertType', moduleName: CORE};\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nconst DASH_CASE_REGEXP = /-+([a-z0-9])/g;\n\nexport function dashCaseToCamelCase(input: string): string {\n  return input.replace(DASH_CASE_REGEXP, (...m: any[]) => m[1].toUpperCase());\n}\n\nexport function splitAtColon(input: string, defaultValues: (string | null)[]): (string | null)[] {\n  return _splitAt(input, ':', defaultValues);\n}\n\nexport function splitAtPeriod(input: string, defaultValues: (string | null)[]): (string | null)[] {\n  return _splitAt(input, '.', defaultValues);\n}\n\nfunction _splitAt(\n  input: string,\n  character: string,\n  defaultValues: (string | null)[],\n): (string | null)[] {\n  const characterIndex = input.indexOf(character);\n  if (characterIndex == -1) return defaultValues;\n  return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];\n}\n\nexport function noUndefined<T>(val: T | undefined): T {\n  return val === undefined ? null! : val;\n}\n\nexport function error(msg: string): never {\n  throw new Error(`Internal Error: ${msg}`);\n}\n\n// Escape characters that have a special meaning in Regular Expressions\nexport function escapeRegExp(s: string): string {\n  return s.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\n}\n\nexport type Byte = number;\n\nexport function utf8Encode(str: string): Byte[] {\n  let encoded: Byte[] = [];\n  for (let index = 0; index < str.length; index++) {\n    let codePoint = str.charCodeAt(index);\n\n    // decode surrogate\n    // see https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n    if (codePoint >= 0xd800 && codePoint <= 0xdbff && str.length > index + 1) {\n      const low = str.charCodeAt(index + 1);\n      if (low >= 0xdc00 && low <= 0xdfff) {\n        index++;\n        codePoint = ((codePoint - 0xd800) << 10) + low - 0xdc00 + 0x10000;\n      }\n    }\n\n    if (codePoint <= 0x7f) {\n      encoded.push(codePoint);\n    } else if (codePoint <= 0x7ff) {\n      encoded.push(((codePoint >> 6) & 0x1f) | 0xc0, (codePoint & 0x3f) | 0x80);\n    } else if (codePoint <= 0xffff) {\n      encoded.push(\n        (codePoint >> 12) | 0xe0,\n        ((codePoint >> 6) & 0x3f) | 0x80,\n        (codePoint & 0x3f) | 0x80,\n      );\n    } else if (codePoint <= 0x1fffff) {\n      encoded.push(\n        ((codePoint >> 18) & 0x07) | 0xf0,\n        ((codePoint >> 12) & 0x3f) | 0x80,\n        ((codePoint >> 6) & 0x3f) | 0x80,\n        (codePoint & 0x3f) | 0x80,\n      );\n    }\n  }\n\n  return encoded;\n}\n\nexport function stringify(token: any): string {\n  if (typeof token === 'string') {\n    return token;\n  }\n\n  if (Array.isArray(token)) {\n    return `[${token.map(stringify).join(', ')}]`;\n  }\n\n  if (token == null) {\n    return '' + token;\n  }\n\n  const name = token.overriddenName || token.name;\n  if (name) {\n    return `${name}`;\n  }\n\n  if (!token.toString) {\n    return 'object';\n  }\n\n  // WARNING: do not try to `JSON.stringify(token)` here\n  // see https://github.com/angular/angular/issues/23440\n  const result = token.toString();\n\n  if (result == null) {\n    return '' + result;\n  }\n\n  const newLineIndex = result.indexOf('\\n');\n  return newLineIndex >= 0 ? result.slice(0, newLineIndex) : result;\n}\n\nexport class Version {\n  public readonly major: string;\n  public readonly minor: string;\n  public readonly patch: string;\n\n  constructor(public full: string) {\n    const splits = full.split('.');\n    this.major = splits[0];\n    this.minor = splits[1];\n    this.patch = splits.slice(2).join('.');\n  }\n}\n\nexport interface Console {\n  log(message: string): void;\n  warn(message: string): void;\n}\n\nconst _global: {[name: string]: any} = globalThis;\nexport {_global as global};\n\nconst V1_TO_18 = /^([1-9]|1[0-8])\\./;\n\nexport function getJitStandaloneDefaultForVersion(version: string): boolean {\n  if (version.startsWith('0.')) {\n    // 0.0.0 is always \"latest\", default is true.\n    return true;\n  }\n  if (V1_TO_18.test(version)) {\n    // Angular v2 - v18 default is false.\n    return false;\n  }\n\n  // All other Angular versions (v19+) default to true.\n  return true;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {utf8Encode} from '../util';\n\n// https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit\nconst VERSION = 3;\n\nconst JS_B64_PREFIX = '# sourceMappingURL=data:application/json;base64,';\n\ntype Segment = {\n  col0: number;\n  sourceUrl?: string;\n  sourceLine0?: number;\n  sourceCol0?: number;\n};\n\nexport type SourceMap = {\n  version: number;\n  file?: string;\n  sourceRoot: string;\n  sources: string[];\n  sourcesContent: (string | null)[];\n  mappings: string;\n};\n\nexport class SourceMapGenerator {\n  private sourcesContent: Map<string, string | null> = new Map();\n  private lines: Segment[][] = [];\n  private lastCol0: number = 0;\n  private hasMappings = false;\n\n  constructor(private file: string | null = null) {}\n\n  // The content is `null` when the content is expected to be loaded using the URL\n  addSource(url: string, content: string | null = null): this {\n    if (!this.sourcesContent.has(url)) {\n      this.sourcesContent.set(url, content);\n    }\n    return this;\n  }\n\n  addLine(): this {\n    this.lines.push([]);\n    this.lastCol0 = 0;\n    return this;\n  }\n\n  addMapping(col0: number, sourceUrl?: string, sourceLine0?: number, sourceCol0?: number): this {\n    if (!this.currentLine) {\n      throw new Error(`A line must be added before mappings can be added`);\n    }\n    if (sourceUrl != null && !this.sourcesContent.has(sourceUrl)) {\n      throw new Error(`Unknown source file \"${sourceUrl}\"`);\n    }\n    if (col0 == null) {\n      throw new Error(`The column in the generated code must be provided`);\n    }\n    if (col0 < this.lastCol0) {\n      throw new Error(`Mapping should be added in output order`);\n    }\n    if (sourceUrl && (sourceLine0 == null || sourceCol0 == null)) {\n      throw new Error(`The source location must be provided when a source url is provided`);\n    }\n\n    this.hasMappings = true;\n    this.lastCol0 = col0;\n    this.currentLine.push({col0, sourceUrl, sourceLine0, sourceCol0});\n    return this;\n  }\n\n  /**\n   * @internal strip this from published d.ts files due to\n   * https://github.com/microsoft/TypeScript/issues/36216\n   */\n  private get currentLine(): Segment[] | null {\n    return this.lines.slice(-1)[0];\n  }\n\n  toJSON(): SourceMap | null {\n    if (!this.hasMappings) {\n      return null;\n    }\n\n    const sourcesIndex = new Map<string, number>();\n    const sources: string[] = [];\n    const sourcesContent: (string | null)[] = [];\n\n    Array.from(this.sourcesContent.keys()).forEach((url: string, i: number) => {\n      sourcesIndex.set(url, i);\n      sources.push(url);\n      sourcesContent.push(this.sourcesContent.get(url) || null);\n    });\n\n    let mappings: string = '';\n    let lastCol0: number = 0;\n    let lastSourceIndex: number = 0;\n    let lastSourceLine0: number = 0;\n    let lastSourceCol0: number = 0;\n\n    this.lines.forEach((segments) => {\n      lastCol0 = 0;\n\n      mappings += segments\n        .map((segment) => {\n          // zero-based starting column of the line in the generated code\n          let segAsStr = toBase64VLQ(segment.col0 - lastCol0);\n          lastCol0 = segment.col0;\n\n          if (segment.sourceUrl != null) {\n            // zero-based index into the “sources” list\n            segAsStr += toBase64VLQ(sourcesIndex.get(segment.sourceUrl)! - lastSourceIndex);\n            lastSourceIndex = sourcesIndex.get(segment.sourceUrl)!;\n            // the zero-based starting line in the original source\n            segAsStr += toBase64VLQ(segment.sourceLine0! - lastSourceLine0);\n            lastSourceLine0 = segment.sourceLine0!;\n            // the zero-based starting column in the original source\n            segAsStr += toBase64VLQ(segment.sourceCol0! - lastSourceCol0);\n            lastSourceCol0 = segment.sourceCol0!;\n          }\n\n          return segAsStr;\n        })\n        .join(',');\n      mappings += ';';\n    });\n\n    mappings = mappings.slice(0, -1);\n\n    return {\n      'file': this.file || '',\n      'version': VERSION,\n      'sourceRoot': '',\n      'sources': sources,\n      'sourcesContent': sourcesContent,\n      'mappings': mappings,\n    };\n  }\n\n  toJsComment(): string {\n    return this.hasMappings\n      ? '//' + JS_B64_PREFIX + toBase64String(JSON.stringify(this, null, 0))\n      : '';\n  }\n}\n\nexport function toBase64String(value: string): string {\n  let b64 = '';\n  const encoded = utf8Encode(value);\n  for (let i = 0; i < encoded.length; ) {\n    const i1 = encoded[i++];\n    const i2 = i < encoded.length ? encoded[i++] : null;\n    const i3 = i < encoded.length ? encoded[i++] : null;\n    b64 += toBase64Digit(i1 >> 2);\n    b64 += toBase64Digit(((i1 & 3) << 4) | (i2 === null ? 0 : i2 >> 4));\n    b64 += i2 === null ? '=' : toBase64Digit(((i2 & 15) << 2) | (i3 === null ? 0 : i3 >> 6));\n    b64 += i2 === null || i3 === null ? '=' : toBase64Digit(i3 & 63);\n  }\n\n  return b64;\n}\n\nfunction toBase64VLQ(value: number): string {\n  value = value < 0 ? (-value << 1) + 1 : value << 1;\n\n  let out = '';\n  do {\n    let digit = value & 31;\n    value = value >> 5;\n    if (value > 0) {\n      digit = digit | 32;\n    }\n    out += toBase64Digit(digit);\n  } while (value > 0);\n\n  return out;\n}\n\nconst B64_DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nfunction toBase64Digit(value: number): string {\n  if (value < 0 || value >= 64) {\n    throw new Error(`Can only encode value in the range [0, 63]`);\n  }\n\n  return B64_DIGITS[value];\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ParseSourceSpan} from '../parse_util';\n\nimport * as o from './output_ast';\nimport {SourceMapGenerator} from './source_map';\n\nconst _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\\\|\\n|\\r|\\$/g;\nconst _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;\nconst _INDENT_WITH = '  ';\n\nclass _EmittedLine {\n  partsLength = 0;\n  parts: string[] = [];\n  srcSpans: (ParseSourceSpan | null)[] = [];\n  constructor(public indent: number) {}\n}\n\nconst BINARY_OPERATORS = new Map([\n  [o.BinaryOperator.And, '&&'],\n  [o.BinaryOperator.Bigger, '>'],\n  [o.BinaryOperator.BiggerEquals, '>='],\n  [o.BinaryOperator.BitwiseOr, '|'],\n  [o.BinaryOperator.BitwiseAnd, '&'],\n  [o.BinaryOperator.Divide, '/'],\n  [o.BinaryOperator.Assign, '='],\n  [o.BinaryOperator.Equals, '=='],\n  [o.BinaryOperator.Identical, '==='],\n  [o.BinaryOperator.Lower, '<'],\n  [o.BinaryOperator.LowerEquals, '<='],\n  [o.BinaryOperator.Minus, '-'],\n  [o.BinaryOperator.Modulo, '%'],\n  [o.BinaryOperator.Exponentiation, '**'],\n  [o.BinaryOperator.Multiply, '*'],\n  [o.BinaryOperator.NotEquals, '!='],\n  [o.BinaryOperator.NotIdentical, '!=='],\n  [o.BinaryOperator.NullishCoalesce, '??'],\n  [o.BinaryOperator.Or, '||'],\n  [o.BinaryOperator.Plus, '+'],\n  [o.BinaryOperator.In, 'in'],\n  [o.BinaryOperator.AdditionAssignment, '+='],\n  [o.BinaryOperator.SubtractionAssignment, '-='],\n  [o.BinaryOperator.MultiplicationAssignment, '*='],\n  [o.BinaryOperator.DivisionAssignment, '/='],\n  [o.BinaryOperator.RemainderAssignment, '%='],\n  [o.BinaryOperator.ExponentiationAssignment, '**='],\n  [o.BinaryOperator.AndAssignment, '&&='],\n  [o.BinaryOperator.OrAssignment, '||='],\n  [o.BinaryOperator.NullishCoalesceAssignment, '??='],\n]);\n\nexport class EmitterVisitorContext {\n  static createRoot(): EmitterVisitorContext {\n    return new EmitterVisitorContext(0);\n  }\n\n  private _lines: _EmittedLine[];\n\n  constructor(private _indent: number) {\n    this._lines = [new _EmittedLine(_indent)];\n  }\n\n  /**\n   * @internal strip this from published d.ts files due to\n   * https://github.com/microsoft/TypeScript/issues/36216\n   */\n  private get _currentLine(): _EmittedLine {\n    return this._lines[this._lines.length - 1];\n  }\n\n  println(from?: {sourceSpan: ParseSourceSpan | null} | null, lastPart: string = ''): void {\n    this.print(from || null, lastPart, true);\n  }\n\n  lineIsEmpty(): boolean {\n    return this._currentLine.parts.length === 0;\n  }\n\n  lineLength(): number {\n    return this._currentLine.indent * _INDENT_WITH.length + this._currentLine.partsLength;\n  }\n\n  print(from: {sourceSpan: ParseSourceSpan | null} | null, part: string, newLine: boolean = false) {\n    if (part.length > 0) {\n      this._currentLine.parts.push(part);\n      this._currentLine.partsLength += part.length;\n      this._currentLine.srcSpans.push((from && from.sourceSpan) || null);\n    }\n    if (newLine) {\n      this._lines.push(new _EmittedLine(this._indent));\n    }\n  }\n\n  removeEmptyLastLine() {\n    if (this.lineIsEmpty()) {\n      this._lines.pop();\n    }\n  }\n\n  incIndent() {\n    this._indent++;\n    if (this.lineIsEmpty()) {\n      this._currentLine.indent = this._indent;\n    }\n  }\n\n  decIndent() {\n    this._indent--;\n    if (this.lineIsEmpty()) {\n      this._currentLine.indent = this._indent;\n    }\n  }\n\n  toSource(): string {\n    return this.sourceLines\n      .map((l) => (l.parts.length > 0 ? _createIndent(l.indent) + l.parts.join('') : ''))\n      .join('\\n');\n  }\n\n  toSourceMapGenerator(genFilePath: string, startsAtLine: number = 0): SourceMapGenerator {\n    const map = new SourceMapGenerator(genFilePath);\n\n    let firstOffsetMapped = false;\n    const mapFirstOffsetIfNeeded = () => {\n      if (!firstOffsetMapped) {\n        // Add a single space so that tools won't try to load the file from disk.\n        // Note: We are using virtual urls like `ng:///`, so we have to\n        // provide a content here.\n        map.addSource(genFilePath, ' ').addMapping(0, genFilePath, 0, 0);\n        firstOffsetMapped = true;\n      }\n    };\n\n    for (let i = 0; i < startsAtLine; i++) {\n      map.addLine();\n      mapFirstOffsetIfNeeded();\n    }\n\n    this.sourceLines.forEach((line, lineIdx) => {\n      map.addLine();\n\n      const spans = line.srcSpans;\n      const parts = line.parts;\n      let col0 = line.indent * _INDENT_WITH.length;\n      let spanIdx = 0;\n      // skip leading parts without source spans\n      while (spanIdx < spans.length && !spans[spanIdx]) {\n        col0 += parts[spanIdx].length;\n        spanIdx++;\n      }\n      if (spanIdx < spans.length && lineIdx === 0 && col0 === 0) {\n        firstOffsetMapped = true;\n      } else {\n        mapFirstOffsetIfNeeded();\n      }\n\n      while (spanIdx < spans.length) {\n        const span = spans[spanIdx]!;\n        const source = span.start.file;\n        const sourceLine = span.start.line;\n        const sourceCol = span.start.col;\n        map\n          .addSource(source.url, source.content)\n          .addMapping(col0, source.url, sourceLine, sourceCol);\n\n        col0 += parts[spanIdx].length;\n        spanIdx++;\n\n        // assign parts without span or the same span to the previous segment\n        while (spanIdx < spans.length && (span === spans[spanIdx] || !spans[spanIdx])) {\n          col0 += parts[spanIdx].length;\n          spanIdx++;\n        }\n      }\n    });\n\n    return map;\n  }\n\n  spanOf(line: number, column: number): ParseSourceSpan | null {\n    const emittedLine = this._lines[line];\n    if (emittedLine) {\n      let columnsLeft = column - _createIndent(emittedLine.indent).length;\n      for (let partIndex = 0; partIndex < emittedLine.parts.length; partIndex++) {\n        const part = emittedLine.parts[partIndex];\n        if (part.length > columnsLeft) {\n          return emittedLine.srcSpans[partIndex];\n        }\n        columnsLeft -= part.length;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @internal strip this from published d.ts files due to\n   * https://github.com/microsoft/TypeScript/issues/36216\n   */\n  private get sourceLines(): _EmittedLine[] {\n    if (this._lines.length && this._lines[this._lines.length - 1].parts.length === 0) {\n      return this._lines.slice(0, -1);\n    }\n    return this._lines;\n  }\n}\n\nexport abstract class AbstractEmitterVisitor implements o.StatementVisitor, o.ExpressionVisitor {\n  private lastIfCondition: o.Expression | null = null;\n\n  constructor(private _escapeDollarInStrings: boolean) {}\n\n  protected printLeadingComments(stmt: o.Statement, ctx: EmitterVisitorContext): void {\n    if (stmt.leadingComments === undefined) {\n      return;\n    }\n    for (const comment of stmt.leadingComments) {\n      if (comment instanceof o.JSDocComment) {\n        ctx.print(stmt, `/*${comment.toString()}*/`, comment.trailingNewline);\n      } else {\n        if (comment.multiline) {\n          ctx.print(stmt, `/* ${comment.text} */`, comment.trailingNewline);\n        } else {\n          comment.text.split('\\n').forEach((line) => {\n            ctx.println(stmt, `// ${line}`);\n          });\n        }\n      }\n    }\n  }\n\n  visitExpressionStmt(stmt: o.ExpressionStatement, ctx: EmitterVisitorContext): any {\n    this.printLeadingComments(stmt, ctx);\n    stmt.expr.visitExpression(this, ctx);\n    ctx.println(stmt, ';');\n    return null;\n  }\n\n  visitReturnStmt(stmt: o.ReturnStatement, ctx: EmitterVisitorContext): any {\n    this.printLeadingComments(stmt, ctx);\n    ctx.print(stmt, `return `);\n    stmt.value.visitExpression(this, ctx);\n    ctx.println(stmt, ';');\n    return null;\n  }\n\n  visitIfStmt(stmt: o.IfStmt, ctx: EmitterVisitorContext): any {\n    this.printLeadingComments(stmt, ctx);\n    ctx.print(stmt, `if (`);\n    this.lastIfCondition = stmt.condition; // We can skip redundant parentheses for the condition.\n    stmt.condition.visitExpression(this, ctx);\n    this.lastIfCondition = null;\n    ctx.print(stmt, `) {`);\n    const hasElseCase = stmt.falseCase != null && stmt.falseCase.length > 0;\n    if (stmt.trueCase.length <= 1 && !hasElseCase) {\n      ctx.print(stmt, ` `);\n      this.visitAllStatements(stmt.trueCase, ctx);\n      ctx.removeEmptyLastLine();\n      ctx.print(stmt, ` `);\n    } else {\n      ctx.println();\n      ctx.incIndent();\n      this.visitAllStatements(stmt.trueCase, ctx);\n      ctx.decIndent();\n      if (hasElseCase) {\n        ctx.println(stmt, `} else {`);\n        ctx.incIndent();\n        this.visitAllStatements(stmt.falseCase, ctx);\n        ctx.decIndent();\n      }\n    }\n    ctx.println(stmt, `}`);\n    return null;\n  }\n\n  abstract visitDeclareVarStmt(stmt: o.DeclareVarStmt, ctx: EmitterVisitorContext): any;\n\n  visitInvokeFunctionExpr(expr: o.InvokeFunctionExpr, ctx: EmitterVisitorContext): any {\n    const shouldParenthesize = expr.fn instanceof o.ArrowFunctionExpr;\n\n    if (shouldParenthesize) {\n      ctx.print(expr.fn, '(');\n    }\n    expr.fn.visitExpression(this, ctx);\n    if (shouldParenthesize) {\n      ctx.print(expr.fn, ')');\n    }\n    ctx.print(expr, `(`);\n    this.visitAllExpressions(expr.args, ctx, ',');\n    ctx.print(expr, `)`);\n    return null;\n  }\n  visitTaggedTemplateLiteralExpr(\n    expr: o.TaggedTemplateLiteralExpr,\n    ctx: EmitterVisitorContext,\n  ): any {\n    expr.tag.visitExpression(this, ctx);\n    expr.template.visitExpression(this, ctx);\n    return null;\n  }\n  visitTemplateLiteralExpr(expr: o.TemplateLiteralExpr, ctx: EmitterVisitorContext) {\n    ctx.print(expr, '`');\n    for (let i = 0; i < expr.elements.length; i++) {\n      expr.elements[i].visitExpression(this, ctx);\n      const expression = i < expr.expressions.length ? expr.expressions[i] : null;\n      if (expression !== null) {\n        ctx.print(expression, '${');\n        expression.visitExpression(this, ctx);\n        ctx.print(expression, '}');\n      }\n    }\n    ctx.print(expr, '`');\n  }\n  visitTemplateLiteralElementExpr(expr: o.TemplateLiteralElementExpr, ctx: EmitterVisitorContext) {\n    ctx.print(expr, expr.rawText);\n  }\n  visitWrappedNodeExpr(ast: o.WrappedNodeExpr<any>, ctx: EmitterVisitorContext): any {\n    throw new Error('Abstract emitter cannot visit WrappedNodeExpr.');\n  }\n  visitTypeofExpr(expr: o.TypeofExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(expr, 'typeof ');\n    expr.expr.visitExpression(this, ctx);\n  }\n  visitVoidExpr(expr: o.VoidExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(expr, 'void ');\n    expr.expr.visitExpression(this, ctx);\n  }\n  visitReadVarExpr(ast: o.ReadVarExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, ast.name);\n    return null;\n  }\n  visitInstantiateExpr(ast: o.InstantiateExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `new `);\n    ast.classExpr.visitExpression(this, ctx);\n    ctx.print(ast, `(`);\n    this.visitAllExpressions(ast.args, ctx, ',');\n    ctx.print(ast, `)`);\n    return null;\n  }\n\n  visitLiteralExpr(ast: o.LiteralExpr, ctx: EmitterVisitorContext): any {\n    const value = ast.value;\n    if (typeof value === 'string') {\n      ctx.print(ast, escapeIdentifier(value, this._escapeDollarInStrings));\n    } else {\n      ctx.print(ast, `${value}`);\n    }\n    return null;\n  }\n\n  visitLocalizedString(ast: o.LocalizedString, ctx: EmitterVisitorContext): any {\n    const head = ast.serializeI18nHead();\n    ctx.print(ast, '$localize `' + head.raw);\n    for (let i = 1; i < ast.messageParts.length; i++) {\n      ctx.print(ast, '${');\n      ast.expressions[i - 1].visitExpression(this, ctx);\n      ctx.print(ast, `}${ast.serializeI18nTemplatePart(i).raw}`);\n    }\n    ctx.print(ast, '`');\n    return null;\n  }\n\n  abstract visitExternalExpr(ast: o.ExternalExpr, ctx: EmitterVisitorContext): any;\n\n  visitConditionalExpr(ast: o.ConditionalExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `(`);\n    ast.condition.visitExpression(this, ctx);\n    ctx.print(ast, '? ');\n    ast.trueCase.visitExpression(this, ctx);\n    ctx.print(ast, ': ');\n    ast.falseCase!.visitExpression(this, ctx);\n    ctx.print(ast, `)`);\n    return null;\n  }\n\n  visitDynamicImportExpr(ast: o.DynamicImportExpr, ctx: EmitterVisitorContext) {\n    ctx.print(ast, `import(${ast.url})`);\n  }\n\n  visitNotExpr(ast: o.NotExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, '!');\n    ast.condition.visitExpression(this, ctx);\n    return null;\n  }\n  abstract visitFunctionExpr(ast: o.FunctionExpr, ctx: EmitterVisitorContext): any;\n  abstract visitArrowFunctionExpr(ast: o.ArrowFunctionExpr, context: any): any;\n  abstract visitDeclareFunctionStmt(stmt: o.DeclareFunctionStmt, context: any): any;\n\n  visitUnaryOperatorExpr(ast: o.UnaryOperatorExpr, ctx: EmitterVisitorContext): any {\n    let opStr: string;\n    switch (ast.operator) {\n      case o.UnaryOperator.Plus:\n        opStr = '+';\n        break;\n      case o.UnaryOperator.Minus:\n        opStr = '-';\n        break;\n      default:\n        throw new Error(`Unknown operator ${ast.operator}`);\n    }\n    const parens = ast !== this.lastIfCondition;\n    if (parens) ctx.print(ast, `(`);\n    ctx.print(ast, opStr);\n    ast.expr.visitExpression(this, ctx);\n    if (parens) ctx.print(ast, `)`);\n    return null;\n  }\n\n  visitBinaryOperatorExpr(ast: o.BinaryOperatorExpr, ctx: EmitterVisitorContext): any {\n    const operator = BINARY_OPERATORS.get(ast.operator);\n    if (!operator) {\n      throw new Error(`Unknown operator ${ast.operator}`);\n    }\n    const parens = ast !== this.lastIfCondition;\n    if (parens) ctx.print(ast, `(`);\n    ast.lhs.visitExpression(this, ctx);\n    ctx.print(ast, ` ${operator} `);\n    ast.rhs.visitExpression(this, ctx);\n    if (parens) ctx.print(ast, `)`);\n    return null;\n  }\n\n  visitReadPropExpr(ast: o.ReadPropExpr, ctx: EmitterVisitorContext): any {\n    ast.receiver.visitExpression(this, ctx);\n    ctx.print(ast, `.`);\n    ctx.print(ast, ast.name);\n    return null;\n  }\n  visitReadKeyExpr(ast: o.ReadKeyExpr, ctx: EmitterVisitorContext): any {\n    ast.receiver.visitExpression(this, ctx);\n    ctx.print(ast, `[`);\n    ast.index.visitExpression(this, ctx);\n    ctx.print(ast, `]`);\n    return null;\n  }\n  visitLiteralArrayExpr(ast: o.LiteralArrayExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `[`);\n    this.visitAllExpressions(ast.entries, ctx, ',');\n    ctx.print(ast, `]`);\n    return null;\n  }\n  visitLiteralMapExpr(ast: o.LiteralMapExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `{`);\n    this.visitAllObjects(\n      (entry) => {\n        ctx.print(\n          ast,\n          `${escapeIdentifier(entry.key, this._escapeDollarInStrings, entry.quoted)}:`,\n        );\n        entry.value.visitExpression(this, ctx);\n      },\n      ast.entries,\n      ctx,\n      ',',\n    );\n    ctx.print(ast, `}`);\n    return null;\n  }\n  visitCommaExpr(ast: o.CommaExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, '(');\n    this.visitAllExpressions(ast.parts, ctx, ',');\n    ctx.print(ast, ')');\n    return null;\n  }\n  visitParenthesizedExpr(ast: o.ParenthesizedExpr, ctx: EmitterVisitorContext): any {\n    // We parenthesize everything regardless of an explicit ParenthesizedExpr, so we can just visit\n    // the inner expression.\n    // TODO: Do we *need* to parenthesize everything?\n    ast.expr.visitExpression(this, ctx);\n  }\n  visitAllExpressions(\n    expressions: o.Expression[],\n    ctx: EmitterVisitorContext,\n    separator: string,\n  ): void {\n    this.visitAllObjects((expr) => expr.visitExpression(this, ctx), expressions, ctx, separator);\n  }\n\n  visitAllObjects<T>(\n    handler: (t: T) => void,\n    expressions: T[],\n    ctx: EmitterVisitorContext,\n    separator: string,\n  ): void {\n    let incrementedIndent = false;\n    for (let i = 0; i < expressions.length; i++) {\n      if (i > 0) {\n        if (ctx.lineLength() > 80) {\n          ctx.print(null, separator, true);\n          if (!incrementedIndent) {\n            // continuation are marked with double indent.\n            ctx.incIndent();\n            ctx.incIndent();\n            incrementedIndent = true;\n          }\n        } else {\n          ctx.print(null, separator, false);\n        }\n      }\n      handler(expressions[i]);\n    }\n    if (incrementedIndent) {\n      // continuation are marked with double indent.\n      ctx.decIndent();\n      ctx.decIndent();\n    }\n  }\n\n  visitAllStatements(statements: o.Statement[], ctx: EmitterVisitorContext): void {\n    statements.forEach((stmt) => stmt.visitStatement(this, ctx));\n  }\n}\n\nexport function escapeIdentifier(\n  input: string,\n  escapeDollar: boolean,\n  alwaysQuote: boolean = true,\n): any {\n  if (input == null) {\n    return null;\n  }\n  const body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, (...match: string[]) => {\n    if (match[0] == '$') {\n      return escapeDollar ? '\\\\$' : '$';\n    } else if (match[0] == '\\n') {\n      return '\\\\n';\n    } else if (match[0] == '\\r') {\n      return '\\\\r';\n    } else {\n      return `\\\\${match[0]}`;\n    }\n  });\n  const requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);\n  return requiresQuotes ? `'${body}'` : body;\n}\n\nfunction _createIndent(count: number): string {\n  let res = '';\n  for (let i = 0; i < count; i++) {\n    res += _INDENT_WITH;\n  }\n  return res;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {escapeIdentifier} from '../output/abstract_emitter';\nimport * as o from '../output/output_ast';\n\nimport {Identifiers} from './r3_identifiers';\n\nexport function typeWithParameters(type: o.Expression, numParams: number): o.ExpressionType {\n  if (numParams === 0) {\n    return o.expressionType(type);\n  }\n  const params: o.Type[] = [];\n  for (let i = 0; i < numParams; i++) {\n    params.push(o.DYNAMIC_TYPE);\n  }\n  return o.expressionType(type, undefined, params);\n}\n\nexport interface R3Reference {\n  value: o.Expression;\n  type: o.Expression;\n}\n\n/**\n * Result of compilation of a render3 code unit, e.g. component, directive, pipe, etc.\n */\nexport interface R3CompiledExpression {\n  expression: o.Expression;\n  type: o.Type;\n  statements: o.Statement[];\n}\n\nconst LEGACY_ANIMATE_SYMBOL_PREFIX = '@';\nexport function prepareSyntheticPropertyName(name: string) {\n  return `${LEGACY_ANIMATE_SYMBOL_PREFIX}${name}`;\n}\n\nexport function prepareSyntheticListenerName(name: string, phase: string) {\n  return `${LEGACY_ANIMATE_SYMBOL_PREFIX}${name}.${phase}`;\n}\n\nexport function getSafePropertyAccessString(accessor: string, name: string): string {\n  const escapedName = escapeIdentifier(name, false, false);\n  return escapedName !== name ? `${accessor}[${escapedName}]` : `${accessor}.${name}`;\n}\n\nexport function prepareSyntheticListenerFunctionName(name: string, phase: string) {\n  return `animation_${name}_${phase}`;\n}\n\nexport function jitOnlyGuardedExpression(expr: o.Expression): o.Expression {\n  return guardedExpression('ngJitMode', expr);\n}\n\nexport function devOnlyGuardedExpression(expr: o.Expression): o.Expression {\n  return guardedExpression('ngDevMode', expr);\n}\n\nexport function guardedExpression(guard: string, expr: o.Expression): o.Expression {\n  const guardExpr = new o.ExternalExpr({name: guard, moduleName: null});\n  const guardNotDefined = new o.BinaryOperatorExpr(\n    o.BinaryOperator.Identical,\n    new o.TypeofExpr(guardExpr),\n    o.literal('undefined'),\n  );\n  const guardUndefinedOrTrue = new o.BinaryOperatorExpr(\n    o.BinaryOperator.Or,\n    guardNotDefined,\n    guardExpr,\n    /* type */ undefined,\n    /* sourceSpan */ undefined,\n  );\n  return new o.BinaryOperatorExpr(o.BinaryOperator.And, guardUndefinedOrTrue, expr);\n}\n\nexport function wrapReference(value: any): R3Reference {\n  const wrapped = new o.WrappedNodeExpr(value);\n  return {value: wrapped, type: wrapped};\n}\n\nexport function refsToArray(refs: R3Reference[], shouldForwardDeclare: boolean): o.Expression {\n  const values = o.literalArr(refs.map((ref) => ref.value));\n  return shouldForwardDeclare ? o.arrowFn([], values) : values;\n}\n\n/**\n * Describes an expression that may have been wrapped in a `forwardRef()` guard.\n *\n * This is used when describing expressions that can refer to types that may eagerly reference types\n * that have not yet been defined.\n */\nexport interface MaybeForwardRefExpression<T extends o.Expression = o.Expression> {\n  /**\n   * The unwrapped expression.\n   */\n  expression: T;\n  /**\n   * Specified whether the `expression` contains a reference to something that has not yet been\n   * defined, and whether the expression is still wrapped in a `forwardRef()` call.\n   *\n   * If this value is `ForwardRefHandling.None` then the `expression` is safe to use as-is.\n   *\n   * Otherwise the `expression` was wrapped in a call to `forwardRef()` and must not be eagerly\n   * evaluated. Instead it must be wrapped in a function closure that will be evaluated lazily to\n   * allow the definition of the expression to be evaluated first.\n   *\n   * In full AOT compilation it can be safe to unwrap the `forwardRef()` call up front if the\n   * expression will actually be evaluated lazily inside a function call after the value of\n   * `expression` has been defined.\n   *\n   * But in other cases, such as partial AOT compilation or JIT compilation the expression will be\n   * evaluated eagerly in top level code so will need to continue to be wrapped in a `forwardRef()`\n   * call.\n   *\n   */\n  forwardRef: ForwardRefHandling;\n}\n\nexport function createMayBeForwardRefExpression<T extends o.Expression>(\n  expression: T,\n  forwardRef: ForwardRefHandling,\n): MaybeForwardRefExpression<T> {\n  return {expression, forwardRef};\n}\n\n/**\n * Convert a `MaybeForwardRefExpression` to an `Expression`, possibly wrapping its expression in a\n * `forwardRef()` call.\n *\n * If `MaybeForwardRefExpression.forwardRef` is `ForwardRefHandling.Unwrapped` then the expression\n * was originally wrapped in a `forwardRef()` call to prevent the value from being eagerly evaluated\n * in the code.\n *\n * See `packages/compiler-cli/src/ngtsc/annotations/src/injectable.ts` and\n * `packages/compiler/src/jit_compiler_facade.ts` for more information.\n */\nexport function convertFromMaybeForwardRefExpression({\n  expression,\n  forwardRef,\n}: MaybeForwardRefExpression): o.Expression {\n  switch (forwardRef) {\n    case ForwardRefHandling.None:\n    case ForwardRefHandling.Wrapped:\n      return expression;\n    case ForwardRefHandling.Unwrapped:\n      return generateForwardRef(expression);\n  }\n}\n\n/**\n * Generate an expression that has the given `expr` wrapped in the following form:\n *\n * ```ts\n * forwardRef(() => expr)\n * ```\n */\nexport function generateForwardRef(expr: o.Expression): o.Expression {\n  return o.importExpr(Identifiers.forwardRef).callFn([o.arrowFn([], expr)]);\n}\n\n/**\n * Specifies how a forward ref has been handled in a MaybeForwardRefExpression\n */\nexport const enum ForwardRefHandling {\n  /** The expression was not wrapped in a `forwardRef()` call in the first place. */\n  None,\n  /** The expression is still wrapped in a `forwardRef()` call. */\n  Wrapped,\n  /** The expression was wrapped in a `forwardRef()` call but has since been unwrapped. */\n  Unwrapped,\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport {FactoryTarget} from '../compiler_facade_interface';\nimport {InjectFlags} from '../core';\nimport * as o from '../output/output_ast';\nimport {Identifiers as R3} from '../render3/r3_identifiers';\n\nimport {R3CompiledExpression, R3Reference, typeWithParameters} from './util';\n\n/**\n * Metadata required by the factory generator to generate a `factory` function for a type.\n */\nexport interface R3ConstructorFactoryMetadata {\n  /**\n   * String name of the type being generated (used to name the factory function).\n   */\n  name: string;\n\n  /**\n   * An expression representing the interface type being constructed.\n   */\n  type: R3Reference;\n\n  /** Number of arguments for the `type`. */\n  typeArgumentCount: number;\n\n  /**\n   * Regardless of whether `fnOrClass` is a constructor function or a user-defined factory, it\n   * may have 0 or more parameters, which will be injected according to the `R3DependencyMetadata`\n   * for those parameters. If this is `null`, then the type's constructor is nonexistent and will\n   * be inherited from `fnOrClass` which is interpreted as the current type. If this is `'invalid'`,\n   * then one or more of the parameters wasn't resolvable and any attempt to use these deps will\n   * result in a runtime error.\n   */\n  deps: R3DependencyMetadata[] | 'invalid' | null;\n\n  /**\n   * Type of the target being created by the factory.\n   */\n  target: FactoryTarget;\n}\n\nexport enum R3FactoryDelegateType {\n  Class = 0,\n  Function = 1,\n}\n\nexport interface R3DelegatedFnOrClassMetadata extends R3ConstructorFactoryMetadata {\n  delegate: o.Expression;\n  delegateType: R3FactoryDelegateType;\n  delegateDeps: R3DependencyMetadata[];\n}\n\nexport interface R3ExpressionFactoryMetadata extends R3ConstructorFactoryMetadata {\n  expression: o.Expression;\n}\n\nexport type R3FactoryMetadata =\n  | R3ConstructorFactoryMetadata\n  | R3DelegatedFnOrClassMetadata\n  | R3ExpressionFactoryMetadata;\n\nexport interface R3DependencyMetadata {\n  /**\n   * An expression representing the token or value to be injected.\n   * Or `null` if the dependency could not be resolved - making it invalid.\n   */\n  token: o.Expression | null;\n\n  /**\n   * If an @Attribute decorator is present, this is the literal type of the attribute name, or\n   * the unknown type if no literal type is available (e.g. the attribute name is an expression).\n   * Otherwise it is null;\n   */\n  attributeNameType: o.Expression | null;\n\n  /**\n   * Whether the dependency has an @Host qualifier.\n   */\n  host: boolean;\n\n  /**\n   * Whether the dependency has an @Optional qualifier.\n   */\n  optional: boolean;\n\n  /**\n   * Whether the dependency has an @Self qualifier.\n   */\n  self: boolean;\n\n  /**\n   * Whether the dependency has an @SkipSelf qualifier.\n   */\n  skipSelf: boolean;\n}\n\n/**\n * Construct a factory function expression for the given `R3FactoryMetadata`.\n */\nexport function compileFactoryFunction(meta: R3FactoryMetadata): R3CompiledExpression {\n  const t = o.variable('__ngFactoryType__');\n  let baseFactoryVar: o.ReadVarExpr | null = null;\n\n  // The type to instantiate via constructor invocation. If there is no delegated factory, meaning\n  // this type is always created by constructor invocation, then this is the type-to-create\n  // parameter provided by the user (t) if specified, or the current type if not. If there is a\n  // delegated factory (which is used to create the current type) then this is only the type-to-\n  // create parameter (t).\n  const typeForCtor = !isDelegatedFactoryMetadata(meta)\n    ? new o.BinaryOperatorExpr(o.BinaryOperator.Or, t, meta.type.value)\n    : t;\n\n  let ctorExpr: o.Expression | null = null;\n  if (meta.deps !== null) {\n    // There is a constructor (either explicitly or implicitly defined).\n    if (meta.deps !== 'invalid') {\n      ctorExpr = new o.InstantiateExpr(typeForCtor, injectDependencies(meta.deps, meta.target));\n    }\n  } else {\n    // There is no constructor, use the base class' factory to construct typeForCtor.\n    baseFactoryVar = o.variable(`ɵ${meta.name}_BaseFactory`);\n    ctorExpr = baseFactoryVar.callFn([typeForCtor]);\n  }\n\n  const body: o.Statement[] = [];\n  let retExpr: o.Expression | null = null;\n\n  function makeConditionalFactory(nonCtorExpr: o.Expression): o.ReadVarExpr {\n    const r = o.variable('__ngConditionalFactory__');\n    body.push(new o.DeclareVarStmt(r.name, o.NULL_EXPR, o.INFERRED_TYPE));\n    const ctorStmt =\n      ctorExpr !== null\n        ? r.set(ctorExpr).toStmt()\n        : o.importExpr(R3.invalidFactory).callFn([]).toStmt();\n    body.push(o.ifStmt(t, [ctorStmt], [r.set(nonCtorExpr).toStmt()]));\n    return r;\n  }\n\n  if (isDelegatedFactoryMetadata(meta)) {\n    // This type is created with a delegated factory. If a type parameter is not specified, call\n    // the factory instead.\n    const delegateArgs = injectDependencies(meta.delegateDeps, meta.target);\n    // Either call `new delegate(...)` or `delegate(...)` depending on meta.delegateType.\n    const factoryExpr = new (\n      meta.delegateType === R3FactoryDelegateType.Class ? o.InstantiateExpr : o.InvokeFunctionExpr\n    )(meta.delegate, delegateArgs);\n    retExpr = makeConditionalFactory(factoryExpr);\n  } else if (isExpressionFactoryMetadata(meta)) {\n    // TODO(alxhub): decide whether to lower the value here or in the caller\n    retExpr = makeConditionalFactory(meta.expression);\n  } else {\n    retExpr = ctorExpr;\n  }\n\n  if (retExpr === null) {\n    // The expression cannot be formed so render an `ɵɵinvalidFactory()` call.\n    body.push(o.importExpr(R3.invalidFactory).callFn([]).toStmt());\n  } else if (baseFactoryVar !== null) {\n    // This factory uses a base factory, so call `ɵɵgetInheritedFactory()` to compute it.\n    const getInheritedFactoryCall = o.importExpr(R3.getInheritedFactory).callFn([meta.type.value]);\n    // Memoize the base factoryFn: `baseFactory || (baseFactory = ɵɵgetInheritedFactory(...))`\n    const baseFactory = new o.BinaryOperatorExpr(\n      o.BinaryOperator.Or,\n      baseFactoryVar,\n      baseFactoryVar.set(getInheritedFactoryCall),\n    );\n    body.push(new o.ReturnStatement(baseFactory.callFn([typeForCtor])));\n  } else {\n    // This is straightforward factory, just return it.\n    body.push(new o.ReturnStatement(retExpr));\n  }\n\n  let factoryFn: o.Expression = o.fn(\n    [new o.FnParam(t.name, o.DYNAMIC_TYPE)],\n    body,\n    o.INFERRED_TYPE,\n    undefined,\n    `${meta.name}_Factory`,\n  );\n\n  if (baseFactoryVar !== null) {\n    // There is a base factory variable so wrap its declaration along with the factory function into\n    // an IIFE.\n    factoryFn = o\n      .arrowFn([], [new o.DeclareVarStmt(baseFactoryVar.name!), new o.ReturnStatement(factoryFn)])\n      .callFn([], /* sourceSpan */ undefined, /* pure */ true);\n  }\n\n  return {\n    expression: factoryFn,\n    statements: [],\n    type: createFactoryType(meta),\n  };\n}\n\nexport function createFactoryType(meta: R3FactoryMetadata) {\n  const ctorDepsType =\n    meta.deps !== null && meta.deps !== 'invalid' ? createCtorDepsType(meta.deps) : o.NONE_TYPE;\n  return o.expressionType(\n    o.importExpr(R3.FactoryDeclaration, [\n      typeWithParameters(meta.type.type, meta.typeArgumentCount),\n      ctorDepsType,\n    ]),\n  );\n}\n\nfunction injectDependencies(deps: R3DependencyMetadata[], target: FactoryTarget): o.Expression[] {\n  return deps.map((dep, index) => compileInjectDependency(dep, target, index));\n}\n\nfunction compileInjectDependency(\n  dep: R3DependencyMetadata,\n  target: FactoryTarget,\n  index: number,\n): o.Expression {\n  // Interpret the dependency according to its resolved type.\n  if (dep.token === null) {\n    return o.importExpr(R3.invalidFactoryDep).callFn([o.literal(index)]);\n  } else if (dep.attributeNameType === null) {\n    // Build up the injection flags according to the metadata.\n    const flags =\n      InjectFlags.Default |\n      (dep.self ? InjectFlags.Self : 0) |\n      (dep.skipSelf ? InjectFlags.SkipSelf : 0) |\n      (dep.host ? InjectFlags.Host : 0) |\n      (dep.optional ? InjectFlags.Optional : 0) |\n      (target === FactoryTarget.Pipe ? InjectFlags.ForPipe : 0);\n\n    // If this dependency is optional or otherwise has non-default flags, then additional\n    // parameters describing how to inject the dependency must be passed to the inject function\n    // that's being used.\n    let flagsParam: o.LiteralExpr | null =\n      flags !== InjectFlags.Default || dep.optional ? o.literal(flags) : null;\n\n    // Build up the arguments to the injectFn call.\n    const injectArgs = [dep.token];\n    if (flagsParam) {\n      injectArgs.push(flagsParam);\n    }\n    const injectFn = getInjectFn(target);\n    return o.importExpr(injectFn).callFn(injectArgs);\n  } else {\n    // The `dep.attributeTypeName` value is defined, which indicates that this is an `@Attribute()`\n    // type dependency. For the generated JS we still want to use the `dep.token` value in case the\n    // name given for the attribute is not a string literal. For example given `@Attribute(foo())`,\n    // we want to generate `ɵɵinjectAttribute(foo())`.\n    //\n    // The `dep.attributeTypeName` is only actually used (in `createCtorDepType()`) to generate\n    // typings.\n    return o.importExpr(R3.injectAttribute).callFn([dep.token]);\n  }\n}\n\nfunction createCtorDepsType(deps: R3DependencyMetadata[]): o.Type {\n  let hasTypes = false;\n  const attributeTypes = deps.map((dep) => {\n    const type = createCtorDepType(dep);\n    if (type !== null) {\n      hasTypes = true;\n      return type;\n    } else {\n      return o.literal(null);\n    }\n  });\n\n  if (hasTypes) {\n    return o.expressionType(o.literalArr(attributeTypes));\n  } else {\n    return o.NONE_TYPE;\n  }\n}\n\nfunction createCtorDepType(dep: R3DependencyMetadata): o.LiteralMapExpr | null {\n  const entries: {key: string; quoted: boolean; value: o.Expression}[] = [];\n\n  if (dep.attributeNameType !== null) {\n    entries.push({key: 'attribute', value: dep.attributeNameType, quoted: false});\n  }\n  if (dep.optional) {\n    entries.push({key: 'optional', value: o.literal(true), quoted: false});\n  }\n  if (dep.host) {\n    entries.push({key: 'host', value: o.literal(true), quoted: false});\n  }\n  if (dep.self) {\n    entries.push({key: 'self', value: o.literal(true), quoted: false});\n  }\n  if (dep.skipSelf) {\n    entries.push({key: 'skipSelf', value: o.literal(true), quoted: false});\n  }\n\n  return entries.length > 0 ? o.literalMap(entries) : null;\n}\n\nexport function isDelegatedFactoryMetadata(\n  meta: R3FactoryMetadata,\n): meta is R3DelegatedFnOrClassMetadata {\n  return (meta as any).delegateType !== undefined;\n}\n\nexport function isExpressionFactoryMetadata(\n  meta: R3FactoryMetadata,\n): meta is R3ExpressionFactoryMetadata {\n  return (meta as any).expression !== undefined;\n}\n\nfunction getInjectFn(target: FactoryTarget): o.ExternalReference {\n  switch (target) {\n    case FactoryTarget.Component:\n    case FactoryTarget.Directive:\n    case FactoryTarget.Pipe:\n      return R3.directiveInject;\n    case FactoryTarget.NgModule:\n    case FactoryTarget.Injectable:\n    default:\n      return R3.inject;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {SecurityContext} from '../core';\nimport {ParseError, ParseSourceSpan} from '../parse_util';\n\nexport class ParseSpan {\n  constructor(\n    public start: number,\n    public end: number,\n  ) {}\n  toAbsolute(absoluteOffset: number): AbsoluteSourceSpan {\n    return new AbsoluteSourceSpan(absoluteOffset + this.start, absoluteOffset + this.end);\n  }\n}\n\nexport abstract class AST {\n  constructor(\n    public span: ParseSpan,\n    /**\n     * Absolute location of the expression AST in a source code file.\n     */\n    public sourceSpan: AbsoluteSourceSpan,\n  ) {}\n\n  abstract visit(visitor: AstVisitor, context?: any): any;\n\n  toString(): string {\n    return 'AST';\n  }\n}\n\nexport abstract class ASTWithName extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public nameSpan: AbsoluteSourceSpan,\n  ) {\n    super(span, sourceSpan);\n  }\n}\n\nexport class EmptyExpr extends AST {\n  override visit(visitor: AstVisitor, context: any = null) {\n    // do nothing\n  }\n}\n\nexport class ImplicitReceiver extends AST {\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitImplicitReceiver(this, context);\n  }\n}\n\n/**\n * Receiver when something is accessed through `this` (e.g. `this.foo`). Note that this class\n * inherits from `ImplicitReceiver`, because accessing something through `this` is treated the\n * same as accessing it implicitly inside of an Angular template (e.g. `[attr.title]=\"this.title\"`\n * is the same as `[attr.title]=\"title\"`.). Inheriting allows for the `this` accesses to be treated\n * the same as implicit ones, except for a couple of exceptions like `$event` and `$any`.\n * TODO: we should find a way for this class not to extend from `ImplicitReceiver` in the future.\n */\nexport class ThisReceiver extends ImplicitReceiver {\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitThisReceiver?.(this, context);\n  }\n}\n\n/**\n * Multiple expressions separated by a semicolon.\n */\nexport class Chain extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public expressions: any[],\n  ) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitChain(this, context);\n  }\n}\n\nexport class Conditional extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public condition: AST,\n    public trueExp: AST,\n    public falseExp: AST,\n  ) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitConditional(this, context);\n  }\n}\n\nexport class PropertyRead extends ASTWithName {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    nameSpan: AbsoluteSourceSpan,\n    public receiver: AST,\n    public name: string,\n  ) {\n    super(span, sourceSpan, nameSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPropertyRead(this, context);\n  }\n}\n\nexport class SafePropertyRead extends ASTWithName {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    nameSpan: AbsoluteSourceSpan,\n    public receiver: AST,\n    public name: string,\n  ) {\n    super(span, sourceSpan, nameSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitSafePropertyRead(this, context);\n  }\n}\n\nexport class KeyedRead extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public receiver: AST,\n    public key: AST,\n  ) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitKeyedRead(this, context);\n  }\n}\n\nexport class SafeKeyedRead extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public receiver: AST,\n    public key: AST,\n  ) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitSafeKeyedRead(this, context);\n  }\n}\n\n/** Possible types for a pipe. */\nexport enum BindingPipeType {\n  /**\n   * Pipe is being referenced by its name, for example:\n   * `@Pipe({name: 'foo'}) class FooPipe` and `{{123 | foo}}`.\n   */\n  ReferencedByName,\n\n  /**\n   * Pipe is being referenced by its class name, for example:\n   * `@Pipe() class FooPipe` and `{{123 | FooPipe}}`.\n   */\n  ReferencedDirectly,\n}\n\nexport class BindingPipe extends ASTWithName {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public exp: AST,\n    public name: string,\n    public args: any[],\n    readonly type: BindingPipeType,\n    nameSpan: AbsoluteSourceSpan,\n  ) {\n    super(span, sourceSpan, nameSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPipe(this, context);\n  }\n}\n\nexport class LiteralPrimitive extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public value: any,\n  ) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitLiteralPrimitive(this, context);\n  }\n}\n\nexport class LiteralArray extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public expressions: any[],\n  ) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitLiteralArray(this, context);\n  }\n}\n\nexport type LiteralMapKey = {\n  key: string;\n  quoted: boolean;\n  isShorthandInitialized?: boolean;\n};\n\nexport class LiteralMap extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public keys: LiteralMapKey[],\n    public values: any[],\n  ) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitLiteralMap(this, context);\n  }\n}\n\nexport class Interpolation extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public strings: string[],\n    public expressions: AST[],\n  ) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitInterpolation(this, context);\n  }\n}\n\nexport class Binary extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public operation: string,\n    public left: AST,\n    public right: AST,\n  ) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitBinary(this, context);\n  }\n\n  static isAssignmentOperation(op: string): boolean {\n    return (\n      op === '=' ||\n      op === '+=' ||\n      op === '-=' ||\n      op === '*=' ||\n      op === '/=' ||\n      op === '%=' ||\n      op === '**=' ||\n      op === '&&=' ||\n      op === '||=' ||\n      op === '??='\n    );\n  }\n}\n\n/**\n * For backwards compatibility reasons, `Unary` inherits from `Binary` and mimics the binary AST\n * node that was originally used. This inheritance relation can be deleted in some future major,\n * after consumers have been given a chance to fully support Unary.\n */\nexport class Unary extends Binary {\n  // Redeclare the properties that are inherited from `Binary` as `never`, as consumers should not\n  // depend on these fields when operating on `Unary`.\n  override left: never = null as never;\n  override right: never = null as never;\n  override operation: never = null as never;\n\n  /**\n   * Creates a unary minus expression \"-x\", represented as `Binary` using \"0 - x\".\n   */\n  static createMinus(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, expr: AST): Unary {\n    return new Unary(\n      span,\n      sourceSpan,\n      '-',\n      expr,\n      '-',\n      new LiteralPrimitive(span, sourceSpan, 0),\n      expr,\n    );\n  }\n\n  /**\n   * Creates a unary plus expression \"+x\", represented as `Binary` using \"x - 0\".\n   */\n  static createPlus(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, expr: AST): Unary {\n    return new Unary(\n      span,\n      sourceSpan,\n      '+',\n      expr,\n      '-',\n      expr,\n      new LiteralPrimitive(span, sourceSpan, 0),\n    );\n  }\n\n  /**\n   * During the deprecation period this constructor is private, to avoid consumers from creating\n   * a `Unary` with the fallback properties for `Binary`.\n   */\n  private constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public operator: string,\n    public expr: AST,\n    binaryOp: string,\n    binaryLeft: AST,\n    binaryRight: AST,\n  ) {\n    super(span, sourceSpan, binaryOp, binaryLeft, binaryRight);\n  }\n\n  override visit(visitor: AstVisitor, context: any = null): any {\n    if (visitor.visitUnary !== undefined) {\n      return visitor.visitUnary(this, context);\n    }\n    return visitor.visitBinary(this, context);\n  }\n}\n\nexport class PrefixNot extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public expression: AST,\n  ) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPrefixNot(this, context);\n  }\n}\n\nexport class TypeofExpression extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public expression: AST,\n  ) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitTypeofExpression(this, context);\n  }\n}\n\nexport class VoidExpression extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public expression: AST,\n  ) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitVoidExpression(this, context);\n  }\n}\n\nexport class NonNullAssert extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public expression: AST,\n  ) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitNonNullAssert(this, context);\n  }\n}\n\nexport class Call extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public receiver: AST,\n    public args: AST[],\n    public argumentSpan: AbsoluteSourceSpan,\n  ) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitCall(this, context);\n  }\n}\n\nexport class SafeCall extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public receiver: AST,\n    public args: AST[],\n    public argumentSpan: AbsoluteSourceSpan,\n  ) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitSafeCall(this, context);\n  }\n}\n\nexport class TaggedTemplateLiteral extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public tag: AST,\n    public template: TemplateLiteral,\n  ) {\n    super(span, sourceSpan);\n  }\n\n  override visit(visitor: AstVisitor, context?: any) {\n    return visitor.visitTaggedTemplateLiteral(this, context);\n  }\n}\n\nexport class TemplateLiteral extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public elements: TemplateLiteralElement[],\n    public expressions: AST[],\n  ) {\n    super(span, sourceSpan);\n  }\n\n  override visit(visitor: AstVisitor, context?: any) {\n    return visitor.visitTemplateLiteral(this, context);\n  }\n}\n\nexport class TemplateLiteralElement extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public text: string,\n  ) {\n    super(span, sourceSpan);\n  }\n\n  override visit(visitor: AstVisitor, context?: any) {\n    return visitor.visitTemplateLiteralElement(this, context);\n  }\n}\n\nexport class ParenthesizedExpression extends AST {\n  constructor(\n    span: ParseSpan,\n    sourceSpan: AbsoluteSourceSpan,\n    public expression: AST,\n  ) {\n    super(span, sourceSpan);\n  }\n\n  override visit(visitor: AstVisitor, context?: any) {\n    return visitor.visitParenthesizedExpression(this, context);\n  }\n}\n\n/**\n * Records the absolute position of a text span in a source file, where `start` and `end` are the\n * starting and ending byte offsets, respectively, of the text span in a source file.\n */\nexport class AbsoluteSourceSpan {\n  constructor(\n    public readonly start: number,\n    public readonly end: number,\n  ) {}\n}\n\nexport class ASTWithSource<T extends AST = AST> extends AST {\n  constructor(\n    public ast: T,\n    public source: string | null,\n    public location: string,\n    absoluteOffset: number,\n    public errors: ParseError[],\n  ) {\n    super(\n      new ParseSpan(0, source === null ? 0 : source.length),\n      new AbsoluteSourceSpan(\n        absoluteOffset,\n        source === null ? absoluteOffset : absoluteOffset + source.length,\n      ),\n    );\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    if (visitor.visitASTWithSource) {\n      return visitor.visitASTWithSource(this, context);\n    }\n    return this.ast.visit(visitor, context);\n  }\n  override toString(): string {\n    return `${this.source} in ${this.location}`;\n  }\n}\n\n/**\n * TemplateBinding refers to a particular key-value pair in a microsyntax\n * expression. A few examples are:\n *\n *   |---------------------|--------------|---------|--------------|\n *   |     expression      |     key      |  value  | binding type |\n *   |---------------------|--------------|---------|--------------|\n *   | 1. let item         |    item      |  null   |   variable   |\n *   | 2. of items         |   ngForOf    |  items  |  expression  |\n *   | 3. let x = y        |      x       |    y    |   variable   |\n *   | 4. index as i       |      i       |  index  |   variable   |\n *   | 5. trackBy: func    | ngForTrackBy |   func  |  expression  |\n *   | 6. *ngIf=\"cond\"     |     ngIf     |   cond  |  expression  |\n *   |---------------------|--------------|---------|--------------|\n *\n * (6) is a notable exception because it is a binding from the template key in\n * the LHS of a HTML attribute to the expression in the RHS. All other bindings\n * in the example above are derived solely from the RHS.\n */\nexport type TemplateBinding = VariableBinding | ExpressionBinding;\n\nexport class VariableBinding {\n  /**\n   * @param sourceSpan entire span of the binding.\n   * @param key name of the LHS along with its span.\n   * @param value optional value for the RHS along with its span.\n   */\n  constructor(\n    public readonly sourceSpan: AbsoluteSourceSpan,\n    public readonly key: TemplateBindingIdentifier,\n    public readonly value: TemplateBindingIdentifier | null,\n  ) {}\n}\n\nexport class ExpressionBinding {\n  /**\n   * @param sourceSpan entire span of the binding.\n   * @param key binding name, like ngForOf, ngForTrackBy, ngIf, along with its\n   * span. Note that the length of the span may not be the same as\n   * `key.source.length`. For example,\n   * 1. key.source = ngFor, key.span is for \"ngFor\"\n   * 2. key.source = ngForOf, key.span is for \"of\"\n   * 3. key.source = ngForTrackBy, key.span is for \"trackBy\"\n   * @param value optional expression for the RHS.\n   */\n  constructor(\n    public readonly sourceSpan: AbsoluteSourceSpan,\n    public readonly key: TemplateBindingIdentifier,\n    public readonly value: ASTWithSource | null,\n  ) {}\n}\n\nexport interface TemplateBindingIdentifier {\n  source: string;\n  span: AbsoluteSourceSpan;\n}\n\nexport interface AstVisitor {\n  /**\n   * The `visitUnary` method is declared as optional for backwards compatibility. In an upcoming\n   * major release, this method will be made required.\n   */\n  visitUnary?(ast: Unary, context: any): any;\n  visitBinary(ast: Binary, context: any): any;\n  visitChain(ast: Chain, context: any): any;\n  visitConditional(ast: Conditional, context: any): any;\n  /**\n   * The `visitThisReceiver` method is declared as optional for backwards compatibility.\n   * In an upcoming major release, this method will be made required.\n   */\n  visitThisReceiver?(ast: ThisReceiver, context: any): any;\n  visitImplicitReceiver(ast: ImplicitReceiver, context: any): any;\n  visitInterpolation(ast: Interpolation, context: any): any;\n  visitKeyedRead(ast: KeyedRead, context: any): any;\n  visitLiteralArray(ast: LiteralArray, context: any): any;\n  visitLiteralMap(ast: LiteralMap, context: any): any;\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any;\n  visitPipe(ast: BindingPipe, context: any): any;\n  visitPrefixNot(ast: PrefixNot, context: any): any;\n  visitTypeofExpression(ast: TypeofExpression, context: any): any;\n  visitVoidExpression(ast: TypeofExpression, context: any): any;\n  visitNonNullAssert(ast: NonNullAssert, context: any): any;\n  visitPropertyRead(ast: PropertyRead, context: any): any;\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): any;\n  visitSafeKeyedRead(ast: SafeKeyedRead, context: any): any;\n  visitCall(ast: Call, context: any): any;\n  visitSafeCall(ast: SafeCall, context: any): any;\n  visitTemplateLiteral(ast: TemplateLiteral, context: any): any;\n  visitTemplateLiteralElement(ast: TemplateLiteralElement, context: any): any;\n  visitTaggedTemplateLiteral(ast: TaggedTemplateLiteral, context: any): any;\n  visitParenthesizedExpression(ast: ParenthesizedExpression, context: any): any;\n  visitASTWithSource?(ast: ASTWithSource, context: any): any;\n  /**\n   * This function is optionally defined to allow classes that implement this\n   * interface to selectively decide if the specified `ast` should be visited.\n   * @param ast node to visit\n   * @param context context that gets passed to the node and all its children\n   */\n  visit?(ast: AST, context?: any): any;\n}\n\nexport class RecursiveAstVisitor implements AstVisitor {\n  visit(ast: AST, context?: any): any {\n    // The default implementation just visits every node.\n    // Classes that extend RecursiveAstVisitor should override this function\n    // to selectively visit the specified node.\n    ast.visit(this, context);\n  }\n  visitUnary(ast: Unary, context: any): any {\n    this.visit(ast.expr, context);\n  }\n  visitBinary(ast: Binary, context: any): any {\n    this.visit(ast.left, context);\n    this.visit(ast.right, context);\n  }\n  visitChain(ast: Chain, context: any): any {\n    this.visitAll(ast.expressions, context);\n  }\n  visitConditional(ast: Conditional, context: any): any {\n    this.visit(ast.condition, context);\n    this.visit(ast.trueExp, context);\n    this.visit(ast.falseExp, context);\n  }\n  visitPipe(ast: BindingPipe, context: any): any {\n    this.visit(ast.exp, context);\n    this.visitAll(ast.args, context);\n  }\n  visitImplicitReceiver(ast: ThisReceiver, context: any): any {}\n  visitThisReceiver(ast: ThisReceiver, context: any): any {}\n  visitInterpolation(ast: Interpolation, context: any): any {\n    this.visitAll(ast.expressions, context);\n  }\n  visitKeyedRead(ast: KeyedRead, context: any): any {\n    this.visit(ast.receiver, context);\n    this.visit(ast.key, context);\n  }\n  visitLiteralArray(ast: LiteralArray, context: any): any {\n    this.visitAll(ast.expressions, context);\n  }\n  visitLiteralMap(ast: LiteralMap, context: any): any {\n    this.visitAll(ast.values, context);\n  }\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any {}\n  visitPrefixNot(ast: PrefixNot, context: any): any {\n    this.visit(ast.expression, context);\n  }\n  visitTypeofExpression(ast: TypeofExpression, context: any) {\n    this.visit(ast.expression, context);\n  }\n  visitVoidExpression(ast: VoidExpression, context: any) {\n    this.visit(ast.expression, context);\n  }\n  visitNonNullAssert(ast: NonNullAssert, context: any): any {\n    this.visit(ast.expression, context);\n  }\n  visitPropertyRead(ast: PropertyRead, context: any): any {\n    this.visit(ast.receiver, context);\n  }\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): any {\n    this.visit(ast.receiver, context);\n  }\n  visitSafeKeyedRead(ast: SafeKeyedRead, context: any): any {\n    this.visit(ast.receiver, context);\n    this.visit(ast.key, context);\n  }\n  visitCall(ast: Call, context: any): any {\n    this.visit(ast.receiver, context);\n    this.visitAll(ast.args, context);\n  }\n  visitSafeCall(ast: SafeCall, context: any): any {\n    this.visit(ast.receiver, context);\n    this.visitAll(ast.args, context);\n  }\n  visitTemplateLiteral(ast: TemplateLiteral, context: any) {\n    // Iterate in the declaration order. Note that there will\n    // always be one expression less than the number of elements.\n    for (let i = 0; i < ast.elements.length; i++) {\n      this.visit(ast.elements[i], context);\n\n      const expression = i < ast.expressions.length ? ast.expressions[i] : null;\n      if (expression !== null) {\n        this.visit(expression, context);\n      }\n    }\n  }\n  visitTemplateLiteralElement(ast: TemplateLiteralElement, context: any) {}\n  visitTaggedTemplateLiteral(ast: TaggedTemplateLiteral, context: any) {\n    this.visit(ast.tag, context);\n    this.visit(ast.template, context);\n  }\n  visitParenthesizedExpression(ast: ParenthesizedExpression, context: any) {\n    this.visit(ast.expression, context);\n  }\n  // This is not part of the AstVisitor interface, just a helper method\n  visitAll(asts: AST[], context: any): any {\n    for (const ast of asts) {\n      this.visit(ast, context);\n    }\n  }\n}\n\n// Bindings\n\nexport class ParsedProperty {\n  public readonly isLiteral: boolean;\n  public readonly isLegacyAnimation: boolean;\n  public readonly isAnimation: boolean;\n\n  constructor(\n    public name: string,\n    public expression: ASTWithSource,\n    public type: ParsedPropertyType,\n    public sourceSpan: ParseSourceSpan,\n    readonly keySpan: ParseSourceSpan,\n    public valueSpan: ParseSourceSpan | undefined,\n  ) {\n    this.isLiteral = this.type === ParsedPropertyType.LITERAL_ATTR;\n    this.isLegacyAnimation = this.type === ParsedPropertyType.LEGACY_ANIMATION;\n    this.isAnimation = this.type === ParsedPropertyType.ANIMATION;\n  }\n}\n\nexport enum ParsedPropertyType {\n  DEFAULT,\n  LITERAL_ATTR,\n  LEGACY_ANIMATION,\n  TWO_WAY,\n  ANIMATION,\n}\n\nexport enum ParsedEventType {\n  // DOM or Directive event\n  Regular,\n  // Legacy animation specific event\n  LegacyAnimation,\n  // Event side of a two-way binding (e.g. `[(property)]=\"expression\"`).\n  TwoWay,\n  // Animation specific event\n  Animation,\n}\n\nexport class ParsedEvent {\n  // Regular events have a target\n  // Legacy Animation events have a phase\n  constructor(\n    name: string,\n    targetOrPhase: string | null,\n    type: ParsedEventType.TwoWay,\n    handler: ASTWithSource<NonNullAssert | PropertyRead | KeyedRead>,\n    sourceSpan: ParseSourceSpan,\n    handlerSpan: ParseSourceSpan,\n    keySpan: ParseSourceSpan,\n  );\n\n  constructor(\n    name: string,\n    targetOrPhase: string | null,\n    type: ParsedEventType,\n    handler: ASTWithSource,\n    sourceSpan: ParseSourceSpan,\n    handlerSpan: ParseSourceSpan,\n    keySpan: ParseSourceSpan,\n  );\n\n  constructor(\n    public name: string,\n    public targetOrPhase: string | null,\n    public type: ParsedEventType,\n    public handler: ASTWithSource,\n    public sourceSpan: ParseSourceSpan,\n    public handlerSpan: ParseSourceSpan,\n    readonly keySpan: ParseSourceSpan,\n  ) {}\n}\n\n/**\n * ParsedVariable represents a variable declaration in a microsyntax expression.\n */\nexport class ParsedVariable {\n  constructor(\n    public readonly name: string,\n    public readonly value: string,\n    public readonly sourceSpan: ParseSourceSpan,\n    public readonly keySpan: ParseSourceSpan,\n    public readonly valueSpan?: ParseSourceSpan,\n  ) {}\n}\n\nexport enum BindingType {\n  // A regular binding to a property (e.g. `[property]=\"expression\"`).\n  Property,\n  // A binding to an element attribute (e.g. `[attr.name]=\"expression\"`).\n  Attribute,\n  // A binding to a CSS class (e.g. `[class.name]=\"condition\"`).\n  Class,\n  // A binding to a style rule (e.g. `[style.rule]=\"expression\"`).\n  Style,\n  // A binding to a legacy animation reference (e.g. `[animate.key]=\"expression\"`).\n  LegacyAnimation,\n  // Property side of a two-way binding (e.g. `[(property)]=\"expression\"`).\n  TwoWay,\n  // A binding to an animation CSS class or function (e.g. `[animate.leave]=\"expression\"`).\n  Animation,\n}\n\nexport class BoundElementProperty {\n  constructor(\n    public name: string,\n    public type: BindingType,\n    public securityContext: SecurityContext,\n    public value: ASTWithSource,\n    public unit: string | null,\n    public sourceSpan: ParseSourceSpan,\n    readonly keySpan: ParseSourceSpan | undefined,\n    public valueSpan: ParseSourceSpan | undefined,\n  ) {}\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nexport enum TagContentType {\n  RAW_TEXT,\n  ESCAPABLE_RAW_TEXT,\n  PARSABLE_DATA,\n}\n\nexport interface TagDefinition {\n  closedByParent: boolean;\n  implicitNamespacePrefix: string | null;\n  isVoid: boolean;\n  ignoreFirstLf: boolean;\n  canSelfClose: boolean;\n  preventNamespaceInheritance: boolean;\n\n  isClosedByChild(name: string): boolean;\n  getContentType(prefix?: string): TagContentType;\n}\n\nexport function splitNsName(elementName: string, fatal: boolean = true): [string | null, string] {\n  if (elementName[0] != ':') {\n    return [null, elementName];\n  }\n\n  const colonIndex = elementName.indexOf(':', 1);\n\n  if (colonIndex === -1) {\n    if (fatal) {\n      throw new Error(`Unsupported format \"${elementName}\" expecting \":namespace:name\"`);\n    } else {\n      return [null, elementName];\n    }\n  }\n\n  return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];\n}\n\n// `<ng-container>` tags work the same regardless the namespace\nexport function isNgContainer(tagName: string): boolean {\n  return splitNsName(tagName)[1] === 'ng-container';\n}\n\n// `<ng-content>` tags work the same regardless the namespace\nexport function isNgContent(tagName: string): boolean {\n  return splitNsName(tagName)[1] === 'ng-content';\n}\n\n// `<ng-template>` tags work the same regardless the namespace\nexport function isNgTemplate(tagName: string): boolean {\n  return splitNsName(tagName)[1] === 'ng-template';\n}\n\nexport function getNsPrefix(fullName: string): string;\nexport function getNsPrefix(fullName: null): null;\nexport function getNsPrefix(fullName: string | null): string | null {\n  return fullName === null ? null : splitNsName(fullName)[0];\n}\n\nexport function mergeNsAndName(prefix: string, localName: string): string {\n  return prefix ? `:${prefix}:${localName}` : localName;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {SecurityContext} from '../core';\nimport {\n  AST,\n  ASTWithSource,\n  BindingType,\n  BoundElementProperty,\n  ParsedEvent,\n  ParsedEventType,\n} from '../expression_parser/ast';\nimport {I18nMeta} from '../i18n/i18n_ast';\nimport {ParseSourceSpan} from '../parse_util';\n\nexport interface Node {\n  sourceSpan: ParseSourceSpan;\n  visit<Result>(visitor: Visitor<Result>): Result;\n}\n\n/**\n * This is an R3 `Node`-like wrapper for a raw `html.Comment` node. We do not currently\n * require the implementation of a visitor for Comments as they are only collected at\n * the top-level of the R3 AST, and only if `Render3ParseOptions['collectCommentNodes']`\n * is true.\n */\nexport class Comment implements Node {\n  constructor(\n    public value: string,\n    public sourceSpan: ParseSourceSpan,\n  ) {}\n  visit<Result>(_visitor: Visitor<Result>): Result {\n    throw new Error('visit() not implemented for Comment');\n  }\n}\n\nexport class Text implements Node {\n  constructor(\n    public value: string,\n    public sourceSpan: ParseSourceSpan,\n  ) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitText(this);\n  }\n}\n\nexport class BoundText implements Node {\n  constructor(\n    public value: AST,\n    public sourceSpan: ParseSourceSpan,\n    public i18n?: I18nMeta,\n  ) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitBoundText(this);\n  }\n}\n\n/**\n * Represents a text attribute in the template.\n *\n * `valueSpan` may not be present in cases where there is no value `<div a></div>`.\n * `keySpan` may also not be present for synthetic attributes from ICU expansions.\n */\nexport class TextAttribute implements Node {\n  constructor(\n    public name: string,\n    public value: string,\n    public sourceSpan: ParseSourceSpan,\n    readonly keySpan: ParseSourceSpan | undefined,\n    public valueSpan?: ParseSourceSpan,\n    public i18n?: I18nMeta,\n  ) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitTextAttribute(this);\n  }\n}\n\nexport class BoundAttribute implements Node {\n  constructor(\n    public name: string,\n    public type: BindingType,\n    public securityContext: SecurityContext,\n    public value: AST,\n    public unit: string | null,\n    public sourceSpan: ParseSourceSpan,\n    readonly keySpan: ParseSourceSpan,\n    public valueSpan: ParseSourceSpan | undefined,\n    public i18n: I18nMeta | undefined,\n  ) {}\n\n  static fromBoundElementProperty(prop: BoundElementProperty, i18n?: I18nMeta): BoundAttribute {\n    if (prop.keySpan === undefined) {\n      throw new Error(\n        `Unexpected state: keySpan must be defined for bound attributes but was not for ${prop.name}: ${prop.sourceSpan}`,\n      );\n    }\n    return new BoundAttribute(\n      prop.name,\n      prop.type,\n      prop.securityContext,\n      prop.value,\n      prop.unit,\n      prop.sourceSpan,\n      prop.keySpan,\n      prop.valueSpan,\n      i18n,\n    );\n  }\n\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitBoundAttribute(this);\n  }\n}\n\nexport class BoundEvent implements Node {\n  constructor(\n    public name: string,\n    public type: ParsedEventType,\n    public handler: AST,\n    public target: string | null,\n    public phase: string | null,\n    public sourceSpan: ParseSourceSpan,\n    public handlerSpan: ParseSourceSpan,\n    readonly keySpan: ParseSourceSpan,\n  ) {}\n\n  static fromParsedEvent(event: ParsedEvent) {\n    const target: string | null =\n      event.type === ParsedEventType.Regular ? event.targetOrPhase : null;\n    const phase: string | null =\n      event.type === ParsedEventType.LegacyAnimation ? event.targetOrPhase : null;\n    if (event.keySpan === undefined) {\n      throw new Error(\n        `Unexpected state: keySpan must be defined for bound event but was not for ${event.name}: ${event.sourceSpan}`,\n      );\n    }\n    return new BoundEvent(\n      event.name,\n      event.type,\n      event.handler,\n      target,\n      phase,\n      event.sourceSpan,\n      event.handlerSpan,\n      event.keySpan,\n    );\n  }\n\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitBoundEvent(this);\n  }\n}\n\nexport class Element implements Node {\n  constructor(\n    public name: string,\n    public attributes: TextAttribute[],\n    public inputs: BoundAttribute[],\n    public outputs: BoundEvent[],\n    public directives: Directive[],\n    public children: Node[],\n    public references: Reference[],\n    public isSelfClosing: boolean,\n    public sourceSpan: ParseSourceSpan,\n    public startSourceSpan: ParseSourceSpan,\n    public endSourceSpan: ParseSourceSpan | null,\n    readonly isVoid: boolean,\n    public i18n?: I18nMeta,\n  ) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitElement(this);\n  }\n}\n\nexport abstract class DeferredTrigger implements Node {\n  constructor(\n    public nameSpan: ParseSourceSpan | null,\n    public sourceSpan: ParseSourceSpan,\n    public prefetchSpan: ParseSourceSpan | null,\n    public whenOrOnSourceSpan: ParseSourceSpan | null,\n    public hydrateSpan: ParseSourceSpan | null,\n  ) {}\n\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitDeferredTrigger(this);\n  }\n}\n\nexport class BoundDeferredTrigger extends DeferredTrigger {\n  constructor(\n    public value: AST,\n    sourceSpan: ParseSourceSpan,\n    prefetchSpan: ParseSourceSpan | null,\n    whenSourceSpan: ParseSourceSpan,\n    hydrateSpan: ParseSourceSpan | null,\n  ) {\n    // BoundDeferredTrigger is for 'when' triggers. These aren't really \"triggers\" and don't have a\n    // nameSpan. Trigger names are the built in event triggers like hover, interaction, etc.\n    super(/** nameSpan */ null, sourceSpan, prefetchSpan, whenSourceSpan, hydrateSpan);\n  }\n}\n\nexport class NeverDeferredTrigger extends DeferredTrigger {}\n\nexport class IdleDeferredTrigger extends DeferredTrigger {}\n\nexport class ImmediateDeferredTrigger extends DeferredTrigger {}\n\nexport class HoverDeferredTrigger extends DeferredTrigger {\n  constructor(\n    public reference: string | null,\n    nameSpan: ParseSourceSpan,\n    sourceSpan: ParseSourceSpan,\n    prefetchSpan: ParseSourceSpan | null,\n    onSourceSpan: ParseSourceSpan | null,\n    hydrateSpan: ParseSourceSpan | null,\n  ) {\n    super(nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan);\n  }\n}\n\nexport class TimerDeferredTrigger extends DeferredTrigger {\n  constructor(\n    public delay: number,\n    nameSpan: ParseSourceSpan,\n    sourceSpan: ParseSourceSpan,\n    prefetchSpan: ParseSourceSpan | null,\n    onSourceSpan: ParseSourceSpan | null,\n    hydrateSpan: ParseSourceSpan | null,\n  ) {\n    super(nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan);\n  }\n}\n\nexport class InteractionDeferredTrigger extends DeferredTrigger {\n  constructor(\n    public reference: string | null,\n    nameSpan: ParseSourceSpan,\n    sourceSpan: ParseSourceSpan,\n    prefetchSpan: ParseSourceSpan | null,\n    onSourceSpan: ParseSourceSpan | null,\n    hydrateSpan: ParseSourceSpan | null,\n  ) {\n    super(nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan);\n  }\n}\n\nexport class ViewportDeferredTrigger extends DeferredTrigger {\n  constructor(\n    public reference: string | null,\n    nameSpan: ParseSourceSpan,\n    sourceSpan: ParseSourceSpan,\n    prefetchSpan: ParseSourceSpan | null,\n    onSourceSpan: ParseSourceSpan | null,\n    hydrateSpan: ParseSourceSpan | null,\n  ) {\n    super(nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan);\n  }\n}\n\nexport class BlockNode {\n  constructor(\n    public nameSpan: ParseSourceSpan,\n    public sourceSpan: ParseSourceSpan,\n    public startSourceSpan: ParseSourceSpan,\n    public endSourceSpan: ParseSourceSpan | null,\n  ) {}\n}\n\nexport class DeferredBlockPlaceholder extends BlockNode implements Node {\n  constructor(\n    public children: Node[],\n    public minimumTime: number | null,\n    nameSpan: ParseSourceSpan,\n    sourceSpan: ParseSourceSpan,\n    startSourceSpan: ParseSourceSpan,\n    endSourceSpan: ParseSourceSpan | null,\n    public i18n?: I18nMeta,\n  ) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n  }\n\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitDeferredBlockPlaceholder(this);\n  }\n}\n\nexport class DeferredBlockLoading extends BlockNode implements Node {\n  constructor(\n    public children: Node[],\n    public afterTime: number | null,\n    public minimumTime: number | null,\n    nameSpan: ParseSourceSpan,\n    sourceSpan: ParseSourceSpan,\n    startSourceSpan: ParseSourceSpan,\n    endSourceSpan: ParseSourceSpan | null,\n    public i18n?: I18nMeta,\n  ) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n  }\n\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitDeferredBlockLoading(this);\n  }\n}\n\nexport class DeferredBlockError extends BlockNode implements Node {\n  constructor(\n    public children: Node[],\n    nameSpan: ParseSourceSpan,\n    sourceSpan: ParseSourceSpan,\n    startSourceSpan: ParseSourceSpan,\n    endSourceSpan: ParseSourceSpan | null,\n    public i18n?: I18nMeta,\n  ) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n  }\n\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitDeferredBlockError(this);\n  }\n}\n\nexport interface DeferredBlockTriggers {\n  when?: BoundDeferredTrigger;\n  idle?: IdleDeferredTrigger;\n  immediate?: ImmediateDeferredTrigger;\n  hover?: HoverDeferredTrigger;\n  timer?: TimerDeferredTrigger;\n  interaction?: InteractionDeferredTrigger;\n  viewport?: ViewportDeferredTrigger;\n  never?: NeverDeferredTrigger;\n}\n\nexport class DeferredBlock extends BlockNode implements Node {\n  readonly triggers: Readonly<DeferredBlockTriggers>;\n  readonly prefetchTriggers: Readonly<DeferredBlockTriggers>;\n  readonly hydrateTriggers: Readonly<DeferredBlockTriggers>;\n  private readonly definedTriggers: (keyof DeferredBlockTriggers)[];\n  private readonly definedPrefetchTriggers: (keyof DeferredBlockTriggers)[];\n  private readonly definedHydrateTriggers: (keyof DeferredBlockTriggers)[];\n\n  constructor(\n    public children: Node[],\n    triggers: DeferredBlockTriggers,\n    prefetchTriggers: DeferredBlockTriggers,\n    hydrateTriggers: DeferredBlockTriggers,\n    public placeholder: DeferredBlockPlaceholder | null,\n    public loading: DeferredBlockLoading | null,\n    public error: DeferredBlockError | null,\n    nameSpan: ParseSourceSpan,\n    sourceSpan: ParseSourceSpan,\n    public mainBlockSpan: ParseSourceSpan,\n    startSourceSpan: ParseSourceSpan,\n    endSourceSpan: ParseSourceSpan | null,\n    public i18n?: I18nMeta,\n  ) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n    this.triggers = triggers;\n    this.prefetchTriggers = prefetchTriggers;\n    this.hydrateTriggers = hydrateTriggers;\n    // We cache the keys since we know that they won't change and we\n    // don't want to enumarate them every time we're traversing the AST.\n    this.definedTriggers = Object.keys(triggers) as (keyof DeferredBlockTriggers)[];\n    this.definedPrefetchTriggers = Object.keys(prefetchTriggers) as (keyof DeferredBlockTriggers)[];\n    this.definedHydrateTriggers = Object.keys(hydrateTriggers) as (keyof DeferredBlockTriggers)[];\n  }\n\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitDeferredBlock(this);\n  }\n\n  visitAll(visitor: Visitor<unknown>): void {\n    // Visit the hydrate triggers first to match their insertion order.\n    this.visitTriggers(this.definedHydrateTriggers, this.hydrateTriggers, visitor);\n    this.visitTriggers(this.definedTriggers, this.triggers, visitor);\n    this.visitTriggers(this.definedPrefetchTriggers, this.prefetchTriggers, visitor);\n    visitAll(visitor, this.children);\n    const remainingBlocks = [this.placeholder, this.loading, this.error].filter(\n      (x) => x !== null,\n    ) as Array<Node>;\n    visitAll(visitor, remainingBlocks);\n  }\n\n  private visitTriggers(\n    keys: (keyof DeferredBlockTriggers)[],\n    triggers: DeferredBlockTriggers,\n    visitor: Visitor,\n  ) {\n    visitAll(\n      visitor,\n      keys.map((k) => triggers[k]!),\n    );\n  }\n}\n\nexport class SwitchBlock extends BlockNode implements Node {\n  constructor(\n    public expression: AST,\n    public cases: SwitchBlockCase[],\n    /**\n     * These blocks are only captured to allow for autocompletion in the language service. They\n     * aren't meant to be processed in any other way.\n     */\n    public unknownBlocks: UnknownBlock[],\n    sourceSpan: ParseSourceSpan,\n    startSourceSpan: ParseSourceSpan,\n    endSourceSpan: ParseSourceSpan | null,\n    nameSpan: ParseSourceSpan,\n  ) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n  }\n\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitSwitchBlock(this);\n  }\n}\n\nexport class SwitchBlockCase extends BlockNode implements Node {\n  constructor(\n    public expression: AST | null,\n    public children: Node[],\n    sourceSpan: ParseSourceSpan,\n    startSourceSpan: ParseSourceSpan,\n    endSourceSpan: ParseSourceSpan | null,\n    nameSpan: ParseSourceSpan,\n    public i18n?: I18nMeta,\n  ) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n  }\n\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitSwitchBlockCase(this);\n  }\n}\n\nexport class ForLoopBlock extends BlockNode implements Node {\n  constructor(\n    public item: Variable,\n    public expression: ASTWithSource,\n    public trackBy: ASTWithSource,\n    public trackKeywordSpan: ParseSourceSpan,\n    public contextVariables: Variable[],\n    public children: Node[],\n    public empty: ForLoopBlockEmpty | null,\n    sourceSpan: ParseSourceSpan,\n    public mainBlockSpan: ParseSourceSpan,\n    startSourceSpan: ParseSourceSpan,\n    endSourceSpan: ParseSourceSpan | null,\n    nameSpan: ParseSourceSpan,\n    public i18n?: I18nMeta,\n  ) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n  }\n\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitForLoopBlock(this);\n  }\n}\n\nexport class ForLoopBlockEmpty extends BlockNode implements Node {\n  constructor(\n    public children: Node[],\n    sourceSpan: ParseSourceSpan,\n    startSourceSpan: ParseSourceSpan,\n    endSourceSpan: ParseSourceSpan | null,\n    nameSpan: ParseSourceSpan,\n    public i18n?: I18nMeta,\n  ) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n  }\n\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitForLoopBlockEmpty(this);\n  }\n}\n\nexport class IfBlock extends BlockNode implements Node {\n  constructor(\n    public branches: IfBlockBranch[],\n    sourceSpan: ParseSourceSpan,\n    startSourceSpan: ParseSourceSpan,\n    endSourceSpan: ParseSourceSpan | null,\n    nameSpan: ParseSourceSpan,\n  ) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n  }\n\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitIfBlock(this);\n  }\n}\n\nexport class IfBlockBranch extends BlockNode implements Node {\n  constructor(\n    public expression: AST | null,\n    public children: Node[],\n    public expressionAlias: Variable | null,\n    sourceSpan: ParseSourceSpan,\n    startSourceSpan: ParseSourceSpan,\n    endSourceSpan: ParseSourceSpan | null,\n    nameSpan: ParseSourceSpan,\n    public i18n?: I18nMeta,\n  ) {\n    super(nameSpan, sourceSpan, startSourceSpan, endSourceSpan);\n  }\n\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitIfBlockBranch(this);\n  }\n}\n\nexport class UnknownBlock implements Node {\n  constructor(\n    public name: string,\n    public sourceSpan: ParseSourceSpan,\n    public nameSpan: ParseSourceSpan,\n  ) {}\n\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitUnknownBlock(this);\n  }\n}\n\nexport class LetDeclaration implements Node {\n  constructor(\n    public name: string,\n    public value: AST,\n    public sourceSpan: ParseSourceSpan,\n    public nameSpan: ParseSourceSpan,\n    public valueSpan: ParseSourceSpan,\n  ) {}\n\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitLetDeclaration(this);\n  }\n}\n\nexport class Component implements Node {\n  constructor(\n    public componentName: string,\n    public tagName: string | null,\n    public fullName: string,\n    public attributes: TextAttribute[],\n    public inputs: BoundAttribute[],\n    public outputs: BoundEvent[],\n    public directives: Directive[],\n    public children: Node[],\n    public references: Reference[],\n    public isSelfClosing: boolean,\n    public sourceSpan: ParseSourceSpan,\n    public startSourceSpan: ParseSourceSpan,\n    public endSourceSpan: ParseSourceSpan | null,\n    public i18n?: I18nMeta,\n  ) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitComponent(this);\n  }\n}\n\nexport class Directive implements Node {\n  constructor(\n    public name: string,\n    public attributes: TextAttribute[],\n    public inputs: BoundAttribute[],\n    public outputs: BoundEvent[],\n    public references: Reference[],\n    public sourceSpan: ParseSourceSpan,\n    public startSourceSpan: ParseSourceSpan,\n    public endSourceSpan: ParseSourceSpan | null,\n    public i18n?: I18nMeta,\n  ) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitDirective(this);\n  }\n}\n\nexport class Template implements Node {\n  constructor(\n    // tagName is the name of the container element, if applicable.\n    // `null` is a special case for when there is a structural directive on an `ng-template` so\n    // the renderer can differentiate between the synthetic template and the one written in the\n    // file.\n    public tagName: string | null,\n    public attributes: TextAttribute[],\n    public inputs: BoundAttribute[],\n    public outputs: BoundEvent[],\n    public directives: Directive[],\n    public templateAttrs: (BoundAttribute | TextAttribute)[],\n    public children: Node[],\n    public references: Reference[],\n    public variables: Variable[],\n    public isSelfClosing: boolean,\n    public sourceSpan: ParseSourceSpan,\n    public startSourceSpan: ParseSourceSpan,\n    public endSourceSpan: ParseSourceSpan | null,\n    public i18n?: I18nMeta,\n  ) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitTemplate(this);\n  }\n}\n\nexport class Content implements Node {\n  readonly name = 'ng-content';\n\n  constructor(\n    public selector: string,\n    public attributes: TextAttribute[],\n    public children: Node[],\n    public isSelfClosing: boolean,\n    public sourceSpan: ParseSourceSpan,\n    public startSourceSpan: ParseSourceSpan,\n    public endSourceSpan: ParseSourceSpan | null,\n    public i18n?: I18nMeta,\n  ) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitContent(this);\n  }\n}\n\nexport class Variable implements Node {\n  constructor(\n    public name: string,\n    public value: string,\n    public sourceSpan: ParseSourceSpan,\n    readonly keySpan: ParseSourceSpan,\n    public valueSpan?: ParseSourceSpan,\n  ) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitVariable(this);\n  }\n}\n\nexport class Reference implements Node {\n  constructor(\n    public name: string,\n    public value: string,\n    public sourceSpan: ParseSourceSpan,\n    readonly keySpan: ParseSourceSpan,\n    public valueSpan?: ParseSourceSpan,\n  ) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitReference(this);\n  }\n}\n\nexport class Icu implements Node {\n  constructor(\n    public vars: {[name: string]: BoundText},\n    public placeholders: {[name: string]: Text | BoundText},\n    public sourceSpan: ParseSourceSpan,\n    public i18n?: I18nMeta,\n  ) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitIcu(this);\n  }\n}\n\n/**\n * AST node that represents the host element of a directive.\n * This node is used only for type checking purposes and cannot be produced from a user's template.\n */\nexport class HostElement implements Node {\n  constructor(\n    readonly tagNames: string[],\n    readonly bindings: BoundAttribute[],\n    readonly listeners: BoundEvent[],\n    readonly sourceSpan: ParseSourceSpan,\n  ) {\n    if (tagNames.length === 0) {\n      throw new Error('HostElement must have at least one tag name.');\n    }\n  }\n\n  visit<Result>(): Result {\n    throw new Error(`HostElement cannot be visited`);\n  }\n}\n\nexport interface Visitor<Result = any> {\n  // Returning a truthy value from `visit()` will prevent `visitAll()` from the call to the typed\n  // method and result returned will become the result included in `visitAll()`s result array.\n  visit?(node: Node): Result;\n\n  visitElement(element: Element): Result;\n  visitTemplate(template: Template): Result;\n  visitContent(content: Content): Result;\n  visitVariable(variable: Variable): Result;\n  visitReference(reference: Reference): Result;\n  visitTextAttribute(attribute: TextAttribute): Result;\n  visitBoundAttribute(attribute: BoundAttribute): Result;\n  visitBoundEvent(attribute: BoundEvent): Result;\n  visitText(text: Text): Result;\n  visitBoundText(text: BoundText): Result;\n  visitIcu(icu: Icu): Result;\n  visitDeferredBlock(deferred: DeferredBlock): Result;\n  visitDeferredBlockPlaceholder(block: DeferredBlockPlaceholder): Result;\n  visitDeferredBlockError(block: DeferredBlockError): Result;\n  visitDeferredBlockLoading(block: DeferredBlockLoading): Result;\n  visitDeferredTrigger(trigger: DeferredTrigger): Result;\n  visitSwitchBlock(block: SwitchBlock): Result;\n  visitSwitchBlockCase(block: SwitchBlockCase): Result;\n  visitForLoopBlock(block: ForLoopBlock): Result;\n  visitForLoopBlockEmpty(block: ForLoopBlockEmpty): Result;\n  visitIfBlock(block: IfBlock): Result;\n  visitIfBlockBranch(block: IfBlockBranch): Result;\n  visitUnknownBlock(block: UnknownBlock): Result;\n  visitLetDeclaration(decl: LetDeclaration): Result;\n  visitComponent(component: Component): Result;\n  visitDirective(directive: Directive): Result;\n}\n\nexport class RecursiveVisitor implements Visitor<void> {\n  visitElement(element: Element): void {\n    visitAll(this, element.attributes);\n    visitAll(this, element.inputs);\n    visitAll(this, element.outputs);\n    visitAll(this, element.directives);\n    visitAll(this, element.children);\n    visitAll(this, element.references);\n  }\n  visitTemplate(template: Template): void {\n    visitAll(this, template.attributes);\n    visitAll(this, template.inputs);\n    visitAll(this, template.outputs);\n    visitAll(this, template.directives);\n    visitAll(this, template.children);\n    visitAll(this, template.references);\n    visitAll(this, template.variables);\n  }\n  visitDeferredBlock(deferred: DeferredBlock): void {\n    deferred.visitAll(this);\n  }\n  visitDeferredBlockPlaceholder(block: DeferredBlockPlaceholder): void {\n    visitAll(this, block.children);\n  }\n  visitDeferredBlockError(block: DeferredBlockError): void {\n    visitAll(this, block.children);\n  }\n  visitDeferredBlockLoading(block: DeferredBlockLoading): void {\n    visitAll(this, block.children);\n  }\n  visitSwitchBlock(block: SwitchBlock): void {\n    visitAll(this, block.cases);\n  }\n  visitSwitchBlockCase(block: SwitchBlockCase): void {\n    visitAll(this, block.children);\n  }\n  visitForLoopBlock(block: ForLoopBlock): void {\n    const blockItems = [block.item, ...block.contextVariables, ...block.children];\n    block.empty && blockItems.push(block.empty);\n    visitAll(this, blockItems);\n  }\n  visitForLoopBlockEmpty(block: ForLoopBlockEmpty): void {\n    visitAll(this, block.children);\n  }\n  visitIfBlock(block: IfBlock): void {\n    visitAll(this, block.branches);\n  }\n  visitIfBlockBranch(block: IfBlockBranch): void {\n    const blockItems = block.children;\n    block.expressionAlias && blockItems.push(block.expressionAlias);\n    visitAll(this, blockItems);\n  }\n  visitContent(content: Content): void {\n    visitAll(this, content.children);\n  }\n  visitComponent(component: Component): void {\n    visitAll(this, component.attributes);\n    visitAll(this, component.inputs);\n    visitAll(this, component.outputs);\n    visitAll(this, component.directives);\n    visitAll(this, component.children);\n    visitAll(this, component.references);\n  }\n  visitDirective(directive: Directive): void {\n    visitAll(this, directive.attributes);\n    visitAll(this, directive.inputs);\n    visitAll(this, directive.outputs);\n    visitAll(this, directive.references);\n  }\n  visitVariable(variable: Variable): void {}\n  visitReference(reference: Reference): void {}\n  visitTextAttribute(attribute: TextAttribute): void {}\n  visitBoundAttribute(attribute: BoundAttribute): void {}\n  visitBoundEvent(attribute: BoundEvent): void {}\n  visitText(text: Text): void {}\n  visitBoundText(text: BoundText): void {}\n  visitIcu(icu: Icu): void {}\n  visitDeferredTrigger(trigger: DeferredTrigger): void {}\n  visitUnknownBlock(block: UnknownBlock): void {}\n  visitLetDeclaration(decl: LetDeclaration): void {}\n}\n\nexport function visitAll<Result>(visitor: Visitor<Result>, nodes: Node[]): Result[] {\n  const result: Result[] = [];\n  if (visitor.visit) {\n    for (const node of nodes) {\n      visitor.visit(node);\n    }\n  } else {\n    for (const node of nodes) {\n      const newNode = node.visit(visitor);\n      if (newNode) {\n        result.push(newNode);\n      }\n    }\n  }\n  return result;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ParseSourceSpan} from '../parse_util';\n\n/**\n * Describes the text contents of a placeholder as it appears in an ICU expression, including its\n * source span information.\n */\nexport interface MessagePlaceholder {\n  /** The text contents of the placeholder */\n  text: string;\n\n  /** The source span of the placeholder */\n  sourceSpan: ParseSourceSpan;\n}\n\nexport class Message {\n  sources: MessageSpan[];\n  id: string;\n  /** The ids to use if there are no custom id and if `i18nLegacyMessageIdFormat` is not empty */\n  legacyIds: string[] = [];\n\n  messageString: string;\n\n  /**\n   * @param nodes message AST\n   * @param placeholders maps placeholder names to static content and their source spans\n   * @param placeholderToMessage maps placeholder names to messages (used for nested ICU messages)\n   * @param meaning\n   * @param description\n   * @param customId\n   */\n  constructor(\n    public nodes: Node[],\n    public placeholders: {[phName: string]: MessagePlaceholder},\n    public placeholderToMessage: {[phName: string]: Message},\n    public meaning: string,\n    public description: string,\n    public customId: string,\n  ) {\n    this.id = this.customId;\n    this.messageString = serializeMessage(this.nodes);\n\n    if (nodes.length) {\n      this.sources = [\n        {\n          filePath: nodes[0].sourceSpan.start.file.url,\n          startLine: nodes[0].sourceSpan.start.line + 1,\n          startCol: nodes[0].sourceSpan.start.col + 1,\n          endLine: nodes[nodes.length - 1].sourceSpan.end.line + 1,\n          endCol: nodes[0].sourceSpan.start.col + 1,\n        },\n      ];\n    } else {\n      this.sources = [];\n    }\n  }\n}\n\n// line and columns indexes are 1 based\nexport interface MessageSpan {\n  filePath: string;\n  startLine: number;\n  startCol: number;\n  endLine: number;\n  endCol: number;\n}\n\nexport interface Node {\n  sourceSpan: ParseSourceSpan;\n  visit(visitor: Visitor, context?: any): any;\n}\n\nexport class Text implements Node {\n  constructor(\n    public value: string,\n    public sourceSpan: ParseSourceSpan,\n  ) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitText(this, context);\n  }\n}\n\n// TODO(vicb): do we really need this node (vs an array) ?\nexport class Container implements Node {\n  constructor(\n    public children: Node[],\n    public sourceSpan: ParseSourceSpan,\n  ) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitContainer(this, context);\n  }\n}\n\nexport class Icu implements Node {\n  constructor(\n    public expression: string,\n    public type: string,\n    public cases: {[k: string]: Node},\n    public sourceSpan: ParseSourceSpan,\n    public expressionPlaceholder?: string,\n  ) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitIcu(this, context);\n  }\n}\n\nexport class TagPlaceholder implements Node {\n  constructor(\n    public tag: string,\n    public attrs: {[k: string]: string},\n    public startName: string,\n    public closeName: string,\n    public children: Node[],\n    public isVoid: boolean,\n    // TODO sourceSpan should cover all (we need a startSourceSpan and endSourceSpan)\n    public sourceSpan: ParseSourceSpan,\n    public startSourceSpan: ParseSourceSpan | null,\n    public endSourceSpan: ParseSourceSpan | null,\n  ) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitTagPlaceholder(this, context);\n  }\n}\n\nexport class Placeholder implements Node {\n  constructor(\n    public value: string,\n    public name: string,\n    public sourceSpan: ParseSourceSpan,\n  ) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitPlaceholder(this, context);\n  }\n}\n\nexport class IcuPlaceholder implements Node {\n  /** Used to capture a message computed from a previous processing pass (see `setI18nRefs()`). */\n  previousMessage?: Message;\n  constructor(\n    public value: Icu,\n    public name: string,\n    public sourceSpan: ParseSourceSpan,\n  ) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitIcuPlaceholder(this, context);\n  }\n}\n\nexport class BlockPlaceholder implements Node {\n  constructor(\n    public name: string,\n    public parameters: string[],\n    public startName: string,\n    public closeName: string,\n    public children: Node[],\n    public sourceSpan: ParseSourceSpan,\n    public startSourceSpan: ParseSourceSpan | null,\n    public endSourceSpan: ParseSourceSpan | null,\n  ) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitBlockPlaceholder(this, context);\n  }\n}\n\n/**\n * Each HTML node that is affect by an i18n tag will also have an `i18n` property that is of type\n * `I18nMeta`.\n * This information is either a `Message`, which indicates it is the root of an i18n message, or a\n * `Node`, which indicates is it part of a containing `Message`.\n */\nexport type I18nMeta = Message | Node;\n\nexport interface Visitor {\n  visitText(text: Text, context?: any): any;\n  visitContainer(container: Container, context?: any): any;\n  visitIcu(icu: Icu, context?: any): any;\n  visitTagPlaceholder(ph: TagPlaceholder, context?: any): any;\n  visitPlaceholder(ph: Placeholder, context?: any): any;\n  visitIcuPlaceholder(ph: IcuPlaceholder, context?: any): any;\n  visitBlockPlaceholder(ph: BlockPlaceholder, context?: any): any;\n}\n\n// Clone the AST\nexport class CloneVisitor implements Visitor {\n  visitText(text: Text, context?: any): Text {\n    return new Text(text.value, text.sourceSpan);\n  }\n\n  visitContainer(container: Container, context?: any): Container {\n    const children = container.children.map((n) => n.visit(this, context));\n    return new Container(children, container.sourceSpan);\n  }\n\n  visitIcu(icu: Icu, context?: any): Icu {\n    const cases: {[k: string]: Node} = {};\n    Object.keys(icu.cases).forEach((key) => (cases[key] = icu.cases[key].visit(this, context)));\n    const msg = new Icu(icu.expression, icu.type, cases, icu.sourceSpan, icu.expressionPlaceholder);\n    return msg;\n  }\n\n  visitTagPlaceholder(ph: TagPlaceholder, context?: any): TagPlaceholder {\n    const children = ph.children.map((n) => n.visit(this, context));\n    return new TagPlaceholder(\n      ph.tag,\n      ph.attrs,\n      ph.startName,\n      ph.closeName,\n      children,\n      ph.isVoid,\n      ph.sourceSpan,\n      ph.startSourceSpan,\n      ph.endSourceSpan,\n    );\n  }\n\n  visitPlaceholder(ph: Placeholder, context?: any): Placeholder {\n    return new Placeholder(ph.value, ph.name, ph.sourceSpan);\n  }\n\n  visitIcuPlaceholder(ph: IcuPlaceholder, context?: any): IcuPlaceholder {\n    return new IcuPlaceholder(ph.value, ph.name, ph.sourceSpan);\n  }\n\n  visitBlockPlaceholder(ph: BlockPlaceholder, context?: any): BlockPlaceholder {\n    const children = ph.children.map((n) => n.visit(this, context));\n    return new BlockPlaceholder(\n      ph.name,\n      ph.parameters,\n      ph.startName,\n      ph.closeName,\n      children,\n      ph.sourceSpan,\n      ph.startSourceSpan,\n      ph.endSourceSpan,\n    );\n  }\n}\n\n// Visit all the nodes recursively\nexport class RecurseVisitor implements Visitor {\n  visitText(text: Text, context?: any): any {}\n\n  visitContainer(container: Container, context?: any): any {\n    container.children.forEach((child) => child.visit(this));\n  }\n\n  visitIcu(icu: Icu, context?: any): any {\n    Object.keys(icu.cases).forEach((k) => {\n      icu.cases[k].visit(this);\n    });\n  }\n\n  visitTagPlaceholder(ph: TagPlaceholder, context?: any): any {\n    ph.children.forEach((child) => child.visit(this));\n  }\n\n  visitPlaceholder(ph: Placeholder, context?: any): any {}\n\n  visitIcuPlaceholder(ph: IcuPlaceholder, context?: any): any {}\n\n  visitBlockPlaceholder(ph: BlockPlaceholder, context?: any): any {\n    ph.children.forEach((child) => child.visit(this));\n  }\n}\n\n/**\n * Serialize the message to the Localize backtick string format that would appear in compiled code.\n */\nfunction serializeMessage(messageNodes: Node[]): string {\n  const visitor = new LocalizeMessageStringVisitor();\n  const str = messageNodes.map((n) => n.visit(visitor)).join('');\n  return str;\n}\n\nclass LocalizeMessageStringVisitor implements Visitor {\n  visitText(text: Text): any {\n    return text.value;\n  }\n\n  visitContainer(container: Container): any {\n    return container.children.map((child) => child.visit(this)).join('');\n  }\n\n  visitIcu(icu: Icu): any {\n    const strCases = Object.keys(icu.cases).map(\n      (k: string) => `${k} {${icu.cases[k].visit(this)}}`,\n    );\n    return `{${icu.expressionPlaceholder}, ${icu.type}, ${strCases.join(' ')}}`;\n  }\n\n  visitTagPlaceholder(ph: TagPlaceholder): any {\n    const children = ph.children.map((child) => child.visit(this)).join('');\n    return `{$${ph.startName}}${children}{$${ph.closeName}}`;\n  }\n\n  visitPlaceholder(ph: Placeholder): any {\n    return `{$${ph.name}}`;\n  }\n\n  visitIcuPlaceholder(ph: IcuPlaceholder): any {\n    return `{$${ph.name}}`;\n  }\n\n  visitBlockPlaceholder(ph: BlockPlaceholder): any {\n    const children = ph.children.map((child) => child.visit(this)).join('');\n    return `{$${ph.startName}}${children}{$${ph.closeName}}`;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as i18n from '../i18n_ast';\n\nexport abstract class Serializer {\n  // - The `placeholders` and `placeholderToMessage` properties are irrelevant in the input messages\n  // - The `id` contains the message id that the serializer is expected to use\n  // - Placeholder names are already map to public names using the provided mapper\n  abstract write(messages: i18n.Message[], locale: string | null): string;\n\n  abstract load(\n    content: string,\n    url: string,\n  ): {locale: string | null; i18nNodesByMsgId: {[msgId: string]: i18n.Node[]}};\n\n  abstract digest(message: i18n.Message): string;\n\n  // Creates a name mapper, see `PlaceholderMapper`\n  // Returning `null` means that no name mapping is used.\n  createNameMapper(message: i18n.Message): PlaceholderMapper | null {\n    return null;\n  }\n}\n\n/**\n * A `PlaceholderMapper` converts placeholder names from internal to serialized representation and\n * back.\n *\n * It should be used for serialization format that put constraints on the placeholder names.\n */\nexport interface PlaceholderMapper {\n  toPublicName(internalName: string): string | null;\n\n  toInternalName(publicName: string): string | null;\n}\n\n/**\n * A simple mapper that take a function to transform an internal name to a public name\n */\nexport class SimplePlaceholderMapper extends i18n.RecurseVisitor implements PlaceholderMapper {\n  private internalToPublic: {[k: string]: string} = {};\n  private publicToNextId: {[k: string]: number} = {};\n  private publicToInternal: {[k: string]: string} = {};\n\n  // create a mapping from the message\n  constructor(\n    message: i18n.Message,\n    private mapName: (name: string) => string,\n  ) {\n    super();\n    message.nodes.forEach((node) => node.visit(this));\n  }\n\n  toPublicName(internalName: string): string | null {\n    return this.internalToPublic.hasOwnProperty(internalName)\n      ? this.internalToPublic[internalName]\n      : null;\n  }\n\n  toInternalName(publicName: string): string | null {\n    return this.publicToInternal.hasOwnProperty(publicName)\n      ? this.publicToInternal[publicName]\n      : null;\n  }\n\n  override visitText(text: i18n.Text, context?: any): any {\n    return null;\n  }\n\n  override visitTagPlaceholder(ph: i18n.TagPlaceholder, context?: any): any {\n    this.visitPlaceholderName(ph.startName);\n    super.visitTagPlaceholder(ph, context);\n    this.visitPlaceholderName(ph.closeName);\n  }\n\n  override visitPlaceholder(ph: i18n.Placeholder, context?: any): any {\n    this.visitPlaceholderName(ph.name);\n  }\n\n  override visitBlockPlaceholder(ph: i18n.BlockPlaceholder, context?: any): any {\n    this.visitPlaceholderName(ph.startName);\n    super.visitBlockPlaceholder(ph, context);\n    this.visitPlaceholderName(ph.closeName);\n  }\n\n  override visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): any {\n    this.visitPlaceholderName(ph.name);\n  }\n\n  // XMB placeholders could only contains A-Z, 0-9 and _\n  private visitPlaceholderName(internalName: string): void {\n    if (!internalName || this.internalToPublic.hasOwnProperty(internalName)) {\n      return;\n    }\n\n    let publicName = this.mapName(internalName);\n\n    if (this.publicToInternal.hasOwnProperty(publicName)) {\n      // Create a new XMB when it has already been used\n      const nextId = this.publicToNextId[publicName];\n      this.publicToNextId[publicName] = nextId + 1;\n      publicName = `${publicName}_${nextId}`;\n    } else {\n      this.publicToNextId[publicName] = 1;\n    }\n\n    this.internalToPublic[internalName] = publicName;\n    this.publicToInternal[publicName] = internalName;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nexport interface IVisitor {\n  visitTag(tag: Tag): any;\n  visitText(text: Text): any;\n  visitDeclaration(decl: Declaration): any;\n  visitDoctype(doctype: Doctype): any;\n}\n\nclass _Visitor implements IVisitor {\n  visitTag(tag: Tag): string {\n    const strAttrs = this._serializeAttributes(tag.attrs);\n\n    if (tag.children.length == 0) {\n      return `<${tag.name}${strAttrs}/>`;\n    }\n\n    const strChildren = tag.children.map((node) => node.visit(this));\n    return `<${tag.name}${strAttrs}>${strChildren.join('')}</${tag.name}>`;\n  }\n\n  visitText(text: Text): string {\n    return text.value;\n  }\n\n  visitDeclaration(decl: Declaration): string {\n    return `<?xml${this._serializeAttributes(decl.attrs)} ?>`;\n  }\n\n  private _serializeAttributes(attrs: {[k: string]: string}) {\n    const strAttrs = Object.keys(attrs)\n      .map((name: string) => `${name}=\"${attrs[name]}\"`)\n      .join(' ');\n    return strAttrs.length > 0 ? ' ' + strAttrs : '';\n  }\n\n  visitDoctype(doctype: Doctype): any {\n    return `<!DOCTYPE ${doctype.rootTag} [\\n${doctype.dtd}\\n]>`;\n  }\n}\n\nconst _visitor = new _Visitor();\n\nexport function serialize(nodes: Node[]): string {\n  return nodes.map((node: Node): string => node.visit(_visitor)).join('');\n}\n\nexport interface Node {\n  visit(visitor: IVisitor): any;\n}\n\nexport class Declaration implements Node {\n  public attrs: {[k: string]: string} = {};\n\n  constructor(unescapedAttrs: {[k: string]: string}) {\n    Object.keys(unescapedAttrs).forEach((k: string) => {\n      this.attrs[k] = escapeXml(unescapedAttrs[k]);\n    });\n  }\n\n  visit(visitor: IVisitor): any {\n    return visitor.visitDeclaration(this);\n  }\n}\n\nexport class Doctype implements Node {\n  constructor(\n    public rootTag: string,\n    public dtd: string,\n  ) {}\n\n  visit(visitor: IVisitor): any {\n    return visitor.visitDoctype(this);\n  }\n}\n\nexport class Tag implements Node {\n  public attrs: {[k: string]: string} = {};\n\n  constructor(\n    public name: string,\n    unescapedAttrs: {[k: string]: string} = {},\n    public children: Node[] = [],\n  ) {\n    Object.keys(unescapedAttrs).forEach((k: string) => {\n      this.attrs[k] = escapeXml(unescapedAttrs[k]);\n    });\n  }\n\n  visit(visitor: IVisitor): any {\n    return visitor.visitTag(this);\n  }\n}\n\nexport class Text implements Node {\n  value: string;\n  constructor(unescapedValue: string) {\n    this.value = escapeXml(unescapedValue);\n  }\n\n  visit(visitor: IVisitor): any {\n    return visitor.visitText(this);\n  }\n}\n\nexport class CR extends Text {\n  constructor(ws: number = 0) {\n    super(`\\n${new Array(ws + 1).join(' ')}`);\n  }\n}\n\nconst _ESCAPED_CHARS: [RegExp, string][] = [\n  [/&/g, '&amp;'],\n  [/\"/g, '&quot;'],\n  [/'/g, '&apos;'],\n  [/</g, '&lt;'],\n  [/>/g, '&gt;'],\n];\n\n// Escape `_ESCAPED_CHARS` characters in the given text with encoded entities\nexport function escapeXml(text: string): string {\n  return _ESCAPED_CHARS.reduce(\n    (text: string, entry: [RegExp, string]) => text.replace(entry[0], entry[1]),\n    text,\n  );\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {decimalDigest} from '../digest';\nimport * as i18n from '../i18n_ast';\n\nimport {PlaceholderMapper, Serializer, SimplePlaceholderMapper} from './serializer';\nimport * as xml from './xml_helper';\n\n/**\n * Defines the `handler` value on the serialized XMB, indicating that Angular\n * generated the bundle. This is useful for analytics in Translation Console.\n *\n * NOTE: Keep in sync with\n * packages/localize/tools/src/extract/translation_files/xmb_translation_serializer.ts.\n */\nconst _XMB_HANDLER = 'angular';\n\nconst _MESSAGES_TAG = 'messagebundle';\nconst _MESSAGE_TAG = 'msg';\nconst _PLACEHOLDER_TAG = 'ph';\nconst _EXAMPLE_TAG = 'ex';\nconst _SOURCE_TAG = 'source';\n\nconst _DOCTYPE = `<!ELEMENT messagebundle (msg)*>\n<!ATTLIST messagebundle class CDATA #IMPLIED>\n\n<!ELEMENT msg (#PCDATA|ph|source)*>\n<!ATTLIST msg id CDATA #IMPLIED>\n<!ATTLIST msg seq CDATA #IMPLIED>\n<!ATTLIST msg name CDATA #IMPLIED>\n<!ATTLIST msg desc CDATA #IMPLIED>\n<!ATTLIST msg meaning CDATA #IMPLIED>\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\n<!ATTLIST msg xml:space (default|preserve) \"default\">\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\n\n<!ELEMENT source (#PCDATA)>\n\n<!ELEMENT ph (#PCDATA|ex)*>\n<!ATTLIST ph name CDATA #REQUIRED>\n\n<!ELEMENT ex (#PCDATA)>`;\n\nexport class Xmb extends Serializer {\n  override write(messages: i18n.Message[], locale: string | null): string {\n    const exampleVisitor = new ExampleVisitor();\n    const visitor = new _Visitor();\n    const rootNode = new xml.Tag(_MESSAGES_TAG);\n    rootNode.attrs['handler'] = _XMB_HANDLER;\n\n    messages.forEach((message) => {\n      const attrs: {[k: string]: string} = {id: message.id};\n\n      if (message.description) {\n        attrs['desc'] = message.description;\n      }\n\n      if (message.meaning) {\n        attrs['meaning'] = message.meaning;\n      }\n\n      let sourceTags: xml.Tag[] = [];\n      message.sources.forEach((source: i18n.MessageSpan) => {\n        sourceTags.push(\n          new xml.Tag(_SOURCE_TAG, {}, [\n            new xml.Text(\n              `${source.filePath}:${source.startLine}${\n                source.endLine !== source.startLine ? ',' + source.endLine : ''\n              }`,\n            ),\n          ]),\n        );\n      });\n\n      rootNode.children.push(\n        new xml.CR(2),\n        new xml.Tag(_MESSAGE_TAG, attrs, [...sourceTags, ...visitor.serialize(message.nodes)]),\n      );\n    });\n\n    rootNode.children.push(new xml.CR());\n\n    return xml.serialize([\n      new xml.Declaration({version: '1.0', encoding: 'UTF-8'}),\n      new xml.CR(),\n      new xml.Doctype(_MESSAGES_TAG, _DOCTYPE),\n      new xml.CR(),\n      exampleVisitor.addDefaultExamples(rootNode),\n      new xml.CR(),\n    ]);\n  }\n\n  override load(\n    content: string,\n    url: string,\n  ): {locale: string; i18nNodesByMsgId: {[msgId: string]: i18n.Node[]}} {\n    throw new Error('Unsupported');\n  }\n\n  override digest(message: i18n.Message): string {\n    return digest(message);\n  }\n\n  override createNameMapper(message: i18n.Message): PlaceholderMapper {\n    return new SimplePlaceholderMapper(message, toPublicName);\n  }\n}\n\nclass _Visitor implements i18n.Visitor {\n  visitText(text: i18n.Text, context?: any): xml.Node[] {\n    return [new xml.Text(text.value)];\n  }\n\n  visitContainer(container: i18n.Container, context: any): xml.Node[] {\n    const nodes: xml.Node[] = [];\n    container.children.forEach((node: i18n.Node) => nodes.push(...node.visit(this)));\n    return nodes;\n  }\n\n  visitIcu(icu: i18n.Icu, context?: any): xml.Node[] {\n    const nodes = [new xml.Text(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n\n    Object.keys(icu.cases).forEach((c: string) => {\n      nodes.push(new xml.Text(`${c} {`), ...icu.cases[c].visit(this), new xml.Text(`} `));\n    });\n\n    nodes.push(new xml.Text(`}`));\n\n    return nodes;\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context?: any): xml.Node[] {\n    const startTagAsText = new xml.Text(`<${ph.tag}>`);\n    const startEx = new xml.Tag(_EXAMPLE_TAG, {}, [startTagAsText]);\n    // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n    const startTagPh = new xml.Tag(_PLACEHOLDER_TAG, {name: ph.startName}, [\n      startEx,\n      startTagAsText,\n    ]);\n    if (ph.isVoid) {\n      // void tags have no children nor closing tags\n      return [startTagPh];\n    }\n\n    const closeTagAsText = new xml.Text(`</${ph.tag}>`);\n    const closeEx = new xml.Tag(_EXAMPLE_TAG, {}, [closeTagAsText]);\n    // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n    const closeTagPh = new xml.Tag(_PLACEHOLDER_TAG, {name: ph.closeName}, [\n      closeEx,\n      closeTagAsText,\n    ]);\n\n    return [startTagPh, ...this.serialize(ph.children), closeTagPh];\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context?: any): xml.Node[] {\n    const interpolationAsText = new xml.Text(`{{${ph.value}}}`);\n    // Example tag needs to be not-empty for TC.\n    const exTag = new xml.Tag(_EXAMPLE_TAG, {}, [interpolationAsText]);\n    return [\n      // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n      new xml.Tag(_PLACEHOLDER_TAG, {name: ph.name}, [exTag, interpolationAsText]),\n    ];\n  }\n\n  visitBlockPlaceholder(ph: i18n.BlockPlaceholder, context?: any): xml.Node[] {\n    const startAsText = new xml.Text(`@${ph.name}`);\n    const startEx = new xml.Tag(_EXAMPLE_TAG, {}, [startAsText]);\n    // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n    const startTagPh = new xml.Tag(_PLACEHOLDER_TAG, {name: ph.startName}, [startEx, startAsText]);\n\n    const closeAsText = new xml.Text(`}`);\n    const closeEx = new xml.Tag(_EXAMPLE_TAG, {}, [closeAsText]);\n    // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n    const closeTagPh = new xml.Tag(_PLACEHOLDER_TAG, {name: ph.closeName}, [closeEx, closeAsText]);\n\n    return [startTagPh, ...this.serialize(ph.children), closeTagPh];\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): xml.Node[] {\n    const icuExpression = ph.value.expression;\n    const icuType = ph.value.type;\n    const icuCases = Object.keys(ph.value.cases)\n      .map((value: string) => value + ' {...}')\n      .join(' ');\n    const icuAsText = new xml.Text(`{${icuExpression}, ${icuType}, ${icuCases}}`);\n    const exTag = new xml.Tag(_EXAMPLE_TAG, {}, [icuAsText]);\n    return [\n      // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n      new xml.Tag(_PLACEHOLDER_TAG, {name: ph.name}, [exTag, icuAsText]),\n    ];\n  }\n\n  serialize(nodes: i18n.Node[]): xml.Node[] {\n    return [].concat(...nodes.map((node) => node.visit(this)));\n  }\n}\n\nexport function digest(message: i18n.Message): string {\n  return decimalDigest(message);\n}\n\n// TC requires at least one non-empty example on placeholders\nclass ExampleVisitor implements xml.IVisitor {\n  addDefaultExamples(node: xml.Node): xml.Node {\n    node.visit(this);\n    return node;\n  }\n\n  visitTag(tag: xml.Tag): void {\n    if (tag.name === _PLACEHOLDER_TAG) {\n      if (!tag.children || tag.children.length == 0) {\n        const exText = new xml.Text(tag.attrs['name'] || '...');\n        tag.children = [new xml.Tag(_EXAMPLE_TAG, {}, [exText])];\n      }\n    } else if (tag.children) {\n      tag.children.forEach((node) => node.visit(this));\n    }\n  }\n\n  visitText(text: xml.Text): void {}\n  visitDeclaration(decl: xml.Declaration): void {}\n  visitDoctype(doctype: xml.Doctype): void {}\n}\n\n// XMB/XTB placeholders can only contain A-Z, 0-9 and _\nexport function toPublicName(internalName: string): string {\n  return internalName.toUpperCase().replace(/[^A-Z0-9_]/g, '_');\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport * as i18n from '../../../i18n/i18n_ast';\nimport {toPublicName} from '../../../i18n/serializers/xmb';\nimport * as html from '../../../ml_parser/ast';\nimport * as o from '../../../output/output_ast';\n\n/** Name of the i18n attributes **/\nexport const I18N_ATTR = 'i18n';\nexport const I18N_ATTR_PREFIX = 'i18n-';\n\n/** Prefix of var expressions used in ICUs */\nexport const I18N_ICU_VAR_PREFIX = 'VAR_';\n\nexport function isI18nAttribute(name: string): boolean {\n  return name === I18N_ATTR || name.startsWith(I18N_ATTR_PREFIX);\n}\n\nexport function hasI18nAttrs(node: html.Element | html.Component): boolean {\n  return node.attrs.some((attr: html.Attribute) => isI18nAttribute(attr.name));\n}\n\nexport function icuFromI18nMessage(message: i18n.Message) {\n  return message.nodes[0] as i18n.IcuPlaceholder;\n}\n\nexport function placeholdersToParams(placeholders: Map<string, string[]>): {\n  [name: string]: o.LiteralExpr;\n} {\n  const params: {[name: string]: o.LiteralExpr} = {};\n  placeholders.forEach((values: string[], key: string) => {\n    params[key] = o.literal(values.length > 1 ? `[${values.join('|')}]` : values[0]);\n  });\n  return params;\n}\n\n/**\n * Format the placeholder names in a map of placeholders to expressions.\n *\n * The placeholder names are converted from \"internal\" format (e.g. `START_TAG_DIV_1`) to \"external\"\n * format (e.g. `startTagDiv_1`).\n *\n * @param params A map of placeholder names to expressions.\n * @param useCamelCase whether to camelCase the placeholder name when formatting.\n * @returns A new map of formatted placeholder names to expressions.\n */\nexport function formatI18nPlaceholderNamesInMap(\n  params: {[name: string]: o.Expression} = {},\n  useCamelCase: boolean,\n) {\n  const _params: {[key: string]: o.Expression} = {};\n  if (params && Object.keys(params).length) {\n    Object.keys(params).forEach(\n      (key) => (_params[formatI18nPlaceholderName(key, useCamelCase)] = params[key]),\n    );\n  }\n  return _params;\n}\n\n/**\n * Converts internal placeholder names to public-facing format\n * (for example to use in goog.getMsg call).\n * Example: `START_TAG_DIV_1` is converted to `startTagDiv_1`.\n *\n * @param name The placeholder name that should be formatted\n * @returns Formatted placeholder name\n */\nexport function formatI18nPlaceholderName(name: string, useCamelCase: boolean = true): string {\n  const publicName = toPublicName(name);\n  if (!useCamelCase) {\n    return publicName;\n  }\n  const chunks = publicName.split('_');\n  if (chunks.length === 1) {\n    // if no \"_\" found - just lowercase the value\n    return name.toLowerCase();\n  }\n  let postfix;\n  // eject last element if it's a number\n  if (/^\\d+$/.test(chunks[chunks.length - 1])) {\n    postfix = chunks.pop();\n  }\n  let raw = chunks.shift()!.toLowerCase();\n  if (chunks.length) {\n    raw += chunks.map((c) => c.charAt(0).toUpperCase() + c.slice(1).toLowerCase()).join('');\n  }\n  return postfix ? `${raw}_${postfix}` : raw;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {InputFlags} from '../../core';\nimport {BindingType} from '../../expression_parser/ast';\nimport {splitNsName} from '../../ml_parser/tags';\nimport * as o from '../../output/output_ast';\nimport {CssSelector} from '../../directive_matching';\nimport * as t from '../r3_ast';\n\nimport {isI18nAttribute} from './i18n/util';\n\n/**\n * Checks whether an object key contains potentially unsafe chars, thus the key should be wrapped in\n * quotes. Note: we do not wrap all keys into quotes, as it may have impact on minification and may\n * not work in some cases when object keys are mangled by a minifier.\n *\n * TODO(FW-1136): this is a temporary solution, we need to come up with a better way of working with\n * inputs that contain potentially unsafe chars.\n */\nexport const UNSAFE_OBJECT_KEY_NAME_REGEXP = /[-.]/;\n\n/** Name of the temporary to use during data binding */\nexport const TEMPORARY_NAME = '_t';\n\n/** Name of the context parameter passed into a template function */\nexport const CONTEXT_NAME = 'ctx';\n\n/** Name of the RenderFlag passed into a template function */\nexport const RENDER_FLAGS = 'rf';\n\n/**\n * Creates an allocator for a temporary variable.\n *\n * A variable declaration is added to the statements the first time the allocator is invoked.\n */\nexport function temporaryAllocator(\n  pushStatement: (st: o.Statement) => void,\n  name: string,\n): () => o.ReadVarExpr {\n  let temp: o.ReadVarExpr | null = null;\n  return () => {\n    if (!temp) {\n      pushStatement(new o.DeclareVarStmt(TEMPORARY_NAME, undefined, o.DYNAMIC_TYPE));\n      temp = o.variable(name);\n    }\n    return temp;\n  };\n}\n\nexport function invalid<T>(this: t.Visitor, arg: o.Expression | o.Statement | t.Node): never {\n  throw new Error(\n    `Invalid state: Visitor ${this.constructor.name} doesn't handle ${arg.constructor.name}`,\n  );\n}\n\nexport function asLiteral(value: any): o.Expression {\n  if (Array.isArray(value)) {\n    return o.literalArr(value.map(asLiteral));\n  }\n  return o.literal(value, o.INFERRED_TYPE);\n}\n\n/**\n * Serializes inputs and outputs for `defineDirective` and `defineComponent`.\n *\n * This will attempt to generate optimized data structures to minimize memory or\n * file size of fully compiled applications.\n */\nexport function conditionallyCreateDirectiveBindingLiteral(\n  map: Record<\n    string,\n    | string\n    | {\n        classPropertyName: string;\n        bindingPropertyName: string;\n        transformFunction: o.Expression | null;\n        isSignal: boolean;\n      }\n  >,\n  forInputs?: boolean,\n): o.Expression | null {\n  const keys = Object.getOwnPropertyNames(map);\n\n  if (keys.length === 0) {\n    return null;\n  }\n\n  return o.literalMap(\n    keys.map((key) => {\n      const value = map[key];\n      let declaredName: string;\n      let publicName: string;\n      let minifiedName: string;\n      let expressionValue: o.Expression;\n\n      if (typeof value === 'string') {\n        // canonical syntax: `dirProp: publicProp`\n        declaredName = key;\n        minifiedName = key;\n        publicName = value;\n        expressionValue = asLiteral(publicName);\n      } else {\n        minifiedName = key;\n        declaredName = value.classPropertyName;\n        publicName = value.bindingPropertyName;\n\n        const differentDeclaringName = publicName !== declaredName;\n        const hasDecoratorInputTransform = value.transformFunction !== null;\n        let flags = InputFlags.None;\n\n        // Build up input flags\n        if (value.isSignal) {\n          flags |= InputFlags.SignalBased;\n        }\n        if (hasDecoratorInputTransform) {\n          flags |= InputFlags.HasDecoratorInputTransform;\n        }\n\n        // Inputs, compared to outputs, will track their declared name (for `ngOnChanges`), support\n        // decorator input transform functions, or store flag information if there is any.\n        if (\n          forInputs &&\n          (differentDeclaringName || hasDecoratorInputTransform || flags !== InputFlags.None)\n        ) {\n          const result = [o.literal(flags), asLiteral(publicName)];\n\n          if (differentDeclaringName || hasDecoratorInputTransform) {\n            result.push(asLiteral(declaredName));\n\n            if (hasDecoratorInputTransform) {\n              result.push(value.transformFunction!);\n            }\n          }\n\n          expressionValue = o.literalArr(result);\n        } else {\n          expressionValue = asLiteral(publicName);\n        }\n      }\n\n      return {\n        key: minifiedName,\n        // put quotes around keys that contain potentially unsafe characters\n        quoted: UNSAFE_OBJECT_KEY_NAME_REGEXP.test(minifiedName),\n        value: expressionValue,\n      };\n    }),\n  );\n}\n\n/**\n * A representation for an object literal used during codegen of definition objects. The generic\n * type `T` allows to reference a documented type of the generated structure, such that the\n * property names that are set can be resolved to their documented declaration.\n */\nexport class DefinitionMap<T = any> {\n  values: {key: string; quoted: boolean; value: o.Expression}[] = [];\n\n  set(key: keyof T, value: o.Expression | null): void {\n    if (value) {\n      const existing = this.values.find((value) => value.key === key);\n\n      if (existing) {\n        existing.value = value;\n      } else {\n        this.values.push({key: key as string, value, quoted: false});\n      }\n    }\n  }\n\n  toLiteralMap(): o.LiteralMapExpr {\n    return o.literalMap(this.values);\n  }\n}\n\n/**\n * Creates a `CssSelector` from an AST node.\n */\nexport function createCssSelectorFromNode(node: t.Element | t.Template): CssSelector {\n  const elementName = node instanceof t.Element ? node.name : 'ng-template';\n  const attributes = getAttrsForDirectiveMatching(node);\n  const cssSelector = new CssSelector();\n  const elementNameNoNs = splitNsName(elementName)[1];\n\n  cssSelector.setElement(elementNameNoNs);\n\n  Object.getOwnPropertyNames(attributes).forEach((name) => {\n    const nameNoNs = splitNsName(name)[1];\n    const value = attributes[name];\n\n    cssSelector.addAttribute(nameNoNs, value);\n    if (name.toLowerCase() === 'class') {\n      const classes = value.trim().split(/\\s+/);\n      classes.forEach((className) => cssSelector.addClassName(className));\n    }\n  });\n\n  return cssSelector;\n}\n\n/**\n * Extract a map of properties to values for a given element or template node, which can be used\n * by the directive matching machinery.\n *\n * @param elOrTpl the element or template in question\n * @return an object set up for directive matching. For attributes on the element/template, this\n * object maps a property name to its (static) value. For any bindings, this map simply maps the\n * property name to an empty string.\n */\nfunction getAttrsForDirectiveMatching(elOrTpl: t.Element | t.Template): {[name: string]: string} {\n  const attributesMap: {[name: string]: string} = {};\n\n  if (elOrTpl instanceof t.Template && elOrTpl.tagName !== 'ng-template') {\n    elOrTpl.templateAttrs.forEach((a) => (attributesMap[a.name] = ''));\n  } else {\n    elOrTpl.attributes.forEach((a) => {\n      if (!isI18nAttribute(a.name)) {\n        attributesMap[a.name] = a.value;\n      }\n    });\n\n    elOrTpl.inputs.forEach((i) => {\n      if (i.type === BindingType.Property || i.type === BindingType.TwoWay) {\n        attributesMap[i.name] = '';\n      }\n    });\n    elOrTpl.outputs.forEach((o) => {\n      attributesMap[o.name] = '';\n    });\n  }\n\n  return attributesMap;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {FactoryTarget} from './compiler_facade_interface';\nimport * as o from './output/output_ast';\nimport {\n  compileFactoryFunction,\n  R3DependencyMetadata,\n  R3FactoryDelegateType,\n  R3FactoryMetadata,\n} from './render3/r3_factory';\nimport {Identifiers} from './render3/r3_identifiers';\nimport {\n  convertFromMaybeForwardRefExpression,\n  MaybeForwardRefExpression,\n  R3CompiledExpression,\n  R3Reference,\n  typeWithParameters,\n} from './render3/util';\nimport {DefinitionMap} from './render3/view/util';\n\nexport interface R3InjectableMetadata {\n  name: string;\n  type: R3Reference;\n  typeArgumentCount: number;\n  providedIn: MaybeForwardRefExpression;\n  useClass?: MaybeForwardRefExpression;\n  useFactory?: o.Expression;\n  useExisting?: MaybeForwardRefExpression;\n  useValue?: MaybeForwardRefExpression;\n  deps?: R3DependencyMetadata[];\n}\n\nexport function compileInjectable(\n  meta: R3InjectableMetadata,\n  resolveForwardRefs: boolean,\n): R3CompiledExpression {\n  let result: {expression: o.Expression; statements: o.Statement[]} | null = null;\n\n  const factoryMeta: R3FactoryMetadata = {\n    name: meta.name,\n    type: meta.type,\n    typeArgumentCount: meta.typeArgumentCount,\n    deps: [],\n    target: FactoryTarget.Injectable,\n  };\n\n  if (meta.useClass !== undefined) {\n    // meta.useClass has two modes of operation. Either deps are specified, in which case `new` is\n    // used to instantiate the class with dependencies injected, or deps are not specified and\n    // the factory of the class is used to instantiate it.\n    //\n    // A special case exists for useClass: Type where Type is the injectable type itself and no\n    // deps are specified, in which case 'useClass' is effectively ignored.\n\n    const useClassOnSelf = meta.useClass.expression.isEquivalent(meta.type.value);\n    let deps: R3DependencyMetadata[] | undefined = undefined;\n    if (meta.deps !== undefined) {\n      deps = meta.deps;\n    }\n\n    if (deps !== undefined) {\n      // factory: () => new meta.useClass(...deps)\n      result = compileFactoryFunction({\n        ...factoryMeta,\n        delegate: meta.useClass.expression,\n        delegateDeps: deps,\n        delegateType: R3FactoryDelegateType.Class,\n      });\n    } else if (useClassOnSelf) {\n      result = compileFactoryFunction(factoryMeta);\n    } else {\n      result = {\n        statements: [],\n        expression: delegateToFactory(\n          meta.type.value as o.WrappedNodeExpr<any>,\n          meta.useClass.expression as o.WrappedNodeExpr<any>,\n          resolveForwardRefs,\n        ),\n      };\n    }\n  } else if (meta.useFactory !== undefined) {\n    if (meta.deps !== undefined) {\n      result = compileFactoryFunction({\n        ...factoryMeta,\n        delegate: meta.useFactory,\n        delegateDeps: meta.deps || [],\n        delegateType: R3FactoryDelegateType.Function,\n      });\n    } else {\n      result = {statements: [], expression: o.arrowFn([], meta.useFactory.callFn([]))};\n    }\n  } else if (meta.useValue !== undefined) {\n    // Note: it's safe to use `meta.useValue` instead of the `USE_VALUE in meta` check used for\n    // client code because meta.useValue is an Expression which will be defined even if the actual\n    // value is undefined.\n    result = compileFactoryFunction({\n      ...factoryMeta,\n      expression: meta.useValue.expression,\n    });\n  } else if (meta.useExisting !== undefined) {\n    // useExisting is an `inject` call on the existing token.\n    result = compileFactoryFunction({\n      ...factoryMeta,\n      expression: o.importExpr(Identifiers.inject).callFn([meta.useExisting.expression]),\n    });\n  } else {\n    result = {\n      statements: [],\n      expression: delegateToFactory(\n        meta.type.value as o.WrappedNodeExpr<any>,\n        meta.type.value as o.WrappedNodeExpr<any>,\n        resolveForwardRefs,\n      ),\n    };\n  }\n\n  const token = meta.type.value;\n\n  const injectableProps = new DefinitionMap<{\n    token: o.Expression;\n    factory: o.Expression;\n    providedIn: o.Expression;\n  }>();\n  injectableProps.set('token', token);\n  injectableProps.set('factory', result.expression);\n\n  // Only generate providedIn property if it has a non-null value\n  if ((meta.providedIn.expression as o.LiteralExpr).value !== null) {\n    injectableProps.set('providedIn', convertFromMaybeForwardRefExpression(meta.providedIn));\n  }\n\n  const expression = o\n    .importExpr(Identifiers.ɵɵdefineInjectable)\n    .callFn([injectableProps.toLiteralMap()], undefined, true);\n  return {\n    expression,\n    type: createInjectableType(meta),\n    statements: result.statements,\n  };\n}\n\nexport function createInjectableType(meta: R3InjectableMetadata) {\n  return new o.ExpressionType(\n    o.importExpr(Identifiers.InjectableDeclaration, [\n      typeWithParameters(meta.type.type, meta.typeArgumentCount),\n    ]),\n  );\n}\n\nfunction delegateToFactory(\n  type: o.WrappedNodeExpr<any>,\n  useType: o.WrappedNodeExpr<any>,\n  unwrapForwardRefs: boolean,\n): o.Expression {\n  if (type.node === useType.node) {\n    // The types are the same, so we can simply delegate directly to the type's factory.\n    // ```\n    // factory: type.ɵfac\n    // ```\n    return useType.prop('ɵfac');\n  }\n\n  if (!unwrapForwardRefs) {\n    // The type is not wrapped in a `forwardRef()`, so we create a simple factory function that\n    // accepts a sub-type as an argument.\n    // ```\n    // factory: function(t) { return useType.ɵfac(t); }\n    // ```\n    return createFactoryFunction(useType);\n  }\n\n  // The useType is actually wrapped in a `forwardRef()` so we need to resolve that before\n  // calling its factory.\n  // ```\n  // factory: function(t) { return core.resolveForwardRef(type).ɵfac(t); }\n  // ```\n  const unwrappedType = o.importExpr(Identifiers.resolveForwardRef).callFn([useType]);\n  return createFactoryFunction(unwrappedType);\n}\n\nfunction createFactoryFunction(type: o.Expression): o.ArrowFunctionExpr {\n  const t = new o.FnParam('__ngFactoryType__', o.DYNAMIC_TYPE);\n  return o.arrowFn([t], type.prop('ɵfac').callFn([o.variable(t.name)]));\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nconst UNUSABLE_INTERPOLATION_REGEXPS = [\n  /@/, // control flow reserved symbol\n  /^\\s*$/, // empty\n  /[<>]/, // html tag\n  /^[{}]$/, // i18n expansion\n  /&(#|[a-z])/i, // character reference,\n  /^\\/\\//, // comment\n];\n\nexport function assertInterpolationSymbols(identifier: string, value: any): void {\n  if (value != null && !(Array.isArray(value) && value.length == 2)) {\n    throw new Error(`Expected '${identifier}' to be an array, [start, end].`);\n  } else if (value != null) {\n    const start = value[0] as string;\n    const end = value[1] as string;\n    // Check for unusable interpolation symbols\n    UNUSABLE_INTERPOLATION_REGEXPS.forEach((regexp) => {\n      if (regexp.test(start) || regexp.test(end)) {\n        throw new Error(`['${start}', '${end}'] contains unusable interpolation symbol.`);\n      }\n    });\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {assertInterpolationSymbols} from '../assertions';\n\nexport class InterpolationConfig {\n  static fromArray(markers: [string, string] | null): InterpolationConfig {\n    if (!markers) {\n      return DEFAULT_INTERPOLATION_CONFIG;\n    }\n\n    assertInterpolationSymbols('interpolation', markers);\n    return new InterpolationConfig(markers[0], markers[1]);\n  }\n\n  constructor(\n    public start: string,\n    public end: string,\n  ) {}\n}\n\nexport const DEFAULT_INTERPOLATION_CONFIG: InterpolationConfig = new InterpolationConfig(\n  '{{',\n  '}}',\n);\n\nexport const DEFAULT_CONTAINER_BLOCKS = new Set(['switch']);\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nexport const $EOF = 0;\nexport const $BSPACE = 8;\nexport const $TAB = 9;\nexport const $LF = 10;\nexport const $VTAB = 11;\nexport const $FF = 12;\nexport const $CR = 13;\nexport const $SPACE = 32;\nexport const $BANG = 33;\nexport const $DQ = 34;\nexport const $HASH = 35;\nexport const $$ = 36;\nexport const $PERCENT = 37;\nexport const $AMPERSAND = 38;\nexport const $SQ = 39;\nexport const $LPAREN = 40;\nexport const $RPAREN = 41;\nexport const $STAR = 42;\nexport const $PLUS = 43;\nexport const $COMMA = 44;\nexport const $MINUS = 45;\nexport const $PERIOD = 46;\nexport const $SLASH = 47;\nexport const $COLON = 58;\nexport const $SEMICOLON = 59;\nexport const $LT = 60;\nexport const $EQ = 61;\nexport const $GT = 62;\nexport const $QUESTION = 63;\n\nexport const $0 = 48;\nexport const $7 = 55;\nexport const $9 = 57;\n\nexport const $A = 65;\nexport const $E = 69;\nexport const $F = 70;\nexport const $X = 88;\nexport const $Z = 90;\n\nexport const $LBRACKET = 91;\nexport const $BACKSLASH = 92;\nexport const $RBRACKET = 93;\nexport const $CARET = 94;\nexport const $_ = 95;\n\nexport const $a = 97;\nexport const $b = 98;\nexport const $e = 101;\nexport const $f = 102;\nexport const $n = 110;\nexport const $r = 114;\nexport const $t = 116;\nexport const $u = 117;\nexport const $v = 118;\nexport const $x = 120;\nexport const $z = 122;\n\nexport const $LBRACE = 123;\nexport const $BAR = 124;\nexport const $RBRACE = 125;\nexport const $NBSP = 160;\n\nexport const $PIPE = 124;\nexport const $TILDA = 126;\nexport const $AT = 64;\n\nexport const $BT = 96;\n\nexport function isWhitespace(code: number): boolean {\n  return (code >= $TAB && code <= $SPACE) || code == $NBSP;\n}\n\nexport function isDigit(code: number): boolean {\n  return $0 <= code && code <= $9;\n}\n\nexport function isAsciiLetter(code: number): boolean {\n  return (code >= $a && code <= $z) || (code >= $A && code <= $Z);\n}\n\nexport function isAsciiHexDigit(code: number): boolean {\n  return (code >= $a && code <= $f) || (code >= $A && code <= $F) || isDigit(code);\n}\n\nexport function isNewLine(code: number): boolean {\n  return code === $LF || code === $CR;\n}\n\nexport function isOctalDigit(code: number): boolean {\n  return $0 <= code && code <= $7;\n}\n\nexport function isQuote(code: number): boolean {\n  return code === $SQ || code === $DQ || code === $BT;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport * as chars from './chars';\nimport {stringify} from './util';\n\nexport class ParseLocation {\n  constructor(\n    public file: ParseSourceFile,\n    public offset: number,\n    public line: number,\n    public col: number,\n  ) {}\n\n  toString(): string {\n    return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;\n  }\n\n  moveBy(delta: number): ParseLocation {\n    const source = this.file.content;\n    const len = source.length;\n    let offset = this.offset;\n    let line = this.line;\n    let col = this.col;\n    while (offset > 0 && delta < 0) {\n      offset--;\n      delta++;\n      const ch = source.charCodeAt(offset);\n      if (ch == chars.$LF) {\n        line--;\n        const priorLine = source\n          .substring(0, offset - 1)\n          .lastIndexOf(String.fromCharCode(chars.$LF));\n        col = priorLine > 0 ? offset - priorLine : offset;\n      } else {\n        col--;\n      }\n    }\n    while (offset < len && delta > 0) {\n      const ch = source.charCodeAt(offset);\n      offset++;\n      delta--;\n      if (ch == chars.$LF) {\n        line++;\n        col = 0;\n      } else {\n        col++;\n      }\n    }\n    return new ParseLocation(this.file, offset, line, col);\n  }\n\n  // Return the source around the location\n  // Up to `maxChars` or `maxLines` on each side of the location\n  getContext(maxChars: number, maxLines: number): {before: string; after: string} | null {\n    const content = this.file.content;\n    let startOffset = this.offset;\n\n    if (startOffset != null) {\n      if (startOffset > content.length - 1) {\n        startOffset = content.length - 1;\n      }\n      let endOffset = startOffset;\n      let ctxChars = 0;\n      let ctxLines = 0;\n\n      while (ctxChars < maxChars && startOffset > 0) {\n        startOffset--;\n        ctxChars++;\n        if (content[startOffset] == '\\n') {\n          if (++ctxLines == maxLines) {\n            break;\n          }\n        }\n      }\n\n      ctxChars = 0;\n      ctxLines = 0;\n      while (ctxChars < maxChars && endOffset < content.length - 1) {\n        endOffset++;\n        ctxChars++;\n        if (content[endOffset] == '\\n') {\n          if (++ctxLines == maxLines) {\n            break;\n          }\n        }\n      }\n\n      return {\n        before: content.substring(startOffset, this.offset),\n        after: content.substring(this.offset, endOffset + 1),\n      };\n    }\n\n    return null;\n  }\n}\n\nexport class ParseSourceFile {\n  constructor(\n    public content: string,\n    public url: string,\n  ) {}\n}\n\nexport class ParseSourceSpan {\n  /**\n   * Create an object that holds information about spans of tokens/nodes captured during\n   * lexing/parsing of text.\n   *\n   * @param start\n   * The location of the start of the span (having skipped leading trivia).\n   * Skipping leading trivia makes source-spans more \"user friendly\", since things like HTML\n   * elements will appear to begin at the start of the opening tag, rather than at the start of any\n   * leading trivia, which could include newlines.\n   *\n   * @param end\n   * The location of the end of the span.\n   *\n   * @param fullStart\n   * The start of the token without skipping the leading trivia.\n   * This is used by tooling that splits tokens further, such as extracting Angular interpolations\n   * from text tokens. Such tooling creates new source-spans relative to the original token's\n   * source-span. If leading trivia characters have been skipped then the new source-spans may be\n   * incorrectly offset.\n   *\n   * @param details\n   * Additional information (such as identifier names) that should be associated with the span.\n   */\n  constructor(\n    public start: ParseLocation,\n    public end: ParseLocation,\n    public fullStart: ParseLocation = start,\n    public details: string | null = null,\n  ) {}\n\n  toString(): string {\n    return this.start.file.content.substring(this.start.offset, this.end.offset);\n  }\n}\n\nexport enum ParseErrorLevel {\n  WARNING,\n  ERROR,\n}\n\nexport class ParseError extends Error {\n  constructor(\n    /** Location of the error. */\n    readonly span: ParseSourceSpan,\n    /** Error message. */\n    readonly msg: string,\n    /** Severity level of the error. */\n    readonly level: ParseErrorLevel = ParseErrorLevel.ERROR,\n    /**\n     * Error that caused the error to be surfaced. For example, an error in a sub-expression that\n     * couldn't be parsed. Not guaranteed to be defined, but can be used to provide more context.\n     */\n    readonly relatedError?: unknown,\n  ) {\n    super(msg);\n\n    // Extending `Error` ends up breaking some internal tests. This appears to be a known issue\n    // when extending errors in TS and the workaround is to explicitly set the prototype.\n    // https://stackoverflow.com/questions/41102060/typescript-extending-error-class\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n\n  contextualMessage(): string {\n    const ctx = this.span.start.getContext(100, 3);\n    return ctx\n      ? `${this.msg} (\"${ctx.before}[${ParseErrorLevel[this.level]} ->]${ctx.after}\")`\n      : this.msg;\n  }\n\n  override toString(): string {\n    const details = this.span.details ? `, ${this.span.details}` : '';\n    return `${this.contextualMessage()}: ${this.span.start}${details}`;\n  }\n}\n\n/**\n * Generates Source Span object for a given R3 Type for JIT mode.\n *\n * @param kind Component or Directive.\n * @param typeName name of the Component or Directive.\n * @param sourceUrl reference to Component or Directive source.\n * @returns instance of ParseSourceSpan that represent a given Component or Directive.\n */\nexport function r3JitTypeSourceSpan(\n  kind: string,\n  typeName: string,\n  sourceUrl: string,\n): ParseSourceSpan {\n  const sourceFileName = `in ${kind} ${typeName} in ${sourceUrl}`;\n  const sourceFile = new ParseSourceFile('', sourceFileName);\n  return new ParseSourceSpan(\n    new ParseLocation(sourceFile, -1, -1, -1),\n    new ParseLocation(sourceFile, -1, -1, -1),\n  );\n}\n\nlet _anonymousTypeIndex = 0;\n\nexport function identifierName(\n  compileIdentifier: CompileIdentifierMetadata | null | undefined,\n): string | null {\n  if (!compileIdentifier || !compileIdentifier.reference) {\n    return null;\n  }\n  const ref = compileIdentifier.reference;\n  if (ref['__anonymousType']) {\n    return ref['__anonymousType'];\n  }\n  if (ref['__forward_ref__']) {\n    // We do not want to try to stringify a `forwardRef()` function because that would cause the\n    // inner function to be evaluated too early, defeating the whole point of the `forwardRef`.\n    return '__forward_ref__';\n  }\n  let identifier = stringify(ref);\n  if (identifier.indexOf('(') >= 0) {\n    // case: anonymous functions!\n    identifier = `anonymous_${_anonymousTypeIndex++}`;\n    ref['__anonymousType'] = identifier;\n  } else {\n    identifier = sanitizeIdentifier(identifier);\n  }\n  return identifier;\n}\n\nexport interface CompileIdentifierMetadata {\n  reference: any;\n}\n\nexport function sanitizeIdentifier(name: string): string {\n  return name.replace(/\\W/g, '_');\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {AbstractEmitterVisitor, EmitterVisitorContext, escapeIdentifier} from './abstract_emitter';\nimport * as o from './output_ast';\n\n/**\n * In TypeScript, tagged template functions expect a \"template object\", which is an array of\n * \"cooked\" strings plus a `raw` property that contains an array of \"raw\" strings. This is\n * typically constructed with a function called `__makeTemplateObject(cooked, raw)`, but it may not\n * be available in all environments.\n *\n * This is a JavaScript polyfill that uses __makeTemplateObject when it's available, but otherwise\n * creates an inline helper with the same functionality.\n *\n * In the inline function, if `Object.defineProperty` is available we use that to attach the `raw`\n * array.\n */\nconst makeTemplateObjectPolyfill =\n  '(this&&this.__makeTemplateObject||function(e,t){return Object.defineProperty?Object.defineProperty(e,\"raw\",{value:t}):e.raw=t,e})';\n\nexport abstract class AbstractJsEmitterVisitor extends AbstractEmitterVisitor {\n  constructor() {\n    super(false);\n  }\n\n  override visitWrappedNodeExpr(ast: o.WrappedNodeExpr<any>, ctx: EmitterVisitorContext): any {\n    throw new Error('Cannot emit a WrappedNodeExpr in Javascript.');\n  }\n\n  override visitDeclareVarStmt(stmt: o.DeclareVarStmt, ctx: EmitterVisitorContext): any {\n    ctx.print(stmt, `var ${stmt.name}`);\n    if (stmt.value) {\n      ctx.print(stmt, ' = ');\n      stmt.value.visitExpression(this, ctx);\n    }\n    ctx.println(stmt, `;`);\n    return null;\n  }\n  override visitTaggedTemplateLiteralExpr(\n    ast: o.TaggedTemplateLiteralExpr,\n    ctx: EmitterVisitorContext,\n  ): any {\n    // The following convoluted piece of code is effectively the downlevelled equivalent of\n    // ```\n    // tag`...`\n    // ```\n    // which is effectively like:\n    // ```\n    // tag(__makeTemplateObject(cooked, raw), expression1, expression2, ...);\n    // ```\n    const elements = ast.template.elements;\n    ast.tag.visitExpression(this, ctx);\n    ctx.print(ast, `(${makeTemplateObjectPolyfill}(`);\n    ctx.print(ast, `[${elements.map((part) => escapeIdentifier(part.text, false)).join(', ')}], `);\n    ctx.print(\n      ast,\n      `[${elements.map((part) => escapeIdentifier(part.rawText, false)).join(', ')}])`,\n    );\n    ast.template.expressions.forEach((expression) => {\n      ctx.print(ast, ', ');\n      expression.visitExpression(this, ctx);\n    });\n    ctx.print(ast, ')');\n    return null;\n  }\n  override visitTemplateLiteralExpr(expr: o.TemplateLiteralExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(expr, '`');\n    for (let i = 0; i < expr.elements.length; i++) {\n      expr.elements[i].visitExpression(this, ctx);\n      const expression = i < expr.expressions.length ? expr.expressions[i] : null;\n      if (expression !== null) {\n        ctx.print(expression, '${');\n        expression.visitExpression(this, ctx);\n        ctx.print(expression, '}');\n      }\n    }\n    ctx.print(expr, '`');\n  }\n  override visitTemplateLiteralElementExpr(\n    expr: o.TemplateLiteralElementExpr,\n    ctx: EmitterVisitorContext,\n  ): any {\n    ctx.print(expr, expr.rawText);\n    return null;\n  }\n  override visitFunctionExpr(ast: o.FunctionExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `function${ast.name ? ' ' + ast.name : ''}(`);\n    this._visitParams(ast.params, ctx);\n    ctx.println(ast, `) {`);\n    ctx.incIndent();\n    this.visitAllStatements(ast.statements, ctx);\n    ctx.decIndent();\n    ctx.print(ast, `}`);\n    return null;\n  }\n  override visitArrowFunctionExpr(ast: o.ArrowFunctionExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, '(');\n    this._visitParams(ast.params, ctx);\n    ctx.print(ast, ') =>');\n\n    if (Array.isArray(ast.body)) {\n      ctx.println(ast, `{`);\n      ctx.incIndent();\n      this.visitAllStatements(ast.body, ctx);\n      ctx.decIndent();\n      ctx.print(ast, `}`);\n    } else {\n      const isObjectLiteral = ast.body instanceof o.LiteralMapExpr;\n\n      if (isObjectLiteral) {\n        ctx.print(ast, '(');\n      }\n\n      ast.body.visitExpression(this, ctx);\n\n      if (isObjectLiteral) {\n        ctx.print(ast, ')');\n      }\n    }\n\n    return null;\n  }\n  override visitDeclareFunctionStmt(stmt: o.DeclareFunctionStmt, ctx: EmitterVisitorContext): any {\n    ctx.print(stmt, `function ${stmt.name}(`);\n    this._visitParams(stmt.params, ctx);\n    ctx.println(stmt, `) {`);\n    ctx.incIndent();\n    this.visitAllStatements(stmt.statements, ctx);\n    ctx.decIndent();\n    ctx.println(stmt, `}`);\n    return null;\n  }\n  override visitLocalizedString(ast: o.LocalizedString, ctx: EmitterVisitorContext): any {\n    // The following convoluted piece of code is effectively the downlevelled equivalent of\n    // ```\n    // $localize `...`\n    // ```\n    // which is effectively like:\n    // ```\n    // $localize(__makeTemplateObject(cooked, raw), expression1, expression2, ...);\n    // ```\n    ctx.print(ast, `$localize(${makeTemplateObjectPolyfill}(`);\n    const parts = [ast.serializeI18nHead()];\n    for (let i = 1; i < ast.messageParts.length; i++) {\n      parts.push(ast.serializeI18nTemplatePart(i));\n    }\n    ctx.print(ast, `[${parts.map((part) => escapeIdentifier(part.cooked, false)).join(', ')}], `);\n    ctx.print(ast, `[${parts.map((part) => escapeIdentifier(part.raw, false)).join(', ')}])`);\n    ast.expressions.forEach((expression) => {\n      ctx.print(ast, ', ');\n      expression.visitExpression(this, ctx);\n    });\n    ctx.print(ast, ')');\n    return null;\n  }\n\n  private _visitParams(params: o.FnParam[], ctx: EmitterVisitorContext): void {\n    this.visitAllObjects((param) => ctx.print(null, param.name), params, ctx, ',');\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/**\n * @fileoverview\n * A module to facilitate use of a Trusted Types policy within the JIT\n * compiler. It lazily constructs the Trusted Types policy, providing helper\n * utilities for promoting strings to Trusted Types. When Trusted Types are not\n * available, strings are used as a fallback.\n * @security All use of this module is security-sensitive and should go through\n * security review.\n */\n\nimport {global} from '../util';\n\n/**\n * While Angular only uses Trusted Types internally for the time being,\n * references to Trusted Types could leak into our core.d.ts, which would force\n * anyone compiling against @angular/core to provide the @types/trusted-types\n * package in their compilation unit.\n *\n * Until https://github.com/microsoft/TypeScript/issues/30024 is resolved, we\n * will keep Angular's public API surface free of references to Trusted Types.\n * For internal and semi-private APIs that need to reference Trusted Types, the\n * minimal type definitions for the Trusted Types API provided by this module\n * should be used instead. They are marked as \"declare\" to prevent them from\n * being renamed by compiler optimization.\n *\n * Adapted from\n * https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/trusted-types/index.d.ts\n * but restricted to the API surface used within Angular.\n */\n\nexport declare interface TrustedScript {\n  __brand__: 'TrustedScript';\n}\n\nexport declare interface TrustedTypePolicyFactory {\n  createPolicy(\n    policyName: string,\n    policyOptions: {\n      createScript?: (input: string) => string;\n    },\n  ): TrustedTypePolicy;\n}\n\nexport declare interface TrustedTypePolicy {\n  createScript(input: string): TrustedScript;\n}\n\n/**\n * The Trusted Types policy, or null if Trusted Types are not\n * enabled/supported, or undefined if the policy has not been created yet.\n */\nlet policy: TrustedTypePolicy | null | undefined;\n\n/**\n * Returns the Trusted Types policy, or null if Trusted Types are not\n * enabled/supported. The first call to this function will create the policy.\n */\nfunction getPolicy(): TrustedTypePolicy | null {\n  if (policy === undefined) {\n    const trustedTypes = global['trustedTypes'] as TrustedTypePolicyFactory | undefined;\n    policy = null;\n\n    if (trustedTypes) {\n      try {\n        policy = trustedTypes.createPolicy('angular#unsafe-jit', {\n          createScript: (s: string) => s,\n        });\n      } catch {\n        // trustedTypes.createPolicy throws if called with a name that is\n        // already registered, even in report-only mode. Until the API changes,\n        // catch the error not to break the applications functionally. In such\n        // cases, the code will fall back to using strings.\n      }\n    }\n  }\n  return policy;\n}\n\n/**\n * Unsafely promote a string to a TrustedScript, falling back to strings when\n * Trusted Types are not available.\n * @security In particular, it must be assured that the provided string will\n * never cause an XSS vulnerability if used in a context that will be\n * interpreted and executed as a script by a browser, e.g. when calling eval.\n */\nfunction trustedScriptFromString(script: string): TrustedScript | string {\n  return getPolicy()?.createScript(script) || script;\n}\n\n/**\n * Unsafely call the Function constructor with the given string arguments.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only called from the JIT compiler, as use in other code can lead to XSS\n * vulnerabilities.\n */\nexport function newTrustedFunctionForJIT(...args: string[]): Function {\n  if (!global['trustedTypes']) {\n    // In environments that don't support Trusted Types, fall back to the most\n    // straightforward implementation:\n    return new Function(...args);\n  }\n\n  // Chrome currently does not support passing TrustedScript to the Function\n  // constructor. The following implements the workaround proposed on the page\n  // below, where the Chromium bug is also referenced:\n  // https://github.com/w3c/webappsec-trusted-types/wiki/Trusted-Types-for-function-constructor\n  const fnArgs = args.slice(0, -1).join(',');\n  const fnBody = args[args.length - 1];\n  const body = `(function anonymous(${fnArgs}\n) { ${fnBody}\n})`;\n\n  // Using eval directly confuses the compiler and prevents this module from\n  // being stripped out of JS binaries even if not used. The global['eval']\n  // indirection fixes that.\n  const fn = global['eval'](trustedScriptFromString(body) as string) as Function;\n  if (fn.bind === undefined) {\n    // Workaround for a browser bug that only exists in Chrome 83, where passing\n    // a TrustedScript to eval just returns the TrustedScript back without\n    // evaluating it. In that case, fall back to the most straightforward\n    // implementation:\n    return new Function(...args);\n  }\n\n  // To completely mimic the behavior of calling \"new Function\", two more\n  // things need to happen:\n  // 1. Stringifying the resulting function should return its source code\n  fn.toString = () => body;\n  // 2. When calling the resulting function, `this` should refer to `global`\n  return fn.bind(global);\n\n  // When Trusted Types support in Function constructors is widely available,\n  // the implementation of this function can be simplified to:\n  // return new Function(...args.map(a => trustedScriptFromString(a)));\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {identifierName} from '../parse_util';\n\nimport {EmitterVisitorContext} from './abstract_emitter';\nimport {AbstractJsEmitterVisitor} from './abstract_js_emitter';\nimport * as o from './output_ast';\nimport {newTrustedFunctionForJIT} from './output_jit_trusted_types';\n\nexport interface ExternalReferenceResolver {\n  resolveExternalReference(ref: o.ExternalReference): unknown;\n}\n\n/**\n * A helper class to manage the evaluation of JIT generated code.\n */\nexport class JitEvaluator {\n  /**\n   *\n   * @param sourceUrl The URL of the generated code.\n   * @param statements An array of Angular statement AST nodes to be evaluated.\n   * @param refResolver Resolves `o.ExternalReference`s into values.\n   * @param createSourceMaps If true then create a source-map for the generated code and include it\n   * inline as a source-map comment.\n   * @returns A map of all the variables in the generated code.\n   */\n  evaluateStatements(\n    sourceUrl: string,\n    statements: o.Statement[],\n    refResolver: ExternalReferenceResolver,\n    createSourceMaps: boolean,\n  ): {[key: string]: any} {\n    const converter = new JitEmitterVisitor(refResolver);\n    const ctx = EmitterVisitorContext.createRoot();\n    // Ensure generated code is in strict mode\n    if (statements.length > 0 && !isUseStrictStatement(statements[0])) {\n      statements = [o.literal('use strict').toStmt(), ...statements];\n    }\n    converter.visitAllStatements(statements, ctx);\n    converter.createReturnStmt(ctx);\n    return this.evaluateCode(sourceUrl, ctx, converter.getArgs(), createSourceMaps);\n  }\n\n  /**\n   * Evaluate a piece of JIT generated code.\n   * @param sourceUrl The URL of this generated code.\n   * @param ctx A context object that contains an AST of the code to be evaluated.\n   * @param vars A map containing the names and values of variables that the evaluated code might\n   * reference.\n   * @param createSourceMap If true then create a source-map for the generated code and include it\n   * inline as a source-map comment.\n   * @returns The result of evaluating the code.\n   */\n  evaluateCode(\n    sourceUrl: string,\n    ctx: EmitterVisitorContext,\n    vars: {[key: string]: any},\n    createSourceMap: boolean,\n  ): any {\n    let fnBody = `\"use strict\";${ctx.toSource()}\\n//# sourceURL=${sourceUrl}`;\n    const fnArgNames: string[] = [];\n    const fnArgValues: any[] = [];\n    for (const argName in vars) {\n      fnArgValues.push(vars[argName]);\n      fnArgNames.push(argName);\n    }\n    if (createSourceMap) {\n      // using `new Function(...)` generates a header, 1 line of no arguments, 2 lines otherwise\n      // E.g. ```\n      // function anonymous(a,b,c\n      // /**/) { ... }```\n      // We don't want to hard code this fact, so we auto detect it via an empty function first.\n      const emptyFn = newTrustedFunctionForJIT(...fnArgNames.concat('return null;')).toString();\n      const headerLines = emptyFn.slice(0, emptyFn.indexOf('return null;')).split('\\n').length - 1;\n      fnBody += `\\n${ctx.toSourceMapGenerator(sourceUrl, headerLines).toJsComment()}`;\n    }\n    const fn = newTrustedFunctionForJIT(...fnArgNames.concat(fnBody));\n    return this.executeFunction(fn, fnArgValues);\n  }\n\n  /**\n   * Execute a JIT generated function by calling it.\n   *\n   * This method can be overridden in tests to capture the functions that are generated\n   * by this `JitEvaluator` class.\n   *\n   * @param fn A function to execute.\n   * @param args The arguments to pass to the function being executed.\n   * @returns The return value of the executed function.\n   */\n  executeFunction(fn: Function, args: any[]) {\n    return fn(...args);\n  }\n}\n\n/**\n * An Angular AST visitor that converts AST nodes into executable JavaScript code.\n */\nexport class JitEmitterVisitor extends AbstractJsEmitterVisitor {\n  private _evalArgNames: string[] = [];\n  private _evalArgValues: any[] = [];\n  private _evalExportedVars: string[] = [];\n\n  constructor(private refResolver: ExternalReferenceResolver) {\n    super();\n  }\n\n  createReturnStmt(ctx: EmitterVisitorContext) {\n    const stmt = new o.ReturnStatement(\n      new o.LiteralMapExpr(\n        this._evalExportedVars.map(\n          (resultVar) => new o.LiteralMapEntry(resultVar, o.variable(resultVar), false),\n        ),\n      ),\n    );\n    stmt.visitStatement(this, ctx);\n  }\n\n  getArgs(): {[key: string]: any} {\n    const result: {[key: string]: any} = {};\n    for (let i = 0; i < this._evalArgNames.length; i++) {\n      result[this._evalArgNames[i]] = this._evalArgValues[i];\n    }\n    return result;\n  }\n\n  override visitExternalExpr(ast: o.ExternalExpr, ctx: EmitterVisitorContext): any {\n    this._emitReferenceToExternal(ast, this.refResolver.resolveExternalReference(ast.value), ctx);\n    return null;\n  }\n\n  override visitWrappedNodeExpr(ast: o.WrappedNodeExpr<any>, ctx: EmitterVisitorContext): any {\n    this._emitReferenceToExternal(ast, ast.node, ctx);\n    return null;\n  }\n\n  override visitDeclareVarStmt(stmt: o.DeclareVarStmt, ctx: EmitterVisitorContext): any {\n    if (stmt.hasModifier(o.StmtModifier.Exported)) {\n      this._evalExportedVars.push(stmt.name);\n    }\n    return super.visitDeclareVarStmt(stmt, ctx);\n  }\n\n  override visitDeclareFunctionStmt(stmt: o.DeclareFunctionStmt, ctx: EmitterVisitorContext): any {\n    if (stmt.hasModifier(o.StmtModifier.Exported)) {\n      this._evalExportedVars.push(stmt.name);\n    }\n    return super.visitDeclareFunctionStmt(stmt, ctx);\n  }\n\n  private _emitReferenceToExternal(\n    ast: o.Expression,\n    value: any,\n    ctx: EmitterVisitorContext,\n  ): void {\n    let id = this._evalArgValues.indexOf(value);\n    if (id === -1) {\n      id = this._evalArgValues.length;\n      this._evalArgValues.push(value);\n      const name = identifierName({reference: value}) || 'val';\n      this._evalArgNames.push(`jit_${name}_${id}`);\n    }\n    ctx.print(ast, this._evalArgNames[id]);\n  }\n}\n\nfunction isUseStrictStatement(statement: o.Statement): boolean {\n  return statement.isEquivalent(o.literal('use strict').toStmt());\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../output/output_ast';\n\nimport {Identifiers as R3} from './r3_identifiers';\nimport {R3CompiledExpression, R3Reference} from './util';\nimport {DefinitionMap} from './view/util';\n\nexport interface R3InjectorMetadata {\n  name: string;\n  type: R3Reference;\n  providers: o.Expression | null;\n  imports: o.Expression[];\n}\n\nexport function compileInjector(meta: R3InjectorMetadata): R3CompiledExpression {\n  const definitionMap = new DefinitionMap<{providers: o.Expression; imports: o.Expression}>();\n\n  if (meta.providers !== null) {\n    definitionMap.set('providers', meta.providers);\n  }\n\n  if (meta.imports.length > 0) {\n    definitionMap.set('imports', o.literalArr(meta.imports));\n  }\n\n  const expression = o\n    .importExpr(R3.defineInjector)\n    .callFn([definitionMap.toLiteralMap()], undefined, true);\n  const type = createInjectorType(meta);\n  return {expression, type, statements: []};\n}\n\nexport function createInjectorType(meta: R3InjectorMetadata): o.Type {\n  return new o.ExpressionType(\n    o.importExpr(R3.InjectorDeclaration, [new o.ExpressionType(meta.type.type)]),\n  );\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../output/output_ast';\nimport {ExternalReferenceResolver} from '../output/output_jit';\n\n/**\n * Implementation of `CompileReflector` which resolves references to @angular/core\n * symbols at runtime, according to a consumer-provided mapping.\n *\n * Only supports `resolveExternalReference`, all other methods throw.\n */\nexport class R3JitReflector implements ExternalReferenceResolver {\n  constructor(private context: {[key: string]: unknown}) {}\n\n  resolveExternalReference(ref: o.ExternalReference): unknown {\n    // This reflector only handles @angular/core imports.\n    if (ref.moduleName !== '@angular/core') {\n      throw new Error(\n        `Cannot resolve external reference to ${ref.moduleName}, only references to @angular/core are supported.`,\n      );\n    }\n    if (!this.context.hasOwnProperty(ref.name!)) {\n      throw new Error(`No value provided for @angular/core symbol '${ref.name!}'.`);\n    }\n    return this.context[ref.name!];\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {R3DeclareNgModuleFacade} from '../compiler_facade_interface';\nimport * as o from '../output/output_ast';\n\nimport {Identifiers as R3} from './r3_identifiers';\nimport {jitOnlyGuardedExpression, R3CompiledExpression, R3Reference, refsToArray} from './util';\nimport {DefinitionMap} from './view/util';\n\n/**\n * How the selector scope of an NgModule (its declarations, imports, and exports) should be emitted\n * as a part of the NgModule definition.\n */\nexport enum R3SelectorScopeMode {\n  /**\n   * Emit the declarations inline into the module definition.\n   *\n   * This option is useful in certain contexts where it's known that JIT support is required. The\n   * tradeoff here is that this emit style prevents directives and pipes from being tree-shaken if\n   * they are unused, but the NgModule is used.\n   */\n  Inline,\n\n  /**\n   * Emit the declarations using a side effectful function call, `ɵɵsetNgModuleScope`, that is\n   * guarded with the `ngJitMode` flag.\n   *\n   * This form of emit supports JIT and can be optimized away if the `ngJitMode` flag is set to\n   * false, which allows unused directives and pipes to be tree-shaken.\n   */\n  SideEffect,\n\n  /**\n   * Don't generate selector scopes at all.\n   *\n   * This is useful for contexts where JIT support is known to be unnecessary.\n   */\n  Omit,\n}\n\n/**\n * The type of the NgModule meta data.\n * - Global: Used for full and partial compilation modes which mainly includes R3References.\n * - Local: Used for the local compilation mode which mainly includes the raw expressions as appears\n * in the NgModule decorator.\n */\nexport enum R3NgModuleMetadataKind {\n  Global,\n  Local,\n}\n\ninterface R3NgModuleMetadataCommon {\n  kind: R3NgModuleMetadataKind;\n\n  /**\n   * An expression representing the module type being compiled.\n   */\n  type: R3Reference;\n\n  /**\n   * How to emit the selector scope values (declarations, imports, exports).\n   */\n  selectorScopeMode: R3SelectorScopeMode;\n\n  /**\n   * The set of schemas that declare elements to be allowed in the NgModule.\n   */\n  schemas: R3Reference[] | null;\n\n  /** Unique ID or expression representing the unique ID of an NgModule. */\n  id: o.Expression | null;\n}\n\n/**\n * Metadata required by the module compiler in full/partial mode to generate a module def (`ɵmod`)\n * for a type.\n */\nexport interface R3NgModuleMetadataGlobal extends R3NgModuleMetadataCommon {\n  kind: R3NgModuleMetadataKind.Global;\n\n  /**\n   * An array of expressions representing the bootstrap components specified by the module.\n   */\n  bootstrap: R3Reference[];\n\n  /**\n   * An array of expressions representing the directives and pipes declared by the module.\n   */\n  declarations: R3Reference[];\n\n  /**\n   * Those declarations which should be visible to downstream consumers. If not specified, all\n   * declarations are made visible to downstream consumers.\n   */\n  publicDeclarationTypes: o.Expression[] | null;\n\n  /**\n   * An array of expressions representing the imports of the module.\n   */\n  imports: R3Reference[];\n\n  /**\n   * Whether or not to include `imports` in generated type declarations.\n   */\n  includeImportTypes: boolean;\n\n  /**\n   * An array of expressions representing the exports of the module.\n   */\n  exports: R3Reference[];\n\n  /**\n   * Whether to generate closure wrappers for bootstrap, declarations, imports, and exports.\n   */\n  containsForwardDecls: boolean;\n}\n\n/**\n * Metadata required by the module compiler in local mode to generate a module def (`ɵmod`) for a\n * type.\n */\nexport interface R3NgModuleMetadataLocal extends R3NgModuleMetadataCommon {\n  kind: R3NgModuleMetadataKind.Local;\n\n  /**\n   * The output expression representing the bootstrap components specified by the module.\n   */\n  bootstrapExpression: o.Expression | null;\n\n  /**\n   * The output expression representing the declarations of the module.\n   */\n  declarationsExpression: o.Expression | null;\n\n  /**\n   * The output expression representing the imports of the module.\n   */\n  importsExpression: o.Expression | null;\n\n  /**\n   * The output expression representing the exports of the module.\n   */\n  exportsExpression: o.Expression | null;\n\n  /**\n   * Local compilation mode always requires scope to be handled using side effect function calls.\n   */\n  selectorScopeMode: R3SelectorScopeMode.SideEffect;\n}\n\n/**\n * Metadata required by the module compiler to generate a module def (`ɵmod`) for a type.\n */\nexport type R3NgModuleMetadata = R3NgModuleMetadataGlobal | R3NgModuleMetadataLocal;\n\n/**\n * The shape of the object literal that is passed to the `ɵɵdefineNgModule()` call.\n */\ninterface R3NgModuleDefMap {\n  /**\n   * An expression representing the module type being compiled.\n   */\n  type: o.Expression;\n  /**\n   * An expression evaluating to an array of expressions representing the bootstrap components\n   * specified by the module.\n   */\n  bootstrap?: o.Expression;\n  /**\n   * An expression evaluating to an array of expressions representing the directives and pipes\n   * declared by the module.\n   */\n  declarations?: o.Expression;\n  /**\n   * An expression evaluating to an array of expressions representing the imports of the module.\n   */\n  imports?: o.Expression;\n  /**\n   * An expression evaluating to an array of expressions representing the exports of the module.\n   */\n  exports?: o.Expression;\n  /**\n   * A literal array expression containing the schemas that declare elements to be allowed in the\n   * NgModule.\n   */\n  schemas?: o.LiteralArrayExpr;\n  /**\n   * An expression evaluating to the unique ID of an NgModule.\n   * */\n  id?: o.Expression;\n}\n\n/**\n * Construct an `R3NgModuleDef` for the given `R3NgModuleMetadata`.\n */\nexport function compileNgModule(meta: R3NgModuleMetadata): R3CompiledExpression {\n  const statements: o.Statement[] = [];\n  const definitionMap = new DefinitionMap<R3NgModuleDefMap>();\n  definitionMap.set('type', meta.type.value);\n\n  // Assign bootstrap definition. In local compilation mode (i.e., for\n  // `R3NgModuleMetadataKind.LOCAL`) we assign the bootstrap field using the runtime\n  // `ɵɵsetNgModuleScope`.\n  if (meta.kind === R3NgModuleMetadataKind.Global && meta.bootstrap.length > 0) {\n    definitionMap.set('bootstrap', refsToArray(meta.bootstrap, meta.containsForwardDecls));\n  }\n\n  if (meta.selectorScopeMode === R3SelectorScopeMode.Inline) {\n    // If requested to emit scope information inline, pass the `declarations`, `imports` and\n    // `exports` to the `ɵɵdefineNgModule()` call directly.\n\n    if (meta.declarations.length > 0) {\n      definitionMap.set('declarations', refsToArray(meta.declarations, meta.containsForwardDecls));\n    }\n\n    if (meta.imports.length > 0) {\n      definitionMap.set('imports', refsToArray(meta.imports, meta.containsForwardDecls));\n    }\n\n    if (meta.exports.length > 0) {\n      definitionMap.set('exports', refsToArray(meta.exports, meta.containsForwardDecls));\n    }\n  } else if (meta.selectorScopeMode === R3SelectorScopeMode.SideEffect) {\n    // In this mode, scope information is not passed into `ɵɵdefineNgModule` as it\n    // would prevent tree-shaking of the declarations, imports and exports references. Instead, it's\n    // patched onto the NgModule definition with a `ɵɵsetNgModuleScope` call that's guarded by the\n    // `ngJitMode` flag.\n    const setNgModuleScopeCall = generateSetNgModuleScopeCall(meta);\n    if (setNgModuleScopeCall !== null) {\n      statements.push(setNgModuleScopeCall);\n    }\n  } else {\n    // Selector scope emit was not requested, so skip it.\n  }\n\n  if (meta.schemas !== null && meta.schemas.length > 0) {\n    definitionMap.set('schemas', o.literalArr(meta.schemas.map((ref) => ref.value)));\n  }\n\n  if (meta.id !== null) {\n    definitionMap.set('id', meta.id);\n\n    // Generate a side-effectful call to register this NgModule by its id, as per the semantics of\n    // NgModule ids.\n    statements.push(\n      o.importExpr(R3.registerNgModuleType).callFn([meta.type.value, meta.id]).toStmt(),\n    );\n  }\n\n  const expression = o\n    .importExpr(R3.defineNgModule)\n    .callFn([definitionMap.toLiteralMap()], undefined, true);\n  const type = createNgModuleType(meta);\n\n  return {expression, type, statements};\n}\n\n/**\n * This function is used in JIT mode to generate the call to `ɵɵdefineNgModule()` from a call to\n * `ɵɵngDeclareNgModule()`.\n */\nexport function compileNgModuleDeclarationExpression(meta: R3DeclareNgModuleFacade): o.Expression {\n  const definitionMap = new DefinitionMap<R3NgModuleDefMap>();\n  definitionMap.set('type', new o.WrappedNodeExpr(meta.type));\n  if (meta.bootstrap !== undefined) {\n    definitionMap.set('bootstrap', new o.WrappedNodeExpr(meta.bootstrap));\n  }\n  if (meta.declarations !== undefined) {\n    definitionMap.set('declarations', new o.WrappedNodeExpr(meta.declarations));\n  }\n  if (meta.imports !== undefined) {\n    definitionMap.set('imports', new o.WrappedNodeExpr(meta.imports));\n  }\n  if (meta.exports !== undefined) {\n    definitionMap.set('exports', new o.WrappedNodeExpr(meta.exports));\n  }\n  if (meta.schemas !== undefined) {\n    definitionMap.set('schemas', new o.WrappedNodeExpr(meta.schemas));\n  }\n  if (meta.id !== undefined) {\n    definitionMap.set('id', new o.WrappedNodeExpr(meta.id));\n  }\n  return o.importExpr(R3.defineNgModule).callFn([definitionMap.toLiteralMap()]);\n}\n\nexport function createNgModuleType(meta: R3NgModuleMetadata): o.ExpressionType {\n  if (meta.kind === R3NgModuleMetadataKind.Local) {\n    return new o.ExpressionType(meta.type.value);\n  }\n\n  const {\n    type: moduleType,\n    declarations,\n    exports,\n    imports,\n    includeImportTypes,\n    publicDeclarationTypes,\n  } = meta;\n\n  return new o.ExpressionType(\n    o.importExpr(R3.NgModuleDeclaration, [\n      new o.ExpressionType(moduleType.type),\n      publicDeclarationTypes === null\n        ? tupleTypeOf(declarations)\n        : tupleOfTypes(publicDeclarationTypes),\n      includeImportTypes ? tupleTypeOf(imports) : o.NONE_TYPE,\n      tupleTypeOf(exports),\n    ]),\n  );\n}\n\n/**\n * Generates a function call to `ɵɵsetNgModuleScope` with all necessary information so that the\n * transitive module scope can be computed during runtime in JIT mode. This call is marked pure\n * such that the references to declarations, imports and exports may be elided causing these\n * symbols to become tree-shakeable.\n */\nfunction generateSetNgModuleScopeCall(meta: R3NgModuleMetadata): o.Statement | null {\n  const scopeMap = new DefinitionMap<{\n    declarations: o.Expression;\n    imports: o.Expression;\n    exports: o.Expression;\n    bootstrap: o.Expression;\n  }>();\n\n  if (meta.kind === R3NgModuleMetadataKind.Global) {\n    if (meta.declarations.length > 0) {\n      scopeMap.set('declarations', refsToArray(meta.declarations, meta.containsForwardDecls));\n    }\n  } else {\n    if (meta.declarationsExpression) {\n      scopeMap.set('declarations', meta.declarationsExpression);\n    }\n  }\n\n  if (meta.kind === R3NgModuleMetadataKind.Global) {\n    if (meta.imports.length > 0) {\n      scopeMap.set('imports', refsToArray(meta.imports, meta.containsForwardDecls));\n    }\n  } else {\n    if (meta.importsExpression) {\n      scopeMap.set('imports', meta.importsExpression);\n    }\n  }\n\n  if (meta.kind === R3NgModuleMetadataKind.Global) {\n    if (meta.exports.length > 0) {\n      scopeMap.set('exports', refsToArray(meta.exports, meta.containsForwardDecls));\n    }\n  } else {\n    if (meta.exportsExpression) {\n      scopeMap.set('exports', meta.exportsExpression);\n    }\n  }\n\n  if (meta.kind === R3NgModuleMetadataKind.Local && meta.bootstrapExpression) {\n    scopeMap.set('bootstrap', meta.bootstrapExpression);\n  }\n\n  if (Object.keys(scopeMap.values).length === 0) {\n    return null;\n  }\n\n  // setNgModuleScope(...)\n  const fnCall = new o.InvokeFunctionExpr(\n    /* fn */ o.importExpr(R3.setNgModuleScope),\n    /* args */ [meta.type.value, scopeMap.toLiteralMap()],\n  );\n\n  // (ngJitMode guard) && setNgModuleScope(...)\n  const guardedCall = jitOnlyGuardedExpression(fnCall);\n\n  // function() { (ngJitMode guard) && setNgModuleScope(...); }\n  const iife = new o.FunctionExpr(/* params */ [], /* statements */ [guardedCall.toStmt()]);\n\n  // (function() { (ngJitMode guard) && setNgModuleScope(...); })()\n  const iifeCall = new o.InvokeFunctionExpr(/* fn */ iife, /* args */ []);\n\n  return iifeCall.toStmt();\n}\n\nfunction tupleTypeOf(exp: R3Reference[]): o.Type {\n  const types = exp.map((ref) => o.typeofExpr(ref.type));\n  return exp.length > 0 ? o.expressionType(o.literalArr(types)) : o.NONE_TYPE;\n}\n\nfunction tupleOfTypes(types: o.Expression[]): o.Type {\n  const typeofTypes = types.map((type) => o.typeofExpr(type));\n  return types.length > 0 ? o.expressionType(o.literalArr(typeofTypes)) : o.NONE_TYPE;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport * as o from '../output/output_ast';\n\nimport {R3DependencyMetadata} from './r3_factory';\nimport {Identifiers as R3} from './r3_identifiers';\nimport {R3CompiledExpression, R3Reference, typeWithParameters} from './util';\n\nexport interface R3PipeMetadata {\n  /**\n   * Name of the pipe type.\n   */\n  name: string;\n\n  /**\n   * An expression representing a reference to the pipe itself.\n   */\n  type: R3Reference;\n\n  /**\n   * Number of generic type parameters of the type itself.\n   */\n  typeArgumentCount: number;\n\n  /**\n   * Name of the pipe.\n   */\n  pipeName: string | null;\n\n  /**\n   * Dependencies of the pipe's constructor.\n   */\n  deps: R3DependencyMetadata[] | null;\n\n  /**\n   * Whether the pipe is marked as pure.\n   */\n  pure: boolean;\n\n  /**\n   * Whether the pipe is standalone.\n   */\n  isStandalone: boolean;\n}\n\nexport function compilePipeFromMetadata(metadata: R3PipeMetadata): R3CompiledExpression {\n  const definitionMapValues: {key: string; quoted: boolean; value: o.Expression}[] = [];\n\n  // e.g. `name: 'myPipe'`\n  definitionMapValues.push({\n    key: 'name',\n    value: o.literal(metadata.pipeName ?? metadata.name),\n    quoted: false,\n  });\n\n  // e.g. `type: MyPipe`\n  definitionMapValues.push({key: 'type', value: metadata.type.value, quoted: false});\n\n  // e.g. `pure: true`\n  definitionMapValues.push({key: 'pure', value: o.literal(metadata.pure), quoted: false});\n\n  if (metadata.isStandalone === false) {\n    definitionMapValues.push({key: 'standalone', value: o.literal(false), quoted: false});\n  }\n\n  const expression = o\n    .importExpr(R3.definePipe)\n    .callFn([o.literalMap(definitionMapValues)], undefined, true);\n  const type = createPipeType(metadata);\n\n  return {expression, type, statements: []};\n}\n\nexport function createPipeType(metadata: R3PipeMetadata): o.Type {\n  return new o.ExpressionType(\n    o.importExpr(R3.PipeDeclaration, [\n      typeWithParameters(metadata.type.type, metadata.typeArgumentCount),\n      new o.ExpressionType(new o.LiteralExpr(metadata.pipeName)),\n      new o.ExpressionType(new o.LiteralExpr(metadata.isStandalone)),\n    ]),\n  );\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ChangeDetectionStrategy, ViewEncapsulation} from '../../core';\nimport {InterpolationConfig} from '../../ml_parser/defaults';\nimport * as o from '../../output/output_ast';\nimport {ParseSourceSpan} from '../../parse_util';\nimport * as t from '../r3_ast';\nimport {R3DependencyMetadata} from '../r3_factory';\nimport {MaybeForwardRefExpression, R3Reference} from '../util';\n\n/**\n * Information needed to compile a directive for the render3 runtime.\n */\nexport interface R3DirectiveMetadata {\n  /**\n   * Name of the directive type.\n   */\n  name: string;\n\n  /**\n   * An expression representing a reference to the directive itself.\n   */\n  type: R3Reference;\n\n  /**\n   * Number of generic type parameters of the type itself.\n   */\n  typeArgumentCount: number;\n\n  /**\n   * A source span for the directive type.\n   */\n  typeSourceSpan: ParseSourceSpan;\n\n  /**\n   * Dependencies of the directive's constructor.\n   */\n  deps: R3DependencyMetadata[] | 'invalid' | null;\n\n  /**\n   * Unparsed selector of the directive, or `null` if there was no selector.\n   */\n  selector: string | null;\n\n  /**\n   * Information about the content queries made by the directive.\n   */\n  queries: R3QueryMetadata[];\n\n  /**\n   * Information about the view queries made by the directive.\n   */\n  viewQueries: R3QueryMetadata[];\n\n  /**\n   * Mappings indicating how the directive interacts with its host element (host bindings,\n   * listeners, etc).\n   */\n  host: R3HostMetadata;\n\n  /**\n   * Information about usage of specific lifecycle events which require special treatment in the\n   * code generator.\n   */\n  lifecycle: {\n    /**\n     * Whether the directive uses NgOnChanges.\n     */\n    usesOnChanges: boolean;\n  };\n\n  /**\n   * A mapping of inputs from class property names to binding property names, or to a tuple of\n   * binding property name and class property name if the names are different.\n   */\n  inputs: {[field: string]: R3InputMetadata};\n\n  /**\n   * A mapping of outputs from class property names to binding property names, or to a tuple of\n   * binding property name and class property name if the names are different.\n   */\n  outputs: {[field: string]: string};\n\n  /**\n   * Whether or not the component or directive inherits from another class\n   */\n  usesInheritance: boolean;\n\n  /**\n   * Whether or not the component or directive inherits its entire decorator from its base class.\n   */\n  fullInheritance: boolean;\n\n  /**\n   * Reference name under which to export the directive's type in a template,\n   * if any.\n   */\n  exportAs: string[] | null;\n\n  /**\n   * The list of providers defined in the directive.\n   */\n  providers: o.Expression | null;\n\n  /**\n   * Whether or not the component or directive is standalone.\n   */\n  isStandalone: boolean;\n\n  /**\n   * Whether or not the component or directive is signal-based.\n   */\n  isSignal: boolean;\n\n  /**\n   * Additional directives applied to the directive host.\n   */\n  hostDirectives: R3HostDirectiveMetadata[] | null;\n}\n\n/**\n * Defines how dynamic imports for deferred dependencies should be emitted in the\n * generated output:\n *  - either in a function on per-component basis (in case of local compilation)\n *  - or in a function on per-block basis (in full compilation mode)\n */\nexport const enum DeferBlockDepsEmitMode {\n  /**\n   * Dynamic imports are grouped on per-block basis.\n   *\n   * This is used in full compilation mode, when compiler has more information\n   * about particular dependencies that belong to this block.\n   */\n  PerBlock,\n\n  /**\n   * Dynamic imports are grouped on per-component basis.\n   *\n   * In local compilation, compiler doesn't have enough information to determine\n   * which deferred dependencies belong to which block. In this case we group all\n   * dynamic imports into a single file on per-component basis.\n   */\n  PerComponent,\n}\n\n/**\n * Specifies how a list of declaration type references should be emitted into the generated code.\n */\nexport const enum DeclarationListEmitMode {\n  /**\n   * The list of declarations is emitted into the generated code as is.\n   *\n   * ```ts\n   * directives: [MyDir],\n   * ```\n   */\n  Direct,\n\n  /**\n   * The list of declarations is emitted into the generated code wrapped inside a closure, which\n   * is needed when at least one declaration is a forward reference.\n   *\n   * ```ts\n   * directives: function () { return [MyDir, ForwardDir]; },\n   * ```\n   */\n  Closure,\n\n  /**\n   * Similar to `Closure`, with the addition that the list of declarations can contain individual\n   * items that are themselves forward references. This is relevant for JIT compilations, as\n   * unwrapping the forwardRef cannot be done statically so must be deferred. This mode emits\n   * the declaration list using a mapping transform through `resolveForwardRef` to ensure that\n   * any forward references within the list are resolved when the outer closure is invoked.\n   *\n   * Consider the case where the runtime has captured two declarations in two distinct values:\n   * ```ts\n   * const dirA = MyDir;\n   * const dirB = forwardRef(function() { return ForwardRef; });\n   * ```\n   *\n   * This mode would emit the declarations captured in `dirA` and `dirB` as follows:\n   * ```ts\n   * directives: function () { return [dirA, dirB].map(ng.resolveForwardRef); },\n   * ```\n   */\n  ClosureResolved,\n\n  RuntimeResolved,\n}\n\n/**\n * Information needed to compile a component for the render3 runtime.\n */\nexport interface R3ComponentMetadata<DeclarationT extends R3TemplateDependency>\n  extends R3DirectiveMetadata {\n  /**\n   * Information about the component's template.\n   */\n  template: {\n    /**\n     * Parsed nodes of the template.\n     */\n    nodes: t.Node[];\n\n    /**\n     * Any ng-content selectors extracted from the template. Contains `*` when an ng-content\n     * element without selector is present.\n     */\n    ngContentSelectors: string[];\n\n    /**\n     * Whether the template preserves whitespaces from the user's code.\n     */\n    preserveWhitespaces?: boolean;\n  };\n\n  declarations: DeclarationT[];\n\n  /** Metadata related to the deferred blocks in the component's template. */\n  defer: R3ComponentDeferMetadata;\n\n  /**\n   * Specifies how the 'directives' and/or `pipes` array, if generated, need to be emitted.\n   */\n  declarationListEmitMode: DeclarationListEmitMode;\n\n  /**\n   * A collection of styling data that will be applied and scoped to the component.\n   */\n  styles: string[];\n\n  /**\n   * A collection of style paths for external stylesheets that will be applied and scoped to the component.\n   */\n  externalStyles?: string[];\n\n  /**\n   * An encapsulation policy for the component's styling.\n   * Possible values:\n   * - `ViewEncapsulation.Emulated`: Apply modified component styles in order to emulate\n   *                                 a native Shadow DOM CSS encapsulation behavior.\n   * - `ViewEncapsulation.None`: Apply component styles globally without any sort of encapsulation.\n   * - `ViewEncapsulation.ShadowDom`: Use the browser's native Shadow DOM API to encapsulate styles.\n   */\n  encapsulation: ViewEncapsulation;\n\n  /**\n   * A collection of animation triggers that will be used in the component template.\n   */\n  animations: o.Expression | null;\n\n  /**\n   * The list of view providers defined in the component.\n   */\n  viewProviders: o.Expression | null;\n\n  /**\n   * Path to the .ts file in which this template's generated code will be included, relative to\n   * the compilation root. This will be used to generate identifiers that need to be globally\n   * unique in certain contexts (such as g3).\n   */\n  relativeContextFilePath: string;\n\n  /**\n   * Whether translation variable name should contain external message id\n   * (used by Closure Compiler's output of `goog.getMsg` for transition period).\n   */\n  i18nUseExternalIds: boolean;\n\n  /**\n   * Overrides the default interpolation start and end delimiters ({{ and }}).\n   */\n  interpolation: InterpolationConfig;\n\n  /**\n   * Strategy used for detecting changes in the component.\n   *\n   * In global compilation mode the value is ChangeDetectionStrategy if available as it is\n   * statically resolved during analysis phase. Whereas in local compilation mode the value is the\n   * expression as appears in the decorator.\n   */\n  changeDetection: ChangeDetectionStrategy | o.Expression | null;\n\n  /**\n   * Relative path to the component's template from the root of the project.\n   * Used to generate debugging information.\n   */\n  relativeTemplatePath: string | null;\n\n  /**\n   * Whether any of the component's dependencies are directives.\n   */\n  hasDirectiveDependencies: boolean;\n\n  /**\n   * The imports expression as appears on the component decorate for standalone component. This\n   * field is currently needed only for local compilation, and so in other compilation modes it may\n   * not be set. If component has empty array imports then this field is not set.\n   */\n  rawImports?: o.Expression;\n}\n\n/**\n * Information about the deferred blocks in a component's template.\n */\nexport type R3ComponentDeferMetadata =\n  | {\n      mode: DeferBlockDepsEmitMode.PerBlock;\n      blocks: Map<t.DeferredBlock, o.Expression | null>;\n    }\n  | {\n      mode: DeferBlockDepsEmitMode.PerComponent;\n      dependenciesFn: o.Expression | null;\n    };\n\n/**\n * Metadata for an individual input on a directive.\n */\nexport interface R3InputMetadata {\n  classPropertyName: string;\n  bindingPropertyName: string;\n  required: boolean;\n  isSignal: boolean;\n  /**\n   * Transform function for the input.\n   *\n   * Null if there is no transform, or if this is a signal input.\n   * Signal inputs capture their transform as part of the `InputSignal`.\n   */\n  transformFunction: o.Expression | null;\n}\n\nexport enum R3TemplateDependencyKind {\n  Directive = 0,\n  Pipe = 1,\n  NgModule = 2,\n}\n\n/**\n * A dependency that's used within a component template.\n */\nexport interface R3TemplateDependency {\n  kind: R3TemplateDependencyKind;\n\n  /**\n   * The type of the dependency as an expression.\n   */\n  type: o.Expression;\n}\n\n/**\n * A dependency that's used within a component template\n */\nexport type R3TemplateDependencyMetadata =\n  | R3DirectiveDependencyMetadata\n  | R3PipeDependencyMetadata\n  | R3NgModuleDependencyMetadata;\n\n/**\n * Information about a directive that is used in a component template. Only the stable, public\n * facing information of the directive is stored here.\n */\nexport interface R3DirectiveDependencyMetadata extends R3TemplateDependency {\n  kind: R3TemplateDependencyKind.Directive;\n\n  /**\n   * The selector of the directive.\n   */\n  selector: string;\n\n  /**\n   * The binding property names of the inputs of the directive.\n   */\n  inputs: string[];\n\n  /**\n   * The binding property names of the outputs of the directive.\n   */\n  outputs: string[];\n\n  /**\n   * Name under which the directive is exported, if any (exportAs in Angular). Null otherwise.\n   */\n  exportAs: string[] | null;\n\n  /**\n   * If true then this directive is actually a component; otherwise it is not.\n   */\n  isComponent: boolean;\n}\n\nexport interface R3PipeDependencyMetadata extends R3TemplateDependency {\n  kind: R3TemplateDependencyKind.Pipe;\n\n  name: string;\n}\n\nexport interface R3NgModuleDependencyMetadata extends R3TemplateDependency {\n  kind: R3TemplateDependencyKind.NgModule;\n}\n\n/**\n * Information needed to compile a query (view or content).\n */\nexport interface R3QueryMetadata {\n  /**\n   * Name of the property on the class to update with query results.\n   */\n  propertyName: string;\n\n  /**\n   * Whether to read only the first matching result, or an array of results.\n   */\n  first: boolean;\n\n  /**\n   * Either an expression representing a type or `InjectionToken` for the query\n   * predicate, or a set of string selectors.\n   *\n   * Note: At compile time we split selectors as an optimization that avoids this\n   * extra work at runtime creation phase.\n   *\n   * Notably, if the selector is not statically analyzable due to an expression,\n   * the selectors may need to be split up at runtime.\n   */\n  predicate: MaybeForwardRefExpression | string[];\n\n  /**\n   * Whether to include only direct children or all descendants.\n   */\n  descendants: boolean;\n\n  /**\n   * If the `QueryList` should fire change event only if actual change to query was computed (vs old\n   * behavior where the change was fired whenever the query was recomputed, even if the recomputed\n   * query resulted in the same list.)\n   */\n  emitDistinctChangesOnly: boolean;\n\n  /**\n   * An expression representing a type to read from each matched node, or null if the default value\n   * for a given node is to be returned.\n   */\n  read: o.Expression | null;\n\n  /**\n   * Whether or not this query should collect only static results.\n   *\n   * If static is true, the query's results will be set on the component after nodes are created,\n   * but before change detection runs. This means that any results that relied upon change detection\n   * to run (e.g. results inside *ngIf or *ngFor views) will not be collected. Query results are\n   * available in the ngOnInit hook.\n   *\n   * If static is false, the query's results will be set on the component after change detection\n   * runs. This means that the query results can contain nodes inside *ngIf or *ngFor views, but\n   * the results will not be available in the ngOnInit hook (only in the ngAfterContentInit for\n   * content hooks and ngAfterViewInit for view hooks).\n   *\n   * Note: For signal-based queries, this option does not have any effect.\n   */\n  static: boolean;\n\n  /** Whether the query is signal-based. */\n  isSignal: boolean;\n}\n\n/**\n * Mappings indicating how the class interacts with its\n * host element (host bindings, listeners, etc).\n */\nexport interface R3HostMetadata {\n  /**\n   * A mapping of attribute binding keys to `o.Expression`s.\n   */\n  attributes: {[key: string]: o.Expression};\n\n  /**\n   * A mapping of event binding keys to unparsed expressions.\n   */\n  listeners: {[key: string]: string};\n\n  /**\n   * A mapping of property binding keys to unparsed expressions.\n   */\n  properties: {[key: string]: string};\n\n  specialAttributes: {styleAttr?: string; classAttr?: string};\n}\n\n/**\n * Information needed to compile a host directive for the render3 runtime.\n */\nexport interface R3HostDirectiveMetadata {\n  /** An expression representing the host directive class itself. */\n  directive: R3Reference;\n\n  /** Whether the expression referring to the host directive is a forward reference. */\n  isForwardReference: boolean;\n\n  /** Inputs from the host directive that will be exposed on the host. */\n  inputs: {[publicName: string]: string} | null;\n\n  /** Outputs from the host directive that will be exposed on the host. */\n  outputs: {[publicName: string]: string} | null;\n}\n\n/**\n * Information needed to compile the defer block resolver function.\n */\nexport type R3DeferResolverFunctionMetadata =\n  | {\n      mode: DeferBlockDepsEmitMode.PerBlock;\n      dependencies: R3DeferPerBlockDependency[];\n    }\n  | {\n      mode: DeferBlockDepsEmitMode.PerComponent;\n      dependencies: R3DeferPerComponentDependency[];\n    };\n\n/**\n * Information about a single dependency of a defer block in `PerBlock` mode.\n */\nexport interface R3DeferPerBlockDependency {\n  /**\n   * Reference to a dependency.\n   */\n  typeReference: o.Expression;\n\n  /**\n   * Dependency class name.\n   */\n  symbolName: string;\n\n  /**\n   * Whether this dependency can be defer-loaded.\n   */\n  isDeferrable: boolean;\n\n  /**\n   * Import path where this dependency is located.\n   */\n  importPath: string | null;\n\n  /**\n   * Whether the symbol is the default export.\n   */\n  isDefaultImport: boolean;\n}\n\n/**\n * Information about a single dependency of a defer block in `PerComponent` mode.\n */\nexport interface R3DeferPerComponentDependency {\n  /**\n   * Dependency class name.\n   */\n  symbolName: string;\n\n  /**\n   * Import path where this dependency is located.\n   */\n  importPath: string;\n\n  /**\n   * Whether the symbol is the default export.\n   */\n  isDefaultImport: boolean;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/**\n * The following set contains all keywords that can be used in the animation css shorthand\n * property and is used during the scoping of keyframes to make sure such keywords\n * are not modified.\n */\nconst animationKeywords = new Set([\n  // global values\n  'inherit',\n  'initial',\n  'revert',\n  'unset',\n  // animation-direction\n  'alternate',\n  'alternate-reverse',\n  'normal',\n  'reverse',\n  // animation-fill-mode\n  'backwards',\n  'both',\n  'forwards',\n  'none',\n  // animation-play-state\n  'paused',\n  'running',\n  // animation-timing-function\n  'ease',\n  'ease-in',\n  'ease-in-out',\n  'ease-out',\n  'linear',\n  'step-start',\n  'step-end',\n  // `steps()` function\n  'end',\n  'jump-both',\n  'jump-end',\n  'jump-none',\n  'jump-start',\n  'start',\n]);\n\n/**\n * The following array contains all of the CSS at-rule identifiers which are scoped.\n */\nconst scopedAtRuleIdentifiers = [\n  '@media',\n  '@supports',\n  '@document',\n  '@layer',\n  '@container',\n  '@scope',\n  '@starting-style',\n];\n\n/**\n * The following class has its origin from a port of shadowCSS from webcomponents.js to TypeScript.\n * It has since diverge in many ways to tailor Angular's needs.\n *\n * Source:\n * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js\n *\n * The original file level comment is reproduced below\n */\n\n/*\n  This is a limited shim for ShadowDOM css styling.\n  https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#styles\n\n  The intention here is to support only the styling features which can be\n  relatively simply implemented. The goal is to allow users to avoid the\n  most obvious pitfalls and do so without compromising performance significantly.\n  For ShadowDOM styling that's not covered here, a set of best practices\n  can be provided that should allow users to accomplish more complex styling.\n\n  The following is a list of specific ShadowDOM styling features and a brief\n  discussion of the approach used to shim.\n\n  Shimmed features:\n\n  * :host, :host-context: ShadowDOM allows styling of the shadowRoot's host\n  element using the :host rule. To shim this feature, the :host styles are\n  reformatted and prefixed with a given scope name and promoted to a\n  document level stylesheet.\n  For example, given a scope name of .foo, a rule like this:\n\n    :host {\n        background: red;\n      }\n    }\n\n  becomes:\n\n    .foo {\n      background: red;\n    }\n\n  * encapsulation: Styles defined within ShadowDOM, apply only to\n  dom inside the ShadowDOM.\n  The selectors are scoped by adding an attribute selector suffix to each\n  simple selector that contains the host element tag name. Each element\n  in the element's ShadowDOM template is also given the scope attribute.\n  Thus, these rules match only elements that have the scope attribute.\n  For example, given a scope name of x-foo, a rule like this:\n\n    div {\n      font-weight: bold;\n    }\n\n  becomes:\n\n    div[x-foo] {\n      font-weight: bold;\n    }\n\n  Note that elements that are dynamically added to a scope must have the scope\n  selector added to them manually.\n\n  * upper/lower bound encapsulation: Styles which are defined outside a\n  shadowRoot should not cross the ShadowDOM boundary and should not apply\n  inside a shadowRoot.\n\n  This styling behavior is not emulated. Some possible ways to do this that\n  were rejected due to complexity and/or performance concerns include: (1) reset\n  every possible property for every possible selector for a given scope name;\n  (2) re-implement css in javascript.\n\n  As an alternative, users should make sure to use selectors\n  specific to the scope in which they are working.\n\n  * ::distributed: This behavior is not emulated. It's often not necessary\n  to style the contents of a specific insertion point and instead, descendants\n  of the host element can be styled selectively. Users can also create an\n  extra node around an insertion point and style that node's contents\n  via descendent selectors. For example, with a shadowRoot like this:\n\n    <style>\n      ::content(div) {\n        background: red;\n      }\n    </style>\n    <content></content>\n\n  could become:\n\n    <style>\n      / *@polyfill .content-container div * /\n      ::content(div) {\n        background: red;\n      }\n    </style>\n    <div class=\"content-container\">\n      <content></content>\n    </div>\n\n  Note the use of @polyfill in the comment above a ShadowDOM specific style\n  declaration. This is a directive to the styling shim to use the selector\n  in comments in lieu of the next selector when running under polyfill.\n*/\nexport class ShadowCss {\n  /*\n   * Shim some cssText with the given selector. Returns cssText that can be included in the document\n   *\n   * The selector is the attribute added to all elements inside the host,\n   * The hostSelector is the attribute added to the host itself.\n   */\n  shimCssText(cssText: string, selector: string, hostSelector: string = ''): string {\n    // **NOTE**: Do not strip comments as this will cause component sourcemaps to break\n    // due to shift in lines.\n\n    // Collect comments and replace them with a placeholder, this is done to avoid complicating\n    // the rule parsing RegExp and keep it safer.\n    const comments: string[] = [];\n    cssText = cssText.replace(_commentRe, (m) => {\n      if (m.match(_commentWithHashRe)) {\n        comments.push(m);\n      } else {\n        // Replace non hash comments with empty lines.\n        // This is done so that we do not leak any sensitive data in comments.\n        const newLinesMatches = m.match(_newLinesRe);\n        comments.push((newLinesMatches?.join('') ?? '') + '\\n');\n      }\n\n      return COMMENT_PLACEHOLDER;\n    });\n\n    cssText = this._insertDirectives(cssText);\n    const scopedCssText = this._scopeCssText(cssText, selector, hostSelector);\n    // Add back comments at the original position.\n    let commentIdx = 0;\n    return scopedCssText.replace(_commentWithHashPlaceHolderRe, () => comments[commentIdx++]);\n  }\n\n  private _insertDirectives(cssText: string): string {\n    cssText = this._insertPolyfillDirectivesInCssText(cssText);\n    return this._insertPolyfillRulesInCssText(cssText);\n  }\n\n  /**\n   * Process styles to add scope to keyframes.\n   *\n   * Modify both the names of the keyframes defined in the component styles and also the css\n   * animation rules using them.\n   *\n   * Animation rules using keyframes defined elsewhere are not modified to allow for globally\n   * defined keyframes.\n   *\n   * For example, we convert this css:\n   *\n   * ```scss\n   * .box {\n   *   animation: box-animation 1s forwards;\n   * }\n   *\n   * @keyframes box-animation {\n   *   to {\n   *     background-color: green;\n   *   }\n   * }\n   * ```\n   *\n   * to this:\n   *\n   * ```scss\n   * .box {\n   *   animation: scopeName_box-animation 1s forwards;\n   * }\n   *\n   * @keyframes scopeName_box-animation {\n   *   to {\n   *     background-color: green;\n   *   }\n   * }\n   * ```\n   *\n   * @param cssText the component's css text that needs to be scoped.\n   * @param scopeSelector the component's scope selector.\n   *\n   * @returns the scoped css text.\n   */\n  private _scopeKeyframesRelatedCss(cssText: string, scopeSelector: string): string {\n    const unscopedKeyframesSet = new Set<string>();\n    const scopedKeyframesCssText = processRules(cssText, (rule) =>\n      this._scopeLocalKeyframeDeclarations(rule, scopeSelector, unscopedKeyframesSet),\n    );\n    return processRules(scopedKeyframesCssText, (rule) =>\n      this._scopeAnimationRule(rule, scopeSelector, unscopedKeyframesSet),\n    );\n  }\n\n  /**\n   * Scopes local keyframes names, returning the updated css rule and it also\n   * adds the original keyframe name to a provided set to collect all keyframes names\n   * so that it can later be used to scope the animation rules.\n   *\n   * For example, it takes a rule such as:\n   *\n   * ```scss\n   * @keyframes box-animation {\n   *   to {\n   *     background-color: green;\n   *   }\n   * }\n   * ```\n   *\n   * and returns:\n   *\n   * ```scss\n   * @keyframes scopeName_box-animation {\n   *   to {\n   *     background-color: green;\n   *   }\n   * }\n   * ```\n   * and as a side effect it adds \"box-animation\" to the `unscopedKeyframesSet` set\n   *\n   * @param cssRule the css rule to process.\n   * @param scopeSelector the component's scope selector.\n   * @param unscopedKeyframesSet the set of unscoped keyframes names (which can be\n   * modified as a side effect)\n   *\n   * @returns the css rule modified with the scoped keyframes name.\n   */\n  private _scopeLocalKeyframeDeclarations(\n    rule: CssRule,\n    scopeSelector: string,\n    unscopedKeyframesSet: Set<string>,\n  ): CssRule {\n    return {\n      ...rule,\n      selector: rule.selector.replace(\n        /(^@(?:-webkit-)?keyframes(?:\\s+))(['\"]?)(.+)\\2(\\s*)$/,\n        (_, start, quote, keyframeName, endSpaces) => {\n          unscopedKeyframesSet.add(unescapeQuotes(keyframeName, quote));\n          return `${start}${quote}${scopeSelector}_${keyframeName}${quote}${endSpaces}`;\n        },\n      ),\n    };\n  }\n\n  /**\n   * Function used to scope a keyframes name (obtained from an animation declaration)\n   * using an existing set of unscopedKeyframes names to discern if the scoping needs to be\n   * performed (keyframes names of keyframes not defined in the component's css need not to be\n   * scoped).\n   *\n   * @param keyframe the keyframes name to check.\n   * @param scopeSelector the component's scope selector.\n   * @param unscopedKeyframesSet the set of unscoped keyframes names.\n   *\n   * @returns the scoped name of the keyframe, or the original name is the name need not to be\n   * scoped.\n   */\n  private _scopeAnimationKeyframe(\n    keyframe: string,\n    scopeSelector: string,\n    unscopedKeyframesSet: ReadonlySet<string>,\n  ): string {\n    return keyframe.replace(/^(\\s*)(['\"]?)(.+?)\\2(\\s*)$/, (_, spaces1, quote, name, spaces2) => {\n      name = `${\n        unscopedKeyframesSet.has(unescapeQuotes(name, quote)) ? scopeSelector + '_' : ''\n      }${name}`;\n      return `${spaces1}${quote}${name}${quote}${spaces2}`;\n    });\n  }\n\n  /**\n   * Regular expression used to extrapolate the possible keyframes from an\n   * animation declaration (with possibly multiple animation definitions)\n   *\n   * The regular expression can be divided in three parts\n   *  - (^|\\s+|,)\n   *    captures how many (if any) leading whitespaces are present or a comma\n   *  - (?:(?:(['\"])((?:\\\\\\\\|\\\\\\2|(?!\\2).)+)\\2)|(-?[A-Za-z][\\w\\-]*))\n   *    captures two different possible keyframes, ones which are quoted or ones which are valid css\n   * indents (custom properties excluded)\n   *  - (?=[,\\s;]|$)\n   *    simply matches the end of the possible keyframe, valid endings are: a comma, a space, a\n   * semicolon or the end of the string\n   */\n  private _animationDeclarationKeyframesRe =\n    /(^|\\s+|,)(?:(?:(['\"])((?:\\\\\\\\|\\\\\\2|(?!\\2).)+)\\2)|(-?[A-Za-z][\\w\\-]*))(?=[,\\s]|$)/g;\n\n  /**\n   * Scope an animation rule so that the keyframes mentioned in such rule\n   * are scoped if defined in the component's css and left untouched otherwise.\n   *\n   * It can scope values of both the 'animation' and 'animation-name' properties.\n   *\n   * @param rule css rule to scope.\n   * @param scopeSelector the component's scope selector.\n   * @param unscopedKeyframesSet the set of unscoped keyframes names.\n   *\n   * @returns the updated css rule.\n   **/\n  private _scopeAnimationRule(\n    rule: CssRule,\n    scopeSelector: string,\n    unscopedKeyframesSet: ReadonlySet<string>,\n  ): CssRule {\n    let content = rule.content.replace(\n      /((?:^|\\s+|;)(?:-webkit-)?animation\\s*:\\s*),*([^;]+)/g,\n      (_, start, animationDeclarations) =>\n        start +\n        animationDeclarations.replace(\n          this._animationDeclarationKeyframesRe,\n          (\n            original: string,\n            leadingSpaces: string,\n            quote = '',\n            quotedName: string,\n            nonQuotedName: string,\n          ) => {\n            if (quotedName) {\n              return `${leadingSpaces}${this._scopeAnimationKeyframe(\n                `${quote}${quotedName}${quote}`,\n                scopeSelector,\n                unscopedKeyframesSet,\n              )}`;\n            } else {\n              return animationKeywords.has(nonQuotedName)\n                ? original\n                : `${leadingSpaces}${this._scopeAnimationKeyframe(\n                    nonQuotedName,\n                    scopeSelector,\n                    unscopedKeyframesSet,\n                  )}`;\n            }\n          },\n        ),\n    );\n    content = content.replace(\n      /((?:^|\\s+|;)(?:-webkit-)?animation-name(?:\\s*):(?:\\s*))([^;]+)/g,\n      (_match, start, commaSeparatedKeyframes) =>\n        `${start}${commaSeparatedKeyframes\n          .split(',')\n          .map((keyframe: string) =>\n            this._scopeAnimationKeyframe(keyframe, scopeSelector, unscopedKeyframesSet),\n          )\n          .join(',')}`,\n    );\n    return {...rule, content};\n  }\n\n  /*\n   * Process styles to convert native ShadowDOM rules that will trip\n   * up the css parser; we rely on decorating the stylesheet with inert rules.\n   *\n   * For example, we convert this rule:\n   *\n   * polyfill-next-selector { content: ':host menu-item'; }\n   * ::content menu-item {\n   *\n   * to this:\n   *\n   * scopeName menu-item {\n   *\n   **/\n  private _insertPolyfillDirectivesInCssText(cssText: string): string {\n    return cssText.replace(_cssContentNextSelectorRe, function (...m: string[]) {\n      return m[2] + '{';\n    });\n  }\n\n  /*\n   * Process styles to add rules which will only apply under the polyfill\n   *\n   * For example, we convert this rule:\n   *\n   * polyfill-rule {\n   *   content: ':host menu-item';\n   * ...\n   * }\n   *\n   * to this:\n   *\n   * scopeName menu-item {...}\n   *\n   **/\n  private _insertPolyfillRulesInCssText(cssText: string): string {\n    return cssText.replace(_cssContentRuleRe, (...m: string[]) => {\n      const rule = m[0].replace(m[1], '').replace(m[2], '');\n      return m[4] + rule;\n    });\n  }\n\n  /* Ensure styles are scoped. Pseudo-scoping takes a rule like:\n   *\n   *  .foo {... }\n   *\n   *  and converts this to\n   *\n   *  scopeName .foo { ... }\n   */\n  private _scopeCssText(cssText: string, scopeSelector: string, hostSelector: string): string {\n    const unscopedRules = this._extractUnscopedRulesFromCssText(cssText);\n    // replace :host and :host-context with -shadowcsshost and -shadowcsshostcontext respectively\n    cssText = this._insertPolyfillHostInCssText(cssText);\n    cssText = this._convertColonHost(cssText);\n    cssText = this._convertColonHostContext(cssText);\n    cssText = this._convertShadowDOMSelectors(cssText);\n    if (scopeSelector) {\n      cssText = this._scopeKeyframesRelatedCss(cssText, scopeSelector);\n      cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);\n    }\n    cssText = cssText + '\\n' + unscopedRules;\n    return cssText.trim();\n  }\n\n  /*\n   * Process styles to add rules which will only apply under the polyfill\n   * and do not process via CSSOM. (CSSOM is destructive to rules on rare\n   * occasions, e.g. -webkit-calc on Safari.)\n   * For example, we convert this rule:\n   *\n   * @polyfill-unscoped-rule {\n   *   content: 'menu-item';\n   * ... }\n   *\n   * to this:\n   *\n   * menu-item {...}\n   *\n   **/\n  private _extractUnscopedRulesFromCssText(cssText: string): string {\n    let r = '';\n    let m: RegExpExecArray | null;\n    _cssContentUnscopedRuleRe.lastIndex = 0;\n    while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {\n      const rule = m[0].replace(m[2], '').replace(m[1], m[4]);\n      r += rule + '\\n\\n';\n    }\n    return r;\n  }\n\n  /*\n   * convert a rule like :host(.foo) > .bar { }\n   *\n   * to\n   *\n   * .foo<scopeName> > .bar\n   */\n  private _convertColonHost(cssText: string): string {\n    return cssText.replace(_cssColonHostRe, (_, hostSelectors: string, otherSelectors: string) => {\n      if (hostSelectors) {\n        const convertedSelectors: string[] = [];\n        const hostSelectorArray = hostSelectors.split(',').map((p) => p.trim());\n        for (const hostSelector of hostSelectorArray) {\n          if (!hostSelector) break;\n          const convertedSelector =\n            _polyfillHostNoCombinator + hostSelector.replace(_polyfillHost, '') + otherSelectors;\n          convertedSelectors.push(convertedSelector);\n        }\n        return convertedSelectors.join(',');\n      } else {\n        return _polyfillHostNoCombinator + otherSelectors;\n      }\n    });\n  }\n\n  /*\n   * convert a rule like :host-context(.foo) > .bar { }\n   *\n   * to\n   *\n   * .foo<scopeName> > .bar, .foo <scopeName> > .bar { }\n   *\n   * and\n   *\n   * :host-context(.foo:host) .bar { ... }\n   *\n   * to\n   *\n   * .foo<scopeName> .bar { ... }\n   */\n  private _convertColonHostContext(cssText: string): string {\n    const length = cssText.length;\n    let parens = 0;\n    let prev = 0;\n    let result = '';\n\n    // Splits up the selectors on their top-level commas, processes the :host-context in them\n    // individually and stitches them back together. This ensures that individual selectors don't\n    // affect each other.\n    for (let i = 0; i < length; i++) {\n      const char = cssText[i];\n\n      // If we hit a comma and there are no open parentheses, take the current chunk and process it.\n      if (char === ',' && parens === 0) {\n        result += this._convertColonHostContextInSelectorPart(cssText.slice(prev, i)) + ',';\n        prev = i + 1;\n        continue;\n      }\n\n      // We've hit the end. Take everything since the last comma.\n      if (i === length - 1) {\n        result += this._convertColonHostContextInSelectorPart(cssText.slice(prev));\n        break;\n      }\n\n      if (char === '(') {\n        parens++;\n      } else if (char === ')') {\n        parens--;\n      }\n    }\n\n    return result;\n  }\n\n  private _convertColonHostContextInSelectorPart(cssText: string): string {\n    return cssText.replace(_cssColonHostContextReGlobal, (selectorText, pseudoPrefix) => {\n      // We have captured a selector that contains a `:host-context` rule.\n\n      // For backward compatibility `:host-context` may contain a comma separated list of selectors.\n      // Each context selector group will contain a list of host-context selectors that must match\n      // an ancestor of the host.\n      // (Normally `contextSelectorGroups` will only contain a single array of context selectors.)\n      const contextSelectorGroups: string[][] = [[]];\n\n      // There may be more than `:host-context` in this selector so `selectorText` could look like:\n      // `:host-context(.one):host-context(.two)`.\n      // Execute `_cssColonHostContextRe` over and over until we have extracted all the\n      // `:host-context` selectors from this selector.\n      let match: RegExpExecArray | null;\n      while ((match = _cssColonHostContextRe.exec(selectorText))) {\n        // `match` = [':host-context(<selectors>)<rest>', <selectors>, <rest>]\n\n        // The `<selectors>` could actually be a comma separated list: `:host-context(.one, .two)`.\n        const newContextSelectors = (match[1] ?? '')\n          .trim()\n          .split(',')\n          .map((m) => m.trim())\n          .filter((m) => m !== '');\n\n        // We must duplicate the current selector group for each of these new selectors.\n        // For example if the current groups are:\n        // ```\n        // [\n        //   ['a', 'b', 'c'],\n        //   ['x', 'y', 'z'],\n        // ]\n        // ```\n        // And we have a new set of comma separated selectors: `:host-context(m,n)` then the new\n        // groups are:\n        // ```\n        // [\n        //   ['a', 'b', 'c', 'm'],\n        //   ['x', 'y', 'z', 'm'],\n        //   ['a', 'b', 'c', 'n'],\n        //   ['x', 'y', 'z', 'n'],\n        // ]\n        // ```\n        const contextSelectorGroupsLength = contextSelectorGroups.length;\n        repeatGroups(contextSelectorGroups, newContextSelectors.length);\n        for (let i = 0; i < newContextSelectors.length; i++) {\n          for (let j = 0; j < contextSelectorGroupsLength; j++) {\n            contextSelectorGroups[j + i * contextSelectorGroupsLength].push(newContextSelectors[i]);\n          }\n        }\n\n        // Update the `selectorText` and see repeat to see if there are more `:host-context`s.\n        selectorText = match[2];\n      }\n\n      // The context selectors now must be combined with each other to capture all the possible\n      // selectors that `:host-context` can match. See `_combineHostContextSelectors()` for more\n      // info about how this is done.\n      return contextSelectorGroups\n        .map((contextSelectors) =>\n          _combineHostContextSelectors(contextSelectors, selectorText, pseudoPrefix),\n        )\n        .join(', ');\n    });\n  }\n\n  /*\n   * Convert combinators like ::shadow and pseudo-elements like ::content\n   * by replacing with space.\n   */\n  private _convertShadowDOMSelectors(cssText: string): string {\n    return _shadowDOMSelectorsRe.reduce((result, pattern) => result.replace(pattern, ' '), cssText);\n  }\n\n  // change a selector like 'div' to 'name div'\n  private _scopeSelectors(cssText: string, scopeSelector: string, hostSelector: string): string {\n    return processRules(cssText, (rule: CssRule) => {\n      let selector = rule.selector;\n      let content = rule.content;\n      if (rule.selector[0] !== '@') {\n        selector = this._scopeSelector({\n          selector,\n          scopeSelector,\n          hostSelector,\n          isParentSelector: true,\n        });\n      } else if (scopedAtRuleIdentifiers.some((atRule) => rule.selector.startsWith(atRule))) {\n        content = this._scopeSelectors(rule.content, scopeSelector, hostSelector);\n      } else if (rule.selector.startsWith('@font-face') || rule.selector.startsWith('@page')) {\n        content = this._stripScopingSelectors(rule.content);\n      }\n      return new CssRule(selector, content);\n    });\n  }\n\n  /**\n   * Handle a css text that is within a rule that should not contain scope selectors by simply\n   * removing them! An example of such a rule is `@font-face`.\n   *\n   * `@font-face` rules cannot contain nested selectors. Nor can they be nested under a selector.\n   * Normally this would be a syntax error by the author of the styles. But in some rare cases, such\n   * as importing styles from a library, and applying `:host ::ng-deep` to the imported styles, we\n   * can end up with broken css if the imported styles happen to contain @font-face rules.\n   *\n   * For example:\n   *\n   * ```\n   * :host ::ng-deep {\n   *   import 'some/lib/containing/font-face';\n   * }\n   *\n   * Similar logic applies to `@page` rules which can contain a particular set of properties,\n   * as well as some specific at-rules. Since they can't be encapsulated, we have to strip\n   * any scoping selectors from them. For more information: https://www.w3.org/TR/css-page-3\n   * ```\n   */\n  private _stripScopingSelectors(cssText: string): string {\n    return processRules(cssText, (rule) => {\n      const selector = rule.selector\n        .replace(_shadowDeepSelectors, ' ')\n        .replace(_polyfillHostNoCombinatorRe, ' ');\n      return new CssRule(selector, rule.content);\n    });\n  }\n\n  private _safeSelector: SafeSelector | undefined;\n  private _shouldScopeIndicator: boolean | undefined;\n\n  // `isParentSelector` is used to distinguish the selectors which are coming from\n  // the initial selector string and any nested selectors, parsed recursively,\n  // for example `selector = 'a:where(.one)'` could be the parent, while recursive call\n  // would have `selector = '.one'`.\n  private _scopeSelector({\n    selector,\n    scopeSelector,\n    hostSelector,\n    isParentSelector = false,\n  }: {\n    selector: string;\n    scopeSelector: string;\n    hostSelector: string;\n    isParentSelector?: boolean;\n  }): string {\n    // Split the selector into independent parts by `,` (comma) unless\n    // comma is within parenthesis, for example `:is(.one, two)`.\n    // Negative lookup after comma allows not splitting inside nested parenthesis,\n    // up to three levels (((,))).\n    const selectorSplitRe =\n      / ?,(?!(?:[^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\))) ?/;\n\n    return selector\n      .split(selectorSplitRe)\n      .map((part) => part.split(_shadowDeepSelectors))\n      .map((deepParts) => {\n        const [shallowPart, ...otherParts] = deepParts;\n        const applyScope = (shallowPart: string) => {\n          if (this._selectorNeedsScoping(shallowPart, scopeSelector)) {\n            return this._applySelectorScope({\n              selector: shallowPart,\n              scopeSelector,\n              hostSelector,\n              isParentSelector,\n            });\n          } else {\n            return shallowPart;\n          }\n        };\n        return [applyScope(shallowPart), ...otherParts].join(' ');\n      })\n      .join(', ');\n  }\n\n  private _selectorNeedsScoping(selector: string, scopeSelector: string): boolean {\n    const re = this._makeScopeMatcher(scopeSelector);\n    return !re.test(selector);\n  }\n\n  private _makeScopeMatcher(scopeSelector: string): RegExp {\n    const lre = /\\[/g;\n    const rre = /\\]/g;\n    scopeSelector = scopeSelector.replace(lre, '\\\\[').replace(rre, '\\\\]');\n    return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');\n  }\n\n  // scope via name and [is=name]\n  private _applySimpleSelectorScope(\n    selector: string,\n    scopeSelector: string,\n    hostSelector: string,\n  ): string {\n    // In Android browser, the lastIndex is not reset when the regex is used in String.replace()\n    _polyfillHostRe.lastIndex = 0;\n    if (_polyfillHostRe.test(selector)) {\n      const replaceBy = `[${hostSelector}]`;\n      let result = selector;\n      while (result.match(_polyfillHostNoCombinatorRe)) {\n        result = result.replace(_polyfillHostNoCombinatorRe, (_hnc, selector) => {\n          return selector.replace(\n            /([^:\\)]*)(:*)(.*)/,\n            (_: string, before: string, colon: string, after: string) => {\n              return before + replaceBy + colon + after;\n            },\n          );\n        });\n      }\n      return result.replace(_polyfillHostRe, replaceBy);\n    }\n\n    return scopeSelector + ' ' + selector;\n  }\n\n  // return a selector with [name] suffix on each simple selector\n  // e.g. .foo.bar > .zot becomes .foo[name].bar[name] > .zot[name]  /** @internal */\n  private _applySelectorScope({\n    selector,\n    scopeSelector,\n    hostSelector,\n    isParentSelector,\n  }: {\n    selector: string;\n    scopeSelector: string;\n    hostSelector: string;\n    isParentSelector?: boolean;\n  }): string {\n    const isRe = /\\[is=([^\\]]*)\\]/g;\n    scopeSelector = scopeSelector.replace(isRe, (_: string, ...parts: string[]) => parts[0]);\n\n    const attrName = `[${scopeSelector}]`;\n\n    const _scopeSelectorPart = (p: string) => {\n      let scopedP = p.trim();\n\n      if (!scopedP) {\n        return p;\n      }\n\n      if (p.includes(_polyfillHostNoCombinator)) {\n        scopedP = this._applySimpleSelectorScope(p, scopeSelector, hostSelector);\n        if (!p.match(_polyfillHostNoCombinatorOutsidePseudoFunction)) {\n          const [_, before, colon, after] = scopedP.match(/([^:]*)(:*)([\\s\\S]*)/)!;\n          scopedP = before + attrName + colon + after;\n        }\n      } else {\n        // remove :host since it should be unnecessary\n        const t = p.replace(_polyfillHostRe, '');\n        if (t.length > 0) {\n          const matches = t.match(/([^:]*)(:*)([\\s\\S]*)/);\n          if (matches) {\n            scopedP = matches[1] + attrName + matches[2] + matches[3];\n          }\n        }\n      }\n\n      return scopedP;\n    };\n\n    // Wraps `_scopeSelectorPart()` to not use it directly on selectors with\n    // pseudo selector functions like `:where()`. Selectors within pseudo selector\n    // functions are recursively sent to `_scopeSelector()`.\n    const _pseudoFunctionAwareScopeSelectorPart = (selectorPart: string) => {\n      let scopedPart = '';\n\n      // Collect all outer `:where()` and `:is()` selectors,\n      // counting parenthesis to keep nested selectors intact.\n      const pseudoSelectorParts = [];\n      let pseudoSelectorMatch: RegExpExecArray | null;\n      while (\n        (pseudoSelectorMatch = _cssPrefixWithPseudoSelectorFunction.exec(selectorPart)) !== null\n      ) {\n        let openedBrackets = 1;\n        let index = _cssPrefixWithPseudoSelectorFunction.lastIndex;\n\n        while (index < selectorPart.length) {\n          const currentSymbol = selectorPart[index];\n          index++;\n          if (currentSymbol === '(') {\n            openedBrackets++;\n            continue;\n          }\n          if (currentSymbol === ')') {\n            openedBrackets--;\n            if (openedBrackets === 0) {\n              break;\n            }\n            continue;\n          }\n        }\n\n        pseudoSelectorParts.push(\n          `${pseudoSelectorMatch[0]}${selectorPart.slice(_cssPrefixWithPseudoSelectorFunction.lastIndex, index)}`,\n        );\n        _cssPrefixWithPseudoSelectorFunction.lastIndex = index;\n      }\n\n      // If selector consists of only `:where()` and `:is()` on the outer level\n      // scope those pseudo-selectors individually, otherwise scope the whole\n      // selector.\n      if (pseudoSelectorParts.join('') === selectorPart) {\n        scopedPart = pseudoSelectorParts\n          .map((selectorPart) => {\n            const [cssPseudoSelectorFunction] =\n              selectorPart.match(_cssPrefixWithPseudoSelectorFunction) ?? [];\n\n            // Unwrap the pseudo selector to scope its contents.\n            // For example,\n            // - `:where(selectorToScope)` -> `selectorToScope`;\n            // - `:is(.foo, .bar)` -> `.foo, .bar`.\n            const selectorToScope = selectorPart.slice(cssPseudoSelectorFunction?.length, -1);\n\n            if (selectorToScope.includes(_polyfillHostNoCombinator)) {\n              this._shouldScopeIndicator = true;\n            }\n\n            const scopedInnerPart = this._scopeSelector({\n              selector: selectorToScope,\n              scopeSelector,\n              hostSelector,\n            });\n\n            // Put the result back into the pseudo selector function.\n            return `${cssPseudoSelectorFunction}${scopedInnerPart})`;\n          })\n          .join('');\n      } else {\n        this._shouldScopeIndicator =\n          this._shouldScopeIndicator || selectorPart.includes(_polyfillHostNoCombinator);\n        scopedPart = this._shouldScopeIndicator ? _scopeSelectorPart(selectorPart) : selectorPart;\n      }\n\n      return scopedPart;\n    };\n\n    if (isParentSelector) {\n      this._safeSelector = new SafeSelector(selector);\n      selector = this._safeSelector.content();\n    }\n\n    let scopedSelector = '';\n    let startIndex = 0;\n    let res: RegExpExecArray | null;\n    // Combinators aren't used as a delimiter if they are within parenthesis,\n    // for example `:where(.one .two)` stays intact.\n    // Similarly to selector separation by comma initially, negative lookahead\n    // is used here to not break selectors within nested parenthesis up to three\n    // nested layers.\n    const sep =\n      /( |>|\\+|~(?!=))(?!([^)(]*(?:\\([^)(]*(?:\\([^)(]*(?:\\([^)(]*\\)[^)(]*)*\\)[^)(]*)*\\)[^)(]*)*\\)))\\s*/g;\n\n    // If a selector appears before :host it should not be shimmed as it\n    // matches on ancestor elements and not on elements in the host's shadow\n    // `:host-context(div)` is transformed to\n    // `-shadowcsshost-no-combinatordiv, div -shadowcsshost-no-combinator`\n    // the `div` is not part of the component in the 2nd selectors and should not be scoped.\n    // Historically `component-tag:host` was matching the component so we also want to preserve\n    // this behavior to avoid breaking legacy apps (it should not match).\n    // The behavior should be:\n    // - `tag:host` -> `tag[h]` (this is to avoid breaking legacy apps, should not match anything)\n    // - `tag :host` -> `tag [h]` (`tag` is not scoped because it's considered part of a\n    //   `:host-context(tag)`)\n    const hasHost = selector.includes(_polyfillHostNoCombinator);\n    // Only scope parts after or on the same level as the first `-shadowcsshost-no-combinator`\n    // when it is present. The selector has the same level when it is a part of a pseudo\n    // selector, like `:where()`, for example `:where(:host, .foo)` would result in `.foo`\n    // being scoped.\n    if (isParentSelector || this._shouldScopeIndicator) {\n      this._shouldScopeIndicator = !hasHost;\n    }\n\n    while ((res = sep.exec(selector)) !== null) {\n      const separator = res[1];\n      // Do not trim the selector, as otherwise this will break sourcemaps\n      // when they are defined on multiple lines\n      // Example:\n      //  div,\n      //  p { color: red}\n      const part = selector.slice(startIndex, res.index);\n\n      // A space following an escaped hex value and followed by another hex character\n      // (ie: \".\\fc ber\" for \".über\") is not a separator between 2 selectors\n      // also keep in mind that backslashes are replaced by a placeholder by SafeSelector\n      // These escaped selectors happen for example when esbuild runs with optimization.minify.\n      if (part.match(/__esc-ph-(\\d+)__/) && selector[res.index + 1]?.match(/[a-fA-F\\d]/)) {\n        continue;\n      }\n\n      const scopedPart = _pseudoFunctionAwareScopeSelectorPart(part);\n      scopedSelector += `${scopedPart} ${separator} `;\n      startIndex = sep.lastIndex;\n    }\n\n    const part = selector.substring(startIndex);\n    scopedSelector += _pseudoFunctionAwareScopeSelectorPart(part);\n\n    // replace the placeholders with their original values\n    // using values stored inside the `safeSelector` instance.\n    return this._safeSelector!.restore(scopedSelector);\n  }\n\n  private _insertPolyfillHostInCssText(selector: string): string {\n    return selector\n      .replace(_colonHostContextRe, _polyfillHostContext)\n      .replace(_colonHostRe, _polyfillHost);\n  }\n}\n\nclass SafeSelector {\n  private placeholders: string[] = [];\n  private index = 0;\n  private _content: string;\n\n  constructor(selector: string) {\n    // Replaces attribute selectors with placeholders.\n    // The WS in [attr=\"va lue\"] would otherwise be interpreted as a selector separator.\n    selector = this._escapeRegexMatches(selector, /(\\[[^\\]]*\\])/g);\n\n    // CSS allows for certain special characters to be used in selectors if they're escaped.\n    // E.g. `.foo:blue` won't match a class called `foo:blue`, because the colon denotes a\n    // pseudo-class, but writing `.foo\\:blue` will match, because the colon was escaped.\n    // Replace all escape sequences (`\\` followed by a character) with a placeholder so\n    // that our handling of pseudo-selectors doesn't mess with them.\n    // Escaped characters have a specific placeholder so they can be detected separately.\n    selector = selector.replace(/(\\\\.)/g, (_, keep) => {\n      const replaceBy = `__esc-ph-${this.index}__`;\n      this.placeholders.push(keep);\n      this.index++;\n      return replaceBy;\n    });\n\n    // Replaces the expression in `:nth-child(2n + 1)` with a placeholder.\n    // WS and \"+\" would otherwise be interpreted as selector separators.\n    this._content = selector.replace(/(:nth-[-\\w]+)(\\([^)]+\\))/g, (_, pseudo, exp) => {\n      const replaceBy = `__ph-${this.index}__`;\n      this.placeholders.push(exp);\n      this.index++;\n      return pseudo + replaceBy;\n    });\n  }\n\n  restore(content: string): string {\n    return content.replace(/__(?:ph|esc-ph)-(\\d+)__/g, (_ph, index) => this.placeholders[+index]);\n  }\n\n  content(): string {\n    return this._content;\n  }\n\n  /**\n   * Replaces all of the substrings that match a regex within a\n   * special string (e.g. `__ph-0__`, `__ph-1__`, etc).\n   */\n  private _escapeRegexMatches(content: string, pattern: RegExp): string {\n    return content.replace(pattern, (_, keep) => {\n      const replaceBy = `__ph-${this.index}__`;\n      this.placeholders.push(keep);\n      this.index++;\n      return replaceBy;\n    });\n  }\n}\n\nconst _cssScopedPseudoFunctionPrefix = '(:(where|is)\\\\()?';\nconst _cssPrefixWithPseudoSelectorFunction = /:(where|is)\\(/gi;\nconst _cssContentNextSelectorRe =\n  /polyfill-next-selector[^}]*content:[\\s]*?(['\"])(.*?)\\1[;\\s]*}([^{]*?){/gim;\nconst _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nconst _cssContentUnscopedRuleRe =\n  /(polyfill-unscoped-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nconst _polyfillHost = '-shadowcsshost';\n// note: :host-context pre-processed to -shadowcsshostcontext.\nconst _polyfillHostContext = '-shadowcsscontext';\nconst _parenSuffix = '(?:\\\\((' + '(?:\\\\([^)(]*\\\\)|[^)(]*)+?' + ')\\\\))';\nconst _cssColonHostRe = new RegExp(_polyfillHost + _parenSuffix + '?([^,{]*)', 'gim');\n// note: :host-context patterns are terminated with `{`, as opposed to :host which\n// is both `{` and `,` because :host-context handles top-level commas differently.\nconst _hostContextPattern = _polyfillHostContext + _parenSuffix + '?([^{]*)';\nconst _cssColonHostContextReGlobal = new RegExp(\n  `${_cssScopedPseudoFunctionPrefix}(${_hostContextPattern})`,\n  'gim',\n);\nconst _cssColonHostContextRe = new RegExp(_hostContextPattern, 'im');\nconst _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';\nconst _polyfillHostNoCombinatorOutsidePseudoFunction = new RegExp(\n  `${_polyfillHostNoCombinator}(?![^(]*\\\\))`,\n  'g',\n);\nconst _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\\s,]*)/;\nconst _shadowDOMSelectorsRe = [\n  /::shadow/g,\n  /::content/g,\n  // Deprecated selectors\n  /\\/shadow-deep\\//g,\n  /\\/shadow\\//g,\n];\n\n// The deep combinator is deprecated in the CSS spec\n// Support for `>>>`, `deep`, `::ng-deep` is then also deprecated and will be removed in the future.\n// see https://github.com/angular/angular/pull/17677\nconst _shadowDeepSelectors = /(?:>>>)|(?:\\/deep\\/)|(?:::ng-deep)/g;\nconst _selectorReSuffix = '([>\\\\s~+[.,{:][\\\\s\\\\S]*)?$';\nconst _polyfillHostRe = /-shadowcsshost/gim;\nconst _colonHostRe = /:host/gim;\nconst _colonHostContextRe = /:host-context/gim;\n\nconst _newLinesRe = /\\r?\\n/g;\nconst _commentRe = /\\/\\*[\\s\\S]*?\\*\\//g;\nconst _commentWithHashRe = /\\/\\*\\s*#\\s*source(Mapping)?URL=/g;\nconst COMMENT_PLACEHOLDER = '%COMMENT%';\nconst _commentWithHashPlaceHolderRe = new RegExp(COMMENT_PLACEHOLDER, 'g');\n\nconst BLOCK_PLACEHOLDER = '%BLOCK%';\nconst _ruleRe = new RegExp(\n  `(\\\\s*(?:${COMMENT_PLACEHOLDER}\\\\s*)*)([^;\\\\{\\\\}]+?)(\\\\s*)((?:{%BLOCK%}?\\\\s*;?)|(?:\\\\s*;))`,\n  'g',\n);\nconst CONTENT_PAIRS = new Map([['{', '}']]);\n\nconst COMMA_IN_PLACEHOLDER = '%COMMA_IN_PLACEHOLDER%';\nconst SEMI_IN_PLACEHOLDER = '%SEMI_IN_PLACEHOLDER%';\nconst COLON_IN_PLACEHOLDER = '%COLON_IN_PLACEHOLDER%';\n\nconst _cssCommaInPlaceholderReGlobal = new RegExp(COMMA_IN_PLACEHOLDER, 'g');\nconst _cssSemiInPlaceholderReGlobal = new RegExp(SEMI_IN_PLACEHOLDER, 'g');\nconst _cssColonInPlaceholderReGlobal = new RegExp(COLON_IN_PLACEHOLDER, 'g');\n\nexport class CssRule {\n  constructor(\n    public selector: string,\n    public content: string,\n  ) {}\n}\n\nexport function processRules(input: string, ruleCallback: (rule: CssRule) => CssRule): string {\n  const escaped = escapeInStrings(input);\n  const inputWithEscapedBlocks = escapeBlocks(escaped, CONTENT_PAIRS, BLOCK_PLACEHOLDER);\n  let nextBlockIndex = 0;\n  const escapedResult = inputWithEscapedBlocks.escapedString.replace(_ruleRe, (...m: string[]) => {\n    const selector = m[2];\n    let content = '';\n    let suffix = m[4];\n    let contentPrefix = '';\n    if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {\n      content = inputWithEscapedBlocks.blocks[nextBlockIndex++];\n      suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);\n      contentPrefix = '{';\n    }\n    const rule = ruleCallback(new CssRule(selector, content));\n    return `${m[1]}${rule.selector}${m[3]}${contentPrefix}${rule.content}${suffix}`;\n  });\n  return unescapeInStrings(escapedResult);\n}\n\nclass StringWithEscapedBlocks {\n  constructor(\n    public escapedString: string,\n    public blocks: string[],\n  ) {}\n}\n\nfunction escapeBlocks(\n  input: string,\n  charPairs: Map<string, string>,\n  placeholder: string,\n): StringWithEscapedBlocks {\n  const resultParts: string[] = [];\n  const escapedBlocks: string[] = [];\n  let openCharCount = 0;\n  let nonBlockStartIndex = 0;\n  let blockStartIndex = -1;\n  let openChar: string | undefined;\n  let closeChar: string | undefined;\n\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n    if (char === '\\\\') {\n      i++;\n    } else if (char === closeChar) {\n      openCharCount--;\n      if (openCharCount === 0) {\n        escapedBlocks.push(input.substring(blockStartIndex, i));\n        resultParts.push(placeholder);\n        nonBlockStartIndex = i;\n        blockStartIndex = -1;\n        openChar = closeChar = undefined;\n      }\n    } else if (char === openChar) {\n      openCharCount++;\n    } else if (openCharCount === 0 && charPairs.has(char)) {\n      openChar = char;\n      closeChar = charPairs.get(char);\n      openCharCount = 1;\n      blockStartIndex = i + 1;\n      resultParts.push(input.substring(nonBlockStartIndex, blockStartIndex));\n    }\n  }\n\n  if (blockStartIndex !== -1) {\n    escapedBlocks.push(input.substring(blockStartIndex));\n    resultParts.push(placeholder);\n  } else {\n    resultParts.push(input.substring(nonBlockStartIndex));\n  }\n\n  return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);\n}\n\n/**\n * Object containing as keys characters that should be substituted by placeholders\n * when found in strings during the css text parsing, and as values the respective\n * placeholders\n */\nconst ESCAPE_IN_STRING_MAP: {[key: string]: string} = {\n  ';': SEMI_IN_PLACEHOLDER,\n  ',': COMMA_IN_PLACEHOLDER,\n  ':': COLON_IN_PLACEHOLDER,\n};\n\n/**\n * Parse the provided css text and inside strings (meaning, inside pairs of unescaped single or\n * double quotes) replace specific characters with their respective placeholders as indicated\n * by the `ESCAPE_IN_STRING_MAP` map.\n *\n * For example convert the text\n *  `animation: \"my-anim:at\\\"ion\" 1s;`\n * to\n *  `animation: \"my-anim%COLON_IN_PLACEHOLDER%at\\\"ion\" 1s;`\n *\n * This is necessary in order to remove the meaning of some characters when found inside strings\n * (for example `;` indicates the end of a css declaration, `,` the sequence of values and `:` the\n * division between property and value during a declaration, none of these meanings apply when such\n * characters are within strings and so in order to prevent parsing issues they need to be replaced\n * with placeholder text for the duration of the css manipulation process).\n *\n * @param input the original css text.\n *\n * @returns the css text with specific characters in strings replaced by placeholders.\n **/\nfunction escapeInStrings(input: string): string {\n  let result = input;\n  let currentQuoteChar: string | null = null;\n  for (let i = 0; i < result.length; i++) {\n    const char = result[i];\n    if (char === '\\\\') {\n      i++;\n    } else {\n      if (currentQuoteChar !== null) {\n        // index i is inside a quoted sub-string\n        if (char === currentQuoteChar) {\n          currentQuoteChar = null;\n        } else {\n          const placeholder: string | undefined = ESCAPE_IN_STRING_MAP[char];\n          if (placeholder) {\n            result = `${result.substr(0, i)}${placeholder}${result.substr(i + 1)}`;\n            i += placeholder.length - 1;\n          }\n        }\n      } else if (char === \"'\" || char === '\"') {\n        currentQuoteChar = char;\n      }\n    }\n  }\n  return result;\n}\n\n/**\n * Replace in a string all occurrences of keys in the `ESCAPE_IN_STRING_MAP` map with their\n * original representation, this is simply used to revert the changes applied by the\n * escapeInStrings function.\n *\n * For example it reverts the text:\n *  `animation: \"my-anim%COLON_IN_PLACEHOLDER%at\\\"ion\" 1s;`\n * to it's original form of:\n *  `animation: \"my-anim:at\\\"ion\" 1s;`\n *\n * Note: For the sake of simplicity this function does not check that the placeholders are\n * actually inside strings as it would anyway be extremely unlikely to find them outside of strings.\n *\n * @param input the css text containing the placeholders.\n *\n * @returns the css text without the placeholders.\n */\nfunction unescapeInStrings(input: string): string {\n  let result = input.replace(_cssCommaInPlaceholderReGlobal, ',');\n  result = result.replace(_cssSemiInPlaceholderReGlobal, ';');\n  result = result.replace(_cssColonInPlaceholderReGlobal, ':');\n  return result;\n}\n\n/**\n * Unescape all quotes present in a string, but only if the string was actually already\n * quoted.\n *\n * This generates a \"canonical\" representation of strings which can be used to match strings\n * which would otherwise only differ because of differently escaped quotes.\n *\n * For example it converts the string (assumed to be quoted):\n *  `this \\\\\"is\\\\\" a \\\\'\\\\\\\\'test`\n * to:\n *  `this \"is\" a '\\\\\\\\'test`\n * (note that the latter backslashes are not removed as they are not actually escaping the single\n * quote)\n *\n *\n * @param input the string possibly containing escaped quotes.\n * @param isQuoted boolean indicating whether the string was quoted inside a bigger string (if not\n * then it means that it doesn't represent an inner string and thus no unescaping is required)\n *\n * @returns the string in the \"canonical\" representation without escaped quotes.\n */\nfunction unescapeQuotes(str: string, isQuoted: boolean): string {\n  return !isQuoted ? str : str.replace(/((?:^|[^\\\\])(?:\\\\\\\\)*)\\\\(?=['\"])/g, '$1');\n}\n\n/**\n * Combine the `contextSelectors` with the `hostMarker` and the `otherSelectors`\n * to create a selector that matches the same as `:host-context()`.\n *\n * Given a single context selector `A` we need to output selectors that match on the host and as an\n * ancestor of the host:\n *\n * ```\n * A <hostMarker>, A<hostMarker> {}\n * ```\n *\n * When there is more than one context selector we also have to create combinations of those\n * selectors with each other. For example if there are `A` and `B` selectors the output is:\n *\n * ```\n * AB<hostMarker>, AB <hostMarker>, A B<hostMarker>,\n * B A<hostMarker>, A B <hostMarker>, B A <hostMarker> {}\n * ```\n *\n * And so on...\n *\n * @param contextSelectors an array of context selectors that will be combined.\n * @param otherSelectors the rest of the selectors that are not context selectors.\n */\nfunction _combineHostContextSelectors(\n  contextSelectors: string[],\n  otherSelectors: string,\n  pseudoPrefix = '',\n): string {\n  const hostMarker = _polyfillHostNoCombinator;\n  _polyfillHostRe.lastIndex = 0; // reset the regex to ensure we get an accurate test\n  const otherSelectorsHasHost = _polyfillHostRe.test(otherSelectors);\n\n  // If there are no context selectors then just output a host marker\n  if (contextSelectors.length === 0) {\n    return hostMarker + otherSelectors;\n  }\n\n  const combined: string[] = [contextSelectors.pop() || ''];\n  while (contextSelectors.length > 0) {\n    const length = combined.length;\n    const contextSelector = contextSelectors.pop();\n    for (let i = 0; i < length; i++) {\n      const previousSelectors = combined[i];\n      // Add the new selector as a descendant of the previous selectors\n      combined[length * 2 + i] = previousSelectors + ' ' + contextSelector;\n      // Add the new selector as an ancestor of the previous selectors\n      combined[length + i] = contextSelector + ' ' + previousSelectors;\n      // Add the new selector to act on the same element as the previous selectors\n      combined[i] = contextSelector + previousSelectors;\n    }\n  }\n  // Finally connect the selector to the `hostMarker`s: either acting directly on the host\n  // (A<hostMarker>) or as an ancestor (A <hostMarker>).\n  return combined\n    .map((s) =>\n      otherSelectorsHasHost\n        ? `${pseudoPrefix}${s}${otherSelectors}`\n        : `${pseudoPrefix}${s}${hostMarker}${otherSelectors}, ${pseudoPrefix}${s} ${hostMarker}${otherSelectors}`,\n    )\n    .join(',');\n}\n\n/**\n * Mutate the given `groups` array so that there are `multiples` clones of the original array\n * stored.\n *\n * For example `repeatGroups([a, b], 3)` will result in `[a, b, a, b, a, b]` - but importantly the\n * newly added groups will be clones of the original.\n *\n * @param groups An array of groups of strings that will be repeated. This array is mutated\n *     in-place.\n * @param multiples The number of times the current groups should appear.\n */\nexport function repeatGroups(groups: string[][], multiples: number): void {\n  const length = groups.length;\n  for (let i = 1; i < multiples; i++) {\n    for (let j = 0; j < length; j++) {\n      groups[j + i * length] = groups[j].slice(0);\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/**\n * Distinguishes different kinds of IR operations.\n *\n * Includes both creation and update operations.\n */\nexport enum OpKind {\n  /**\n   * A special operation type which is used to represent the beginning and end nodes of a linked\n   * list of operations.\n   */\n  ListEnd,\n\n  /**\n   * An operation which wraps an output AST statement.\n   */\n  Statement,\n\n  /**\n   * An operation which declares and initializes a `SemanticVariable`.\n   */\n  Variable,\n\n  /**\n   * An operation to begin rendering of an element.\n   */\n  ElementStart,\n\n  /**\n   * An operation to render an element with no children.\n   */\n  Element,\n\n  /**\n   * An operation which declares an embedded view.\n   */\n  Template,\n\n  /**\n   * An operation to end rendering of an element previously started with `ElementStart`.\n   */\n  ElementEnd,\n\n  /**\n   * An operation to begin an `ng-container`.\n   */\n  ContainerStart,\n\n  /**\n   * An operation for an `ng-container` with no children.\n   */\n  Container,\n\n  /**\n   * An operation to end an `ng-container`.\n   */\n  ContainerEnd,\n\n  /**\n   * An operation disable binding for subsequent elements, which are descendants of a non-bindable\n   * node.\n   */\n  DisableBindings,\n\n  /**\n   * Create a conditional creation instruction op.\n   */\n  ConditionalCreate,\n\n  /**\n   * Create a conditional branch creation instruction op.\n   */\n  ConditionalBranchCreate,\n\n  /**\n   * An op to conditionally render a template.\n   */\n  Conditional,\n\n  /**\n   * An operation to re-enable binding, after it was previously disabled.\n   */\n  EnableBindings,\n\n  /**\n   * An operation to render a text node.\n   */\n  Text,\n\n  /**\n   * An operation declaring an event listener for an element.\n   */\n  Listener,\n\n  /**\n   * An operation to interpolate text into a text node.\n   */\n  InterpolateText,\n\n  /**\n   * An intermediate binding op, that has not yet been processed into an individual property,\n   * attribute, style, etc.\n   */\n  Binding,\n\n  /**\n   * An operation to bind an expression to a property of an element.\n   */\n  Property,\n\n  /**\n   * An operation to bind an expression to a style property of an element.\n   */\n  StyleProp,\n\n  /**\n   * An operation to bind an expression to a class property of an element.\n   */\n  ClassProp,\n\n  /**\n   * An operation to bind an expression to the styles of an element.\n   */\n  StyleMap,\n\n  /**\n   * An operation to bind an expression to the classes of an element.\n   */\n  ClassMap,\n\n  /**\n   * An operation to advance the runtime's implicit slot context during the update phase of a view.\n   */\n  Advance,\n\n  /**\n   * An operation to instantiate a pipe.\n   */\n  Pipe,\n\n  /**\n   * An operation to associate an attribute with an element.\n   */\n  Attribute,\n\n  /**\n   * An attribute that has been extracted for inclusion in the consts array.\n   */\n  ExtractedAttribute,\n\n  /**\n   * An operation that configures a `@defer` block.\n   */\n  Defer,\n\n  /**\n   * An operation that controls when a `@defer` loads.\n   */\n  DeferOn,\n\n  /**\n   * An operation that controls when a `@defer` loads, using a custom expression as the condition.\n   */\n  DeferWhen,\n\n  /**\n   * An i18n message that has been extracted for inclusion in the consts array.\n   */\n  I18nMessage,\n\n  /**\n   * A binding to a native DOM property.\n   */\n  DomProperty,\n\n  /**\n   * A namespace change, which causes the subsequent elements to be processed as either HTML or SVG.\n   */\n  Namespace,\n\n  /**\n   * Configure a content projeciton definition for the view.\n   */\n  ProjectionDef,\n\n  /**\n   * Create a content projection slot.\n   */\n  Projection,\n\n  /**\n   * Create a repeater creation instruction op.\n   */\n  RepeaterCreate,\n\n  /**\n   * An update up for a repeater.\n   */\n  Repeater,\n\n  /**\n   * An operation to bind an expression to the property side of a two-way binding.\n   */\n  TwoWayProperty,\n\n  /**\n   * An operation declaring the event side of a two-way binding.\n   */\n  TwoWayListener,\n\n  /**\n   * A creation-time operation that initializes the slot for a `@let` declaration.\n   */\n  DeclareLet,\n\n  /**\n   * An update-time operation that stores the current value of a `@let` declaration.\n   */\n  StoreLet,\n\n  /**\n   * The start of an i18n block.\n   */\n  I18nStart,\n\n  /**\n   * A self-closing i18n on a single element.\n   */\n  I18n,\n\n  /**\n   * The end of an i18n block.\n   */\n  I18nEnd,\n\n  /**\n   * An expression in an i18n message.\n   */\n  I18nExpression,\n\n  /**\n   * An instruction that applies a set of i18n expressions.\n   */\n  I18nApply,\n\n  /**\n   * An instruction to create an ICU expression.\n   */\n  IcuStart,\n\n  /**\n   * An instruction to update an ICU expression.\n   */\n  IcuEnd,\n\n  /**\n   * An instruction representing a placeholder in an ICU expression.\n   */\n  IcuPlaceholder,\n\n  /**\n   * An i18n context containing information needed to generate an i18n message.\n   */\n  I18nContext,\n\n  /**\n   * A creation op that corresponds to i18n attributes on an element.\n   */\n  I18nAttributes,\n\n  /**\n   * Creation op that attaches the location at which an element was defined in a template to it.\n   */\n  SourceLocation,\n\n  /**\n   * An operation to bind animation css classes to an element.\n   */\n  Animation,\n\n  /**\n   * An operation to bind animation css classes to an element.\n   */\n  AnimationString,\n\n  /**\n   * An operation to bind animation css classes to an element.\n   */\n  AnimationBinding,\n\n  /**\n   * An operation to bind animation events to an element.\n   */\n  AnimationListener,\n}\n\n/**\n * Distinguishes different kinds of IR expressions.\n */\nexport enum ExpressionKind {\n  /**\n   * Read of a variable in a lexical scope.\n   */\n  LexicalRead,\n\n  /**\n   * A reference to the current view context.\n   */\n  Context,\n\n  /**\n   * A reference to the view context, for use inside a track function.\n   */\n  TrackContext,\n\n  /**\n   * Read of a variable declared in a `VariableOp`.\n   */\n  ReadVariable,\n\n  /**\n   * Runtime operation to navigate to the next view context in the view hierarchy.\n   */\n  NextContext,\n\n  /**\n   * Runtime operation to retrieve the value of a local reference.\n   */\n  Reference,\n\n  /**\n   * A call storing the value of a `@let` declaration.\n   */\n  StoreLet,\n\n  /**\n   * A reference to a `@let` declaration read from the context view.\n   */\n  ContextLetReference,\n\n  /**\n   * Runtime operation to snapshot the current view context.\n   */\n  GetCurrentView,\n\n  /**\n   * Runtime operation to restore a snapshotted view.\n   */\n  RestoreView,\n\n  /**\n   * Runtime operation to reset the current view context after `RestoreView`.\n   */\n  ResetView,\n\n  /**\n   * Defines and calls a function with change-detected arguments.\n   */\n  PureFunctionExpr,\n\n  /**\n   * Indicates a positional parameter to a pure function definition.\n   */\n  PureFunctionParameterExpr,\n\n  /**\n   * Binding to a pipe transformation.\n   */\n  PipeBinding,\n\n  /**\n   * Binding to a pipe transformation with a variable number of arguments.\n   */\n  PipeBindingVariadic,\n\n  /*\n   * A safe property read requiring expansion into a null check.\n   */\n  SafePropertyRead,\n\n  /**\n   * A safe keyed read requiring expansion into a null check.\n   */\n  SafeKeyedRead,\n\n  /**\n   * A safe function call requiring expansion into a null check.\n   */\n  SafeInvokeFunction,\n\n  /**\n   * An intermediate expression that will be expanded from a safe read into an explicit ternary.\n   */\n  SafeTernaryExpr,\n\n  /**\n   * An empty expression that will be stipped before generating the final output.\n   */\n  EmptyExpr,\n\n  /*\n   * An assignment to a temporary variable.\n   */\n  AssignTemporaryExpr,\n\n  /**\n   * A reference to a temporary variable.\n   */\n  ReadTemporaryExpr,\n\n  /**\n   * An expression that will cause a literal slot index to be emitted.\n   */\n  SlotLiteralExpr,\n\n  /**\n   * A test expression for a conditional op.\n   */\n  ConditionalCase,\n\n  /**\n   * An expression that will be automatically extracted to the component const array.\n   */\n  ConstCollected,\n\n  /**\n   * Operation that sets the value of a two-way binding.\n   */\n  TwoWayBindingSet,\n}\n\nexport enum VariableFlags {\n  None = 0b0000,\n\n  /**\n   * Always inline this variable, regardless of the number of times it's used.\n   * An `AlwaysInline` variable may not depend on context, because doing so may cause side effects\n   * that are illegal when multi-inlined. (The optimizer will enforce this constraint.)\n   */\n  AlwaysInline = 0b0001,\n}\n/**\n * Distinguishes between different kinds of `SemanticVariable`s.\n */\nexport enum SemanticVariableKind {\n  /**\n   * Represents the context of a particular view.\n   */\n  Context,\n\n  /**\n   * Represents an identifier declared in the lexical scope of a view.\n   */\n  Identifier,\n\n  /**\n   * Represents a saved state that can be used to restore a view in a listener handler function.\n   */\n  SavedView,\n\n  /**\n   * An alias generated by a special embedded view type (e.g. a `@for` block).\n   */\n  Alias,\n}\n\n/**\n * Whether to compile in compatibilty mode. In compatibility mode, the template pipeline will\n * attempt to match the output of `TemplateDefinitionBuilder` as exactly as possible, at the cost\n * of producing quirky or larger code in some cases.\n */\nexport enum CompatibilityMode {\n  Normal,\n  TemplateDefinitionBuilder,\n}\n\n/**\n * Enumeration of the types of attributes which can be applied to an element.\n */\nexport enum BindingKind {\n  /**\n   * Static attributes.\n   */\n  Attribute,\n\n  /**\n   * Class bindings.\n   */\n  ClassName,\n\n  /**\n   * Style bindings.\n   */\n  StyleProperty,\n\n  /**\n   * Dynamic property bindings.\n   */\n  Property,\n\n  /**\n   * Property or attribute bindings on a template.\n   */\n  Template,\n\n  /**\n   * Internationalized attributes.\n   */\n  I18n,\n\n  /**\n   * Legacy animation property bindings.\n   */\n  LegacyAnimation,\n\n  /**\n   * Property side of a two-way binding.\n   */\n  TwoWayProperty,\n\n  /**\n   * Property side of an animation binding.\n   */\n  Animation,\n}\n\n/**\n * Enumeration of possible times i18n params can be resolved.\n */\nexport enum I18nParamResolutionTime {\n  /**\n   * Param is resolved at message creation time. Most params should be resolved at message creation\n   * time. However, ICU params need to be handled in post-processing.\n   */\n  Creation,\n\n  /**\n   * Param is resolved during post-processing. This should be used for params whose value comes from\n   * an ICU.\n   */\n  Postproccessing,\n}\n\n/**\n * The contexts in which an i18n expression can be used.\n */\nexport enum I18nExpressionFor {\n  /**\n   * This expression is used as a value (i.e. inside an i18n block).\n   */\n  I18nText,\n\n  /**\n   * This expression is used in a binding.\n   */\n  I18nAttribute,\n}\n\n/**\n * Flags that describe what an i18n param value. These determine how the value is serialized into\n * the final map.\n */\nexport enum I18nParamValueFlags {\n  None = 0b0000,\n\n  /**\n   *  This value represents an element tag.\n   */\n  ElementTag = 0b1,\n\n  /**\n   * This value represents a template tag.\n   */\n  TemplateTag = 0b10,\n\n  /**\n   * This value represents the opening of a tag.\n   */\n  OpenTag = 0b0100,\n\n  /**\n   * This value represents the closing of a tag.\n   */\n  CloseTag = 0b1000,\n\n  /**\n   * This value represents an i18n expression index.\n   */\n  ExpressionIndex = 0b10000,\n}\n\n/**\n * Whether the active namespace is HTML, MathML, or SVG mode.\n */\nexport enum Namespace {\n  HTML,\n  SVG,\n  Math,\n}\n\n/**\n * The type of a `@defer` trigger, for use in the ir.\n */\nexport enum DeferTriggerKind {\n  Idle,\n  Immediate,\n  Timer,\n  Hover,\n  Interaction,\n  Viewport,\n  Never,\n}\n\n/**\n * Kinds of i18n contexts. They can be created because of root i18n blocks, or ICUs.\n */\nexport enum I18nContextKind {\n  RootI18n,\n  Icu,\n  Attr,\n}\n\nexport enum TemplateKind {\n  NgTemplate,\n  Structural,\n  Block,\n}\n\n/**\n * Kinds of animations\n */\nexport const enum AnimationKind {\n  ENTER = 'enter',\n  LEAVE = 'leave',\n}\n\n/**\n * Kinds of animations\n */\nexport const enum AnimationBindingKind {\n  STRING,\n  VALUE,\n}\n\n/**\n * Kinds of modifiers for a defer block.\n */\nexport const enum DeferOpModifierKind {\n  NONE = 'none',\n  PREFETCH = 'prefetch',\n  HYDRATE = 'hydrate',\n}\n\n/**\n * Specifies defer block flags, which should be used for all\n * instances of a given defer block (the flags that should be\n * placed into the `TDeferDetails` at runtime).\n */\nexport const enum TDeferDetailsFlags {\n  Default = 0,\n\n  /**\n   * Whether or not the defer block has hydrate triggers.\n   */\n  HasHydrateTriggers = 1 << 0,\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport type {ParseSourceSpan} from '../../../../parse_util';\nimport type {Expression} from './expression';\nimport * as o from '../../../../output/output_ast';\nimport type {Op, XrefId} from './operations';\nimport {SlotHandle} from './handle';\n\n/**\n * Marker symbol for `ConsumesSlotOpTrait`.\n */\nexport const ConsumesSlot: unique symbol = Symbol('ConsumesSlot');\n\n/**\n * Marker symbol for `DependsOnSlotContextOpTrait`.\n */\nexport const DependsOnSlotContext: unique symbol = Symbol('DependsOnSlotContext');\n\n/**\n * Marker symbol for `ConsumesVars` trait.\n */\nexport const ConsumesVarsTrait: unique symbol = Symbol('ConsumesVars');\n\n/**\n * Marker symbol for `UsesVarOffset` trait.\n */\nexport const UsesVarOffset: unique symbol = Symbol('UsesVarOffset');\n\n/**\n * Marks an operation as requiring allocation of one or more data slots for storage.\n */\nexport interface ConsumesSlotOpTrait {\n  readonly [ConsumesSlot]: true;\n\n  /**\n   * Assigned data slot (the starting index, if more than one slot is needed) for this operation, or\n   * `null` if slots have not yet been assigned.\n   */\n  handle: SlotHandle;\n\n  /**\n   * The number of slots which will be used by this operation. By default 1, but can be increased if\n   * necessary.\n   */\n  numSlotsUsed: number;\n\n  /**\n   * `XrefId` of this operation (e.g. the element stored in the assigned slot). This `XrefId` is\n   * used to link this `ConsumesSlotOpTrait` operation with `DependsOnSlotContextTrait` or\n   * `UsesSlotIndexExprTrait` implementors and ensure that the assigned slot is propagated through\n   * the IR to all consumers.\n   */\n  xref: XrefId;\n}\n\n/**\n * Marks an operation as depending on the runtime's implicit slot context being set to a particular\n * slot.\n *\n * The runtime has an implicit slot context which is adjusted using the `advance()` instruction\n * during the execution of template update functions. This trait marks an operation as requiring\n * this implicit context to be `advance()`'d to point at a particular slot prior to execution.\n */\nexport interface DependsOnSlotContextOpTrait {\n  readonly [DependsOnSlotContext]: true;\n\n  /**\n   * `XrefId` of the `ConsumesSlotOpTrait` which the implicit slot context must reference before\n   * this operation can be executed.\n   */\n  target: XrefId;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Marker trait indicating that an operation or expression consumes variable storage space.\n */\nexport interface ConsumesVarsTrait {\n  [ConsumesVarsTrait]: true;\n}\n\n/**\n * Marker trait indicating that an expression requires knowledge of the number of variable storage\n * slots used prior to it.\n */\nexport interface UsesVarOffsetTrait {\n  [UsesVarOffset]: true;\n\n  varOffset: number | null;\n}\n\n/**\n * Default values for most `ConsumesSlotOpTrait` fields (used with the spread operator to initialize\n * implementors of the trait).\n */\nexport const TRAIT_CONSUMES_SLOT: Omit<ConsumesSlotOpTrait, 'xref' | 'handle'> = {\n  [ConsumesSlot]: true,\n  numSlotsUsed: 1,\n} as const;\n\n/**\n * Default values for most `DependsOnSlotContextOpTrait` fields (used with the spread operator to\n * initialize implementors of the trait).\n */\nexport const TRAIT_DEPENDS_ON_SLOT_CONTEXT: Omit<\n  DependsOnSlotContextOpTrait,\n  'target' | 'sourceSpan'\n> = {\n  [DependsOnSlotContext]: true,\n} as const;\n\n/**\n * Default values for `UsesVars` fields (used with the spread operator to initialize\n * implementors of the trait).\n */\nexport const TRAIT_CONSUMES_VARS: ConsumesVarsTrait = {\n  [ConsumesVarsTrait]: true,\n} as const;\n\n/**\n * Test whether an operation implements `ConsumesSlotOpTrait`.\n */\nexport function hasConsumesSlotTrait<OpT extends Op<OpT>>(\n  op: OpT,\n): op is OpT & ConsumesSlotOpTrait {\n  return (op as Partial<ConsumesSlotOpTrait>)[ConsumesSlot] === true;\n}\n\n/**\n * Test whether an operation implements `DependsOnSlotContextOpTrait`.\n */\nexport function hasDependsOnSlotContextTrait<ExprT extends o.Expression>(\n  expr: ExprT,\n): expr is ExprT & DependsOnSlotContextOpTrait;\nexport function hasDependsOnSlotContextTrait<OpT extends Op<OpT>>(\n  op: OpT,\n): op is OpT & DependsOnSlotContextOpTrait;\nexport function hasDependsOnSlotContextTrait(value: any): boolean {\n  return (value as Partial<DependsOnSlotContextOpTrait>)[DependsOnSlotContext] === true;\n}\n\n/**\n * Test whether an operation implements `ConsumesVarsTrait`.\n */\nexport function hasConsumesVarsTrait<ExprT extends Expression>(\n  expr: ExprT,\n): expr is ExprT & ConsumesVarsTrait;\nexport function hasConsumesVarsTrait<OpT extends Op<OpT>>(op: OpT): op is OpT & ConsumesVarsTrait;\nexport function hasConsumesVarsTrait(value: any): boolean {\n  return (value as Partial<ConsumesVarsTrait>)[ConsumesVarsTrait] === true;\n}\n\n/**\n * Test whether an expression implements `UsesVarOffsetTrait`.\n */\nexport function hasUsesVarOffsetTrait<ExprT extends Expression>(\n  expr: ExprT,\n): expr is ExprT & UsesVarOffsetTrait {\n  return (expr as Partial<UsesVarOffsetTrait>)[UsesVarOffset] === true;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../../../output/output_ast';\nimport {OpKind, VariableFlags} from '../enums';\nimport {Op, XrefId} from '../operations';\nimport {SemanticVariable} from '../variable';\n\n/**\n * A special `Op` which is used internally in the `OpList` linked list to represent the head and\n * tail nodes of the list.\n *\n * `ListEndOp` is created internally in the `OpList` and should not be instantiated directly.\n */\nexport interface ListEndOp<OpT extends Op<OpT>> extends Op<OpT> {\n  kind: OpKind.ListEnd;\n}\n\n/**\n * An `Op` which directly wraps an output `Statement`.\n *\n * Often `StatementOp`s are the final result of IR processing.\n */\nexport interface StatementOp<OpT extends Op<OpT>> extends Op<OpT> {\n  kind: OpKind.Statement;\n\n  /**\n   * The output statement.\n   */\n  statement: o.Statement;\n}\n\n/**\n * Create a `StatementOp`.\n */\nexport function createStatementOp<OpT extends Op<OpT>>(statement: o.Statement): StatementOp<OpT> {\n  return {\n    kind: OpKind.Statement,\n    statement,\n    ...NEW_OP,\n  };\n}\n\n/**\n * Operation which declares and initializes a `SemanticVariable`, that is valid either in create or\n * update IR.\n */\nexport interface VariableOp<OpT extends Op<OpT>> extends Op<OpT> {\n  kind: OpKind.Variable;\n\n  /**\n   * `XrefId` which identifies this specific variable, and is used to reference this variable from\n   * other parts of the IR.\n   */\n  xref: XrefId;\n\n  /**\n   * The `SemanticVariable` which describes the meaning behind this variable.\n   */\n  variable: SemanticVariable;\n\n  /**\n   * Expression representing the value of the variable.\n   */\n  initializer: o.Expression;\n\n  flags: VariableFlags;\n}\n\n/**\n * Create a `VariableOp`.\n */\nexport function createVariableOp<OpT extends Op<OpT>>(\n  xref: XrefId,\n  variable: SemanticVariable,\n  initializer: o.Expression,\n  flags: VariableFlags,\n): VariableOp<OpT> {\n  return {\n    kind: OpKind.Variable,\n    xref,\n    variable,\n    initializer,\n    flags,\n    ...NEW_OP,\n  };\n}\n\n/**\n * Static structure shared by all operations.\n *\n * Used as a convenience via the spread operator (`...NEW_OP`) when creating new operations, and\n * ensures the fields are always in the same order.\n */\nexport const NEW_OP: Pick<Op<any>, 'debugListId' | 'prev' | 'next'> = {\n  debugListId: null,\n  prev: null,\n  next: null,\n};\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {SecurityContext} from '../../../../../core';\nimport * as i18n from '../../../../../i18n/i18n_ast';\nimport * as o from '../../../../../output/output_ast';\nimport {ParseSourceSpan} from '../../../../../parse_util';\nimport {\n  AnimationBindingKind,\n  AnimationKind,\n  BindingKind,\n  DeferOpModifierKind,\n  I18nExpressionFor,\n  I18nParamResolutionTime,\n  OpKind,\n  TemplateKind,\n} from '../enums';\nimport type {ConditionalCaseExpr} from '../expression';\nimport {SlotHandle} from '../handle';\nimport {Op, XrefId} from '../operations';\nimport {\n  ConsumesVarsTrait,\n  DependsOnSlotContextOpTrait,\n  TRAIT_CONSUMES_VARS,\n  TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n} from '../traits';\nimport type {DomPropertyOp} from './host';\nimport {ListEndOp, NEW_OP, StatementOp, VariableOp} from './shared';\n\n/**\n * An operation usable on the update side of the IR.\n */\nexport type UpdateOp =\n  | ListEndOp<UpdateOp>\n  | StatementOp<UpdateOp>\n  | PropertyOp\n  | TwoWayPropertyOp\n  | AttributeOp\n  | StylePropOp\n  | ClassPropOp\n  | StyleMapOp\n  | ClassMapOp\n  | InterpolateTextOp\n  | AdvanceOp\n  | VariableOp<UpdateOp>\n  | BindingOp\n  | DomPropertyOp\n  | ConditionalOp\n  | I18nExpressionOp\n  | I18nApplyOp\n  | RepeaterOp\n  | DeferWhenOp\n  | AnimationBindingOp\n  | StoreLetOp;\n\n/**\n * A logical operation to perform string interpolation on a text node.\n *\n * Interpolation inputs are stored as static `string`s and dynamic `o.Expression`s, in separate\n * arrays. Thus, the interpolation `A{{b}}C{{d}}E` is stored as 3 static strings `['A', 'C', 'E']`\n * and 2 dynamic expressions `[b, d]`.\n */\nexport interface InterpolateTextOp extends Op<UpdateOp>, ConsumesVarsTrait {\n  kind: OpKind.InterpolateText;\n\n  /**\n   * Reference to the text node to which the interpolation is bound.\n   */\n  target: XrefId;\n\n  /**\n   * The interpolated value.\n   */\n  interpolation: Interpolation;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Create an `InterpolationTextOp`.\n */\nexport function createInterpolateTextOp(\n  xref: XrefId,\n  interpolation: Interpolation,\n  sourceSpan: ParseSourceSpan,\n): InterpolateTextOp {\n  return {\n    kind: OpKind.InterpolateText,\n    target: xref,\n    interpolation,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP,\n  };\n}\n\nexport class Interpolation {\n  constructor(\n    readonly strings: string[],\n    readonly expressions: o.Expression[],\n    readonly i18nPlaceholders: string[],\n  ) {\n    if (i18nPlaceholders.length !== 0 && i18nPlaceholders.length !== expressions.length) {\n      throw new Error(\n        `Expected ${expressions.length} placeholders to match interpolation expression count, but got ${i18nPlaceholders.length}`,\n      );\n    }\n  }\n}\n\n/**\n * An intermediate binding op, that has not yet been processed into an individual property,\n * attribute, style, etc.\n */\nexport interface BindingOp extends Op<UpdateOp> {\n  kind: OpKind.Binding;\n\n  /**\n   * Reference to the element on which the property is bound.\n   */\n  target: XrefId;\n\n  /**\n   *  The kind of binding represented by this op.\n   */\n  bindingKind: BindingKind;\n\n  /**\n   *  The name of this binding.\n   */\n  name: string;\n\n  /**\n   * Expression which is bound to the property.\n   */\n  expression: o.Expression | Interpolation;\n\n  /**\n   * The unit of the bound value.\n   */\n  unit: string | null;\n\n  /**\n   * The security context of the binding.\n   */\n  securityContext: SecurityContext | SecurityContext[];\n\n  /**\n   * Whether the binding is a TextAttribute (e.g. `some-attr=\"some-value\"`).\n   *\n   * This needs to be tracked for compatibility with `TemplateDefinitionBuilder` which treats\n   * `style` and `class` TextAttributes differently from `[attr.style]` and `[attr.class]`.\n   */\n  isTextAttribute: boolean;\n\n  isStructuralTemplateAttribute: boolean;\n\n  /**\n   * Whether this binding is on a structural template.\n   */\n  templateKind: TemplateKind | null;\n\n  i18nContext: XrefId | null;\n  i18nMessage: i18n.Message | null;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Create a `BindingOp`, not yet transformed into a particular type of binding.\n */\nexport function createBindingOp(\n  target: XrefId,\n  kind: BindingKind,\n  name: string,\n  expression: o.Expression | Interpolation,\n  unit: string | null,\n  securityContext: SecurityContext | SecurityContext[],\n  isTextAttribute: boolean,\n  isStructuralTemplateAttribute: boolean,\n  templateKind: TemplateKind | null,\n  i18nMessage: i18n.Message | null,\n  sourceSpan: ParseSourceSpan,\n): BindingOp {\n  return {\n    kind: OpKind.Binding,\n    bindingKind: kind,\n    target,\n    name,\n    expression,\n    unit,\n    securityContext,\n    isTextAttribute,\n    isStructuralTemplateAttribute,\n    templateKind,\n    i18nContext: null,\n    i18nMessage,\n    sourceSpan,\n    ...NEW_OP,\n  };\n}\n\n/**\n * A logical operation representing binding to a property in the update IR.\n */\nexport interface PropertyOp extends Op<UpdateOp>, ConsumesVarsTrait, DependsOnSlotContextOpTrait {\n  kind: OpKind.Property;\n\n  /**\n   * Reference to the element on which the property is bound.\n   */\n  target: XrefId;\n\n  /**\n   * Name of the bound property.\n   */\n  name: string;\n\n  /**\n   * Expression which is bound to the property.\n   */\n  expression: o.Expression | Interpolation;\n\n  /**\n   * Whether this property is an animation trigger.\n   */\n  bindingKind: BindingKind;\n\n  /**\n   * The security context of the binding.\n   */\n  securityContext: SecurityContext | SecurityContext[];\n\n  /**\n   * The sanitizer for this property.\n   */\n  sanitizer: o.Expression | null;\n\n  isStructuralTemplateAttribute: boolean;\n\n  /**\n   * The kind of template targeted by the binding, or null if this binding does not target a\n   * template.\n   */\n  templateKind: TemplateKind | null;\n\n  i18nContext: XrefId | null;\n  i18nMessage: i18n.Message | null;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Create a `PropertyOp`.\n */\nexport function createPropertyOp(\n  target: XrefId,\n  name: string,\n  expression: o.Expression | Interpolation,\n  bindingKind: BindingKind,\n  securityContext: SecurityContext | SecurityContext[],\n  isStructuralTemplateAttribute: boolean,\n  templateKind: TemplateKind | null,\n  i18nContext: XrefId | null,\n  i18nMessage: i18n.Message | null,\n  sourceSpan: ParseSourceSpan,\n): PropertyOp {\n  return {\n    kind: OpKind.Property,\n    target,\n    name,\n    expression,\n    bindingKind,\n    securityContext,\n    sanitizer: null,\n    isStructuralTemplateAttribute,\n    templateKind,\n    i18nContext,\n    i18nMessage,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP,\n  };\n}\n\n/**\n * A logical operation representing the property binding side of a two-way binding in the update IR.\n */\nexport interface TwoWayPropertyOp\n  extends Op<UpdateOp>,\n    ConsumesVarsTrait,\n    DependsOnSlotContextOpTrait {\n  kind: OpKind.TwoWayProperty;\n\n  /**\n   * Reference to the element on which the property is bound.\n   */\n  target: XrefId;\n\n  /**\n   * Name of the property.\n   */\n  name: string;\n\n  /**\n   * Expression which is bound to the property.\n   */\n  expression: o.Expression;\n\n  /**\n   * The security context of the binding.\n   */\n  securityContext: SecurityContext | SecurityContext[];\n\n  /**\n   * The sanitizer for this property.\n   */\n  sanitizer: o.Expression | null;\n\n  isStructuralTemplateAttribute: boolean;\n\n  /**\n   * The kind of template targeted by the binding, or null if this binding does not target a\n   * template.\n   */\n  templateKind: TemplateKind | null;\n\n  i18nContext: XrefId | null;\n  i18nMessage: i18n.Message | null;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Create a `TwoWayPropertyOp`.\n */\nexport function createTwoWayPropertyOp(\n  target: XrefId,\n  name: string,\n  expression: o.Expression,\n  securityContext: SecurityContext | SecurityContext[],\n  isStructuralTemplateAttribute: boolean,\n  templateKind: TemplateKind | null,\n  i18nContext: XrefId | null,\n  i18nMessage: i18n.Message | null,\n  sourceSpan: ParseSourceSpan,\n): TwoWayPropertyOp {\n  return {\n    kind: OpKind.TwoWayProperty,\n    target,\n    name,\n    expression,\n    securityContext,\n    sanitizer: null,\n    isStructuralTemplateAttribute,\n    templateKind,\n    i18nContext,\n    i18nMessage,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP,\n  };\n}\n\n/**\n * A logical operation representing binding to a style property in the update IR.\n */\nexport interface StylePropOp extends Op<UpdateOp>, ConsumesVarsTrait, DependsOnSlotContextOpTrait {\n  kind: OpKind.StyleProp;\n\n  /**\n   * Reference to the element on which the property is bound.\n   */\n  target: XrefId;\n\n  /**\n   * Name of the bound property.\n   */\n  name: string;\n\n  /**\n   * Expression which is bound to the property.\n   */\n  expression: o.Expression | Interpolation;\n\n  /**\n   * The unit of the bound value.\n   */\n  unit: string | null;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/** Create a `StylePropOp`. */\nexport function createStylePropOp(\n  xref: XrefId,\n  name: string,\n  expression: o.Expression | Interpolation,\n  unit: string | null,\n  sourceSpan: ParseSourceSpan,\n): StylePropOp {\n  return {\n    kind: OpKind.StyleProp,\n    target: xref,\n    name,\n    expression,\n    unit,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP,\n  };\n}\n\n/**\n * A logical operation representing binding to a class property in the update IR.\n */\nexport interface ClassPropOp extends Op<UpdateOp>, ConsumesVarsTrait, DependsOnSlotContextOpTrait {\n  kind: OpKind.ClassProp;\n\n  /**\n   * Reference to the element on which the property is bound.\n   */\n  target: XrefId;\n\n  /**\n   * Name of the bound property.\n   */\n  name: string;\n\n  /**\n   * Expression which is bound to the property.\n   */\n  expression: o.Expression;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Create a `ClassPropOp`.\n */\nexport function createClassPropOp(\n  xref: XrefId,\n  name: string,\n  expression: o.Expression,\n  sourceSpan: ParseSourceSpan,\n): ClassPropOp {\n  return {\n    kind: OpKind.ClassProp,\n    target: xref,\n    name,\n    expression,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP,\n  };\n}\n\n/**\n * A logical operation representing binding to a style map in the update IR.\n */\nexport interface StyleMapOp extends Op<UpdateOp>, ConsumesVarsTrait, DependsOnSlotContextOpTrait {\n  kind: OpKind.StyleMap;\n\n  /**\n   * Reference to the element on which the property is bound.\n   */\n  target: XrefId;\n\n  /**\n   * Expression which is bound to the property.\n   */\n  expression: o.Expression | Interpolation;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/** Create a `StyleMapOp`. */\nexport function createStyleMapOp(\n  xref: XrefId,\n  expression: o.Expression | Interpolation,\n  sourceSpan: ParseSourceSpan,\n): StyleMapOp {\n  return {\n    kind: OpKind.StyleMap,\n    target: xref,\n    expression,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP,\n  };\n}\n\n/**\n * A logical operation representing binding to a style map in the update IR.\n */\nexport interface ClassMapOp extends Op<UpdateOp>, ConsumesVarsTrait, DependsOnSlotContextOpTrait {\n  kind: OpKind.ClassMap;\n\n  /**\n   * Reference to the element on which the property is bound.\n   */\n  target: XrefId;\n\n  /**\n   * Expression which is bound to the property.\n   */\n  expression: o.Expression | Interpolation;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Create a `ClassMapOp`.\n */\nexport function createClassMapOp(\n  xref: XrefId,\n  expression: o.Expression | Interpolation,\n  sourceSpan: ParseSourceSpan,\n): ClassMapOp {\n  return {\n    kind: OpKind.ClassMap,\n    target: xref,\n    expression,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP,\n  };\n}\n\n/**\n * A logical operation representing setting an attribute on an element in the update IR.\n */\nexport interface AttributeOp extends Op<UpdateOp> {\n  kind: OpKind.Attribute;\n\n  /**\n   * The `XrefId` of the template-like element the attribute will belong to.\n   */\n  target: XrefId;\n\n  /**\n   * The namespace of the attribute (or null if none).\n   */\n  namespace: string | null;\n\n  /**\n   * The name of the attribute.\n   */\n  name: string;\n\n  /**\n   * The value of the attribute.\n   */\n  expression: o.Expression | Interpolation;\n\n  /**\n   * The security context of the binding.\n   */\n  securityContext: SecurityContext | SecurityContext[];\n\n  /**\n   * The sanitizer for this attribute.\n   */\n  sanitizer: o.Expression | null;\n\n  /**\n   * Whether the binding is a TextAttribute (e.g. `some-attr=\"some-value\"`).\n   *\n   * This needs to be tracked for compatibility with `TemplateDefinitionBuilder` which treats\n   * `style` and `class` TextAttributes differently from `[attr.style]` and `[attr.class]`.\n   */\n  isTextAttribute: boolean;\n\n  isStructuralTemplateAttribute: boolean;\n\n  /**\n   * The kind of template targeted by the binding, or null if this binding does not target a\n   * template.\n   */\n  templateKind: TemplateKind | null;\n\n  /**\n   * The i18n context, if this is an i18n attribute.\n   */\n  i18nContext: XrefId | null;\n\n  i18nMessage: i18n.Message | null;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Create an `AttributeOp`.\n */\nexport function createAttributeOp(\n  target: XrefId,\n  namespace: string | null,\n  name: string,\n  expression: o.Expression | Interpolation,\n  securityContext: SecurityContext | SecurityContext[],\n  isTextAttribute: boolean,\n  isStructuralTemplateAttribute: boolean,\n  templateKind: TemplateKind | null,\n  i18nMessage: i18n.Message | null,\n  sourceSpan: ParseSourceSpan,\n): AttributeOp {\n  return {\n    kind: OpKind.Attribute,\n    target,\n    namespace,\n    name,\n    expression,\n    securityContext,\n    sanitizer: null,\n    isTextAttribute,\n    isStructuralTemplateAttribute,\n    templateKind,\n    i18nContext: null,\n    i18nMessage,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP,\n  };\n}\n\n/**\n * Logical operation to advance the runtime's internal slot pointer in the update IR.\n */\nexport interface AdvanceOp extends Op<UpdateOp> {\n  kind: OpKind.Advance;\n\n  /**\n   * Delta by which to advance the pointer.\n   */\n  delta: number;\n\n  // Source span of the binding that caused the advance\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Create an `AdvanceOp`.\n */\nexport function createAdvanceOp(delta: number, sourceSpan: ParseSourceSpan): AdvanceOp {\n  return {\n    kind: OpKind.Advance,\n    delta,\n    sourceSpan,\n    ...NEW_OP,\n  };\n}\n\n/**\n * Logical operation representing a conditional expression in the update IR.\n */\nexport interface ConditionalOp\n  extends Op<ConditionalOp>,\n    DependsOnSlotContextOpTrait,\n    ConsumesVarsTrait {\n  kind: OpKind.Conditional;\n\n  /**\n   * The insertion point, which is the first template in the creation block belonging to this\n   * condition.\n   */\n  target: XrefId;\n\n  /**\n   * The main test expression (for a switch), or `null` (for an if, which has no test\n   * expression).\n   */\n  test: o.Expression | null;\n\n  /**\n   * Each possible embedded view that could be displayed has a condition (or is default). This\n   * structure maps each view xref to its corresponding condition.\n   */\n  conditions: Array<ConditionalCaseExpr>;\n\n  /**\n   * After processing, this will be a single collapsed Joost-expression that evaluates the\n   * conditions, and yields the slot number of the template which should be displayed.\n   */\n  processed: o.Expression | null;\n\n  /**\n   * Control flow conditionals can accept a context value (this is a result of specifying an\n   * alias). This expression will be passed to the conditional instruction's context parameter.\n   */\n  contextValue: o.Expression | null;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Create a conditional op, which will display an embedded view according to a condtion.\n */\nexport function createConditionalOp(\n  target: XrefId,\n  test: o.Expression | null,\n  conditions: Array<ConditionalCaseExpr>,\n  sourceSpan: ParseSourceSpan,\n): ConditionalOp {\n  return {\n    kind: OpKind.Conditional,\n    target,\n    test,\n    conditions,\n    processed: null,\n    sourceSpan,\n    contextValue: null,\n    ...NEW_OP,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n  };\n}\n\nexport interface RepeaterOp extends Op<UpdateOp>, DependsOnSlotContextOpTrait {\n  kind: OpKind.Repeater;\n\n  /**\n   * The RepeaterCreate op associated with this repeater.\n   */\n  target: XrefId;\n\n  targetSlot: SlotHandle;\n\n  /**\n   * The collection provided to the for loop as its expression.\n   */\n  collection: o.Expression;\n\n  sourceSpan: ParseSourceSpan;\n}\n\nexport function createRepeaterOp(\n  repeaterCreate: XrefId,\n  targetSlot: SlotHandle,\n  collection: o.Expression,\n  sourceSpan: ParseSourceSpan,\n): RepeaterOp {\n  return {\n    kind: OpKind.Repeater,\n    target: repeaterCreate,\n    targetSlot,\n    collection,\n    sourceSpan,\n    ...NEW_OP,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n  };\n}\n\n/**\n * A logical operation representing binding to an animation in the update IR.\n */\nexport interface AnimationBindingOp extends Op<UpdateOp> {\n  kind: OpKind.AnimationBinding;\n\n  /**\n   * The name of the extracted attribute.\n   */\n  name: string;\n\n  /**\n   * Reference to the element on which the property is bound.\n   */\n  target: XrefId;\n\n  /**\n   * Name of the bound property.\n   */\n  animationKind: AnimationKind;\n\n  /**\n   * Expression which is bound to the property.\n   */\n  expression: o.Expression | Interpolation;\n\n  i18nMessage: XrefId | null;\n\n  /**\n   * The security context of the binding.\n   */\n  securityContext: SecurityContext | SecurityContext[];\n\n  /**\n   * The sanitizer for this property.\n   */\n  sanitizer: o.Expression | null;\n\n  sourceSpan: ParseSourceSpan;\n\n  animationBindingKind: AnimationBindingKind;\n}\n\n/**\n * Create an `AnimationBindingOp`.\n */\nexport function createAnimationBindingOp(\n  name: string,\n  target: XrefId,\n  animationKind: AnimationKind,\n  expression: o.Expression | Interpolation,\n  securityContext: SecurityContext | SecurityContext[],\n  sourceSpan: ParseSourceSpan,\n  animationBindingKind: AnimationBindingKind,\n): AnimationBindingOp {\n  return {\n    kind: OpKind.AnimationBinding,\n    name,\n    target,\n    animationKind,\n    expression,\n    i18nMessage: null,\n    securityContext,\n    sanitizer: null,\n    sourceSpan,\n    animationBindingKind,\n    ...NEW_OP,\n  };\n}\n\nexport interface DeferWhenOp extends Op<UpdateOp>, DependsOnSlotContextOpTrait, ConsumesVarsTrait {\n  kind: OpKind.DeferWhen;\n\n  /**\n   * The `defer` create op associated with this when condition.\n   */\n  target: XrefId;\n\n  /**\n   * A user-provided expression that triggers the defer op.\n   */\n  expr: o.Expression;\n\n  /**\n   * Modifier set on the trigger by the user (e.g. `hydrate`, `prefetch` etc).\n   */\n  modifier: DeferOpModifierKind;\n\n  sourceSpan: ParseSourceSpan;\n}\n\nexport function createDeferWhenOp(\n  target: XrefId,\n  expr: o.Expression,\n  modifier: DeferOpModifierKind,\n  sourceSpan: ParseSourceSpan,\n): DeferWhenOp {\n  return {\n    kind: OpKind.DeferWhen,\n    target,\n    expr,\n    modifier,\n    sourceSpan,\n    ...NEW_OP,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n  };\n}\n\n/**\n * An op that represents an expression in an i18n message.\n *\n * TODO: This can represent expressions used in both i18n attributes and normal i18n content. We\n * may want to split these into two different op types, deriving from the same base class.\n */\nexport interface I18nExpressionOp\n  extends Op<UpdateOp>,\n    ConsumesVarsTrait,\n    DependsOnSlotContextOpTrait {\n  kind: OpKind.I18nExpression;\n\n  /**\n   * The i18n context that this expression belongs to.\n   */\n  context: XrefId;\n\n  /**\n   * The Xref of the op that we need to `advance` to.\n   *\n   * In an i18n block, this is initially the i18n start op, but will eventually correspond to\n   * the final slot consumer in the owning i18n block.\n   * TODO: We should make text i18nExpressions target the i18nEnd instruction, instead the last\n   * slot consumer in the i18n block. This makes them resilient to that last consumer being\n   * deleted. (Or new slot consumers being added!)\n   *\n   * In an i18n attribute, this is the xref of the corresponding elementStart/element.\n   */\n  target: XrefId;\n\n  /**\n   * In an i18n block, this should be the i18n start op.\n   *\n   * In an i18n attribute, this will be the xref of the attribute configuration instruction.\n   */\n  i18nOwner: XrefId;\n\n  /**\n   * A handle for the slot that this expression modifies.\n   * - In an i18n block, this is the handle of the block.\n   * - In an i18n attribute, this is the handle of the corresponding i18nAttributes instruction.\n   */\n  handle: SlotHandle;\n\n  /**\n   * The expression value.\n   */\n  expression: o.Expression;\n\n  icuPlaceholder: XrefId | null;\n\n  /**\n   * The i18n placeholder associated with this expression. This can be null if the expression is\n   * part of an ICU placeholder. In this case it gets combined with the string literal value and\n   * other expressions in the ICU placeholder and assigned to the translated message under the ICU\n   * placeholder name.\n   */\n  i18nPlaceholder: string | null;\n\n  /**\n   * The time that this expression is resolved.\n   */\n  resolutionTime: I18nParamResolutionTime;\n\n  /**\n   * Whether this i18n expression applies to a template or to a binding.\n   */\n  usage: I18nExpressionFor;\n\n  /**\n   * If this is an I18nExpressionContext.Binding, this expression is associated with a named\n   * attribute. That name is stored here.\n   */\n  name: string;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Create an i18n expression op.\n */\nexport function createI18nExpressionOp(\n  context: XrefId,\n  target: XrefId,\n  i18nOwner: XrefId,\n  handle: SlotHandle,\n  expression: o.Expression,\n  icuPlaceholder: XrefId | null,\n  i18nPlaceholder: string | null,\n  resolutionTime: I18nParamResolutionTime,\n  usage: I18nExpressionFor,\n  name: string,\n  sourceSpan: ParseSourceSpan,\n): I18nExpressionOp {\n  return {\n    kind: OpKind.I18nExpression,\n    context,\n    target,\n    i18nOwner,\n    handle,\n    expression,\n    icuPlaceholder,\n    i18nPlaceholder,\n    resolutionTime,\n    usage,\n    name,\n    sourceSpan,\n    ...NEW_OP,\n    ...TRAIT_CONSUMES_VARS,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n  };\n}\n\n/**\n * An op that represents applying a set of i18n expressions.\n */\nexport interface I18nApplyOp extends Op<UpdateOp> {\n  kind: OpKind.I18nApply;\n\n  /**\n   * In an i18n block, this should be the i18n start op.\n   *\n   * In an i18n attribute, this will be the xref of the attribute configuration instruction.\n   */\n  owner: XrefId;\n\n  /**\n   * A handle for the slot that i18n apply instruction should apply to. In an i18n block, this\n   * is the slot of the i18n block this expression belongs to. In an i18n attribute, this is the\n   * slot of the corresponding i18nAttributes instruction.\n   */\n  handle: SlotHandle;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Creates an op to apply i18n expression ops.\n */\nexport function createI18nApplyOp(\n  owner: XrefId,\n  handle: SlotHandle,\n  sourceSpan: ParseSourceSpan,\n): I18nApplyOp {\n  return {\n    kind: OpKind.I18nApply,\n    owner,\n    handle,\n    sourceSpan,\n    ...NEW_OP,\n  };\n}\n\n/**\n * Op to store the current value of a `@let` declaration.\n */\nexport interface StoreLetOp extends Op<UpdateOp>, ConsumesVarsTrait {\n  kind: OpKind.StoreLet;\n  sourceSpan: ParseSourceSpan;\n\n  /** Name that the user set when declaring the `@let`. */\n  declaredName: string;\n\n  /** XrefId of the slot in which the call may write its value. */\n  target: XrefId;\n\n  /** Value of the `@let` declaration. */\n  value: o.Expression;\n}\n\n/**\n * Creates a `StoreLetOp`.\n */\nexport function createStoreLetOp(\n  target: XrefId,\n  declaredName: string,\n  value: o.Expression,\n  sourceSpan: ParseSourceSpan,\n): StoreLetOp {\n  return {\n    kind: OpKind.StoreLet,\n    target,\n    declaredName,\n    value,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP,\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport type {ParseSourceSpan} from '../../../../parse_util';\n\nimport * as t from '../../../../render3/r3_ast';\nimport {ExpressionKind, OpKind} from './enums';\nimport {SlotHandle} from './handle';\nimport type {XrefId} from './operations';\nimport type {CreateOp} from './ops/create';\nimport {Interpolation, type UpdateOp} from './ops/update';\nimport {\n  ConsumesVarsTrait,\n  DependsOnSlotContext,\n  DependsOnSlotContextOpTrait,\n  UsesVarOffset,\n  UsesVarOffsetTrait,\n} from './traits';\n\n/**\n * An `o.Expression` subtype representing a logical expression in the intermediate representation.\n */\nexport type Expression =\n  | LexicalReadExpr\n  | ReferenceExpr\n  | ContextExpr\n  | NextContextExpr\n  | GetCurrentViewExpr\n  | RestoreViewExpr\n  | ResetViewExpr\n  | ReadVariableExpr\n  | PureFunctionExpr\n  | PureFunctionParameterExpr\n  | PipeBindingExpr\n  | PipeBindingVariadicExpr\n  | SafePropertyReadExpr\n  | SafeKeyedReadExpr\n  | SafeInvokeFunctionExpr\n  | EmptyExpr\n  | AssignTemporaryExpr\n  | ReadTemporaryExpr\n  | SlotLiteralExpr\n  | ConditionalCaseExpr\n  | ConstCollectedExpr\n  | TwoWayBindingSetExpr\n  | ContextLetReferenceExpr\n  | StoreLetExpr\n  | TrackContextExpr;\n\n/**\n * Transformer type which converts expressions into general `o.Expression`s (which may be an\n * identity transformation).\n */\nexport type ExpressionTransform = (expr: o.Expression, flags: VisitorContextFlag) => o.Expression;\n\n/**\n * Check whether a given `o.Expression` is a logical IR expression type.\n */\nexport function isIrExpression(expr: o.Expression): expr is Expression {\n  return expr instanceof ExpressionBase;\n}\n\n/**\n * Base type used for all logical IR expressions.\n */\nexport abstract class ExpressionBase extends o.Expression {\n  abstract readonly kind: ExpressionKind;\n\n  constructor(sourceSpan: ParseSourceSpan | null = null) {\n    super(null, sourceSpan);\n  }\n\n  /**\n   * Run the transformer against any nested expressions which may be present in this IR expression\n   * subtype.\n   */\n  abstract transformInternalExpressions(\n    transform: ExpressionTransform,\n    flags: VisitorContextFlag,\n  ): void;\n}\n\n/**\n * Logical expression representing a lexical read of a variable name.\n */\nexport class LexicalReadExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.LexicalRead;\n\n  constructor(readonly name: string) {\n    super();\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): void {}\n\n  override isEquivalent(other: LexicalReadExpr): boolean {\n    // We assume that the lexical reads are in the same context, which must be true for parent\n    // expressions to be equivalent.\n    // TODO: is this generally safe?\n    return this.name === other.name;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(): void {}\n\n  override clone(): LexicalReadExpr {\n    return new LexicalReadExpr(this.name);\n  }\n}\n\n/**\n * Runtime operation to retrieve the value of a local reference.\n */\nexport class ReferenceExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.Reference;\n\n  constructor(\n    readonly target: XrefId,\n    readonly targetSlot: SlotHandle,\n    readonly offset: number,\n  ) {\n    super();\n  }\n\n  override visitExpression(): void {}\n\n  override isEquivalent(e: o.Expression): boolean {\n    return e instanceof ReferenceExpr && e.target === this.target;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(): void {}\n\n  override clone(): ReferenceExpr {\n    return new ReferenceExpr(this.target, this.targetSlot, this.offset);\n  }\n}\n\nexport class StoreLetExpr\n  extends ExpressionBase\n  implements ConsumesVarsTrait, DependsOnSlotContextOpTrait\n{\n  override readonly kind = ExpressionKind.StoreLet;\n  readonly [ConsumesVarsTrait] = true;\n  readonly [DependsOnSlotContext] = true;\n\n  constructor(\n    readonly target: XrefId,\n    public value: o.Expression,\n    override sourceSpan: ParseSourceSpan,\n  ) {\n    super();\n  }\n\n  override visitExpression(): void {}\n\n  override isEquivalent(e: o.Expression): boolean {\n    return (\n      e instanceof StoreLetExpr && e.target === this.target && e.value.isEquivalent(this.value)\n    );\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(\n    transform: ExpressionTransform,\n    flags: VisitorContextFlag,\n  ): void {\n    this.value = transformExpressionsInExpression(this.value, transform, flags);\n  }\n\n  override clone(): StoreLetExpr {\n    return new StoreLetExpr(this.target, this.value, this.sourceSpan);\n  }\n}\n\nexport class ContextLetReferenceExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.ContextLetReference;\n\n  constructor(\n    readonly target: XrefId,\n    readonly targetSlot: SlotHandle,\n  ) {\n    super();\n  }\n\n  override visitExpression(): void {}\n\n  override isEquivalent(e: o.Expression): boolean {\n    return e instanceof ContextLetReferenceExpr && e.target === this.target;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(): void {}\n\n  override clone(): ContextLetReferenceExpr {\n    return new ContextLetReferenceExpr(this.target, this.targetSlot);\n  }\n}\n\n/**\n * A reference to the current view context (usually the `ctx` variable in a template function).\n */\nexport class ContextExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.Context;\n\n  constructor(readonly view: XrefId) {\n    super();\n  }\n\n  override visitExpression(): void {}\n\n  override isEquivalent(e: o.Expression): boolean {\n    return e instanceof ContextExpr && e.view === this.view;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(): void {}\n\n  override clone(): ContextExpr {\n    return new ContextExpr(this.view);\n  }\n}\n\n/**\n * A reference to the current view context inside a track function.\n */\nexport class TrackContextExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.TrackContext;\n\n  constructor(readonly view: XrefId) {\n    super();\n  }\n\n  override visitExpression(): void {}\n\n  override isEquivalent(e: o.Expression): boolean {\n    return e instanceof TrackContextExpr && e.view === this.view;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(): void {}\n\n  override clone(): TrackContextExpr {\n    return new TrackContextExpr(this.view);\n  }\n}\n\n/**\n * Runtime operation to navigate to the next view context in the view hierarchy.\n */\nexport class NextContextExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.NextContext;\n\n  steps = 1;\n\n  constructor() {\n    super();\n  }\n\n  override visitExpression(): void {}\n\n  override isEquivalent(e: o.Expression): boolean {\n    return e instanceof NextContextExpr && e.steps === this.steps;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(): void {}\n\n  override clone(): NextContextExpr {\n    const expr = new NextContextExpr();\n    expr.steps = this.steps;\n    return expr;\n  }\n}\n\n/**\n * Runtime operation to snapshot the current view context.\n *\n * The result of this operation can be stored in a variable and later used with the `RestoreView`\n * operation.\n */\nexport class GetCurrentViewExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.GetCurrentView;\n\n  constructor() {\n    super();\n  }\n\n  override visitExpression(): void {}\n\n  override isEquivalent(e: o.Expression): boolean {\n    return e instanceof GetCurrentViewExpr;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(): void {}\n\n  override clone(): GetCurrentViewExpr {\n    return new GetCurrentViewExpr();\n  }\n}\n\n/**\n * Runtime operation to restore a snapshotted view.\n */\nexport class RestoreViewExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.RestoreView;\n\n  constructor(public view: XrefId | o.Expression) {\n    super();\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): void {\n    if (typeof this.view !== 'number') {\n      this.view.visitExpression(visitor, context);\n    }\n  }\n\n  override isEquivalent(e: o.Expression): boolean {\n    if (!(e instanceof RestoreViewExpr) || typeof e.view !== typeof this.view) {\n      return false;\n    }\n\n    if (typeof this.view === 'number') {\n      return this.view === e.view;\n    } else {\n      return this.view.isEquivalent(e.view as o.Expression);\n    }\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(\n    transform: ExpressionTransform,\n    flags: VisitorContextFlag,\n  ): void {\n    if (typeof this.view !== 'number') {\n      this.view = transformExpressionsInExpression(this.view, transform, flags);\n    }\n  }\n\n  override clone(): RestoreViewExpr {\n    return new RestoreViewExpr(this.view instanceof o.Expression ? this.view.clone() : this.view);\n  }\n}\n\n/**\n * Runtime operation to reset the current view context after `RestoreView`.\n */\nexport class ResetViewExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.ResetView;\n\n  constructor(public expr: o.Expression) {\n    super();\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): any {\n    this.expr.visitExpression(visitor, context);\n  }\n\n  override isEquivalent(e: o.Expression): boolean {\n    return e instanceof ResetViewExpr && this.expr.isEquivalent(e.expr);\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(\n    transform: ExpressionTransform,\n    flags: VisitorContextFlag,\n  ): void {\n    this.expr = transformExpressionsInExpression(this.expr, transform, flags);\n  }\n\n  override clone(): ResetViewExpr {\n    return new ResetViewExpr(this.expr.clone());\n  }\n}\n\nexport class TwoWayBindingSetExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.TwoWayBindingSet;\n\n  constructor(\n    public target: o.Expression,\n    public value: o.Expression,\n  ) {\n    super();\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): void {\n    this.target.visitExpression(visitor, context);\n    this.value.visitExpression(visitor, context);\n  }\n\n  override isEquivalent(other: TwoWayBindingSetExpr): boolean {\n    return this.target.isEquivalent(other.target) && this.value.isEquivalent(other.value);\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(transform: ExpressionTransform, flags: VisitorContextFlag) {\n    this.target = transformExpressionsInExpression(this.target, transform, flags);\n    this.value = transformExpressionsInExpression(this.value, transform, flags);\n  }\n\n  override clone(): TwoWayBindingSetExpr {\n    return new TwoWayBindingSetExpr(this.target, this.value);\n  }\n}\n\n/**\n * Read of a variable declared as an `ir.VariableOp` and referenced through its `ir.XrefId`.\n */\nexport class ReadVariableExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.ReadVariable;\n  name: string | null = null;\n  constructor(readonly xref: XrefId) {\n    super();\n  }\n\n  override visitExpression(): void {}\n\n  override isEquivalent(other: o.Expression): boolean {\n    return other instanceof ReadVariableExpr && other.xref === this.xref;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(): void {}\n\n  override clone(): ReadVariableExpr {\n    const expr = new ReadVariableExpr(this.xref);\n    expr.name = this.name;\n    return expr;\n  }\n}\n\nexport class PureFunctionExpr\n  extends ExpressionBase\n  implements ConsumesVarsTrait, UsesVarOffsetTrait\n{\n  override readonly kind = ExpressionKind.PureFunctionExpr;\n  readonly [ConsumesVarsTrait] = true;\n  readonly [UsesVarOffset] = true;\n\n  varOffset: number | null = null;\n\n  /**\n   * The expression which should be memoized as a pure computation.\n   *\n   * This expression contains internal `PureFunctionParameterExpr`s, which are placeholders for the\n   * positional argument expressions in `args.\n   */\n  body: o.Expression | null;\n\n  /**\n   * Positional arguments to the pure function which will memoize the `body` expression, which act\n   * as memoization keys.\n   */\n  args: o.Expression[];\n\n  /**\n   * Once extracted to the `ConstantPool`, a reference to the function which defines the computation\n   * of `body`.\n   */\n  fn: o.Expression | null = null;\n\n  constructor(expression: o.Expression | null, args: o.Expression[]) {\n    super();\n    this.body = expression;\n    this.args = args;\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any) {\n    this.body?.visitExpression(visitor, context);\n    for (const arg of this.args) {\n      arg.visitExpression(visitor, context);\n    }\n  }\n\n  override isEquivalent(other: o.Expression): boolean {\n    if (!(other instanceof PureFunctionExpr) || other.args.length !== this.args.length) {\n      return false;\n    }\n\n    return (\n      other.body !== null &&\n      this.body !== null &&\n      other.body.isEquivalent(this.body) &&\n      other.args.every((arg, idx) => arg.isEquivalent(this.args[idx]))\n    );\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(\n    transform: ExpressionTransform,\n    flags: VisitorContextFlag,\n  ): void {\n    if (this.body !== null) {\n      // TODO: figure out if this is the right flag to pass here.\n      this.body = transformExpressionsInExpression(\n        this.body,\n        transform,\n        flags | VisitorContextFlag.InChildOperation,\n      );\n    } else if (this.fn !== null) {\n      this.fn = transformExpressionsInExpression(this.fn, transform, flags);\n    }\n\n    for (let i = 0; i < this.args.length; i++) {\n      this.args[i] = transformExpressionsInExpression(this.args[i], transform, flags);\n    }\n  }\n\n  override clone(): PureFunctionExpr {\n    const expr = new PureFunctionExpr(\n      this.body?.clone() ?? null,\n      this.args.map((arg) => arg.clone()),\n    );\n    expr.fn = this.fn?.clone() ?? null;\n    expr.varOffset = this.varOffset;\n    return expr;\n  }\n}\n\nexport class PureFunctionParameterExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.PureFunctionParameterExpr;\n\n  constructor(public index: number) {\n    super();\n  }\n\n  override visitExpression(): void {}\n\n  override isEquivalent(other: o.Expression): boolean {\n    return other instanceof PureFunctionParameterExpr && other.index === this.index;\n  }\n\n  override isConstant(): boolean {\n    return true;\n  }\n\n  override transformInternalExpressions(): void {}\n\n  override clone(): PureFunctionParameterExpr {\n    return new PureFunctionParameterExpr(this.index);\n  }\n}\n\nexport class PipeBindingExpr\n  extends ExpressionBase\n  implements ConsumesVarsTrait, UsesVarOffsetTrait\n{\n  override readonly kind = ExpressionKind.PipeBinding;\n  readonly [ConsumesVarsTrait] = true;\n  readonly [UsesVarOffset] = true;\n\n  varOffset: number | null = null;\n\n  constructor(\n    readonly target: XrefId,\n    readonly targetSlot: SlotHandle,\n    readonly name: string,\n    readonly args: o.Expression[],\n  ) {\n    super();\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): void {\n    for (const arg of this.args) {\n      arg.visitExpression(visitor, context);\n    }\n  }\n\n  override isEquivalent(): boolean {\n    return false;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(\n    transform: ExpressionTransform,\n    flags: VisitorContextFlag,\n  ): void {\n    for (let idx = 0; idx < this.args.length; idx++) {\n      this.args[idx] = transformExpressionsInExpression(this.args[idx], transform, flags);\n    }\n  }\n\n  override clone() {\n    const r = new PipeBindingExpr(\n      this.target,\n      this.targetSlot,\n      this.name,\n      this.args.map((a) => a.clone()),\n    );\n    r.varOffset = this.varOffset;\n    return r;\n  }\n}\n\nexport class PipeBindingVariadicExpr\n  extends ExpressionBase\n  implements ConsumesVarsTrait, UsesVarOffsetTrait\n{\n  override readonly kind = ExpressionKind.PipeBindingVariadic;\n  readonly [ConsumesVarsTrait] = true;\n  readonly [UsesVarOffset] = true;\n\n  varOffset: number | null = null;\n\n  constructor(\n    readonly target: XrefId,\n    readonly targetSlot: SlotHandle,\n    readonly name: string,\n    public args: o.Expression,\n    public numArgs: number,\n  ) {\n    super();\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): void {\n    this.args.visitExpression(visitor, context);\n  }\n\n  override isEquivalent(): boolean {\n    return false;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(\n    transform: ExpressionTransform,\n    flags: VisitorContextFlag,\n  ): void {\n    this.args = transformExpressionsInExpression(this.args, transform, flags);\n  }\n\n  override clone(): PipeBindingVariadicExpr {\n    const r = new PipeBindingVariadicExpr(\n      this.target,\n      this.targetSlot,\n      this.name,\n      this.args.clone(),\n      this.numArgs,\n    );\n    r.varOffset = this.varOffset;\n    return r;\n  }\n}\n\nexport class SafePropertyReadExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.SafePropertyRead;\n\n  constructor(\n    public receiver: o.Expression,\n    public name: string,\n  ) {\n    super();\n  }\n\n  // An alias for name, which allows other logic to handle property reads and keyed reads together.\n  get index() {\n    return this.name;\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): any {\n    this.receiver.visitExpression(visitor, context);\n  }\n\n  override isEquivalent(): boolean {\n    return false;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(\n    transform: ExpressionTransform,\n    flags: VisitorContextFlag,\n  ): void {\n    this.receiver = transformExpressionsInExpression(this.receiver, transform, flags);\n  }\n\n  override clone(): SafePropertyReadExpr {\n    return new SafePropertyReadExpr(this.receiver.clone(), this.name);\n  }\n}\n\nexport class SafeKeyedReadExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.SafeKeyedRead;\n\n  constructor(\n    public receiver: o.Expression,\n    public index: o.Expression,\n    sourceSpan: ParseSourceSpan | null,\n  ) {\n    super(sourceSpan);\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): any {\n    this.receiver.visitExpression(visitor, context);\n    this.index.visitExpression(visitor, context);\n  }\n\n  override isEquivalent(): boolean {\n    return false;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(\n    transform: ExpressionTransform,\n    flags: VisitorContextFlag,\n  ): void {\n    this.receiver = transformExpressionsInExpression(this.receiver, transform, flags);\n    this.index = transformExpressionsInExpression(this.index, transform, flags);\n  }\n\n  override clone(): SafeKeyedReadExpr {\n    return new SafeKeyedReadExpr(this.receiver.clone(), this.index.clone(), this.sourceSpan);\n  }\n}\n\nexport class SafeInvokeFunctionExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.SafeInvokeFunction;\n\n  constructor(\n    public receiver: o.Expression,\n    public args: o.Expression[],\n  ) {\n    super();\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): any {\n    this.receiver.visitExpression(visitor, context);\n    for (const a of this.args) {\n      a.visitExpression(visitor, context);\n    }\n  }\n\n  override isEquivalent(): boolean {\n    return false;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(\n    transform: ExpressionTransform,\n    flags: VisitorContextFlag,\n  ): void {\n    this.receiver = transformExpressionsInExpression(this.receiver, transform, flags);\n    for (let i = 0; i < this.args.length; i++) {\n      this.args[i] = transformExpressionsInExpression(this.args[i], transform, flags);\n    }\n  }\n\n  override clone(): SafeInvokeFunctionExpr {\n    return new SafeInvokeFunctionExpr(\n      this.receiver.clone(),\n      this.args.map((a) => a.clone()),\n    );\n  }\n}\n\nexport class SafeTernaryExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.SafeTernaryExpr;\n\n  constructor(\n    public guard: o.Expression,\n    public expr: o.Expression,\n  ) {\n    super();\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): any {\n    this.guard.visitExpression(visitor, context);\n    this.expr.visitExpression(visitor, context);\n  }\n\n  override isEquivalent(): boolean {\n    return false;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(\n    transform: ExpressionTransform,\n    flags: VisitorContextFlag,\n  ): void {\n    this.guard = transformExpressionsInExpression(this.guard, transform, flags);\n    this.expr = transformExpressionsInExpression(this.expr, transform, flags);\n  }\n\n  override clone(): SafeTernaryExpr {\n    return new SafeTernaryExpr(this.guard.clone(), this.expr.clone());\n  }\n}\n\nexport class EmptyExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.EmptyExpr;\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): any {}\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof EmptyExpr;\n  }\n\n  override isConstant() {\n    return true;\n  }\n\n  override clone(): EmptyExpr {\n    return new EmptyExpr();\n  }\n\n  override transformInternalExpressions(): void {}\n}\n\nexport class AssignTemporaryExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.AssignTemporaryExpr;\n\n  public name: string | null = null;\n\n  constructor(\n    public expr: o.Expression,\n    public xref: XrefId,\n  ) {\n    super();\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): any {\n    this.expr.visitExpression(visitor, context);\n  }\n\n  override isEquivalent(): boolean {\n    return false;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(\n    transform: ExpressionTransform,\n    flags: VisitorContextFlag,\n  ): void {\n    this.expr = transformExpressionsInExpression(this.expr, transform, flags);\n  }\n\n  override clone(): AssignTemporaryExpr {\n    const a = new AssignTemporaryExpr(this.expr.clone(), this.xref);\n    a.name = this.name;\n    return a;\n  }\n}\n\nexport class ReadTemporaryExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.ReadTemporaryExpr;\n\n  public name: string | null = null;\n\n  constructor(public xref: XrefId) {\n    super();\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): any {}\n\n  override isEquivalent(): boolean {\n    return this.xref === this.xref;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(\n    transform: ExpressionTransform,\n    flags: VisitorContextFlag,\n  ): void {}\n\n  override clone(): ReadTemporaryExpr {\n    const r = new ReadTemporaryExpr(this.xref);\n    r.name = this.name;\n    return r;\n  }\n}\n\nexport class SlotLiteralExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.SlotLiteralExpr;\n\n  constructor(readonly slot: SlotHandle) {\n    super();\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): any {}\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof SlotLiteralExpr && e.slot === this.slot;\n  }\n\n  override isConstant() {\n    return true;\n  }\n\n  override clone(): SlotLiteralExpr {\n    return new SlotLiteralExpr(this.slot);\n  }\n\n  override transformInternalExpressions(): void {}\n}\n\nexport class ConditionalCaseExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.ConditionalCase;\n\n  /**\n   * Create an expression for one branch of a conditional.\n   * @param expr The expression to be tested for this case. Might be null, as in an `else` case.\n   * @param target The Xref of the view to be displayed if this condition is true.\n   */\n  constructor(\n    public expr: o.Expression | null,\n    readonly target: XrefId,\n    readonly targetSlot: SlotHandle,\n    readonly alias: t.Variable | null = null,\n  ) {\n    super();\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): any {\n    if (this.expr !== null) {\n      this.expr.visitExpression(visitor, context);\n    }\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof ConditionalCaseExpr && e.expr === this.expr;\n  }\n\n  override isConstant() {\n    return true;\n  }\n\n  override clone(): ConditionalCaseExpr {\n    return new ConditionalCaseExpr(this.expr, this.target, this.targetSlot);\n  }\n\n  override transformInternalExpressions(\n    transform: ExpressionTransform,\n    flags: VisitorContextFlag,\n  ): void {\n    if (this.expr !== null) {\n      this.expr = transformExpressionsInExpression(this.expr, transform, flags);\n    }\n  }\n}\n\nexport class ConstCollectedExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.ConstCollected;\n\n  constructor(public expr: o.Expression) {\n    super();\n  }\n\n  override transformInternalExpressions(\n    transform: ExpressionTransform,\n    flags: VisitorContextFlag,\n  ): void {\n    this.expr = transform(this.expr, flags);\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any) {\n    this.expr.visitExpression(visitor, context);\n  }\n\n  override isEquivalent(e: o.Expression): boolean {\n    if (!(e instanceof ConstCollectedExpr)) {\n      return false;\n    }\n    return this.expr.isEquivalent(e.expr);\n  }\n\n  override isConstant(): boolean {\n    return this.expr.isConstant();\n  }\n\n  override clone(): ConstCollectedExpr {\n    return new ConstCollectedExpr(this.expr);\n  }\n}\n\n/**\n * Visits all `Expression`s in the AST of `op` with the `visitor` function.\n */\nexport function visitExpressionsInOp(\n  op: CreateOp | UpdateOp,\n  visitor: (expr: o.Expression, flags: VisitorContextFlag) => void,\n): void {\n  transformExpressionsInOp(\n    op,\n    (expr, flags) => {\n      visitor(expr, flags);\n      return expr;\n    },\n    VisitorContextFlag.None,\n  );\n}\n\nexport enum VisitorContextFlag {\n  None = 0b0000,\n  InChildOperation = 0b0001,\n}\n\nfunction transformExpressionsInInterpolation(\n  interpolation: Interpolation,\n  transform: ExpressionTransform,\n  flags: VisitorContextFlag,\n) {\n  for (let i = 0; i < interpolation.expressions.length; i++) {\n    interpolation.expressions[i] = transformExpressionsInExpression(\n      interpolation.expressions[i],\n      transform,\n      flags,\n    );\n  }\n}\n\n/**\n * Transform all `Expression`s in the AST of `op` with the `transform` function.\n *\n * All such operations will be replaced with the result of applying `transform`, which may be an\n * identity transformation.\n */\nexport function transformExpressionsInOp(\n  op: CreateOp | UpdateOp,\n  transform: ExpressionTransform,\n  flags: VisitorContextFlag,\n): void {\n  switch (op.kind) {\n    case OpKind.StyleProp:\n    case OpKind.StyleMap:\n    case OpKind.ClassProp:\n    case OpKind.ClassMap:\n    case OpKind.AnimationString:\n    case OpKind.AnimationBinding:\n    case OpKind.Binding:\n      if (op.expression instanceof Interpolation) {\n        transformExpressionsInInterpolation(op.expression, transform, flags);\n      } else {\n        op.expression = transformExpressionsInExpression(op.expression, transform, flags);\n      }\n      break;\n    case OpKind.Property:\n    case OpKind.DomProperty:\n    case OpKind.Attribute:\n      if (op.expression instanceof Interpolation) {\n        transformExpressionsInInterpolation(op.expression, transform, flags);\n      } else {\n        op.expression = transformExpressionsInExpression(op.expression, transform, flags);\n      }\n      op.sanitizer =\n        op.sanitizer && transformExpressionsInExpression(op.sanitizer, transform, flags);\n      break;\n    case OpKind.TwoWayProperty:\n      op.expression = transformExpressionsInExpression(op.expression, transform, flags);\n      op.sanitizer =\n        op.sanitizer && transformExpressionsInExpression(op.sanitizer, transform, flags);\n      break;\n    case OpKind.I18nExpression:\n      op.expression = transformExpressionsInExpression(op.expression, transform, flags);\n      break;\n    case OpKind.InterpolateText:\n      transformExpressionsInInterpolation(op.interpolation, transform, flags);\n      break;\n    case OpKind.Statement:\n      transformExpressionsInStatement(op.statement, transform, flags);\n      break;\n    case OpKind.Variable:\n      op.initializer = transformExpressionsInExpression(op.initializer, transform, flags);\n      break;\n    case OpKind.Conditional:\n      for (const condition of op.conditions) {\n        if (condition.expr === null) {\n          // This is a default case.\n          continue;\n        }\n        condition.expr = transformExpressionsInExpression(condition.expr, transform, flags);\n      }\n      if (op.processed !== null) {\n        op.processed = transformExpressionsInExpression(op.processed, transform, flags);\n      }\n      if (op.contextValue !== null) {\n        op.contextValue = transformExpressionsInExpression(op.contextValue, transform, flags);\n      }\n      break;\n    case OpKind.Animation:\n    case OpKind.AnimationListener:\n    case OpKind.Listener:\n    case OpKind.TwoWayListener:\n      for (const innerOp of op.handlerOps) {\n        transformExpressionsInOp(innerOp, transform, flags | VisitorContextFlag.InChildOperation);\n      }\n      break;\n    case OpKind.ExtractedAttribute:\n      op.expression =\n        op.expression && transformExpressionsInExpression(op.expression, transform, flags);\n      op.trustedValueFn =\n        op.trustedValueFn && transformExpressionsInExpression(op.trustedValueFn, transform, flags);\n      break;\n    case OpKind.RepeaterCreate:\n      if (op.trackByOps === null) {\n        op.track = transformExpressionsInExpression(op.track, transform, flags);\n      } else {\n        for (const innerOp of op.trackByOps) {\n          transformExpressionsInOp(innerOp, transform, flags | VisitorContextFlag.InChildOperation);\n        }\n      }\n      if (op.trackByFn !== null) {\n        op.trackByFn = transformExpressionsInExpression(op.trackByFn, transform, flags);\n      }\n      break;\n    case OpKind.Repeater:\n      op.collection = transformExpressionsInExpression(op.collection, transform, flags);\n      break;\n    case OpKind.Defer:\n      if (op.loadingConfig !== null) {\n        op.loadingConfig = transformExpressionsInExpression(op.loadingConfig, transform, flags);\n      }\n      if (op.placeholderConfig !== null) {\n        op.placeholderConfig = transformExpressionsInExpression(\n          op.placeholderConfig,\n          transform,\n          flags,\n        );\n      }\n      if (op.resolverFn !== null) {\n        op.resolverFn = transformExpressionsInExpression(op.resolverFn, transform, flags);\n      }\n      break;\n    case OpKind.I18nMessage:\n      for (const [placeholder, expr] of op.params) {\n        op.params.set(placeholder, transformExpressionsInExpression(expr, transform, flags));\n      }\n      for (const [placeholder, expr] of op.postprocessingParams) {\n        op.postprocessingParams.set(\n          placeholder,\n          transformExpressionsInExpression(expr, transform, flags),\n        );\n      }\n      break;\n    case OpKind.DeferWhen:\n      op.expr = transformExpressionsInExpression(op.expr, transform, flags);\n      break;\n    case OpKind.StoreLet:\n      op.value = transformExpressionsInExpression(op.value, transform, flags);\n      break;\n    case OpKind.Advance:\n    case OpKind.Container:\n    case OpKind.ContainerEnd:\n    case OpKind.ContainerStart:\n    case OpKind.DeferOn:\n    case OpKind.DisableBindings:\n    case OpKind.Element:\n    case OpKind.ElementEnd:\n    case OpKind.ElementStart:\n    case OpKind.EnableBindings:\n    case OpKind.I18n:\n    case OpKind.I18nApply:\n    case OpKind.I18nContext:\n    case OpKind.I18nEnd:\n    case OpKind.I18nStart:\n    case OpKind.IcuEnd:\n    case OpKind.IcuStart:\n    case OpKind.Namespace:\n    case OpKind.Pipe:\n    case OpKind.Projection:\n    case OpKind.ProjectionDef:\n    case OpKind.Template:\n    case OpKind.Text:\n    case OpKind.I18nAttributes:\n    case OpKind.IcuPlaceholder:\n    case OpKind.DeclareLet:\n    case OpKind.SourceLocation:\n    case OpKind.ConditionalCreate:\n    case OpKind.ConditionalBranchCreate:\n      // These operations contain no expressions.\n      break;\n    default:\n      throw new Error(`AssertionError: transformExpressionsInOp doesn't handle ${OpKind[op.kind]}`);\n  }\n}\n\n/**\n * Transform all `Expression`s in the AST of `expr` with the `transform` function.\n *\n * All such operations will be replaced with the result of applying `transform`, which may be an\n * identity transformation.\n */\nexport function transformExpressionsInExpression(\n  expr: o.Expression,\n  transform: ExpressionTransform,\n  flags: VisitorContextFlag,\n): o.Expression {\n  if (expr instanceof ExpressionBase) {\n    expr.transformInternalExpressions(transform, flags);\n  } else if (expr instanceof o.BinaryOperatorExpr) {\n    expr.lhs = transformExpressionsInExpression(expr.lhs, transform, flags);\n    expr.rhs = transformExpressionsInExpression(expr.rhs, transform, flags);\n  } else if (expr instanceof o.UnaryOperatorExpr) {\n    expr.expr = transformExpressionsInExpression(expr.expr, transform, flags);\n  } else if (expr instanceof o.ReadPropExpr) {\n    expr.receiver = transformExpressionsInExpression(expr.receiver, transform, flags);\n  } else if (expr instanceof o.ReadKeyExpr) {\n    expr.receiver = transformExpressionsInExpression(expr.receiver, transform, flags);\n    expr.index = transformExpressionsInExpression(expr.index, transform, flags);\n  } else if (expr instanceof o.InvokeFunctionExpr) {\n    expr.fn = transformExpressionsInExpression(expr.fn, transform, flags);\n    for (let i = 0; i < expr.args.length; i++) {\n      expr.args[i] = transformExpressionsInExpression(expr.args[i], transform, flags);\n    }\n  } else if (expr instanceof o.LiteralArrayExpr) {\n    for (let i = 0; i < expr.entries.length; i++) {\n      expr.entries[i] = transformExpressionsInExpression(expr.entries[i], transform, flags);\n    }\n  } else if (expr instanceof o.LiteralMapExpr) {\n    for (let i = 0; i < expr.entries.length; i++) {\n      expr.entries[i].value = transformExpressionsInExpression(\n        expr.entries[i].value,\n        transform,\n        flags,\n      );\n    }\n  } else if (expr instanceof o.ConditionalExpr) {\n    expr.condition = transformExpressionsInExpression(expr.condition, transform, flags);\n    expr.trueCase = transformExpressionsInExpression(expr.trueCase, transform, flags);\n    if (expr.falseCase !== null) {\n      expr.falseCase = transformExpressionsInExpression(expr.falseCase, transform, flags);\n    }\n  } else if (expr instanceof o.TypeofExpr) {\n    expr.expr = transformExpressionsInExpression(expr.expr, transform, flags);\n  } else if (expr instanceof o.VoidExpr) {\n    expr.expr = transformExpressionsInExpression(expr.expr, transform, flags);\n  } else if (expr instanceof o.LocalizedString) {\n    for (let i = 0; i < expr.expressions.length; i++) {\n      expr.expressions[i] = transformExpressionsInExpression(expr.expressions[i], transform, flags);\n    }\n  } else if (expr instanceof o.NotExpr) {\n    expr.condition = transformExpressionsInExpression(expr.condition, transform, flags);\n  } else if (expr instanceof o.TaggedTemplateLiteralExpr) {\n    expr.tag = transformExpressionsInExpression(expr.tag, transform, flags);\n    expr.template.expressions = expr.template.expressions.map((e) =>\n      transformExpressionsInExpression(e, transform, flags),\n    );\n  } else if (expr instanceof o.ArrowFunctionExpr) {\n    if (Array.isArray(expr.body)) {\n      for (let i = 0; i < expr.body.length; i++) {\n        transformExpressionsInStatement(expr.body[i], transform, flags);\n      }\n    } else {\n      expr.body = transformExpressionsInExpression(expr.body, transform, flags);\n    }\n  } else if (expr instanceof o.WrappedNodeExpr) {\n    // TODO: Do we need to transform any TS nodes nested inside of this expression?\n  } else if (expr instanceof o.TemplateLiteralExpr) {\n    for (let i = 0; i < expr.expressions.length; i++) {\n      expr.expressions[i] = transformExpressionsInExpression(expr.expressions[i], transform, flags);\n    }\n  } else if (expr instanceof o.ParenthesizedExpr) {\n    expr.expr = transformExpressionsInExpression(expr.expr, transform, flags);\n  } else if (\n    expr instanceof o.ReadVarExpr ||\n    expr instanceof o.ExternalExpr ||\n    expr instanceof o.LiteralExpr\n  ) {\n    // No action for these types.\n  } else {\n    throw new Error(`Unhandled expression kind: ${expr.constructor.name}`);\n  }\n  return transform(expr, flags);\n}\n\n/**\n * Transform all `Expression`s in the AST of `stmt` with the `transform` function.\n *\n * All such operations will be replaced with the result of applying `transform`, which may be an\n * identity transformation.\n */\nexport function transformExpressionsInStatement(\n  stmt: o.Statement,\n  transform: ExpressionTransform,\n  flags: VisitorContextFlag,\n): void {\n  if (stmt instanceof o.ExpressionStatement) {\n    stmt.expr = transformExpressionsInExpression(stmt.expr, transform, flags);\n  } else if (stmt instanceof o.ReturnStatement) {\n    stmt.value = transformExpressionsInExpression(stmt.value, transform, flags);\n  } else if (stmt instanceof o.DeclareVarStmt) {\n    if (stmt.value !== undefined) {\n      stmt.value = transformExpressionsInExpression(stmt.value, transform, flags);\n    }\n  } else if (stmt instanceof o.IfStmt) {\n    stmt.condition = transformExpressionsInExpression(stmt.condition, transform, flags);\n    for (const caseStatement of stmt.trueCase) {\n      transformExpressionsInStatement(caseStatement, transform, flags);\n    }\n    for (const caseStatement of stmt.falseCase) {\n      transformExpressionsInStatement(caseStatement, transform, flags);\n    }\n  } else {\n    throw new Error(`Unhandled statement kind: ${stmt.constructor.name}`);\n  }\n}\n\n/**\n * Checks whether the given expression is a string literal.\n */\nexport function isStringLiteral(expr: o.Expression): expr is o.LiteralExpr & {value: string} {\n  return expr instanceof o.LiteralExpr && typeof expr.value === 'string';\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {OpKind} from './enums';\n\n/**\n * Branded type for a cross-reference ID. During ingest, `XrefId`s are generated to link together\n * different IR operations which need to reference each other.\n */\nexport type XrefId = number & {__brand: 'XrefId'};\n\n/**\n * Base interface for semantic operations being performed within a template.\n *\n * @param OpT a specific narrower type of `Op` (for example, creation operations) which this\n *     specific subtype of `Op` can be linked with in a linked list.\n */\nexport interface Op<OpT extends Op<OpT>> {\n  /**\n   * All operations have a distinct kind.\n   */\n  kind: OpKind;\n\n  /**\n   * The previous operation in the linked list, if any.\n   *\n   * This is `null` for operation nodes not currently in a list, or for the special head/tail nodes.\n   */\n  prev: OpT | null;\n\n  /**\n   * The next operation in the linked list, if any.\n   *\n   * This is `null` for operation nodes not currently in a list, or for the special head/tail nodes.\n   */\n  next: OpT | null;\n\n  /**\n   * Debug id of the list to which this node currently belongs, or `null` if this node is not part\n   * of a list.\n   */\n  debugListId: number | null;\n}\n\n/**\n * A linked list of `Op` nodes of a given subtype.\n *\n * @param OpT specific subtype of `Op` nodes which this list contains.\n */\nexport class OpList<OpT extends Op<OpT>> {\n  static nextListId = 0;\n\n  /**\n   * Debug ID of this `OpList` instance.\n   */\n  readonly debugListId = OpList.nextListId++;\n\n  // OpList uses static head/tail nodes of a special `ListEnd` type.\n  // This avoids the need for special casing of the first and last list\n  // elements in all list operations.\n  readonly head: OpT = {\n    kind: OpKind.ListEnd,\n    next: null,\n    prev: null,\n    debugListId: this.debugListId,\n  } as OpT;\n\n  readonly tail = {\n    kind: OpKind.ListEnd,\n    next: null,\n    prev: null,\n    debugListId: this.debugListId,\n  } as OpT;\n\n  constructor() {\n    // Link `head` and `tail` together at the start (list is empty).\n    this.head.next = this.tail;\n    this.tail.prev = this.head;\n  }\n\n  /**\n   * Push a new operation to the tail of the list.\n   */\n  push(op: OpT | Array<OpT>): void {\n    if (Array.isArray(op)) {\n      for (const o of op) {\n        this.push(o);\n      }\n      return;\n    }\n\n    OpList.assertIsNotEnd(op);\n    OpList.assertIsUnowned(op);\n\n    op.debugListId = this.debugListId;\n\n    // The old \"previous\" node (which might be the head, if the list is empty).\n    const oldLast = this.tail.prev!;\n\n    // Insert `op` following the old last node.\n    op.prev = oldLast;\n    oldLast.next = op;\n\n    // Connect `op` with the list tail.\n    op.next = this.tail;\n    this.tail.prev = op;\n  }\n\n  /**\n   * Prepend one or more nodes to the start of the list.\n   */\n  prepend(ops: OpT[]): void {\n    if (ops.length === 0) {\n      return;\n    }\n\n    for (const op of ops) {\n      OpList.assertIsNotEnd(op);\n      OpList.assertIsUnowned(op);\n\n      op.debugListId = this.debugListId;\n    }\n\n    const first = this.head.next!;\n\n    let prev = this.head;\n    for (const op of ops) {\n      prev.next = op;\n      op.prev = prev;\n\n      prev = op;\n    }\n\n    prev.next = first;\n    first.prev = prev;\n  }\n\n  /**\n   * `OpList` is iterable via the iteration protocol.\n   *\n   * It's safe to mutate the part of the list that has already been returned by the iterator, up to\n   * and including the last operation returned. Mutations beyond that point _may_ be safe, but may\n   * also corrupt the iteration position and should be avoided.\n   */\n  *[Symbol.iterator](): Generator<OpT> {\n    let current = this.head.next!;\n    while (current !== this.tail) {\n      // Guards against corruption of the iterator state by mutations to the tail of the list during\n      // iteration.\n      OpList.assertIsOwned(current, this.debugListId);\n\n      const next = current.next!;\n      yield current;\n      current = next;\n    }\n  }\n\n  *reversed(): Generator<OpT> {\n    let current = this.tail.prev!;\n    while (current !== this.head) {\n      OpList.assertIsOwned(current, this.debugListId);\n\n      const prev = current.prev!;\n      yield current;\n      current = prev;\n    }\n  }\n\n  /**\n   * Replace `oldOp` with `newOp` in the list.\n   */\n  static replace<OpT extends Op<OpT>>(oldOp: OpT, newOp: OpT): void {\n    OpList.assertIsNotEnd(oldOp);\n    OpList.assertIsNotEnd(newOp);\n\n    OpList.assertIsOwned(oldOp);\n    OpList.assertIsUnowned(newOp);\n\n    newOp.debugListId = oldOp.debugListId;\n    if (oldOp.prev !== null) {\n      oldOp.prev.next = newOp;\n      newOp.prev = oldOp.prev;\n    }\n    if (oldOp.next !== null) {\n      oldOp.next.prev = newOp;\n      newOp.next = oldOp.next;\n    }\n    oldOp.debugListId = null;\n    oldOp.prev = null;\n    oldOp.next = null;\n  }\n\n  /**\n   * Replace `oldOp` with some number of new operations in the list (which may include `oldOp`).\n   */\n  static replaceWithMany<OpT extends Op<OpT>>(oldOp: OpT, newOps: OpT[]): void {\n    if (newOps.length === 0) {\n      // Replacing with an empty list -> pure removal.\n      OpList.remove(oldOp);\n      return;\n    }\n\n    OpList.assertIsNotEnd(oldOp);\n    OpList.assertIsOwned(oldOp);\n\n    const listId = oldOp.debugListId;\n    oldOp.debugListId = null;\n\n    for (const newOp of newOps) {\n      OpList.assertIsNotEnd(newOp);\n\n      // `newOp` might be `oldOp`, but at this point it's been marked as unowned.\n      OpList.assertIsUnowned(newOp);\n    }\n\n    // It should be safe to reuse `oldOp` in the `newOps` list - maybe you want to sandwich an\n    // operation between two new ops.\n    const {prev: oldPrev, next: oldNext} = oldOp;\n    oldOp.prev = null;\n    oldOp.next = null;\n\n    let prev: OpT = oldPrev!;\n    for (const newOp of newOps) {\n      OpList.assertIsUnowned(newOp);\n      newOp.debugListId = listId;\n\n      prev!.next = newOp;\n      newOp.prev = prev;\n\n      // This _should_ be the case, but set it just in case.\n      newOp.next = null;\n\n      prev = newOp;\n    }\n    // At the end of iteration, `prev` holds the last node in the list.\n    const first = newOps[0]!;\n    const last = prev!;\n\n    // Replace `oldOp` with the chain `first` -> `last`.\n    if (oldPrev !== null) {\n      oldPrev.next = first;\n      first.prev = oldPrev;\n    }\n\n    if (oldNext !== null) {\n      oldNext.prev = last;\n      last.next = oldNext;\n    }\n  }\n\n  /**\n   * Remove the given node from the list which contains it.\n   */\n  static remove<OpT extends Op<OpT>>(op: OpT): void {\n    OpList.assertIsNotEnd(op);\n    OpList.assertIsOwned(op);\n\n    op.prev!.next = op.next;\n    op.next!.prev = op.prev;\n\n    // Break any link between the node and this list to safeguard against its usage in future\n    // operations.\n    op.debugListId = null;\n    op.prev = null;\n    op.next = null;\n  }\n\n  /**\n   * Insert `op` before `target`.\n   */\n  static insertBefore<OpT extends Op<OpT>>(op: OpT | OpT[], target: OpT): void {\n    if (Array.isArray(op)) {\n      for (const o of op) {\n        OpList.insertBefore(o, target);\n      }\n      return;\n    }\n\n    OpList.assertIsOwned(target);\n    if (target.prev === null) {\n      throw new Error(`AssertionError: illegal operation on list start`);\n    }\n\n    OpList.assertIsNotEnd(op);\n\n    OpList.assertIsUnowned(op);\n\n    op.debugListId = target.debugListId;\n\n    // Just in case.\n    op.prev = null;\n\n    target.prev!.next = op;\n    op.prev = target.prev;\n\n    op.next = target;\n    target.prev = op;\n  }\n\n  /**\n   * Insert `op` after `target`.\n   */\n  static insertAfter<OpT extends Op<OpT>>(op: OpT, target: OpT): void {\n    OpList.assertIsOwned(target);\n    if (target.next === null) {\n      throw new Error(`AssertionError: illegal operation on list end`);\n    }\n\n    OpList.assertIsNotEnd(op);\n\n    OpList.assertIsUnowned(op);\n\n    op.debugListId = target.debugListId;\n\n    target.next.prev = op;\n    op.next = target.next;\n\n    op.prev = target;\n    target.next = op;\n  }\n\n  /**\n   * Asserts that `op` does not currently belong to a list.\n   */\n  static assertIsUnowned<OpT extends Op<OpT>>(op: OpT): void {\n    if (op.debugListId !== null) {\n      throw new Error(`AssertionError: illegal operation on owned node: ${OpKind[op.kind]}`);\n    }\n  }\n\n  /**\n   * Asserts that `op` currently belongs to a list. If `byList` is passed, `op` is asserted to\n   * specifically belong to that list.\n   */\n  static assertIsOwned<OpT extends Op<OpT>>(op: OpT, byList?: number): void {\n    if (op.debugListId === null) {\n      throw new Error(`AssertionError: illegal operation on unowned node: ${OpKind[op.kind]}`);\n    } else if (byList !== undefined && op.debugListId !== byList) {\n      throw new Error(\n        `AssertionError: node belongs to the wrong list (expected ${byList}, actual ${op.debugListId})`,\n      );\n    }\n  }\n\n  /**\n   * Asserts that `op` is not a special `ListEnd` node.\n   */\n  static assertIsNotEnd<OpT extends Op<OpT>>(op: OpT): void {\n    if (op.kind === OpKind.ListEnd) {\n      throw new Error(`AssertionError: illegal operation on list head or tail`);\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nexport class SlotHandle {\n  slot: number | null = null;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {SecurityContext} from '../../../../../core';\nimport * as i18n from '../../../../../i18n/i18n_ast';\nimport * as o from '../../../../../output/output_ast';\nimport {ParseSourceSpan} from '../../../../../parse_util';\nimport {\n  AnimationKind,\n  BindingKind,\n  DeferOpModifierKind,\n  DeferTriggerKind,\n  I18nContextKind,\n  I18nParamValueFlags,\n  Namespace,\n  OpKind,\n  TDeferDetailsFlags,\n  TemplateKind,\n} from '../enums';\nimport {SlotHandle} from '../handle';\nimport {Op, OpList, XrefId} from '../operations';\nimport {\n  ConsumesSlotOpTrait,\n  ConsumesVarsTrait,\n  TRAIT_CONSUMES_SLOT,\n  TRAIT_CONSUMES_VARS,\n} from '../traits';\n\nimport {ListEndOp, NEW_OP, StatementOp, VariableOp} from './shared';\n\nimport type {Interpolation, UpdateOp} from './update';\n\n/**\n * An operation usable on the creation side of the IR.\n */\nexport type CreateOp =\n  | ListEndOp<CreateOp>\n  | StatementOp<CreateOp>\n  | ElementOp\n  | ElementStartOp\n  | ElementEndOp\n  | ContainerOp\n  | ContainerStartOp\n  | ContainerEndOp\n  | TemplateOp\n  | EnableBindingsOp\n  | DisableBindingsOp\n  | TextOp\n  | ListenerOp\n  | TwoWayListenerOp\n  | PipeOp\n  | VariableOp<CreateOp>\n  | NamespaceOp\n  | ProjectionDefOp\n  | ProjectionOp\n  | ExtractedAttributeOp\n  | DeferOp\n  | DeferOnOp\n  | ConditionalCreateOp\n  | ConditionalBranchCreateOp\n  | RepeaterCreateOp\n  | I18nMessageOp\n  | I18nOp\n  | I18nStartOp\n  | I18nEndOp\n  | IcuStartOp\n  | IcuEndOp\n  | IcuPlaceholderOp\n  | I18nContextOp\n  | I18nAttributesOp\n  | DeclareLetOp\n  | AnimationListenerOp\n  | AnimationStringOp\n  | AnimationOp\n  | SourceLocationOp;\n\n/**\n * An operation representing the creation of an element or container.\n */\nexport type ElementOrContainerOps =\n  | ElementOp\n  | ElementStartOp\n  | ContainerOp\n  | ContainerStartOp\n  | TemplateOp\n  | RepeaterCreateOp\n  | ConditionalCreateOp\n  | ConditionalBranchCreateOp;\n\n/**\n * The set of OpKinds that represent the creation of an element or container\n */\nconst elementContainerOpKinds = new Set([\n  OpKind.Element,\n  OpKind.ElementStart,\n  OpKind.Container,\n  OpKind.ContainerStart,\n  OpKind.Template,\n  OpKind.RepeaterCreate,\n  OpKind.ConditionalCreate,\n  OpKind.ConditionalBranchCreate,\n]);\n\n/**\n * Checks whether the given operation represents the creation of an element or container.\n */\nexport function isElementOrContainerOp(op: CreateOp): op is ElementOrContainerOps {\n  return elementContainerOpKinds.has(op.kind);\n}\n\n/**\n * Representation of a local reference on an element.\n */\nexport interface LocalRef {\n  /**\n   * User-defined name of the local ref variable.\n   */\n  name: string;\n\n  /**\n   * Target of the local reference variable (often `''`).\n   */\n  target: string;\n}\n\n/**\n * Base interface for `Element`, `ElementStart`, and `Template` operations, containing common fields\n * used to represent their element-like nature.\n */\nexport interface ElementOrContainerOpBase extends Op<CreateOp>, ConsumesSlotOpTrait {\n  kind: ElementOrContainerOps['kind'];\n\n  /**\n   * `XrefId` allocated for this element.\n   *\n   * This ID is used to reference this element from other IR structures.\n   */\n  xref: XrefId;\n\n  /**\n   * Attributes of various kinds on this element. Represented as a `ConstIndex` pointer into the\n   * shared `consts` array of the component compilation.\n   */\n  attributes: ConstIndex | null;\n\n  /**\n   * Local references to this element.\n   *\n   * Before local ref processing, this is an array of `LocalRef` declarations.\n   *\n   * After processing, it's a `ConstIndex` pointer into the shared `consts` array of the component\n   * compilation.\n   */\n  localRefs: LocalRef[] | ConstIndex | null;\n\n  /**\n   * Whether this container is marked `ngNonBindable`, which disabled Angular binding for itself and\n   * all descendants.\n   */\n  nonBindable: boolean;\n\n  /**\n   * The span of the element's start tag.\n   */\n  startSourceSpan: ParseSourceSpan;\n\n  /**\n   * The whole source span of the element, including children.\n   */\n  wholeSourceSpan: ParseSourceSpan;\n}\n\nexport interface ElementOpBase extends ElementOrContainerOpBase {\n  kind:\n    | OpKind.Element\n    | OpKind.ElementStart\n    | OpKind.Template\n    | OpKind.RepeaterCreate\n    | OpKind.ConditionalCreate\n    | OpKind.ConditionalBranchCreate;\n\n  /**\n   * The HTML tag name for this element.\n   */\n  tag: string | null;\n\n  /**\n   * The namespace of this element, which controls the preceding namespace instruction.\n   */\n  namespace: Namespace;\n}\n\n/**\n * Logical operation representing the start of an element in the creation IR.\n */\nexport interface ElementStartOp extends ElementOpBase {\n  kind: OpKind.ElementStart;\n\n  /**\n   * The i18n placeholder data associated with this element.\n   */\n  i18nPlaceholder?: i18n.TagPlaceholder;\n}\n\n/**\n * Create an `ElementStartOp`.\n */\nexport function createElementStartOp(\n  tag: string,\n  xref: XrefId,\n  namespace: Namespace,\n  i18nPlaceholder: i18n.TagPlaceholder | undefined,\n  startSourceSpan: ParseSourceSpan,\n  wholeSourceSpan: ParseSourceSpan,\n): ElementStartOp {\n  return {\n    kind: OpKind.ElementStart,\n    xref,\n    tag,\n    handle: new SlotHandle(),\n    attributes: null,\n    localRefs: [],\n    nonBindable: false,\n    namespace,\n    i18nPlaceholder,\n    startSourceSpan,\n    wholeSourceSpan,\n    ...TRAIT_CONSUMES_SLOT,\n    ...NEW_OP,\n  };\n}\n\n/**\n * Logical operation representing an element with no children in the creation IR.\n */\nexport interface ElementOp extends ElementOpBase {\n  kind: OpKind.Element;\n\n  /**\n   * The i18n placeholder data associated with this element.\n   */\n  i18nPlaceholder?: i18n.TagPlaceholder;\n}\n\n/**\n * Logical operation representing an embedded view declaration in the creation IR.\n */\nexport interface TemplateOp extends ElementOpBase {\n  kind: OpKind.Template;\n\n  templateKind: TemplateKind;\n\n  /**\n   * The number of declaration slots used by this template, or `null` if slots have not yet been\n   * assigned.\n   */\n  decls: number | null;\n\n  /**\n   * The number of binding variable slots used by this template, or `null` if binding variables have\n   * not yet been counted.\n   */\n  vars: number | null;\n\n  /**\n   * Suffix to add to the name of the generated template function.\n   */\n  functionNameSuffix: string;\n\n  /**\n   * The i18n placeholder data associated with this template.\n   */\n  i18nPlaceholder?: i18n.TagPlaceholder | i18n.BlockPlaceholder;\n}\n\n/**\n * Create a `TemplateOp`.\n */\nexport function createTemplateOp(\n  xref: XrefId,\n  templateKind: TemplateKind,\n  tag: string | null,\n  functionNameSuffix: string,\n  namespace: Namespace,\n  i18nPlaceholder: i18n.TagPlaceholder | i18n.BlockPlaceholder | undefined,\n  startSourceSpan: ParseSourceSpan,\n  wholeSourceSpan: ParseSourceSpan,\n): TemplateOp {\n  return {\n    kind: OpKind.Template,\n    xref,\n    templateKind,\n    attributes: null,\n    tag,\n    handle: new SlotHandle(),\n    functionNameSuffix,\n    decls: null,\n    vars: null,\n    localRefs: [],\n    nonBindable: false,\n    namespace,\n    i18nPlaceholder,\n    startSourceSpan,\n    wholeSourceSpan,\n    ...TRAIT_CONSUMES_SLOT,\n    ...NEW_OP,\n  };\n}\n\n/**\n * An op that creates a conditional (e.g. a if or switch).\n */\nexport interface ConditionalCreateOp extends ElementOpBase {\n  kind: OpKind.ConditionalCreate;\n\n  templateKind: TemplateKind;\n\n  /**\n   * The number of declaration slots used by this template, or `null` if slots have not yet been\n   * assigned.\n   */\n  decls: number | null;\n\n  /**\n   * The number of binding variable slots used by this template, or `null` if binding variables have\n   * not yet been counted.\n   */\n  vars: number | null;\n\n  /**\n   * Suffix to add to the name of the generated template function.\n   */\n  functionNameSuffix: string;\n\n  /**\n   * The i18n placeholder data associated with this template.\n   */\n  i18nPlaceholder?: i18n.TagPlaceholder | i18n.BlockPlaceholder;\n}\n\nexport function createConditionalCreateOp(\n  xref: XrefId,\n  templateKind: TemplateKind,\n  tag: string | null,\n  functionNameSuffix: string,\n  namespace: Namespace,\n  i18nPlaceholder: i18n.TagPlaceholder | i18n.BlockPlaceholder | undefined,\n  startSourceSpan: ParseSourceSpan,\n  wholeSourceSpan: ParseSourceSpan,\n): ConditionalCreateOp {\n  return {\n    kind: OpKind.ConditionalCreate,\n    xref,\n    templateKind,\n    attributes: null,\n    tag,\n    handle: new SlotHandle(),\n    functionNameSuffix,\n    decls: null,\n    vars: null,\n    localRefs: [],\n    nonBindable: false,\n    namespace,\n    i18nPlaceholder,\n    startSourceSpan,\n    wholeSourceSpan,\n    ...TRAIT_CONSUMES_SLOT,\n    ...NEW_OP,\n  };\n}\n\n/**\n * An op that creates a conditional branch (e.g. an else or case).\n */\nexport interface ConditionalBranchCreateOp extends ElementOpBase {\n  kind: OpKind.ConditionalBranchCreate;\n\n  templateKind: TemplateKind;\n\n  /**\n   * The number of declaration slots used by this template, or `null` if slots have not yet been\n   * assigned.\n   */\n  decls: number | null;\n\n  /**\n   * The number of binding variable slots used by this template, or `null` if binding variables have\n   * not yet been counted.\n   */\n  vars: number | null;\n\n  /**\n   * Suffix to add to the name of the generated template function.\n   */\n  functionNameSuffix: string;\n\n  /**\n   * The i18n placeholder data associated with this template.\n   */\n  i18nPlaceholder?: i18n.TagPlaceholder | i18n.BlockPlaceholder;\n}\n\nexport function createConditionalBranchCreateOp(\n  xref: XrefId,\n  templateKind: TemplateKind,\n  tag: string | null,\n  functionNameSuffix: string,\n  namespace: Namespace,\n  i18nPlaceholder: i18n.TagPlaceholder | i18n.BlockPlaceholder | undefined,\n  startSourceSpan: ParseSourceSpan,\n  wholeSourceSpan: ParseSourceSpan,\n): ConditionalBranchCreateOp {\n  return {\n    kind: OpKind.ConditionalBranchCreate,\n    xref,\n    templateKind,\n    attributes: null,\n    tag,\n    handle: new SlotHandle(),\n    functionNameSuffix,\n    decls: null,\n    vars: null,\n    localRefs: [],\n    nonBindable: false,\n    namespace,\n    i18nPlaceholder,\n    startSourceSpan,\n    wholeSourceSpan,\n    ...TRAIT_CONSUMES_SLOT,\n    ...NEW_OP,\n  };\n}\n\n/**\n * An op that creates a repeater (e.g. a for loop).\n */\nexport interface RepeaterCreateOp extends ElementOpBase, ConsumesVarsTrait {\n  kind: OpKind.RepeaterCreate;\n\n  /**\n   * The number of declaration slots used by this repeater's template, or `null` if slots have not\n   * yet been assigned.\n   */\n  decls: number | null;\n\n  /**\n   * The number of binding variable slots used by this repeater's, or `null` if binding variables\n   * have not yet been counted.\n   */\n  vars: number | null;\n\n  /**\n   * The Xref of the empty view function. (For the primary view function, use the `xref` property).\n   */\n  emptyView: XrefId | null;\n\n  /**\n   * The track expression to use while iterating.\n   */\n  track: o.Expression;\n\n  /**\n   * Some kinds of expressions (e.g. safe reads or nullish coalescing) require additional ops\n   * in order to work. This OpList keeps track of those ops, if they're necessary.\n   */\n  trackByOps: OpList<UpdateOp> | null;\n\n  /**\n   * `null` initially, then an `o.Expression`. Might be a track expression, or might be a reference\n   * into the constant pool.\n   */\n  trackByFn: o.Expression | null;\n\n  /**\n   * Context variables avaialable in this block.\n   */\n  varNames: RepeaterVarNames;\n\n  /**\n   * Whether the repeater track function relies on the component instance.\n   */\n  usesComponentInstance: boolean;\n\n  /**\n   * Suffix to add to the name of the generated template function.\n   */\n  functionNameSuffix: string;\n\n  /**\n   * Tag name for the empty block.\n   */\n  emptyTag: string | null;\n\n  /**\n   * Attributes of various kinds on the empty block. Represented as a `ConstIndex` pointer into the\n   * shared `consts` array of the component compilation.\n   */\n  emptyAttributes: ConstIndex | null;\n\n  /**\n   * The i18n placeholder for the repeated item template.\n   */\n  i18nPlaceholder: i18n.BlockPlaceholder | undefined;\n\n  /**\n   * The i18n placeholder for the empty template.\n   */\n  emptyI18nPlaceholder: i18n.BlockPlaceholder | undefined;\n}\n\n// TODO: add source spans?\nexport interface RepeaterVarNames {\n  $index: Set<string>;\n  $implicit: string;\n}\n\nexport function createRepeaterCreateOp(\n  primaryView: XrefId,\n  emptyView: XrefId | null,\n  tag: string | null,\n  track: o.Expression,\n  varNames: RepeaterVarNames,\n  emptyTag: string | null,\n  i18nPlaceholder: i18n.BlockPlaceholder | undefined,\n  emptyI18nPlaceholder: i18n.BlockPlaceholder | undefined,\n  startSourceSpan: ParseSourceSpan,\n  wholeSourceSpan: ParseSourceSpan,\n): RepeaterCreateOp {\n  return {\n    kind: OpKind.RepeaterCreate,\n    attributes: null,\n    xref: primaryView,\n    handle: new SlotHandle(),\n    emptyView,\n    track,\n    trackByFn: null,\n    trackByOps: null,\n    tag,\n    emptyTag,\n    emptyAttributes: null,\n    functionNameSuffix: 'For',\n    namespace: Namespace.HTML,\n    nonBindable: false,\n    localRefs: [],\n    decls: null,\n    vars: null,\n    varNames,\n    usesComponentInstance: false,\n    i18nPlaceholder,\n    emptyI18nPlaceholder,\n    startSourceSpan,\n    wholeSourceSpan,\n    ...TRAIT_CONSUMES_SLOT,\n    ...NEW_OP,\n    ...TRAIT_CONSUMES_VARS,\n    numSlotsUsed: emptyView === null ? 2 : 3,\n  };\n}\n\n/**\n * Logical operation representing the end of an element structure in the creation IR.\n *\n * Pairs with an `ElementStart` operation.\n */\nexport interface ElementEndOp extends Op<CreateOp> {\n  kind: OpKind.ElementEnd;\n\n  /**\n   * The `XrefId` of the element declared via `ElementStart`.\n   */\n  xref: XrefId;\n\n  sourceSpan: ParseSourceSpan | null;\n}\n\n/**\n * Create an `ElementEndOp`.\n */\nexport function createElementEndOp(xref: XrefId, sourceSpan: ParseSourceSpan | null): ElementEndOp {\n  return {\n    kind: OpKind.ElementEnd,\n    xref,\n    sourceSpan,\n    ...NEW_OP,\n  };\n}\n\n/**\n * Logical operation representing the start of a container in the creation IR.\n */\nexport interface ContainerStartOp extends ElementOrContainerOpBase {\n  kind: OpKind.ContainerStart;\n}\n\n/**\n * Logical operation representing an empty container in the creation IR.\n */\nexport interface ContainerOp extends ElementOrContainerOpBase {\n  kind: OpKind.Container;\n}\n\n/**\n * Logical operation representing the end of a container structure in the creation IR.\n *\n * Pairs with an `ContainerStart` operation.\n */\nexport interface ContainerEndOp extends Op<CreateOp> {\n  kind: OpKind.ContainerEnd;\n\n  /**\n   * The `XrefId` of the element declared via `ContainerStart`.\n   */\n  xref: XrefId;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Logical operation causing binding to be disabled in descendents of a non-bindable container.\n */\nexport interface DisableBindingsOp extends Op<CreateOp> {\n  kind: OpKind.DisableBindings;\n\n  /**\n   * `XrefId` of the element that was marked non-bindable.\n   */\n  xref: XrefId;\n}\n\nexport function createDisableBindingsOp(xref: XrefId): DisableBindingsOp {\n  return {\n    kind: OpKind.DisableBindings,\n    xref,\n    ...NEW_OP,\n  };\n}\n\n/**\n * Logical operation causing binding to be re-enabled after visiting descendants of a\n * non-bindable container.\n */\nexport interface EnableBindingsOp extends Op<CreateOp> {\n  kind: OpKind.EnableBindings;\n\n  /**\n   * `XrefId` of the element that was marked non-bindable.\n   */\n  xref: XrefId;\n}\n\nexport function createEnableBindingsOp(xref: XrefId): EnableBindingsOp {\n  return {\n    kind: OpKind.EnableBindings,\n    xref,\n    ...NEW_OP,\n  };\n}\n\n/**\n * Logical operation representing a text node in the creation IR.\n */\nexport interface TextOp extends Op<CreateOp>, ConsumesSlotOpTrait {\n  kind: OpKind.Text;\n\n  /**\n   * `XrefId` used to reference this text node in other IR structures.\n   */\n  xref: XrefId;\n\n  /**\n   * The static initial value of the text node.\n   */\n  initialValue: string;\n\n  /**\n   * The placeholder for this text in its parent ICU. If this text is not part of an ICU, the\n   * placeholder is null.\n   */\n  icuPlaceholder: string | null;\n\n  sourceSpan: ParseSourceSpan | null;\n}\n\n/**\n * Create a `TextOp`.\n */\nexport function createTextOp(\n  xref: XrefId,\n  initialValue: string,\n  icuPlaceholder: string | null,\n  sourceSpan: ParseSourceSpan | null,\n): TextOp {\n  return {\n    kind: OpKind.Text,\n    xref,\n    handle: new SlotHandle(),\n    initialValue,\n    icuPlaceholder,\n    sourceSpan,\n    ...TRAIT_CONSUMES_SLOT,\n    ...NEW_OP,\n  };\n}\n\n/**\n * A logical operation representing binding to an animation in the create IR.\n */\nexport interface AnimationStringOp extends Op<CreateOp> {\n  kind: OpKind.AnimationString;\n\n  target: XrefId;\n\n  /**\n   * The name of the extracted attribute.\n   */\n  name: string;\n\n  /**\n   * Kind of animation (enter or leave).\n   */\n  animationKind: AnimationKind;\n\n  /**\n   * Expression which is bound to the property.\n   */\n  expression: o.Expression | Interpolation;\n\n  i18nMessage: XrefId | null;\n\n  /**\n   * The security context of the binding.\n   */\n  securityContext: SecurityContext | SecurityContext[];\n\n  /**\n   * The sanitizer for this property.\n   */\n  sanitizer: o.Expression | null;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Create an `AnimationOp`.\n */\nexport function createAnimationStringOp(\n  name: string,\n  target: XrefId,\n  animationKind: AnimationKind,\n  expression: o.Expression | Interpolation,\n  securityContext: SecurityContext | SecurityContext[],\n  sourceSpan: ParseSourceSpan,\n): AnimationStringOp {\n  return {\n    kind: OpKind.AnimationString,\n    name,\n    target,\n    animationKind,\n    expression,\n    i18nMessage: null,\n    securityContext,\n    sanitizer: null,\n    sourceSpan,\n    ...NEW_OP,\n  };\n}\n\n/**\n * A logical operation representing binding to an animation in the create IR.\n */\nexport interface AnimationOp extends Op<CreateOp> {\n  kind: OpKind.Animation;\n\n  target: XrefId;\n\n  /**\n   * The name of the extracted attribute.\n   */\n  name: string;\n\n  /**\n   * Kind of animation (enter or leave).\n   */\n  animationKind: AnimationKind;\n\n  /**\n   * A list of `UpdateOp`s representing the body of the callback function.\n   */\n  handlerOps: OpList<UpdateOp>;\n\n  /**\n   * Name of the function\n   */\n  handlerFnName: string | null;\n\n  i18nMessage: XrefId | null;\n\n  /**\n   * The security context of the binding.\n   */\n  securityContext: SecurityContext | SecurityContext[];\n\n  /**\n   * The sanitizer for this property.\n   */\n  sanitizer: o.Expression | null;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Create an `AnimationOp`.\n */\nexport function createAnimationOp(\n  name: string,\n  target: XrefId,\n  animationKind: AnimationKind,\n  callbackOps: Array<UpdateOp>,\n  securityContext: SecurityContext | SecurityContext[],\n  sourceSpan: ParseSourceSpan,\n): AnimationOp {\n  const handlerOps = new OpList<UpdateOp>();\n  handlerOps.push(callbackOps);\n  return {\n    kind: OpKind.Animation,\n    name,\n    target,\n    animationKind,\n    handlerOps,\n    handlerFnName: null,\n    i18nMessage: null,\n    securityContext,\n    sanitizer: null,\n    sourceSpan,\n    ...NEW_OP,\n  };\n}\n\n/**\n * Logical operation representing an event listener on an element in the creation IR.\n */\nexport interface ListenerOp extends Op<CreateOp> {\n  kind: OpKind.Listener;\n\n  target: XrefId;\n  targetSlot: SlotHandle;\n\n  /**\n   * Whether this listener is from a host binding.\n   */\n  hostListener: boolean;\n\n  /**\n   * Name of the event which is being listened to.\n   */\n  name: string;\n\n  /**\n   * Tag name of the element on which this listener is placed. Might be null, if this listener\n   * belongs to a host binding.\n   */\n  tag: string | null;\n\n  /**\n   * A list of `UpdateOp`s representing the body of the event listener.\n   */\n  handlerOps: OpList<UpdateOp>;\n\n  /**\n   * Name of the function\n   */\n  handlerFnName: string | null;\n\n  /**\n   * Whether this listener is known to consume `$event` in its body.\n   */\n  consumesDollarEvent: boolean;\n\n  /**\n   * Whether the listener is listening for an animation event.\n   */\n  isLegacyAnimationListener: boolean;\n\n  /**\n   * The animation phase of the listener.\n   */\n  legacyAnimationPhase: string | null;\n\n  /**\n   * Some event listeners can have a target, e.g. in `document:dragover`.\n   */\n  eventTarget: string | null;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Create a `ListenerOp`. Host bindings reuse all the listener logic.\n */\nexport function createListenerOp(\n  target: XrefId,\n  targetSlot: SlotHandle,\n  name: string,\n  tag: string | null,\n  handlerOps: Array<UpdateOp>,\n  legacyAnimationPhase: string | null,\n  eventTarget: string | null,\n  hostListener: boolean,\n  sourceSpan: ParseSourceSpan,\n): ListenerOp {\n  const handlerList = new OpList<UpdateOp>();\n  handlerList.push(handlerOps);\n  return {\n    kind: OpKind.Listener,\n    target,\n    targetSlot,\n    tag,\n    hostListener,\n    name,\n    handlerOps: handlerList,\n    handlerFnName: null,\n    consumesDollarEvent: false,\n    isLegacyAnimationListener: legacyAnimationPhase !== null,\n    legacyAnimationPhase: legacyAnimationPhase,\n    eventTarget,\n    sourceSpan,\n    ...NEW_OP,\n  };\n}\n\nexport interface AnimationListenerOp extends Op<CreateOp> {\n  kind: OpKind.AnimationListener;\n\n  target: XrefId;\n  targetSlot: SlotHandle;\n\n  /**\n   * Whether this listener is from a host binding.\n   */\n  hostListener: boolean;\n\n  /**\n   * Name of the event which is being listened to.\n   */\n  name: string;\n\n  /**\n   * Whether the event is on enter or leave\n   */\n  animationKind: AnimationKind;\n\n  /**\n   * Tag name of the element on which this listener is placed. Might be null, if this listener\n   * belongs to a host binding.\n   */\n  tag: string | null;\n\n  /**\n   * A list of `UpdateOp`s representing the body of the event listener.\n   */\n  handlerOps: OpList<UpdateOp>;\n\n  /**\n   * Name of the function\n   */\n  handlerFnName: string | null;\n\n  /**\n   * Whether this listener is known to consume `$event` in its body.\n   */\n  consumesDollarEvent: boolean;\n\n  /**\n   * Some event listeners can have a target, e.g. in `document:dragover`.\n   */\n  eventTarget: string | null;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Create a `ListenerOp`. Host bindings reuse all the listener logic.\n */\nexport function createAnimationListenerOp(\n  target: XrefId,\n  targetSlot: SlotHandle,\n  name: string,\n  tag: string | null,\n  handlerOps: Array<UpdateOp>,\n  animationKind: AnimationKind,\n  eventTarget: string | null,\n  hostListener: boolean,\n  sourceSpan: ParseSourceSpan,\n): AnimationListenerOp {\n  const handlerList = new OpList<UpdateOp>();\n  handlerList.push(handlerOps);\n  return {\n    kind: OpKind.AnimationListener,\n    target,\n    targetSlot,\n    tag,\n    hostListener,\n    name,\n    animationKind,\n    handlerOps: handlerList,\n    handlerFnName: null,\n    consumesDollarEvent: false,\n    eventTarget,\n    sourceSpan,\n    ...NEW_OP,\n  };\n}\n\n/**\n * Logical operation representing the event side of a two-way binding on an element\n * in the creation IR.\n */\nexport interface TwoWayListenerOp extends Op<CreateOp> {\n  kind: OpKind.TwoWayListener;\n\n  target: XrefId;\n  targetSlot: SlotHandle;\n\n  /**\n   * Name of the event which is being listened to.\n   */\n  name: string;\n\n  /**\n   * Tag name of the element on which this listener is placed.\n   */\n  tag: string | null;\n\n  /**\n   * A list of `UpdateOp`s representing the body of the event listener.\n   */\n  handlerOps: OpList<UpdateOp>;\n\n  /**\n   * Name of the function\n   */\n  handlerFnName: string | null;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Create a `TwoWayListenerOp`.\n */\nexport function createTwoWayListenerOp(\n  target: XrefId,\n  targetSlot: SlotHandle,\n  name: string,\n  tag: string | null,\n  handlerOps: Array<UpdateOp>,\n  sourceSpan: ParseSourceSpan,\n): TwoWayListenerOp {\n  const handlerList = new OpList<UpdateOp>();\n  handlerList.push(handlerOps);\n  return {\n    kind: OpKind.TwoWayListener,\n    target,\n    targetSlot,\n    tag,\n    name,\n    handlerOps: handlerList,\n    handlerFnName: null,\n    sourceSpan,\n    ...NEW_OP,\n  };\n}\n\nexport interface PipeOp extends Op<CreateOp>, ConsumesSlotOpTrait {\n  kind: OpKind.Pipe;\n  xref: XrefId;\n  name: string;\n}\n\nexport function createPipeOp(xref: XrefId, slot: SlotHandle, name: string): PipeOp {\n  return {\n    kind: OpKind.Pipe,\n    xref,\n    handle: slot,\n    name,\n    ...NEW_OP,\n    ...TRAIT_CONSUMES_SLOT,\n  };\n}\n\n/**\n * An op corresponding to a namespace instruction, for switching between HTML, SVG, and MathML.\n */\nexport interface NamespaceOp extends Op<CreateOp> {\n  kind: OpKind.Namespace;\n  active: Namespace;\n}\n\nexport function createNamespaceOp(namespace: Namespace): NamespaceOp {\n  return {\n    kind: OpKind.Namespace,\n    active: namespace,\n    ...NEW_OP,\n  };\n}\n\n/**\n * An op that creates a content projection slot.\n */\nexport interface ProjectionDefOp extends Op<CreateOp> {\n  kind: OpKind.ProjectionDef;\n\n  // The parsed selector information for this projection def.\n  def: o.Expression | null;\n}\n\nexport function createProjectionDefOp(def: o.Expression | null): ProjectionDefOp {\n  return {\n    kind: OpKind.ProjectionDef,\n    def,\n    ...NEW_OP,\n  };\n}\n\n/**\n * An op that creates a content projection slot.\n */\nexport interface ProjectionOp extends Op<CreateOp>, ConsumesSlotOpTrait {\n  kind: OpKind.Projection;\n\n  xref: XrefId;\n\n  projectionSlotIndex: number;\n\n  attributes: null | o.LiteralArrayExpr;\n\n  localRefs: string[];\n\n  selector: string;\n\n  i18nPlaceholder?: i18n.TagPlaceholder;\n\n  sourceSpan: ParseSourceSpan;\n\n  fallbackView: XrefId | null;\n\n  fallbackViewI18nPlaceholder?: i18n.BlockPlaceholder;\n}\n\nexport function createProjectionOp(\n  xref: XrefId,\n  selector: string,\n  i18nPlaceholder: i18n.TagPlaceholder | undefined,\n  fallbackView: XrefId | null,\n  sourceSpan: ParseSourceSpan,\n): ProjectionOp {\n  return {\n    kind: OpKind.Projection,\n    xref,\n    handle: new SlotHandle(),\n    selector,\n    i18nPlaceholder,\n    fallbackView,\n    projectionSlotIndex: 0,\n    attributes: null,\n    localRefs: [],\n    sourceSpan,\n    ...NEW_OP,\n    ...TRAIT_CONSUMES_SLOT,\n    numSlotsUsed: fallbackView === null ? 1 : 2,\n  };\n}\n\n/**\n * Represents an attribute that has been extracted for inclusion in the consts array.\n */\nexport interface ExtractedAttributeOp extends Op<CreateOp> {\n  kind: OpKind.ExtractedAttribute;\n\n  /**\n   * The `XrefId` of the template-like element the extracted attribute will belong to.\n   */\n  target: XrefId;\n\n  /**\n   *  The kind of binding represented by this extracted attribute.\n   */\n  bindingKind: BindingKind;\n\n  /**\n   * The namespace of the attribute (or null if none).\n   */\n  namespace: string | null;\n\n  /**\n   * The name of the extracted attribute.\n   */\n  name: string;\n\n  /**\n   * The value expression of the extracted attribute.\n   */\n  expression: o.Expression | null;\n\n  /**\n   * If this attribute has a corresponding i18n attribute (e.g. `i18n-foo=\"m:d\"`), then this is the\n   * i18n context for it.\n   */\n  i18nContext: XrefId | null;\n\n  /**\n   * The security context of the binding.\n   */\n  securityContext: SecurityContext | SecurityContext[];\n\n  /**\n   * The trusted value function for this property.\n   */\n  trustedValueFn: o.Expression | null;\n\n  i18nMessage: i18n.Message | null;\n}\n\n/**\n * Create an `ExtractedAttributeOp`.\n */\nexport function createExtractedAttributeOp(\n  target: XrefId,\n  bindingKind: BindingKind,\n  namespace: string | null,\n  name: string,\n  expression: o.Expression | null,\n  i18nContext: XrefId | null,\n  i18nMessage: i18n.Message | null,\n  securityContext: SecurityContext | SecurityContext[],\n): ExtractedAttributeOp {\n  return {\n    kind: OpKind.ExtractedAttribute,\n    target,\n    bindingKind,\n    namespace,\n    name,\n    expression,\n    i18nContext,\n    i18nMessage,\n    securityContext,\n    trustedValueFn: null,\n    ...NEW_OP,\n  };\n}\n\nexport interface DeferOp extends Op<CreateOp>, ConsumesSlotOpTrait {\n  kind: OpKind.Defer;\n\n  /**\n   * The xref of this defer op.\n   */\n  xref: XrefId;\n\n  /**\n   * The xref of the main view.\n   */\n  mainView: XrefId;\n\n  mainSlot: SlotHandle;\n\n  /**\n   * Secondary loading block associated with this defer op.\n   */\n  loadingView: XrefId | null;\n\n  loadingSlot: SlotHandle | null;\n\n  /**\n   * Secondary placeholder block associated with this defer op.\n   */\n  placeholderView: XrefId | null;\n\n  placeholderSlot: SlotHandle | null;\n\n  /**\n   * Secondary error block associated with this defer op.\n   */\n  errorView: XrefId | null;\n\n  errorSlot: SlotHandle | null;\n\n  placeholderMinimumTime: number | null;\n  loadingMinimumTime: number | null;\n  loadingAfterTime: number | null;\n\n  placeholderConfig: o.Expression | null;\n  loadingConfig: o.Expression | null;\n\n  /**\n   * Depending on the compilation mode, there can be either one dependency resolution function\n   * per deferred block or one for the entire template. This field contains the function that\n   * belongs specifically to the current deferred block.\n   */\n  ownResolverFn: o.Expression | null;\n\n  /**\n   * After processing, the resolver function for the defer deps will be extracted to the constant\n   * pool, and a reference to that function will be populated here.\n   */\n  resolverFn: o.Expression | null;\n\n  /**\n   * Specifies defer block flags, which should be used for all\n   * instances of a given defer block (the flags that should be\n   * placed into the `TDeferDetails` at runtime).\n   */\n  flags: TDeferDetailsFlags | null;\n\n  sourceSpan: ParseSourceSpan;\n}\n\nexport function createDeferOp(\n  xref: XrefId,\n  main: XrefId,\n  mainSlot: SlotHandle,\n  ownResolverFn: o.Expression | null,\n  resolverFn: o.Expression | null,\n  sourceSpan: ParseSourceSpan,\n): DeferOp {\n  return {\n    kind: OpKind.Defer,\n    xref,\n    handle: new SlotHandle(),\n    mainView: main,\n    mainSlot,\n    loadingView: null,\n    loadingSlot: null,\n    loadingConfig: null,\n    loadingMinimumTime: null,\n    loadingAfterTime: null,\n    placeholderView: null,\n    placeholderSlot: null,\n    placeholderConfig: null,\n    placeholderMinimumTime: null,\n    errorView: null,\n    errorSlot: null,\n    ownResolverFn,\n    resolverFn,\n    flags: null,\n    sourceSpan,\n    ...NEW_OP,\n    ...TRAIT_CONSUMES_SLOT,\n    numSlotsUsed: 2,\n  };\n}\ninterface DeferTriggerBase {\n  kind: DeferTriggerKind;\n}\n\ninterface DeferTriggerWithTargetBase extends DeferTriggerBase {\n  targetName: string | null;\n\n  /**\n   * The Xref of the targeted name. May be in a different view.\n   */\n  targetXref: XrefId | null;\n\n  /**\n   * The slot index of the named reference, inside the view provided below. This slot may not be\n   * inside the current view, and is handled specially as a result.\n   */\n  targetSlot: SlotHandle | null;\n\n  targetView: XrefId | null;\n\n  /**\n   * Number of steps to walk up or down the view tree to find the target localRef.\n   */\n  targetSlotViewSteps: number | null;\n}\n\ninterface DeferIdleTrigger extends DeferTriggerBase {\n  kind: DeferTriggerKind.Idle;\n}\n\ninterface DeferImmediateTrigger extends DeferTriggerBase {\n  kind: DeferTriggerKind.Immediate;\n}\n\ninterface DeferNeverTrigger extends DeferTriggerBase {\n  kind: DeferTriggerKind.Never;\n}\n\ninterface DeferHoverTrigger extends DeferTriggerWithTargetBase {\n  kind: DeferTriggerKind.Hover;\n}\n\ninterface DeferTimerTrigger extends DeferTriggerBase {\n  kind: DeferTriggerKind.Timer;\n\n  delay: number;\n}\n\ninterface DeferInteractionTrigger extends DeferTriggerWithTargetBase {\n  kind: DeferTriggerKind.Interaction;\n}\n\ninterface DeferViewportTrigger extends DeferTriggerWithTargetBase {\n  kind: DeferTriggerKind.Viewport;\n}\n\n/**\n * The union type of all defer trigger interfaces.\n */\nexport type DeferTrigger =\n  | DeferIdleTrigger\n  | DeferImmediateTrigger\n  | DeferTimerTrigger\n  | DeferHoverTrigger\n  | DeferInteractionTrigger\n  | DeferViewportTrigger\n  | DeferNeverTrigger;\n\nexport interface DeferOnOp extends Op<CreateOp> {\n  kind: OpKind.DeferOn;\n\n  defer: XrefId;\n\n  /**\n   * The trigger for this defer op (e.g. idle, hover, etc).\n   */\n  trigger: DeferTrigger;\n\n  /**\n   * Modifier set on the trigger by the user (e.g. `hydrate`, `prefetch` etc).\n   */\n  modifier: DeferOpModifierKind;\n\n  sourceSpan: ParseSourceSpan;\n}\n\nexport function createDeferOnOp(\n  defer: XrefId,\n  trigger: DeferTrigger,\n  modifier: DeferOpModifierKind,\n  sourceSpan: ParseSourceSpan,\n): DeferOnOp {\n  return {\n    kind: OpKind.DeferOn,\n    defer,\n    trigger,\n    modifier,\n    sourceSpan,\n    ...NEW_OP,\n  };\n}\n\n/**\n * Op that reserves a slot during creation time for a `@let` declaration.\n */\nexport interface DeclareLetOp extends Op<CreateOp>, ConsumesSlotOpTrait {\n  kind: OpKind.DeclareLet;\n  xref: XrefId;\n  sourceSpan: ParseSourceSpan;\n  declaredName: string;\n}\n\n/**\n * Creates a `DeclareLetOp`.\n */\nexport function createDeclareLetOp(\n  xref: XrefId,\n  declaredName: string,\n  sourceSpan: ParseSourceSpan,\n): DeclareLetOp {\n  return {\n    kind: OpKind.DeclareLet,\n    xref,\n    declaredName,\n    sourceSpan,\n    handle: new SlotHandle(),\n    ...TRAIT_CONSUMES_SLOT,\n    ...NEW_OP,\n  };\n}\n\n/**\n * Represents a single value in an i18n param map. Each placeholder in the map may have multiple of\n * these values associated with it.\n */\nexport interface I18nParamValue {\n  /**\n   * The value. This can be either a slot number, special string, or compound-value consisting of an\n   * element slot number and template slot number.\n   */\n  value: string | number | {element: number; template: number};\n\n  /**\n   * The sub-template index associated with the value.\n   */\n  subTemplateIndex: number | null;\n\n  /**\n   * Flags associated with the value.\n   */\n  flags: I18nParamValueFlags;\n}\n\n/**\n * Represents an i18n message that has been extracted for inclusion in the consts array.\n */\nexport interface I18nMessageOp extends Op<CreateOp> {\n  kind: OpKind.I18nMessage;\n\n  /**\n   * An id used to reference this message.\n   */\n  xref: XrefId;\n\n  /**\n   * The context from which this message was extracted\n   * TODO: remove this, and add another property here instead to match ExtractedAttributes\n   */\n  i18nContext: XrefId;\n\n  /**\n   * A reference to the i18n op this message was extracted from.\n   *\n   * This might be null, which means this message is not associated with a block. This probably\n   * means it is an i18n attribute's message.\n   */\n  i18nBlock: XrefId | null;\n\n  /**\n   * The i18n message represented by this op.\n   */\n  message: i18n.Message;\n\n  /**\n   * The placeholder used for this message when it is referenced in another message.\n   * For a top-level message that isn't referenced from another message, this will be null.\n   */\n  messagePlaceholder: string | null;\n\n  /**\n   * Whether this message needs post-processing.\n   */\n  needsPostprocessing: boolean;\n\n  /**\n   * The param map, with placeholders represented as an `Expression`.\n   */\n  params: Map<string, o.Expression>;\n\n  /**\n   * The post-processing param map, with placeholders represented as an `Expression`.\n   */\n  postprocessingParams: Map<string, o.Expression>;\n\n  /**\n   * A list of sub-messages that are referenced by this message.\n   */\n  subMessages: XrefId[];\n}\n\n/**\n * Create an `ExtractedMessageOp`.\n */\nexport function createI18nMessageOp(\n  xref: XrefId,\n  i18nContext: XrefId,\n  i18nBlock: XrefId | null,\n  message: i18n.Message,\n  messagePlaceholder: string | null,\n  params: Map<string, o.Expression>,\n  postprocessingParams: Map<string, o.Expression>,\n  needsPostprocessing: boolean,\n): I18nMessageOp {\n  return {\n    kind: OpKind.I18nMessage,\n    xref,\n    i18nContext,\n    i18nBlock,\n    message,\n    messagePlaceholder,\n    params,\n    postprocessingParams,\n    needsPostprocessing,\n    subMessages: [],\n    ...NEW_OP,\n  };\n}\n\nexport interface I18nOpBase extends Op<CreateOp>, ConsumesSlotOpTrait {\n  kind: OpKind.I18nStart | OpKind.I18n;\n\n  /**\n   * `XrefId` allocated for this i18n block.\n   */\n  xref: XrefId;\n\n  /**\n   * A reference to the root i18n block that this one belongs to. For a root i18n block, this is\n   * the same as xref.\n   */\n  root: XrefId;\n\n  /**\n   * The i18n metadata associated with this op.\n   */\n  message: i18n.Message;\n\n  /**\n   * The index in the consts array where the message i18n message is stored.\n   */\n  messageIndex: ConstIndex | null;\n\n  /**\n   * The index of this sub-block in the i18n message. For a root i18n block, this is null.\n   */\n  subTemplateIndex: number | null;\n\n  /**\n   * The i18n context generated from this block. Initially null, until the context is created.\n   */\n  context: XrefId | null;\n\n  sourceSpan: ParseSourceSpan | null;\n}\n\n/**\n * Represents an empty i18n block.\n */\nexport interface I18nOp extends I18nOpBase {\n  kind: OpKind.I18n;\n}\n\n/**\n * Represents the start of an i18n block.\n */\nexport interface I18nStartOp extends I18nOpBase {\n  kind: OpKind.I18nStart;\n}\n\n/**\n * Create an `I18nStartOp`.\n */\nexport function createI18nStartOp(\n  xref: XrefId,\n  message: i18n.Message,\n  root: XrefId | undefined,\n  sourceSpan: ParseSourceSpan | null,\n): I18nStartOp {\n  return {\n    kind: OpKind.I18nStart,\n    xref,\n    handle: new SlotHandle(),\n    root: root ?? xref,\n    message,\n    messageIndex: null,\n    subTemplateIndex: null,\n    context: null,\n    sourceSpan,\n    ...NEW_OP,\n    ...TRAIT_CONSUMES_SLOT,\n  };\n}\n\n/**\n * Represents the end of an i18n block.\n */\nexport interface I18nEndOp extends Op<CreateOp> {\n  kind: OpKind.I18nEnd;\n\n  /**\n   * The `XrefId` of the `I18nStartOp` that created this block.\n   */\n  xref: XrefId;\n\n  sourceSpan: ParseSourceSpan | null;\n}\n\n/**\n * Create an `I18nEndOp`.\n */\nexport function createI18nEndOp(xref: XrefId, sourceSpan: ParseSourceSpan | null): I18nEndOp {\n  return {\n    kind: OpKind.I18nEnd,\n    xref,\n    sourceSpan,\n    ...NEW_OP,\n  };\n}\n\n/**\n * An op that represents the start of an ICU expression.\n */\nexport interface IcuStartOp extends Op<CreateOp> {\n  kind: OpKind.IcuStart;\n\n  /**\n   * The ID of the ICU.\n   */\n  xref: XrefId;\n\n  /**\n   * The i18n message for this ICU.\n   */\n  message: i18n.Message;\n\n  /**\n   * Placeholder used to reference this ICU in other i18n messages.\n   */\n  messagePlaceholder: string;\n\n  /**\n   * A reference to the i18n context for this op. Initially null, until the context is created.\n   */\n  context: XrefId | null;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Creates an ICU start op.\n */\nexport function createIcuStartOp(\n  xref: XrefId,\n  message: i18n.Message,\n  messagePlaceholder: string,\n  sourceSpan: ParseSourceSpan,\n): IcuStartOp {\n  return {\n    kind: OpKind.IcuStart,\n    xref,\n    message,\n    messagePlaceholder,\n    context: null,\n    sourceSpan,\n    ...NEW_OP,\n  };\n}\n\n/**\n * An op that represents the end of an ICU expression.\n */\nexport interface IcuEndOp extends Op<CreateOp> {\n  kind: OpKind.IcuEnd;\n\n  /**\n   * The ID of the corresponding IcuStartOp.\n   */\n  xref: XrefId;\n}\n\n/**\n * Creates an ICU end op.\n */\nexport function createIcuEndOp(xref: XrefId): IcuEndOp {\n  return {\n    kind: OpKind.IcuEnd,\n    xref,\n    ...NEW_OP,\n  };\n}\n\n/**\n * An op that represents a placeholder in an ICU expression.\n */\nexport interface IcuPlaceholderOp extends Op<CreateOp> {\n  kind: OpKind.IcuPlaceholder;\n\n  /**\n   * The ID of the ICU placeholder.\n   */\n  xref: XrefId;\n\n  /**\n   * The name of the placeholder in the ICU expression.\n   */\n  name: string;\n\n  /**\n   * The static strings to be combined with dynamic expression values to form the text. This works\n   * like interpolation, but the strings are combined at compile time, using special placeholders\n   * for the dynamic expressions, and put into the translated message.\n   */\n  strings: string[];\n\n  /**\n   * Placeholder values for the i18n expressions to be combined with the static strings to form the\n   * full placeholder value.\n   */\n  expressionPlaceholders: I18nParamValue[];\n}\n\n/**\n * Creates an ICU placeholder op.\n */\nexport function createIcuPlaceholderOp(\n  xref: XrefId,\n  name: string,\n  strings: string[],\n): IcuPlaceholderOp {\n  return {\n    kind: OpKind.IcuPlaceholder,\n    xref,\n    name,\n    strings,\n    expressionPlaceholders: [],\n    ...NEW_OP,\n  };\n}\n\n/**\n * An i18n context that is used to generate a translated i18n message. A separate context is created\n * for three different scenarios:\n *\n * 1. For each top-level i18n block.\n * 2. For each ICU referenced as a sub-message. ICUs that are referenced as a sub-message will be\n *    used to generate a separate i18n message, but will not be extracted directly into the consts\n *    array. Instead they will be pulled in as part of the initialization statements for the message\n *    that references them.\n * 3. For each i18n attribute.\n *\n * Child i18n blocks, resulting from the use of an ng-template inside of a parent i18n block, do not\n * generate a separate context. Instead their content is included in the translated message for\n * their root block.\n */\nexport interface I18nContextOp extends Op<CreateOp> {\n  kind: OpKind.I18nContext;\n\n  contextKind: I18nContextKind;\n\n  /**\n   * The id of this context.\n   */\n  xref: XrefId;\n\n  /**\n   * A reference to the I18nStartOp or I18nOp this context belongs to.\n   *\n   * It is possible for multiple contexts to belong to the same block, since both the block and any\n   * ICUs inside the block will each get their own context.\n   *\n   * This might be `null`, in which case the context is not associated with an i18n block. This\n   * probably means that it belongs to an i18n attribute.\n   */\n  i18nBlock: XrefId | null;\n\n  /**\n   * The i18n message associated with this context.\n   */\n  message: i18n.Message;\n\n  /**\n   * The param map for this context.\n   */\n  params: Map<string, I18nParamValue[]>;\n\n  /**\n   * The post-processing param map for this context.\n   */\n  postprocessingParams: Map<string, I18nParamValue[]>;\n\n  sourceSpan: ParseSourceSpan;\n}\n\nexport function createI18nContextOp(\n  contextKind: I18nContextKind,\n  xref: XrefId,\n  i18nBlock: XrefId | null,\n  message: i18n.Message,\n  sourceSpan: ParseSourceSpan,\n): I18nContextOp {\n  if (i18nBlock === null && contextKind !== I18nContextKind.Attr) {\n    throw new Error('AssertionError: i18nBlock must be provided for non-attribute contexts.');\n  }\n\n  return {\n    kind: OpKind.I18nContext,\n    contextKind,\n    xref,\n    i18nBlock,\n    message,\n    sourceSpan,\n    params: new Map(),\n    postprocessingParams: new Map(),\n    ...NEW_OP,\n  };\n}\n\nexport interface I18nAttributesOp extends Op<CreateOp>, ConsumesSlotOpTrait {\n  kind: OpKind.I18nAttributes;\n\n  /**\n   * The element targeted by these attributes.\n   */\n  target: XrefId;\n\n  /**\n   * I18nAttributes instructions correspond to a const array with configuration information.\n   */\n  i18nAttributesConfig: ConstIndex | null;\n}\n\nexport function createI18nAttributesOp(\n  xref: XrefId,\n  handle: SlotHandle,\n  target: XrefId,\n): I18nAttributesOp {\n  return {\n    kind: OpKind.I18nAttributes,\n    xref,\n    handle,\n    target,\n    i18nAttributesConfig: null,\n    ...NEW_OP,\n    ...TRAIT_CONSUMES_SLOT,\n  };\n}\n\n/** Describes a location at which an element is defined within a template. */\nexport interface ElementSourceLocation {\n  targetSlot: SlotHandle;\n  offset: number;\n  line: number;\n  column: number;\n}\n\n/**\n * Op that attaches the location at which each element is defined within the source template.\n */\nexport interface SourceLocationOp extends Op<CreateOp> {\n  kind: OpKind.SourceLocation;\n  templatePath: string;\n  locations: ElementSourceLocation[];\n}\n\n/** Create a `SourceLocationOp`. */\nexport function createSourceLocationOp(\n  templatePath: string,\n  locations: ElementSourceLocation[],\n): SourceLocationOp {\n  return {\n    kind: OpKind.SourceLocation,\n    templatePath,\n    locations,\n    ...NEW_OP,\n  };\n}\n\n/**\n * An index into the `consts` array which is shared across the compilation of all views in a\n * component.\n */\nexport type ConstIndex = number & {__brand: 'ConstIndex'};\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../../../../src/output/output_ast';\nimport {ParseSourceSpan} from '../../../../../../src/parse_util';\nimport {SecurityContext} from '../../../../../core';\nimport {BindingKind, OpKind} from '../enums';\nimport {Op, XrefId} from '../operations';\nimport {ConsumesVarsTrait, TRAIT_CONSUMES_VARS} from '../traits';\n\nimport {NEW_OP} from './shared';\n\nimport type {Interpolation, UpdateOp} from './update';\n\n/**\n * Logical operation representing a binding to a native DOM property.\n */\nexport interface DomPropertyOp extends Op<UpdateOp>, ConsumesVarsTrait {\n  kind: OpKind.DomProperty;\n  name: string;\n  expression: o.Expression | Interpolation;\n  bindingKind: BindingKind;\n\n  i18nContext: XrefId | null;\n\n  securityContext: SecurityContext | SecurityContext[];\n\n  sanitizer: o.Expression | null;\n\n  sourceSpan: ParseSourceSpan;\n}\n\nexport function createDomPropertyOp(\n  name: string,\n  expression: o.Expression | Interpolation,\n  bindingKind: BindingKind,\n  i18nContext: XrefId | null,\n  securityContext: SecurityContext | SecurityContext[],\n  sourceSpan: ParseSourceSpan,\n): DomPropertyOp {\n  return {\n    kind: OpKind.DomProperty,\n    name,\n    expression,\n    bindingKind,\n    i18nContext,\n    securityContext,\n    sanitizer: null,\n    sourceSpan,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP,\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport type {SemanticVariableKind} from './enums';\nimport type {XrefId} from './operations';\n\n/**\n * Union type for the different kinds of variables.\n */\nexport type SemanticVariable =\n  | ContextVariable\n  | IdentifierVariable\n  | SavedViewVariable\n  | AliasVariable;\n\nexport interface SemanticVariableBase {\n  kind: SemanticVariableKind;\n\n  /**\n   * Name assigned to this variable in generated code, or `null` if not yet assigned.\n   */\n  name: string | null;\n}\n\n/**\n * When referenced in the template's context parameters, this indicates a reference to the entire\n * context object, rather than a specific parameter.\n */\nexport const CTX_REF = 'CTX_REF_MARKER';\n\n/**\n * A variable that represents the context of a particular view.\n */\nexport interface ContextVariable extends SemanticVariableBase {\n  kind: SemanticVariableKind.Context;\n\n  /**\n   * `XrefId` of the view that this variable represents.\n   */\n  view: XrefId;\n}\n\n/**\n * A variable that represents a specific identifier within a template.\n */\nexport interface IdentifierVariable extends SemanticVariableBase {\n  kind: SemanticVariableKind.Identifier;\n\n  /**\n   * The identifier whose value in the template is tracked in this variable.\n   */\n  identifier: string;\n\n  /**\n   * Whether the variable was declared locally within the same view or somewhere else.\n   */\n  local: boolean;\n}\n\n/**\n * A variable that represents a saved view context.\n */\nexport interface SavedViewVariable extends SemanticVariableBase {\n  kind: SemanticVariableKind.SavedView;\n\n  /**\n   * The view context saved in this variable.\n   */\n  view: XrefId;\n}\n\n/**\n * A variable that will be inlined at every location it is used. An alias is also allowed to depend\n * on the value of a semantic variable.\n */\nexport interface AliasVariable extends SemanticVariableBase {\n  kind: SemanticVariableKind.Alias;\n  identifier: string;\n  expression: o.Expression;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ConstantPool} from '../../../constant_pool';\nimport * as o from '../../../output/output_ast';\nimport {R3ComponentDeferMetadata} from '../../../render3/view/api';\nimport * as ir from '../ir';\n\nexport enum CompilationJobKind {\n  Tmpl,\n  Host,\n  Both, // A special value used to indicate that some logic applies to both compilation types\n}\n\n/** Possible modes in which a component's template can be compiled. */\nexport enum TemplateCompilationMode {\n  /** Supports the full instruction set, including directives. */\n  Full,\n\n  /** Uses a narrower instruction set that doesn't support directives and allows optimizations. */\n  DomOnly,\n}\n\n/**\n * An entire ongoing compilation, which will result in one or more template functions when complete.\n * Contains one or more corresponding compilation units.\n */\nexport abstract class CompilationJob {\n  constructor(\n    readonly componentName: string,\n    readonly pool: ConstantPool,\n    readonly compatibility: ir.CompatibilityMode,\n    readonly mode: TemplateCompilationMode,\n  ) {}\n\n  kind: CompilationJobKind = CompilationJobKind.Both;\n\n  /**\n   * A compilation job will contain one or more compilation units.\n   */\n  abstract get units(): Iterable<CompilationUnit>;\n\n  /**\n   * The root compilation unit, such as the component's template, or the host binding's compilation\n   * unit.\n   */\n  abstract root: CompilationUnit;\n\n  /**\n   * A unique string used to identify this kind of job, and generate the template function (as a\n   * suffix of the name).\n   */\n  abstract fnSuffix: string;\n\n  /**\n   * Generate a new unique `ir.XrefId` in this job.\n   */\n  allocateXrefId(): ir.XrefId {\n    return this.nextXrefId++ as ir.XrefId;\n  }\n\n  /**\n   * Tracks the next `ir.XrefId` which can be assigned as template structures are ingested.\n   */\n  private nextXrefId: ir.XrefId = 0 as ir.XrefId;\n}\n\n/**\n * Compilation-in-progress of a whole component's template, including the main template and any\n * embedded views or host bindings.\n */\nexport class ComponentCompilationJob extends CompilationJob {\n  constructor(\n    componentName: string,\n    pool: ConstantPool,\n    compatibility: ir.CompatibilityMode,\n    mode: TemplateCompilationMode,\n    readonly relativeContextFilePath: string,\n    readonly i18nUseExternalIds: boolean,\n    readonly deferMeta: R3ComponentDeferMetadata,\n    readonly allDeferrableDepsFn: o.ReadVarExpr | null,\n    readonly relativeTemplatePath: string | null,\n    readonly enableDebugLocations: boolean,\n  ) {\n    super(componentName, pool, compatibility, mode);\n    this.root = new ViewCompilationUnit(this, this.allocateXrefId(), null);\n    this.views.set(this.root.xref, this.root);\n  }\n\n  override kind = CompilationJobKind.Tmpl;\n\n  override readonly fnSuffix: string = 'Template';\n\n  /**\n   * The root view, representing the component's template.\n   */\n  override readonly root: ViewCompilationUnit;\n\n  readonly views = new Map<ir.XrefId, ViewCompilationUnit>();\n\n  /**\n   * Causes ngContentSelectors to be emitted, for content projection slots in the view. Possibly a\n   * reference into the constant pool.\n   */\n  public contentSelectors: o.Expression | null = null;\n\n  /**\n   * Add a `ViewCompilation` for a new embedded view to this compilation.\n   */\n  allocateView(parent: ir.XrefId): ViewCompilationUnit {\n    const view = new ViewCompilationUnit(this, this.allocateXrefId(), parent);\n    this.views.set(view.xref, view);\n    return view;\n  }\n\n  override get units(): Iterable<ViewCompilationUnit> {\n    return this.views.values();\n  }\n\n  /**\n   * Add a constant `o.Expression` to the compilation and return its index in the `consts` array.\n   */\n  addConst(newConst: o.Expression, initializers?: o.Statement[]): ir.ConstIndex {\n    for (let idx = 0; idx < this.consts.length; idx++) {\n      if (this.consts[idx].isEquivalent(newConst)) {\n        return idx as ir.ConstIndex;\n      }\n    }\n    const idx = this.consts.length;\n    this.consts.push(newConst);\n    if (initializers) {\n      this.constsInitializers.push(...initializers);\n    }\n    return idx as ir.ConstIndex;\n  }\n\n  /**\n   * Constant expressions used by operations within this component's compilation.\n   *\n   * This will eventually become the `consts` array in the component definition.\n   */\n  readonly consts: o.Expression[] = [];\n\n  /**\n   * Initialization statements needed to set up the consts.\n   */\n  readonly constsInitializers: o.Statement[] = [];\n}\n\n/**\n * A compilation unit is compiled into a template function. Some example units are views and host\n * bindings.\n */\nexport abstract class CompilationUnit {\n  constructor(readonly xref: ir.XrefId) {}\n\n  /**\n   * List of creation operations for this view.\n   *\n   * Creation operations may internally contain other operations, including update operations.\n   */\n  readonly create = new ir.OpList<ir.CreateOp>();\n\n  /**\n   * List of update operations for this view.\n   */\n  readonly update = new ir.OpList<ir.UpdateOp>();\n\n  /**\n   * The enclosing job, which might contain several individual compilation units.\n   */\n  abstract readonly job: CompilationJob;\n\n  /**\n   * Name of the function which will be generated for this unit.\n   *\n   * May be `null` if not yet determined.\n   */\n  fnName: string | null = null;\n\n  /**\n   * Number of variable slots used within this view, or `null` if variables have not yet been\n   * counted.\n   */\n  vars: number | null = null;\n\n  /**\n   * Iterate over all `ir.Op`s within this view.\n   *\n   * Some operations may have child operations, which this iterator will visit.\n   */\n  *ops(): Generator<ir.CreateOp | ir.UpdateOp> {\n    for (const op of this.create) {\n      yield op;\n      if (\n        op.kind === ir.OpKind.Listener ||\n        op.kind === ir.OpKind.Animation ||\n        op.kind === ir.OpKind.AnimationListener ||\n        op.kind === ir.OpKind.TwoWayListener\n      ) {\n        for (const listenerOp of op.handlerOps) {\n          yield listenerOp;\n        }\n      } else if (op.kind === ir.OpKind.RepeaterCreate && op.trackByOps !== null) {\n        for (const trackOp of op.trackByOps) {\n          yield trackOp;\n        }\n      }\n    }\n    for (const op of this.update) {\n      yield op;\n    }\n  }\n}\n\n/**\n * Compilation-in-progress of an individual view within a template.\n */\nexport class ViewCompilationUnit extends CompilationUnit {\n  constructor(\n    readonly job: ComponentCompilationJob,\n    xref: ir.XrefId,\n    readonly parent: ir.XrefId | null,\n  ) {\n    super(xref);\n  }\n\n  /**\n   * Map of declared variables available within this view to the property on the context object\n   * which they alias.\n   */\n  readonly contextVariables = new Map<string, string>();\n\n  /**\n   * Set of aliases available within this view. An alias is a variable whose provided expression is\n   * inlined at every location it is used. It may also depend on context variables, by name.\n   */\n  readonly aliases = new Set<ir.AliasVariable>();\n\n  /**\n   * Number of declaration slots used within this view, or `null` if slots have not yet been\n   * allocated.\n   */\n  decls: number | null = null;\n}\n\n/**\n * Compilation-in-progress of a host binding, which contains a single unit for that host binding.\n */\nexport class HostBindingCompilationJob extends CompilationJob {\n  constructor(\n    componentName: string,\n    pool: ConstantPool,\n    compatibility: ir.CompatibilityMode,\n    mode: TemplateCompilationMode,\n  ) {\n    super(componentName, pool, compatibility, mode);\n    this.root = new HostBindingCompilationUnit(this);\n  }\n\n  override kind = CompilationJobKind.Host;\n\n  override readonly fnSuffix: string = 'HostBindings';\n\n  override readonly root: HostBindingCompilationUnit;\n\n  override get units(): Iterable<HostBindingCompilationUnit> {\n    return [this.root];\n  }\n}\n\nexport class HostBindingCompilationUnit extends CompilationUnit {\n  constructor(readonly job: HostBindingCompilationJob) {\n    super(0 as ir.XrefId);\n  }\n\n  /**\n   * Much like an element can have attributes, so can a host binding function.\n   */\n  attributes: o.LiteralArrayExpr | null = null;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\nimport {CompilationJob} from '../compilation';\n\n/**\n * Find any function calls to `$any`, excluding `this.$any`, and delete them, since they have no\n * runtime effects.\n */\nexport function deleteAnyCasts(job: CompilationJob): void {\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      ir.transformExpressionsInOp(op, removeAnys, ir.VisitorContextFlag.None);\n    }\n  }\n}\n\nfunction removeAnys(e: o.Expression): o.Expression {\n  if (\n    e instanceof o.InvokeFunctionExpr &&\n    e.fn instanceof ir.LexicalReadExpr &&\n    e.fn.name === '$any'\n  ) {\n    if (e.args.length !== 1) {\n      throw new Error('The $any builtin function expects exactly one argument.');\n    }\n    return e.args[0];\n  }\n  return e;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as ir from '../../ir';\nimport {CompilationJob} from '../compilation';\n\n/**\n * Adds apply operations after i18n expressions.\n */\nexport function applyI18nExpressions(job: CompilationJob): void {\n  const i18nContexts = new Map<ir.XrefId, ir.I18nContextOp>();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === ir.OpKind.I18nContext) {\n        i18nContexts.set(op.xref, op);\n      }\n    }\n  }\n\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      // Only add apply after expressions that are not followed by more expressions.\n      if (op.kind === ir.OpKind.I18nExpression && needsApplication(i18nContexts, op)) {\n        // TODO: what should be the source span for the apply op?\n        ir.OpList.insertAfter<ir.UpdateOp>(\n          ir.createI18nApplyOp(op.i18nOwner, op.handle, null!),\n          op,\n        );\n      }\n    }\n  }\n}\n\n/**\n * Checks whether the given expression op needs to be followed with an apply op.\n */\nfunction needsApplication(i18nContexts: Map<ir.XrefId, ir.I18nContextOp>, op: ir.I18nExpressionOp) {\n  // If the next op is not another expression, we need to apply.\n  if (op.next?.kind !== ir.OpKind.I18nExpression) {\n    return true;\n  }\n\n  const context = i18nContexts.get(op.context);\n  const nextContext = i18nContexts.get(op.next.context);\n\n  if (context === undefined) {\n    throw new Error(\n      \"AssertionError: expected an I18nContextOp to exist for the I18nExpressionOp's context\",\n    );\n  }\n\n  if (nextContext === undefined) {\n    throw new Error(\n      \"AssertionError: expected an I18nContextOp to exist for the next I18nExpressionOp's context\",\n    );\n  }\n\n  // If the next op is an expression targeting a different i18n block (or different element, in the\n  // case of i18n attributes), we need to apply.\n\n  // First, handle the case of i18n blocks.\n  if (context.i18nBlock !== null) {\n    // This is a block context. Compare the blocks.\n    if (context.i18nBlock !== nextContext.i18nBlock) {\n      return true;\n    }\n    return false;\n  }\n\n  // Second, handle the case of i18n attributes.\n  if (op.i18nOwner !== op.next.i18nOwner) {\n    return true;\n  }\n  return false;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as ir from '../../ir';\nimport {CompilationJob} from '../compilation';\n\ninterface BlockState {\n  blockXref: ir.XrefId;\n  lastSlotConsumer: ir.XrefId;\n}\n\n/**\n * Updates i18n expression ops to target the last slot in their owning i18n block, and moves them\n * after the last update instruction that depends on that slot.\n */\nexport function assignI18nSlotDependencies(job: CompilationJob) {\n  for (const unit of job.units) {\n    // The first update op.\n    let updateOp = unit.update.head;\n\n    // I18n expressions currently being moved during the iteration.\n    let i18nExpressionsInProgress: ir.I18nExpressionOp[] = [];\n\n    // Non-null  while we are iterating through an i18nStart/i18nEnd pair\n    let state: BlockState | null = null;\n\n    for (const createOp of unit.create) {\n      if (createOp.kind === ir.OpKind.I18nStart) {\n        state = {\n          blockXref: createOp.xref,\n          lastSlotConsumer: createOp.xref,\n        };\n      } else if (createOp.kind === ir.OpKind.I18nEnd) {\n        for (const op of i18nExpressionsInProgress) {\n          op.target = state!.lastSlotConsumer;\n          ir.OpList.insertBefore(op as ir.UpdateOp, updateOp!);\n        }\n        i18nExpressionsInProgress.length = 0;\n        state = null;\n      }\n\n      if (ir.hasConsumesSlotTrait(createOp)) {\n        if (state !== null) {\n          state.lastSlotConsumer = createOp.xref;\n        }\n\n        while (true) {\n          if (updateOp.next === null) {\n            break;\n          }\n\n          if (\n            state !== null &&\n            updateOp.kind === ir.OpKind.I18nExpression &&\n            updateOp.usage === ir.I18nExpressionFor.I18nText &&\n            updateOp.i18nOwner === state.blockXref\n          ) {\n            const opToRemove = updateOp;\n            updateOp = updateOp.next!;\n            ir.OpList.remove<ir.UpdateOp>(opToRemove);\n            i18nExpressionsInProgress.push(opToRemove);\n            continue;\n          }\n\n          let hasDifferentTarget = false;\n          if (ir.hasDependsOnSlotContextTrait(updateOp) && updateOp.target !== createOp.xref) {\n            hasDifferentTarget = true;\n          } else if (\n            // Some expressions may consume slots as well (e.g. `storeLet`).\n            updateOp.kind === ir.OpKind.Statement ||\n            updateOp.kind === ir.OpKind.Variable\n          ) {\n            ir.visitExpressionsInOp(updateOp, (expr) => {\n              if (\n                !hasDifferentTarget &&\n                ir.hasDependsOnSlotContextTrait(expr) &&\n                expr.target !== createOp.xref\n              ) {\n                hasDifferentTarget = true;\n              }\n            });\n          }\n\n          if (hasDifferentTarget) {\n            break;\n          }\n\n          updateOp = updateOp.next!;\n        }\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as ir from '../../ir';\nimport type {ComponentCompilationJob} from '../compilation';\n\n/**\n * Locates all of the elements defined in a creation block and outputs an op\n * that will expose their definition location in the DOM.\n */\nexport function attachSourceLocations(job: ComponentCompilationJob): void {\n  if (!job.enableDebugLocations || job.relativeTemplatePath === null) {\n    return;\n  }\n\n  for (const unit of job.units) {\n    const locations: ir.ElementSourceLocation[] = [];\n\n    for (const op of unit.create) {\n      if (op.kind === ir.OpKind.ElementStart || op.kind === ir.OpKind.Element) {\n        const start = op.startSourceSpan.start;\n        locations.push({\n          targetSlot: op.handle,\n          offset: start.offset,\n          line: start.line,\n          column: start.col,\n        });\n      }\n    }\n\n    if (locations.length > 0) {\n      unit.create.push(ir.createSourceLocationOp(job.relativeTemplatePath, locations));\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as ir from '../../ir';\nimport type {CompilationUnit} from '../compilation';\n\n/**\n * Gets a map of all elements in the given view by their xref id.\n */\nexport function createOpXrefMap(\n  unit: CompilationUnit,\n): Map<ir.XrefId, ir.ConsumesSlotOpTrait & ir.CreateOp> {\n  const map = new Map<ir.XrefId, ir.ConsumesSlotOpTrait & ir.CreateOp>();\n  for (const op of unit.create) {\n    if (!ir.hasConsumesSlotTrait(op)) {\n      continue;\n    }\n    map.set(op.xref, op);\n\n    // TODO(dylhunn): `@for` loops with `@empty` blocks need to be special-cased here,\n    // because the slot consumer trait currently only supports one slot per consumer and we\n    // need two. This should be revisited when making the refactors mentioned in:\n    // https://github.com/angular/angular/pull/53620#discussion_r1430918822\n    if (op.kind === ir.OpKind.RepeaterCreate && op.emptyView !== null) {\n      map.set(op.emptyView, op);\n    }\n  }\n  return map;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {SecurityContext} from '../../../../core';\nimport * as ir from '../../ir';\nimport {CompilationJobKind, type CompilationJob, type CompilationUnit} from '../compilation';\nimport {createOpXrefMap} from '../util/elements';\n\n/**\n * Find all extractable attribute and binding ops, and create ExtractedAttributeOps for them.\n * In cases where no instruction needs to be generated for the attribute or binding, it is removed.\n */\nexport function extractAttributes(job: CompilationJob): void {\n  for (const unit of job.units) {\n    const elements = createOpXrefMap(unit);\n    for (const op of unit.ops()) {\n      switch (op.kind) {\n        case ir.OpKind.Attribute:\n          extractAttributeOp(unit, op, elements);\n          break;\n        case ir.OpKind.Property:\n          if (\n            op.bindingKind !== ir.BindingKind.LegacyAnimation &&\n            op.bindingKind !== ir.BindingKind.Animation\n          ) {\n            let bindingKind: ir.BindingKind;\n            if (op.i18nMessage !== null && op.templateKind === null) {\n              // If the binding has an i18n context, it is an i18n attribute, and should have that\n              // kind in the consts array.\n              bindingKind = ir.BindingKind.I18n;\n            } else if (op.isStructuralTemplateAttribute) {\n              bindingKind = ir.BindingKind.Template;\n            } else {\n              bindingKind = ir.BindingKind.Property;\n            }\n\n            ir.OpList.insertBefore<ir.CreateOp>(\n              // Deliberately null i18nMessage value\n              ir.createExtractedAttributeOp(\n                op.target,\n                bindingKind,\n                null,\n                op.name,\n                /* expression */ null,\n                /* i18nContext */ null,\n                /* i18nMessage */ null,\n                op.securityContext,\n              ),\n              lookupElement(elements, op.target),\n            );\n          }\n          break;\n        case ir.OpKind.TwoWayProperty:\n          ir.OpList.insertBefore<ir.CreateOp>(\n            ir.createExtractedAttributeOp(\n              op.target,\n              ir.BindingKind.TwoWayProperty,\n              null,\n              op.name,\n              /* expression */ null,\n              /* i18nContext */ null,\n              /* i18nMessage */ null,\n              op.securityContext,\n            ),\n            lookupElement(elements, op.target),\n          );\n          break;\n        case ir.OpKind.StyleProp:\n        case ir.OpKind.ClassProp:\n          // TODO: Can style or class bindings be i18n attributes?\n\n          // The old compiler treated empty style bindings as regular bindings for the purpose of\n          // directive matching. That behavior is incorrect, but we emulate it in compatibility\n          // mode.\n          if (\n            unit.job.compatibility === ir.CompatibilityMode.TemplateDefinitionBuilder &&\n            op.expression instanceof ir.EmptyExpr\n          ) {\n            ir.OpList.insertBefore<ir.CreateOp>(\n              ir.createExtractedAttributeOp(\n                op.target,\n                ir.BindingKind.Property,\n                null,\n                op.name,\n                /* expression */ null,\n                /* i18nContext */ null,\n                /* i18nMessage */ null,\n                SecurityContext.STYLE,\n              ),\n              lookupElement(elements, op.target),\n            );\n          }\n          break;\n        case ir.OpKind.Listener:\n          if (!op.isLegacyAnimationListener) {\n            const extractedAttributeOp = ir.createExtractedAttributeOp(\n              op.target,\n              ir.BindingKind.Property,\n              null,\n              op.name,\n              /* expression */ null,\n              /* i18nContext */ null,\n              /* i18nMessage */ null,\n              SecurityContext.NONE,\n            );\n            if (job.kind === CompilationJobKind.Host) {\n              if (job.compatibility) {\n                // TemplateDefinitionBuilder does not extract listener bindings to the const array\n                // (which is honestly pretty inconsistent).\n                break;\n              }\n              // This attribute will apply to the enclosing host binding compilation unit, so order\n              // doesn't matter.\n              unit.create.push(extractedAttributeOp);\n            } else {\n              ir.OpList.insertBefore<ir.CreateOp>(\n                extractedAttributeOp,\n                lookupElement(elements, op.target),\n              );\n            }\n          }\n          break;\n        case ir.OpKind.TwoWayListener:\n          // Two-way listeners aren't supported in host bindings.\n          if (job.kind !== CompilationJobKind.Host) {\n            const extractedAttributeOp = ir.createExtractedAttributeOp(\n              op.target,\n              ir.BindingKind.Property,\n              null,\n              op.name,\n              /* expression */ null,\n              /* i18nContext */ null,\n              /* i18nMessage */ null,\n              SecurityContext.NONE,\n            );\n            ir.OpList.insertBefore<ir.CreateOp>(\n              extractedAttributeOp,\n              lookupElement(elements, op.target),\n            );\n          }\n          break;\n      }\n    }\n  }\n}\n\n/**\n * Looks up an element in the given map by xref ID.\n */\nfunction lookupElement(\n  elements: Map<ir.XrefId, ir.ConsumesSlotOpTrait & ir.CreateOp>,\n  xref: ir.XrefId,\n): ir.ConsumesSlotOpTrait & ir.CreateOp {\n  const el = elements.get(xref);\n  if (el === undefined) {\n    throw new Error('All attributes should have an element-like target.');\n  }\n  return el;\n}\n\n/**\n * Extracts an attribute binding.\n */\nfunction extractAttributeOp(\n  unit: CompilationUnit,\n  op: ir.AttributeOp,\n  elements: Map<ir.XrefId, ir.ConsumesSlotOpTrait & ir.CreateOp>,\n) {\n  if (op.expression instanceof ir.Interpolation) {\n    return;\n  }\n\n  let extractable = op.isTextAttribute || op.expression.isConstant();\n  if (unit.job.compatibility === ir.CompatibilityMode.TemplateDefinitionBuilder) {\n    // TemplateDefinitionBuilder only extracts text attributes. It does not extract attriibute\n    // bindings, even if they are constants.\n    extractable &&= op.isTextAttribute;\n  }\n\n  if (extractable) {\n    const extractedAttributeOp = ir.createExtractedAttributeOp(\n      op.target,\n      op.isStructuralTemplateAttribute ? ir.BindingKind.Template : ir.BindingKind.Attribute,\n      op.namespace,\n      op.name,\n      op.expression,\n      op.i18nContext,\n      op.i18nMessage,\n      op.securityContext,\n    );\n    if (unit.job.kind === CompilationJobKind.Host) {\n      // This attribute will apply to the enclosing host binding compilation unit, so order doesn't\n      // matter.\n      unit.create.push(extractedAttributeOp);\n    } else {\n      const ownerOp = lookupElement(elements, op.target);\n      ir.OpList.insertBefore<ir.CreateOp>(extractedAttributeOp, ownerOp);\n    }\n    ir.OpList.remove<ir.UpdateOp>(op);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nconst ARIA_PREFIX = 'aria-';\n\n/**\n * Returns whether `name` is an ARIA attribute name.\n *\n * This is a heuristic based on whether name begins with and is longer than `aria-`.\n */\nexport function isAriaAttribute(name: string): boolean {\n  return name.startsWith(ARIA_PREFIX) && name.length > ARIA_PREFIX.length;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {splitNsName} from '../../../../ml_parser/tags';\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\nimport {CompilationJob, CompilationJobKind, TemplateCompilationMode} from '../compilation';\nimport {isAriaAttribute} from '../util/attributes';\n\n/**\n * Looks up an element in the given map by xref ID.\n */\nfunction lookupElement(\n  elements: Map<ir.XrefId, ir.ElementOrContainerOps>,\n  xref: ir.XrefId,\n): ir.ElementOrContainerOps {\n  const el = elements.get(xref);\n  if (el === undefined) {\n    throw new Error('All attributes should have an element-like target.');\n  }\n  return el;\n}\n\nexport function specializeBindings(job: CompilationJob): void {\n  const elements = new Map<ir.XrefId, ir.ElementOrContainerOps>();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (!ir.isElementOrContainerOp(op)) {\n        continue;\n      }\n      elements.set(op.xref, op);\n    }\n  }\n\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      if (op.kind !== ir.OpKind.Binding) {\n        continue;\n      }\n      switch (op.bindingKind) {\n        case ir.BindingKind.Attribute:\n          if (op.name === 'ngNonBindable') {\n            ir.OpList.remove<ir.UpdateOp>(op);\n            const target = lookupElement(elements, op.target);\n            target.nonBindable = true;\n          } else if (op.name.startsWith('animate.')) {\n            ir.OpList.replace<ir.UpdateOp>(\n              op,\n              ir.createAnimationBindingOp(\n                op.name,\n                op.target,\n                op.name === 'animate.enter' ? ir.AnimationKind.ENTER : ir.AnimationKind.LEAVE,\n                op.expression,\n                op.securityContext,\n                op.sourceSpan,\n                ir.AnimationBindingKind.STRING,\n              ),\n            );\n          } else {\n            const [namespace, name] = splitNsName(op.name);\n            ir.OpList.replace<ir.UpdateOp>(\n              op,\n              ir.createAttributeOp(\n                op.target,\n                namespace,\n                name,\n                op.expression,\n                op.securityContext,\n                op.isTextAttribute,\n                op.isStructuralTemplateAttribute,\n                op.templateKind,\n                op.i18nMessage,\n                op.sourceSpan,\n              ),\n            );\n          }\n          break;\n        case ir.BindingKind.Animation:\n          ir.OpList.replace<ir.UpdateOp>(\n            op,\n            ir.createAnimationBindingOp(\n              op.name,\n              op.target,\n              op.name === 'animate.enter' ? ir.AnimationKind.ENTER : ir.AnimationKind.LEAVE,\n              op.expression,\n              op.securityContext,\n              op.sourceSpan,\n              ir.AnimationBindingKind.VALUE,\n            ),\n          );\n          break;\n        case ir.BindingKind.Property:\n        case ir.BindingKind.LegacyAnimation:\n          // Convert a property binding targeting an ARIA attribute (e.g. [aria-label]) into an\n          // attribute binding when we know it can't also target an input. Note that a `Host` job is\n          // always `DomOnly`, so this condition must be checked first.\n          if (job.mode === TemplateCompilationMode.DomOnly && isAriaAttribute(op.name)) {\n            ir.OpList.replace<ir.UpdateOp>(\n              op,\n              ir.createAttributeOp(\n                op.target,\n                /* namespace= */ null,\n                op.name,\n                op.expression,\n                op.securityContext,\n                /* isTextAttribute= */ false,\n                op.isStructuralTemplateAttribute,\n                op.templateKind,\n                op.i18nMessage,\n                op.sourceSpan,\n              ),\n            );\n          } else if (job.kind === CompilationJobKind.Host) {\n            ir.OpList.replace<ir.UpdateOp>(\n              op,\n              ir.createDomPropertyOp(\n                op.name,\n                op.expression,\n                op.bindingKind,\n                op.i18nContext,\n                op.securityContext,\n                op.sourceSpan,\n              ),\n            );\n          } else {\n            ir.OpList.replace<ir.UpdateOp>(\n              op,\n              ir.createPropertyOp(\n                op.target,\n                op.name,\n                op.expression,\n                op.bindingKind,\n                op.securityContext,\n                op.isStructuralTemplateAttribute,\n                op.templateKind,\n                op.i18nContext,\n                op.i18nMessage,\n                op.sourceSpan,\n              ),\n            );\n          }\n          break;\n        case ir.BindingKind.TwoWayProperty:\n          if (!(op.expression instanceof o.Expression)) {\n            // We shouldn't be able to hit this code path since interpolations in two-way bindings\n            // result in a parser error. We assert here so that downstream we can assume that\n            // the value is always an expression.\n            throw new Error(\n              `Expected value of two-way property binding \"${op.name}\" to be an expression`,\n            );\n          }\n\n          ir.OpList.replace<ir.UpdateOp>(\n            op,\n            ir.createTwoWayPropertyOp(\n              op.target,\n              op.name,\n              op.expression,\n              op.securityContext,\n              op.isStructuralTemplateAttribute,\n              op.templateKind,\n              op.i18nContext,\n              op.i18nMessage,\n              op.sourceSpan,\n            ),\n          );\n          break;\n        case ir.BindingKind.I18n:\n        case ir.BindingKind.ClassName:\n        case ir.BindingKind.StyleProperty:\n          throw new Error(`Unhandled binding of kind ${ir.BindingKind[op.bindingKind]}`);\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport {Identifiers as R3} from '../../../../render3/r3_identifiers';\nimport * as ir from '../../ir';\nimport {CompilationJob} from '../compilation';\n\nconst CHAIN_COMPATIBILITY = new Map<o.ExternalReference, o.ExternalReference>([\n  [R3.ariaProperty, R3.ariaProperty],\n  [R3.attribute, R3.attribute],\n  [R3.classProp, R3.classProp],\n  [R3.element, R3.element],\n  [R3.elementContainer, R3.elementContainer],\n  [R3.elementContainerEnd, R3.elementContainerEnd],\n  [R3.elementContainerStart, R3.elementContainerStart],\n  [R3.elementEnd, R3.elementEnd],\n  [R3.elementStart, R3.elementStart],\n  [R3.domProperty, R3.domProperty],\n  [R3.i18nExp, R3.i18nExp],\n  [R3.listener, R3.listener],\n  [R3.listener, R3.listener],\n  [R3.property, R3.property],\n  [R3.styleProp, R3.styleProp],\n  [R3.syntheticHostListener, R3.syntheticHostListener],\n  [R3.syntheticHostProperty, R3.syntheticHostProperty],\n  [R3.templateCreate, R3.templateCreate],\n  [R3.twoWayProperty, R3.twoWayProperty],\n  [R3.twoWayListener, R3.twoWayListener],\n  [R3.declareLet, R3.declareLet],\n  [R3.conditionalCreate, R3.conditionalBranchCreate],\n  [R3.conditionalBranchCreate, R3.conditionalBranchCreate],\n  [R3.domElement, R3.domElement],\n  [R3.domElementStart, R3.domElementStart],\n  [R3.domElementEnd, R3.domElementEnd],\n  [R3.domElementContainer, R3.domElementContainer],\n  [R3.domElementContainerStart, R3.domElementContainerStart],\n  [R3.domElementContainerEnd, R3.domElementContainerEnd],\n  [R3.domListener, R3.domListener],\n  [R3.domTemplate, R3.domTemplate],\n  [R3.animationEnter, R3.animationEnter],\n  [R3.animationLeave, R3.animationLeave],\n  [R3.animationEnterListener, R3.animationEnterListener],\n  [R3.animationLeaveListener, R3.animationLeaveListener],\n]);\n\n/**\n * Chaining results in repeated call expressions, causing a deep AST of receiver expressions. To prevent running out of\n * stack depth the maximum number of chained instructions is limited to this threshold, which has been selected\n * arbitrarily.\n */\nconst MAX_CHAIN_LENGTH = 256;\n\n/**\n * Post-process a reified view compilation and convert sequential calls to chainable instructions\n * into chain calls.\n *\n * For example, two `elementStart` operations in sequence:\n *\n * ```ts\n * elementStart(0, 'div');\n * elementStart(1, 'span');\n * ```\n *\n * Can be called as a chain instead:\n *\n * ```ts\n * elementStart(0, 'div')(1, 'span');\n * ```\n */\nexport function chain(job: CompilationJob): void {\n  for (const unit of job.units) {\n    chainOperationsInList(unit.create);\n    chainOperationsInList(unit.update);\n  }\n}\n\nfunction chainOperationsInList(opList: ir.OpList<ir.CreateOp | ir.UpdateOp>): void {\n  let chain: Chain | null = null;\n  for (const op of opList) {\n    if (op.kind !== ir.OpKind.Statement || !(op.statement instanceof o.ExpressionStatement)) {\n      // This type of statement isn't chainable.\n      chain = null;\n      continue;\n    }\n    if (\n      !(op.statement.expr instanceof o.InvokeFunctionExpr) ||\n      !(op.statement.expr.fn instanceof o.ExternalExpr)\n    ) {\n      // This is a statement, but not an instruction-type call, so not chainable.\n      chain = null;\n      continue;\n    }\n\n    const instruction = op.statement.expr.fn.value;\n    if (!CHAIN_COMPATIBILITY.has(instruction)) {\n      // This instruction isn't chainable.\n      chain = null;\n      continue;\n    }\n\n    // This instruction can be chained. It can either be added on to the previous chain (if\n    // compatible) or it can be the start of a new chain.\n    if (\n      chain !== null &&\n      CHAIN_COMPATIBILITY.get(chain.instruction) === instruction &&\n      chain.length < MAX_CHAIN_LENGTH\n    ) {\n      // This instruction can be added onto the previous chain.\n      const expression = chain.expression.callFn(\n        op.statement.expr.args,\n        op.statement.expr.sourceSpan,\n        op.statement.expr.pure,\n      );\n      chain.expression = expression;\n      chain.op.statement = expression.toStmt();\n      chain.length++;\n      ir.OpList.remove(op as ir.Op<ir.CreateOp | ir.UpdateOp>);\n    } else {\n      // Leave this instruction alone for now, but consider it the start of a new chain.\n      chain = {\n        op,\n        instruction,\n        expression: op.statement.expr,\n        length: 1,\n      };\n    }\n  }\n}\n\n/**\n * Structure representing an in-progress chain.\n */\ninterface Chain {\n  /**\n   * The statement which holds the entire chain.\n   */\n  op: ir.StatementOp<ir.CreateOp | ir.UpdateOp>;\n\n  /**\n   * The expression representing the whole current chained call.\n   *\n   * This should be the same as `op.statement.expression`, but is extracted here for convenience\n   * since the `op` type doesn't capture the fact that `op.statement` is an `o.ExpressionStatement`.\n   */\n  expression: o.Expression;\n\n  /**\n   * The instruction that is being chained.\n   */\n  instruction: o.ExternalReference;\n\n  /**\n   * The number of instructions that have been collected into this chain.\n   */\n  length: number;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as ir from '../../ir';\nimport {CompilationJob} from '../compilation';\n\n/**\n * Attribute or style interpolations of the form `[attr.foo]=\"{{foo}}\"\"` should be \"collapsed\"\n * into a plain instruction, instead of an interpolated one.\n *\n * (We cannot do this for singleton property interpolations,\n * because they need to stringify their expressions)\n *\n * The reification step is also capable of performing this transformation, but doing it early in the\n * pipeline allows other phases to accurately know what instruction will be emitted.\n */\nexport function collapseSingletonInterpolations(job: CompilationJob): void {\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      const eligibleOpKind =\n        op.kind === ir.OpKind.Attribute ||\n        op.kind === ir.OpKind.StyleProp ||\n        op.kind == ir.OpKind.StyleMap ||\n        op.kind === ir.OpKind.ClassMap;\n      if (\n        eligibleOpKind &&\n        op.expression instanceof ir.Interpolation &&\n        op.expression.strings.length === 2 &&\n        op.expression.strings.every((s) => s === '')\n      ) {\n        op.expression = op.expression.expressions[0];\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\nimport {ComponentCompilationJob} from '../compilation';\n\n/**\n * Collapse the various conditions of conditional ops (if, switch) into a single test expression.\n */\nexport function generateConditionalExpressions(job: ComponentCompilationJob): void {\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      if (op.kind !== ir.OpKind.Conditional) {\n        continue;\n      }\n\n      let test: o.Expression;\n\n      // Any case with a `null` condition is `default`. If one exists, default to it instead.\n      const defaultCase = op.conditions.findIndex((cond) => cond.expr === null);\n      if (defaultCase >= 0) {\n        const slot = op.conditions.splice(defaultCase, 1)[0].targetSlot;\n        test = new ir.SlotLiteralExpr(slot);\n      } else {\n        // By default, a switch evaluates to `-1`, causing no template to be displayed.\n        test = o.literal(-1);\n      }\n\n      // Switch expressions assign their main test to a temporary, to avoid re-executing it.\n      let tmp = op.test == null ? null : new ir.AssignTemporaryExpr(op.test, job.allocateXrefId());\n      let caseExpressionTemporaryXref: ir.XrefId | null = null;\n\n      // For each remaining condition, test whether the temporary satifies the check. (If no temp is\n      // present, just check each expression directly.)\n      for (let i = op.conditions.length - 1; i >= 0; i--) {\n        let conditionalCase = op.conditions[i];\n        if (conditionalCase.expr === null) {\n          continue;\n        }\n        if (tmp !== null) {\n          const useTmp = i === 0 ? tmp : new ir.ReadTemporaryExpr(tmp.xref);\n          conditionalCase.expr = new o.BinaryOperatorExpr(\n            o.BinaryOperator.Identical,\n            useTmp,\n            conditionalCase.expr,\n          );\n        } else if (conditionalCase.alias !== null) {\n          // Since we can only pass one variable into the conditional instruction,\n          // reuse the same variable to store the result of the expressions.\n          caseExpressionTemporaryXref ??= job.allocateXrefId();\n          conditionalCase.expr = new ir.AssignTemporaryExpr(\n            conditionalCase.expr,\n            caseExpressionTemporaryXref,\n          );\n          op.contextValue = new ir.ReadTemporaryExpr(caseExpressionTemporaryXref);\n        }\n        test = new o.ConditionalExpr(\n          conditionalCase.expr,\n          new ir.SlotLiteralExpr(conditionalCase.targetSlot),\n          test,\n        );\n      }\n\n      // Save the resulting aggregate Joost-expression.\n      op.processed = test;\n\n      // Clear the original conditions array, since we no longer need it, and don't want it to\n      // affect subsequent phases (e.g. pipe creation).\n      op.conditions = [];\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../output/output_ast';\nimport * as ir from '../ir';\n\nexport const BINARY_OPERATORS = new Map([\n  ['&&', o.BinaryOperator.And],\n  ['>', o.BinaryOperator.Bigger],\n  ['>=', o.BinaryOperator.BiggerEquals],\n  ['|', o.BinaryOperator.BitwiseOr],\n  ['&', o.BinaryOperator.BitwiseAnd],\n  ['/', o.BinaryOperator.Divide],\n  ['=', o.BinaryOperator.Assign],\n  ['==', o.BinaryOperator.Equals],\n  ['===', o.BinaryOperator.Identical],\n  ['<', o.BinaryOperator.Lower],\n  ['<=', o.BinaryOperator.LowerEquals],\n  ['-', o.BinaryOperator.Minus],\n  ['%', o.BinaryOperator.Modulo],\n  ['**', o.BinaryOperator.Exponentiation],\n  ['*', o.BinaryOperator.Multiply],\n  ['!=', o.BinaryOperator.NotEquals],\n  ['!==', o.BinaryOperator.NotIdentical],\n  ['??', o.BinaryOperator.NullishCoalesce],\n  ['||', o.BinaryOperator.Or],\n  ['+', o.BinaryOperator.Plus],\n  ['in', o.BinaryOperator.In],\n  ['+=', o.BinaryOperator.AdditionAssignment],\n  ['-=', o.BinaryOperator.SubtractionAssignment],\n  ['*=', o.BinaryOperator.MultiplicationAssignment],\n  ['/=', o.BinaryOperator.DivisionAssignment],\n  ['%=', o.BinaryOperator.RemainderAssignment],\n  ['**=', o.BinaryOperator.ExponentiationAssignment],\n  ['&&=', o.BinaryOperator.AndAssignment],\n  ['||=', o.BinaryOperator.OrAssignment],\n  ['??=', o.BinaryOperator.NullishCoalesceAssignment],\n]);\n\nexport function namespaceForKey(namespacePrefixKey: string | null): ir.Namespace {\n  const NAMESPACES = new Map([\n    ['svg', ir.Namespace.SVG],\n    ['math', ir.Namespace.Math],\n  ]);\n  if (namespacePrefixKey === null) {\n    return ir.Namespace.HTML;\n  }\n  return NAMESPACES.get(namespacePrefixKey) ?? ir.Namespace.HTML;\n}\n\nexport function keyForNamespace(namespace: ir.Namespace): string | null {\n  const NAMESPACES = new Map([\n    ['svg', ir.Namespace.SVG],\n    ['math', ir.Namespace.Math],\n  ]);\n  for (const [k, n] of NAMESPACES.entries()) {\n    if (n === namespace) {\n      return k;\n    }\n  }\n  return null; // No namespace prefix for HTML\n}\n\nexport function prefixWithNamespace(strippedTag: string, namespace: ir.Namespace): string {\n  if (namespace === ir.Namespace.HTML) {\n    return strippedTag;\n  }\n  return `:${keyForNamespace(namespace)}:${strippedTag}`;\n}\n\nexport type LiteralType = string | number | boolean | null | Array<LiteralType>;\n\nexport function literalOrArrayLiteral(value: LiteralType): o.Expression {\n  if (Array.isArray(value)) {\n    return o.literalArr(value.map(literalOrArrayLiteral));\n  }\n  return o.literal(value);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as core from '../../../../core';\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\n\nimport {\n  ComponentCompilationJob,\n  HostBindingCompilationJob,\n  type CompilationJob,\n} from '../compilation';\nimport {literalOrArrayLiteral} from '../conversion';\n\n/**\n * Converts the semantic attributes of element-like operations (elements, templates) into constant\n * array expressions, and lifts them into the overall component `consts`.\n */\nexport function collectElementConsts(job: CompilationJob): void {\n  // Collect all extracted attributes.\n  const allElementAttributes = new Map<ir.XrefId, ElementAttributes>();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === ir.OpKind.ExtractedAttribute) {\n        const attributes =\n          allElementAttributes.get(op.target) || new ElementAttributes(job.compatibility);\n        allElementAttributes.set(op.target, attributes);\n        attributes.add(op.bindingKind, op.name, op.expression, op.namespace, op.trustedValueFn);\n        ir.OpList.remove<ir.CreateOp>(op);\n      }\n    }\n  }\n\n  // Serialize the extracted attributes into the const array.\n  if (job instanceof ComponentCompilationJob) {\n    for (const unit of job.units) {\n      for (const op of unit.create) {\n        // TODO: Simplify and combine these cases.\n        if (op.kind == ir.OpKind.Projection) {\n          const attributes = allElementAttributes.get(op.xref);\n          if (attributes !== undefined) {\n            const attrArray = serializeAttributes(attributes);\n            if (attrArray.entries.length > 0) {\n              op.attributes = attrArray;\n            }\n          }\n        } else if (ir.isElementOrContainerOp(op)) {\n          op.attributes = getConstIndex(job, allElementAttributes, op.xref);\n\n          // TODO(dylhunn): `@for` loops with `@empty` blocks need to be special-cased here,\n          // because the slot consumer trait currently only supports one slot per consumer and we\n          // need two. This should be revisited when making the refactors mentioned in:\n          // https://github.com/angular/angular/pull/53620#discussion_r1430918822\n          if (op.kind === ir.OpKind.RepeaterCreate && op.emptyView !== null) {\n            op.emptyAttributes = getConstIndex(job, allElementAttributes, op.emptyView);\n          }\n        }\n      }\n    }\n  } else if (job instanceof HostBindingCompilationJob) {\n    // TODO: If the host binding case further diverges, we may want to split it into its own\n    // phase.\n    for (const [xref, attributes] of allElementAttributes.entries()) {\n      if (xref !== job.root.xref) {\n        throw new Error(\n          `An attribute would be const collected into the host binding's template function, but is not associated with the root xref.`,\n        );\n      }\n      const attrArray = serializeAttributes(attributes);\n      if (attrArray.entries.length > 0) {\n        job.root.attributes = attrArray;\n      }\n    }\n  }\n}\n\nfunction getConstIndex(\n  job: ComponentCompilationJob,\n  allElementAttributes: Map<ir.XrefId, ElementAttributes>,\n  xref: ir.XrefId,\n): ir.ConstIndex | null {\n  const attributes = allElementAttributes.get(xref);\n  if (attributes !== undefined) {\n    const attrArray = serializeAttributes(attributes);\n    if (attrArray.entries.length > 0) {\n      return job.addConst(attrArray);\n    }\n  }\n  return null;\n}\n\n/**\n * Shared instance of an empty array to avoid unnecessary array allocations.\n */\nconst FLYWEIGHT_ARRAY: ReadonlyArray<o.Expression> = Object.freeze<o.Expression[]>([]);\n\n/**\n * Container for all of the various kinds of attributes which are applied on an element.\n */\nclass ElementAttributes {\n  private known = new Map<ir.BindingKind, Set<string>>();\n  private byKind = new Map<\n    // Property bindings are excluded here, because they need to be tracked in the same\n    // array to maintain their order. They're tracked in the `propertyBindings` array.\n    Exclude<ir.BindingKind, ir.BindingKind.Property | ir.BindingKind.TwoWayProperty>,\n    o.Expression[]\n  >();\n  private propertyBindings: o.Expression[] | null = null;\n\n  projectAs: string | null = null;\n\n  get attributes(): ReadonlyArray<o.Expression> {\n    return this.byKind.get(ir.BindingKind.Attribute) ?? FLYWEIGHT_ARRAY;\n  }\n\n  get classes(): ReadonlyArray<o.Expression> {\n    return this.byKind.get(ir.BindingKind.ClassName) ?? FLYWEIGHT_ARRAY;\n  }\n\n  get styles(): ReadonlyArray<o.Expression> {\n    return this.byKind.get(ir.BindingKind.StyleProperty) ?? FLYWEIGHT_ARRAY;\n  }\n\n  get bindings(): ReadonlyArray<o.Expression> {\n    return this.propertyBindings ?? FLYWEIGHT_ARRAY;\n  }\n\n  get template(): ReadonlyArray<o.Expression> {\n    return this.byKind.get(ir.BindingKind.Template) ?? FLYWEIGHT_ARRAY;\n  }\n\n  get i18n(): ReadonlyArray<o.Expression> {\n    return this.byKind.get(ir.BindingKind.I18n) ?? FLYWEIGHT_ARRAY;\n  }\n\n  constructor(private compatibility: ir.CompatibilityMode) {}\n\n  private isKnown(kind: ir.BindingKind, name: string) {\n    const nameToValue = this.known.get(kind) ?? new Set<string>();\n    this.known.set(kind, nameToValue);\n    if (nameToValue.has(name)) {\n      return true;\n    }\n    nameToValue.add(name);\n    return false;\n  }\n\n  add(\n    kind: ir.BindingKind,\n    name: string,\n    value: o.Expression | null,\n    namespace: string | null,\n    trustedValueFn: o.Expression | null,\n  ): void {\n    // TemplateDefinitionBuilder puts duplicate attribute, class, and style values into the consts\n    // array. This seems inefficient, we can probably keep just the first one or the last value\n    // (whichever actually gets applied when multiple values are listed for the same attribute).\n    const allowDuplicates =\n      this.compatibility === ir.CompatibilityMode.TemplateDefinitionBuilder &&\n      (kind === ir.BindingKind.Attribute ||\n        kind === ir.BindingKind.ClassName ||\n        kind === ir.BindingKind.StyleProperty);\n    if (!allowDuplicates && this.isKnown(kind, name)) {\n      return;\n    }\n\n    // TODO: Can this be its own phase\n    if (name === 'ngProjectAs') {\n      if (\n        value === null ||\n        !(value instanceof o.LiteralExpr) ||\n        value.value == null ||\n        typeof value.value?.toString() !== 'string'\n      ) {\n        throw Error('ngProjectAs must have a string literal value');\n      }\n      this.projectAs = value.value.toString();\n      // TODO: TemplateDefinitionBuilder allows `ngProjectAs` to also be assigned as a literal\n      // attribute. Is this sane?\n    }\n\n    const array = this.arrayFor(kind);\n    array.push(...getAttributeNameLiterals(namespace, name));\n    if (kind === ir.BindingKind.Attribute || kind === ir.BindingKind.StyleProperty) {\n      if (value === null) {\n        throw Error('Attribute, i18n attribute, & style element attributes must have a value');\n      }\n      if (trustedValueFn !== null) {\n        if (!ir.isStringLiteral(value)) {\n          throw Error('AssertionError: extracted attribute value should be string literal');\n        }\n        array.push(\n          o.taggedTemplate(\n            trustedValueFn,\n            new o.TemplateLiteralExpr([new o.TemplateLiteralElementExpr(value.value)], []),\n            undefined,\n            value.sourceSpan,\n          ),\n        );\n      } else {\n        array.push(value);\n      }\n    }\n  }\n\n  private arrayFor(kind: ir.BindingKind): o.Expression[] {\n    if (kind === ir.BindingKind.Property || kind === ir.BindingKind.TwoWayProperty) {\n      this.propertyBindings ??= [];\n      return this.propertyBindings;\n    } else {\n      if (!this.byKind.has(kind)) {\n        this.byKind.set(kind, []);\n      }\n      return this.byKind.get(kind)!;\n    }\n  }\n}\n\n/**\n * Gets an array of literal expressions representing the attribute's namespaced name.\n */\nfunction getAttributeNameLiterals(namespace: string | null, name: string): o.LiteralExpr[] {\n  const nameLiteral = o.literal(name);\n\n  if (namespace) {\n    return [o.literal(core.AttributeMarker.NamespaceURI), o.literal(namespace), nameLiteral];\n  }\n\n  return [nameLiteral];\n}\n\n/**\n * Serializes an ElementAttributes object into an array expression.\n */\nfunction serializeAttributes({\n  attributes,\n  bindings,\n  classes,\n  i18n,\n  projectAs,\n  styles,\n  template,\n}: ElementAttributes): o.LiteralArrayExpr {\n  const attrArray = [...attributes];\n\n  if (projectAs !== null) {\n    // Parse the attribute value into a CssSelectorList. Note that we only take the\n    // first selector, because we don't support multiple selectors in ngProjectAs.\n    const parsedR3Selector = core.parseSelectorToR3Selector(projectAs)[0];\n    attrArray.push(\n      o.literal(core.AttributeMarker.ProjectAs),\n      literalOrArrayLiteral(parsedR3Selector),\n    );\n  }\n  if (classes.length > 0) {\n    attrArray.push(o.literal(core.AttributeMarker.Classes), ...classes);\n  }\n  if (styles.length > 0) {\n    attrArray.push(o.literal(core.AttributeMarker.Styles), ...styles);\n  }\n  if (bindings.length > 0) {\n    attrArray.push(o.literal(core.AttributeMarker.Bindings), ...bindings);\n  }\n  if (template.length > 0) {\n    attrArray.push(o.literal(core.AttributeMarker.Template), ...template);\n  }\n  if (i18n.length > 0) {\n    attrArray.push(o.literal(core.AttributeMarker.I18n), ...i18n);\n  }\n  return o.literalArr(attrArray);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as ir from '../../ir';\nimport * as o from '../../../../output/output_ast';\nimport {CompilationJob, CompilationJobKind} from '../compilation';\n\n/**\n * Looks up an element in the given map by xref ID.\n */\nfunction lookupElement(\n  elements: Map<ir.XrefId, ir.ElementOrContainerOps>,\n  xref: ir.XrefId,\n): ir.ElementOrContainerOps {\n  const el = elements.get(xref);\n  if (el === undefined) {\n    throw new Error('All attributes should have an element-like target.');\n  }\n  return el;\n}\n\nexport function convertAnimations(job: CompilationJob): void {\n  const elements = new Map<ir.XrefId, ir.ElementOrContainerOps>();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (!ir.isElementOrContainerOp(op)) {\n        continue;\n      }\n      elements.set(op.xref, op);\n    }\n  }\n\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      if (op.kind === ir.OpKind.AnimationBinding) {\n        const createAnimationOp = getAnimationOp(op);\n        if (job.kind === CompilationJobKind.Host) {\n          unit.create.push(createAnimationOp);\n        } else {\n          ir.OpList.insertAfter<ir.CreateOp>(createAnimationOp, lookupElement(elements, op.target));\n        }\n        ir.OpList.remove<ir.UpdateOp>(op);\n      }\n    }\n  }\n}\n\nfunction getAnimationOp(op: ir.AnimationBindingOp): ir.AnimationOp | ir.AnimationStringOp {\n  if (op.animationBindingKind === ir.AnimationBindingKind.STRING) {\n    // this is a simple string case\n    return ir.createAnimationStringOp(\n      op.name,\n      op.target,\n      op.name === 'animate.enter' ? ir.AnimationKind.ENTER : ir.AnimationKind.LEAVE,\n      op.expression,\n      op.securityContext,\n      op.sourceSpan,\n    );\n  } else {\n    const expression = op.expression as ir.Expression;\n    return ir.createAnimationOp(\n      op.name,\n      op.target,\n      op.name === 'animate.enter' ? ir.AnimationKind.ENTER : ir.AnimationKind.LEAVE,\n      [ir.createStatementOp(new o.ReturnStatement(expression, expression.sourceSpan))],\n      op.securityContext,\n      op.sourceSpan,\n    );\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as ir from '../../ir';\nimport {CompilationJob} from '../compilation';\n\n/**\n * Some binding instructions in the update block may actually correspond to i18n bindings. In that\n * case, they should be replaced with i18nExp instructions for the dynamic portions.\n */\nexport function convertI18nBindings(job: CompilationJob): void {\n  const i18nAttributesByElem: Map<ir.XrefId, ir.I18nAttributesOp> = new Map();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === ir.OpKind.I18nAttributes) {\n        i18nAttributesByElem.set(op.target, op);\n      }\n    }\n\n    for (const op of unit.update) {\n      switch (op.kind) {\n        case ir.OpKind.Property:\n        case ir.OpKind.Attribute:\n          if (op.i18nContext === null) {\n            continue;\n          }\n\n          if (!(op.expression instanceof ir.Interpolation)) {\n            continue;\n          }\n\n          const i18nAttributesForElem = i18nAttributesByElem.get(op.target);\n          if (i18nAttributesForElem === undefined) {\n            throw new Error(\n              'AssertionError: An i18n attribute binding instruction requires the owning element to have an I18nAttributes create instruction',\n            );\n          }\n\n          if (i18nAttributesForElem.target !== op.target) {\n            throw new Error(\n              'AssertionError: Expected i18nAttributes target element to match binding target element',\n            );\n          }\n\n          const ops: ir.UpdateOp[] = [];\n          for (let i = 0; i < op.expression.expressions.length; i++) {\n            const expr = op.expression.expressions[i];\n\n            if (op.expression.i18nPlaceholders.length !== op.expression.expressions.length) {\n              throw new Error(\n                `AssertionError: An i18n attribute binding instruction requires the same number of expressions and placeholders, but found ${op.expression.i18nPlaceholders.length} placeholders and ${op.expression.expressions.length} expressions`,\n              );\n            }\n\n            ops.push(\n              ir.createI18nExpressionOp(\n                op.i18nContext,\n                i18nAttributesForElem.target,\n                i18nAttributesForElem.xref,\n                i18nAttributesForElem.handle,\n                expr,\n                null,\n                op.expression.i18nPlaceholders[i],\n                ir.I18nParamResolutionTime.Creation,\n                ir.I18nExpressionFor.I18nAttribute,\n                op.name,\n                op.sourceSpan,\n              ),\n            );\n          }\n          ir.OpList.replaceWithMany(op as ir.UpdateOp, ops);\n          break;\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as i18n from '../../../../i18n/i18n_ast';\nimport * as ir from '../../ir';\nimport {CompilationJob} from '../compilation';\n\n/**\n * Create one helper context op per i18n block (including generate descending blocks).\n *\n * Also, if an ICU exists inside an i18n block that also contains other localizable content (such as\n * string), create an additional helper context op for the ICU.\n *\n * These context ops are later used for generating i18n messages. (Although we generate at least one\n * context op per nested view, we will collect them up the tree later, to generate a top-level\n * message.)\n */\nexport function createI18nContexts(job: CompilationJob) {\n  // Create i18n context ops for i18n attrs.\n  const attrContextByMessage = new Map<i18n.Message, ir.XrefId>();\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      switch (op.kind) {\n        case ir.OpKind.Binding:\n        case ir.OpKind.Property:\n        case ir.OpKind.Attribute:\n        case ir.OpKind.ExtractedAttribute:\n          if (op.i18nMessage === null) {\n            continue;\n          }\n          if (!attrContextByMessage.has(op.i18nMessage)) {\n            const i18nContext = ir.createI18nContextOp(\n              ir.I18nContextKind.Attr,\n              job.allocateXrefId(),\n              null,\n              op.i18nMessage,\n              null!,\n            );\n            unit.create.push(i18nContext);\n            attrContextByMessage.set(op.i18nMessage, i18nContext.xref);\n          }\n          op.i18nContext = attrContextByMessage.get(op.i18nMessage)!;\n          break;\n      }\n    }\n  }\n\n  // Create i18n context ops for root i18n blocks.\n  const blockContextByI18nBlock = new Map<ir.XrefId, ir.I18nContextOp>();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case ir.OpKind.I18nStart:\n          if (op.xref === op.root) {\n            const contextOp = ir.createI18nContextOp(\n              ir.I18nContextKind.RootI18n,\n              job.allocateXrefId(),\n              op.xref,\n              op.message,\n              null!,\n            );\n            unit.create.push(contextOp);\n            op.context = contextOp.xref;\n            blockContextByI18nBlock.set(op.xref, contextOp);\n          }\n          break;\n      }\n    }\n  }\n\n  // Assign i18n contexts for child i18n blocks. These don't need their own conext, instead they\n  // should inherit from their root i18n block.\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === ir.OpKind.I18nStart && op.xref !== op.root) {\n        const rootContext = blockContextByI18nBlock.get(op.root);\n        if (rootContext === undefined) {\n          throw Error('AssertionError: Root i18n block i18n context should have been created.');\n        }\n        op.context = rootContext.xref;\n        blockContextByI18nBlock.set(op.xref, rootContext);\n      }\n    }\n  }\n\n  // Create or assign i18n contexts for ICUs.\n  let currentI18nOp: ir.I18nStartOp | null = null;\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case ir.OpKind.I18nStart:\n          currentI18nOp = op;\n          break;\n        case ir.OpKind.I18nEnd:\n          currentI18nOp = null;\n          break;\n        case ir.OpKind.IcuStart:\n          if (currentI18nOp === null) {\n            throw Error('AssertionError: Unexpected ICU outside of an i18n block.');\n          }\n          if (op.message.id !== currentI18nOp.message.id) {\n            // This ICU is a sub-message inside its parent i18n block message. We need to give it\n            // its own context.\n            const contextOp = ir.createI18nContextOp(\n              ir.I18nContextKind.Icu,\n              job.allocateXrefId(),\n              currentI18nOp.root,\n              op.message,\n              null!,\n            );\n            unit.create.push(contextOp);\n            op.context = contextOp.xref;\n          } else {\n            // This ICU is the only translatable content in its parent i18n block. We need to\n            // convert the parent's context into an ICU context.\n            op.context = currentI18nOp.context;\n            blockContextByI18nBlock.get(currentI18nOp.xref)!.contextKind = ir.I18nContextKind.Icu;\n          }\n          break;\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as ir from '../../ir';\nimport type {CompilationJob} from '../compilation';\n\n/**\n * Deduplicate text bindings, e.g. <div class=\"cls1\" class=\"cls2\">\n */\nexport function deduplicateTextBindings(job: CompilationJob): void {\n  const seen = new Map<ir.XrefId, Set<string>>();\n  for (const unit of job.units) {\n    for (const op of unit.update.reversed()) {\n      if (op.kind === ir.OpKind.Binding && op.isTextAttribute) {\n        const seenForElement = seen.get(op.target) || new Set();\n        if (seenForElement.has(op.name)) {\n          if (job.compatibility === ir.CompatibilityMode.TemplateDefinitionBuilder) {\n            // For most duplicated attributes, TemplateDefinitionBuilder lists all of the values in\n            // the consts array. However, for style and class attributes it only keeps the last one.\n            // We replicate that behavior here since it has actual consequences for apps with\n            // duplicate class or style attrs.\n            if (op.name === 'style' || op.name === 'class') {\n              ir.OpList.remove<ir.UpdateOp>(op);\n            }\n          } else {\n            // TODO: Determine the correct behavior. It would probably make sense to merge multiple\n            // style and class attributes. Alternatively we could just throw an error, as HTML\n            // doesn't permit duplicate attributes.\n          }\n        }\n        seenForElement.add(op.name);\n        seen.set(op.target, seenForElement);\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as ir from '../../ir';\nimport type {ComponentCompilationJob} from '../compilation';\nimport {literalOrArrayLiteral} from '../conversion';\n\n/**\n * Defer instructions take a configuration array, which should be collected into the component\n * consts. This phase finds the config options, and creates the corresponding const array.\n */\nexport function configureDeferInstructions(job: ComponentCompilationJob): void {\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind !== ir.OpKind.Defer) {\n        continue;\n      }\n\n      if (op.placeholderMinimumTime !== null) {\n        op.placeholderConfig = new ir.ConstCollectedExpr(\n          literalOrArrayLiteral([op.placeholderMinimumTime]),\n        );\n      }\n      if (op.loadingMinimumTime !== null || op.loadingAfterTime !== null) {\n        op.loadingConfig = new ir.ConstCollectedExpr(\n          literalOrArrayLiteral([op.loadingMinimumTime, op.loadingAfterTime]),\n        );\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as ir from '../../ir';\nimport type {ComponentCompilationJob, ViewCompilationUnit} from '../compilation';\n\n/**\n * Some `defer` conditions can reference other elements in the template, using their local reference\n * names. However, the semantics are quite different from the normal local reference system: in\n * particular, we need to look at local reference names in enclosing views. This phase resolves\n * all such references to actual xrefs.\n */\nexport function resolveDeferTargetNames(job: ComponentCompilationJob): void {\n  const scopes = new Map<ir.XrefId, Scope>();\n\n  function getScopeForView(view: ViewCompilationUnit): Scope {\n    if (scopes.has(view.xref)) {\n      return scopes.get(view.xref)!;\n    }\n\n    const scope = new Scope();\n    for (const op of view.create) {\n      // add everything that can be referenced.\n      if (!ir.isElementOrContainerOp(op) || op.localRefs === null) {\n        continue;\n      }\n      if (!Array.isArray(op.localRefs)) {\n        throw new Error(\n          'LocalRefs were already processed, but were needed to resolve defer targets.',\n        );\n      }\n\n      for (const ref of op.localRefs) {\n        if (ref.target !== '') {\n          continue;\n        }\n        scope.targets.set(ref.name, {xref: op.xref, slot: op.handle});\n      }\n    }\n\n    scopes.set(view.xref, scope);\n    return scope;\n  }\n\n  function resolveTrigger(\n    deferOwnerView: ViewCompilationUnit,\n    op: ir.DeferOnOp,\n    placeholderView: ir.XrefId | null,\n  ): void {\n    switch (op.trigger.kind) {\n      case ir.DeferTriggerKind.Idle:\n      case ir.DeferTriggerKind.Never:\n      case ir.DeferTriggerKind.Immediate:\n      case ir.DeferTriggerKind.Timer:\n        return;\n      case ir.DeferTriggerKind.Hover:\n      case ir.DeferTriggerKind.Interaction:\n      case ir.DeferTriggerKind.Viewport:\n        if (op.trigger.targetName === null) {\n          // A `null` target name indicates we should default to the first element in the\n          // placeholder block.\n          if (placeholderView === null) {\n            throw new Error('defer on trigger with no target name must have a placeholder block');\n          }\n          const placeholder = job.views.get(placeholderView);\n          if (placeholder == undefined) {\n            throw new Error('AssertionError: could not find placeholder view for defer on trigger');\n          }\n          for (const placeholderOp of placeholder.create) {\n            if (\n              ir.hasConsumesSlotTrait(placeholderOp) &&\n              (ir.isElementOrContainerOp(placeholderOp) ||\n                placeholderOp.kind === ir.OpKind.Projection)\n            ) {\n              op.trigger.targetXref = placeholderOp.xref;\n              op.trigger.targetView = placeholderView;\n              op.trigger.targetSlotViewSteps = -1;\n              op.trigger.targetSlot = placeholderOp.handle;\n              return;\n            }\n          }\n          return;\n        }\n        let view: ViewCompilationUnit | null =\n          placeholderView !== null ? job.views.get(placeholderView)! : deferOwnerView;\n        let step = placeholderView !== null ? -1 : 0;\n\n        while (view !== null) {\n          const scope = getScopeForView(view);\n          if (scope.targets.has(op.trigger.targetName)) {\n            const {xref, slot} = scope.targets.get(op.trigger.targetName)!;\n\n            op.trigger.targetXref = xref;\n            op.trigger.targetView = view.xref;\n            op.trigger.targetSlotViewSteps = step;\n            op.trigger.targetSlot = slot;\n            return;\n          }\n\n          view = view.parent !== null ? job.views.get(view.parent)! : null;\n          step++;\n        }\n        break;\n      default:\n        throw new Error(`Trigger kind ${(op.trigger as any).kind} not handled`);\n    }\n  }\n\n  // Find the defer ops, and assign the data about their targets.\n  for (const unit of job.units) {\n    const defers = new Map<ir.XrefId, ir.DeferOp>();\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case ir.OpKind.Defer:\n          defers.set(op.xref, op);\n          break;\n        case ir.OpKind.DeferOn:\n          const deferOp = defers.get(op.defer)!;\n          resolveTrigger(\n            unit,\n            op,\n            op.modifier === ir.DeferOpModifierKind.HYDRATE\n              ? deferOp.mainView\n              : deferOp.placeholderView,\n          );\n          break;\n      }\n    }\n  }\n}\n\nclass Scope {\n  targets = new Map<string, {xref: ir.XrefId; slot: ir.SlotHandle}>();\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as ir from '../../ir';\nimport type {CompilationJob} from '../compilation';\n\nconst REPLACEMENTS = new Map<ir.OpKind, [ir.OpKind, ir.OpKind]>([\n  [ir.OpKind.ElementEnd, [ir.OpKind.ElementStart, ir.OpKind.Element]],\n  [ir.OpKind.ContainerEnd, [ir.OpKind.ContainerStart, ir.OpKind.Container]],\n  [ir.OpKind.I18nEnd, [ir.OpKind.I18nStart, ir.OpKind.I18n]],\n]);\n\n/**\n * Op kinds that should not prevent merging of start/end ops.\n */\nconst IGNORED_OP_KINDS = new Set([ir.OpKind.Pipe]);\n\n/**\n * Replace sequences of mergable instructions (e.g. `ElementStart` and `ElementEnd`) with a\n * consolidated instruction (e.g. `Element`).\n */\nexport function collapseEmptyInstructions(job: CompilationJob): void {\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      // Find end ops that may be able to be merged.\n      const opReplacements = REPLACEMENTS.get(op.kind);\n      if (opReplacements === undefined) {\n        continue;\n      }\n      const [startKind, mergedKind] = opReplacements;\n\n      // Locate the previous (non-ignored) op.\n      let prevOp: ir.CreateOp | null = op.prev;\n      while (prevOp !== null && IGNORED_OP_KINDS.has(prevOp.kind)) {\n        prevOp = prevOp.prev;\n      }\n\n      // If the previous op is the corresponding start op, we can megre.\n      if (prevOp !== null && prevOp.kind === startKind) {\n        // Transmute the start instruction to the merged version. This is safe as they're designed\n        // to be identical apart from the `kind`.\n        (prevOp as ir.Op<ir.CreateOp>).kind = mergedKind;\n\n        // Remove the end instruction.\n        ir.OpList.remove<ir.CreateOp>(op);\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\nimport {CompilationJob} from '../compilation';\n\ninterface SafeTransformContext {\n  job: CompilationJob;\n}\n\n/**\n * Safe read expressions such as `a?.b` have different semantics in Angular templates as\n * compared to JavaScript. In particular, they default to `null` instead of `undefined`. This phase\n * finds all unresolved safe read expressions, and converts them into the appropriate output AST\n * reads, guarded by null checks. We generate temporaries as needed, to avoid re-evaluating the same\n * sub-expression multiple times.\n */\nexport function expandSafeReads(job: CompilationJob): void {\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      ir.transformExpressionsInOp(op, (e) => safeTransform(e, {job}), ir.VisitorContextFlag.None);\n      ir.transformExpressionsInOp(op, ternaryTransform, ir.VisitorContextFlag.None);\n    }\n  }\n}\n\n// A lookup set of all the expression kinds that require a temporary variable to be generated.\nconst requiresTemporary = [\n  o.InvokeFunctionExpr,\n  o.LiteralArrayExpr,\n  o.LiteralMapExpr,\n  o.ParenthesizedExpr,\n  ir.SafeInvokeFunctionExpr,\n  ir.PipeBindingExpr,\n].map((e) => e.constructor.name);\n\nfunction needsTemporaryInSafeAccess(e: o.Expression): boolean {\n  // TODO: We probably want to use an expression visitor to recursively visit all descendents.\n  // However, that would potentially do a lot of extra work (because it cannot short circuit), so we\n  // implement the logic ourselves for now.\n  if (e instanceof o.UnaryOperatorExpr) {\n    return needsTemporaryInSafeAccess(e.expr);\n  } else if (e instanceof o.BinaryOperatorExpr) {\n    return needsTemporaryInSafeAccess(e.lhs) || needsTemporaryInSafeAccess(e.rhs);\n  } else if (e instanceof o.ConditionalExpr) {\n    if (e.falseCase && needsTemporaryInSafeAccess(e.falseCase)) return true;\n    return needsTemporaryInSafeAccess(e.condition) || needsTemporaryInSafeAccess(e.trueCase);\n  } else if (e instanceof o.NotExpr) {\n    return needsTemporaryInSafeAccess(e.condition);\n  } else if (e instanceof ir.AssignTemporaryExpr) {\n    return needsTemporaryInSafeAccess(e.expr);\n  } else if (e instanceof o.ReadPropExpr) {\n    return needsTemporaryInSafeAccess(e.receiver);\n  } else if (e instanceof o.ReadKeyExpr) {\n    return needsTemporaryInSafeAccess(e.receiver) || needsTemporaryInSafeAccess(e.index);\n  } else if (e instanceof o.ParenthesizedExpr) {\n    return needsTemporaryInSafeAccess(e.expr);\n  }\n  // TODO: Switch to a method which is exhaustive of newly added expression subtypes.\n  return (\n    e instanceof o.InvokeFunctionExpr ||\n    e instanceof o.LiteralArrayExpr ||\n    e instanceof o.LiteralMapExpr ||\n    e instanceof ir.SafeInvokeFunctionExpr ||\n    e instanceof ir.PipeBindingExpr\n  );\n}\n\nfunction temporariesIn(e: o.Expression): Set<ir.XrefId> {\n  const temporaries = new Set<ir.XrefId>();\n  // TODO: Although it's not currently supported by the transform helper, we should be able to\n  // short-circuit exploring the tree to do less work. In particular, we don't have to penetrate\n  // into the subexpressions of temporary assignments.\n  ir.transformExpressionsInExpression(\n    e,\n    (e) => {\n      if (e instanceof ir.AssignTemporaryExpr) {\n        temporaries.add(e.xref);\n      }\n      return e;\n    },\n    ir.VisitorContextFlag.None,\n  );\n  return temporaries;\n}\n\nfunction eliminateTemporaryAssignments(\n  e: o.Expression,\n  tmps: Set<ir.XrefId>,\n  ctx: SafeTransformContext,\n): o.Expression {\n  // TODO: We can be more efficient than the transform helper here. We don't need to visit any\n  // descendents of temporary assignments.\n  ir.transformExpressionsInExpression(\n    e,\n    (e) => {\n      if (e instanceof ir.AssignTemporaryExpr && tmps.has(e.xref)) {\n        const read = new ir.ReadTemporaryExpr(e.xref);\n        // `TemplateDefinitionBuilder` has the (accidental?) behavior of generating assignments of\n        // temporary variables to themselves. This happens because some subexpression that the\n        // temporary refers to, possibly through nested temporaries, has a function call. We copy that\n        // behavior here.\n        return ctx.job.compatibility === ir.CompatibilityMode.TemplateDefinitionBuilder\n          ? new ir.AssignTemporaryExpr(read, read.xref)\n          : read;\n      }\n      return e;\n    },\n    ir.VisitorContextFlag.None,\n  );\n  return e;\n}\n\n/**\n * Creates a safe ternary guarded by the input expression, and with a body generated by the provided\n * callback on the input expression. Generates a temporary variable assignment if needed, and\n * deduplicates nested temporary assignments if needed.\n */\nfunction safeTernaryWithTemporary(\n  guard: o.Expression,\n  body: (e: o.Expression) => o.Expression,\n  ctx: SafeTransformContext,\n): ir.SafeTernaryExpr {\n  let result: [o.Expression, o.Expression];\n  if (needsTemporaryInSafeAccess(guard)) {\n    const xref = ctx.job.allocateXrefId();\n    result = [new ir.AssignTemporaryExpr(guard, xref), new ir.ReadTemporaryExpr(xref)];\n  } else {\n    result = [guard, guard.clone()];\n    // Consider an expression like `a?.[b?.c()]?.d`. The `b?.c()` will be transformed first,\n    // introducing a temporary assignment into the key. Then, as part of expanding the `?.d`. That\n    // assignment will be duplicated into both the guard and expression sides. We de-duplicate it,\n    // by transforming it from an assignment into a read on the expression side.\n    eliminateTemporaryAssignments(result[1], temporariesIn(result[0]), ctx);\n  }\n  return new ir.SafeTernaryExpr(result[0], body(result[1]));\n}\n\nfunction isSafeAccessExpression(\n  e: o.Expression,\n): e is ir.SafePropertyReadExpr | ir.SafeKeyedReadExpr | ir.SafeInvokeFunctionExpr {\n  return (\n    e instanceof ir.SafePropertyReadExpr ||\n    e instanceof ir.SafeKeyedReadExpr ||\n    e instanceof ir.SafeInvokeFunctionExpr\n  );\n}\n\nfunction isUnsafeAccessExpression(\n  e: o.Expression,\n): e is o.ReadPropExpr | o.ReadKeyExpr | o.InvokeFunctionExpr {\n  return (\n    e instanceof o.ReadPropExpr || e instanceof o.ReadKeyExpr || e instanceof o.InvokeFunctionExpr\n  );\n}\n\nfunction isAccessExpression(\n  e: o.Expression,\n): e is\n  | o.ReadPropExpr\n  | ir.SafePropertyReadExpr\n  | o.ReadKeyExpr\n  | ir.SafeKeyedReadExpr\n  | o.InvokeFunctionExpr\n  | ir.SafeInvokeFunctionExpr {\n  return isSafeAccessExpression(e) || isUnsafeAccessExpression(e);\n}\n\nfunction deepestSafeTernary(e: o.Expression): ir.SafeTernaryExpr | null {\n  if (isAccessExpression(e) && e.receiver instanceof ir.SafeTernaryExpr) {\n    let st = e.receiver;\n    while (st.expr instanceof ir.SafeTernaryExpr) {\n      st = st.expr;\n    }\n    return st;\n  }\n  return null;\n}\n\n// TODO: When strict compatibility with TemplateDefinitionBuilder is not required, we can use `&&`\n// instead to save some code size.\nfunction safeTransform(e: o.Expression, ctx: SafeTransformContext): o.Expression {\n  if (!isAccessExpression(e)) {\n    return e;\n  }\n\n  const dst = deepestSafeTernary(e);\n\n  if (dst) {\n    if (e instanceof o.InvokeFunctionExpr) {\n      dst.expr = dst.expr.callFn(e.args);\n      return e.receiver;\n    }\n    if (e instanceof o.ReadPropExpr) {\n      dst.expr = dst.expr.prop(e.name);\n      return e.receiver;\n    }\n    if (e instanceof o.ReadKeyExpr) {\n      dst.expr = dst.expr.key(e.index);\n      return e.receiver;\n    }\n    if (e instanceof ir.SafeInvokeFunctionExpr) {\n      dst.expr = safeTernaryWithTemporary(dst.expr, (r: o.Expression) => r.callFn(e.args), ctx);\n      return e.receiver;\n    }\n    if (e instanceof ir.SafePropertyReadExpr) {\n      dst.expr = safeTernaryWithTemporary(dst.expr, (r: o.Expression) => r.prop(e.name), ctx);\n      return e.receiver;\n    }\n    if (e instanceof ir.SafeKeyedReadExpr) {\n      dst.expr = safeTernaryWithTemporary(dst.expr, (r: o.Expression) => r.key(e.index), ctx);\n      return e.receiver;\n    }\n  } else {\n    if (e instanceof ir.SafeInvokeFunctionExpr) {\n      return safeTernaryWithTemporary(e.receiver, (r: o.Expression) => r.callFn(e.args), ctx);\n    }\n    if (e instanceof ir.SafePropertyReadExpr) {\n      return safeTernaryWithTemporary(e.receiver, (r: o.Expression) => r.prop(e.name), ctx);\n    }\n    if (e instanceof ir.SafeKeyedReadExpr) {\n      return safeTernaryWithTemporary(e.receiver, (r: o.Expression) => r.key(e.index), ctx);\n    }\n  }\n\n  return e;\n}\n\nfunction ternaryTransform(e: o.Expression): o.Expression {\n  if (!(e instanceof ir.SafeTernaryExpr)) {\n    return e;\n  }\n  return new o.ParenthesizedExpr(\n    new o.ConditionalExpr(\n      new o.BinaryOperatorExpr(o.BinaryOperator.Equals, e.guard, o.NULL_EXPR),\n      o.NULL_EXPR,\n      e.expr,\n    ),\n  );\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\nimport {CompilationJob} from '../compilation';\n\n/**\n * The escape sequence used indicate message param values.\n */\nconst ESCAPE = '\\uFFFD';\n\n/**\n * Marker used to indicate an element tag.\n */\nconst ELEMENT_MARKER = '#';\n\n/**\n * Marker used to indicate a template tag.\n */\nconst TEMPLATE_MARKER = '*';\n\n/**\n * Marker used to indicate closing of an element or template tag.\n */\nconst TAG_CLOSE_MARKER = '/';\n\n/**\n * Marker used to indicate the sub-template context.\n */\nconst CONTEXT_MARKER = ':';\n\n/**\n * Marker used to indicate the start of a list of values.\n */\nconst LIST_START_MARKER = '[';\n\n/**\n * Marker used to indicate the end of a list of values.\n */\nconst LIST_END_MARKER = ']';\n\n/**\n * Delimiter used to separate multiple values in a list.\n */\nconst LIST_DELIMITER = '|';\n\n/**\n * Formats the param maps on extracted message ops into a maps of `Expression` objects that can be\n * used in the final output.\n */\nexport function extractI18nMessages(job: CompilationJob): void {\n  // Create an i18n message for each context.\n  // TODO: Merge the context op with the message op since they're 1:1 anyways.\n  const i18nMessagesByContext = new Map<ir.XrefId, ir.I18nMessageOp>();\n  const i18nBlocks = new Map<ir.XrefId, ir.I18nStartOp>();\n  const i18nContexts = new Map<ir.XrefId, ir.I18nContextOp>();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case ir.OpKind.I18nContext:\n          const i18nMessageOp = createI18nMessage(job, op);\n          unit.create.push(i18nMessageOp);\n          i18nMessagesByContext.set(op.xref, i18nMessageOp);\n          i18nContexts.set(op.xref, op);\n          break;\n        case ir.OpKind.I18nStart:\n          i18nBlocks.set(op.xref, op);\n          break;\n      }\n    }\n  }\n\n  // Associate sub-messages for ICUs with their root message. At this point we can also remove the\n  // ICU start/end ops, as they are no longer needed.\n  let currentIcu: ir.IcuStartOp | null = null;\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case ir.OpKind.IcuStart:\n          currentIcu = op;\n          ir.OpList.remove<ir.CreateOp>(op);\n          // Skip any contexts not associated with an ICU.\n          const icuContext = i18nContexts.get(op.context!)!;\n          if (icuContext.contextKind !== ir.I18nContextKind.Icu) {\n            continue;\n          }\n          // Skip ICUs that share a context with their i18n message. These represent root-level\n          // ICUs, not sub-messages.\n          const i18nBlock = i18nBlocks.get(icuContext.i18nBlock!)!;\n          if (i18nBlock.context === icuContext.xref) {\n            continue;\n          }\n          // Find the root message and push this ICUs message as a sub-message.\n          const rootI18nBlock = i18nBlocks.get(i18nBlock.root)!;\n          const rootMessage = i18nMessagesByContext.get(rootI18nBlock.context!);\n          if (rootMessage === undefined) {\n            throw Error('AssertionError: ICU sub-message should belong to a root message.');\n          }\n          const subMessage = i18nMessagesByContext.get(icuContext.xref)!;\n          subMessage.messagePlaceholder = op.messagePlaceholder;\n          rootMessage.subMessages.push(subMessage.xref);\n          break;\n        case ir.OpKind.IcuEnd:\n          currentIcu = null;\n          ir.OpList.remove<ir.CreateOp>(op);\n          break;\n        case ir.OpKind.IcuPlaceholder:\n          // Add ICU placeholders to the message, then remove the ICU placeholder ops.\n          if (currentIcu === null || currentIcu.context == null) {\n            throw Error('AssertionError: Unexpected ICU placeholder outside of i18n context');\n          }\n          const msg = i18nMessagesByContext.get(currentIcu.context)!;\n          msg.postprocessingParams.set(op.name, o.literal(formatIcuPlaceholder(op)));\n          ir.OpList.remove<ir.CreateOp>(op);\n          break;\n      }\n    }\n  }\n}\n\n/**\n * Create an i18n message op from an i18n context op.\n */\nfunction createI18nMessage(\n  job: CompilationJob,\n  context: ir.I18nContextOp,\n  messagePlaceholder?: string,\n): ir.I18nMessageOp {\n  let formattedParams = formatParams(context.params);\n  const formattedPostprocessingParams = formatParams(context.postprocessingParams);\n  let needsPostprocessing = [...context.params.values()].some((v) => v.length > 1);\n  return ir.createI18nMessageOp(\n    job.allocateXrefId(),\n    context.xref,\n    context.i18nBlock,\n    context.message,\n    messagePlaceholder ?? null,\n    formattedParams,\n    formattedPostprocessingParams,\n    needsPostprocessing,\n  );\n}\n\n/**\n * Formats an ICU placeholder into a single string with expression placeholders.\n */\nfunction formatIcuPlaceholder(op: ir.IcuPlaceholderOp) {\n  if (op.strings.length !== op.expressionPlaceholders.length + 1) {\n    throw Error(\n      `AssertionError: Invalid ICU placeholder with ${op.strings.length} strings and ${op.expressionPlaceholders.length} expressions`,\n    );\n  }\n  const values = op.expressionPlaceholders.map(formatValue);\n  return op.strings.flatMap((str, i) => [str, values[i] || '']).join('');\n}\n\n/**\n * Formats a map of `I18nParamValue[]` values into a map of `Expression` values.\n */\nfunction formatParams(params: Map<string, ir.I18nParamValue[]>) {\n  const formattedParams = new Map<string, o.Expression>();\n  for (const [placeholder, placeholderValues] of params) {\n    const serializedValues = formatParamValues(placeholderValues);\n    if (serializedValues !== null) {\n      formattedParams.set(placeholder, o.literal(serializedValues));\n    }\n  }\n  return formattedParams;\n}\n\n/**\n * Formats an `I18nParamValue[]` into a string (or null for empty array).\n */\nfunction formatParamValues(values: ir.I18nParamValue[]): string | null {\n  if (values.length === 0) {\n    return null;\n  }\n  const serializedValues = values.map((value) => formatValue(value));\n  return serializedValues.length === 1\n    ? serializedValues[0]\n    : `${LIST_START_MARKER}${serializedValues.join(LIST_DELIMITER)}${LIST_END_MARKER}`;\n}\n\n/**\n * Formats a single `I18nParamValue` into a string\n */\nfunction formatValue(value: ir.I18nParamValue): string {\n  // Element tags with a structural directive use a special form that concatenates the element and\n  // template values.\n  if (\n    value.flags & ir.I18nParamValueFlags.ElementTag &&\n    value.flags & ir.I18nParamValueFlags.TemplateTag\n  ) {\n    if (typeof value.value !== 'object') {\n      throw Error('AssertionError: Expected i18n param value to have an element and template slot');\n    }\n    const elementValue = formatValue({\n      ...value,\n      value: value.value.element,\n      flags: value.flags & ~ir.I18nParamValueFlags.TemplateTag,\n    });\n    const templateValue = formatValue({\n      ...value,\n      value: value.value.template,\n      flags: value.flags & ~ir.I18nParamValueFlags.ElementTag,\n    });\n    // TODO(mmalerba): This is likely a bug in TemplateDefinitionBuilder, we should not need to\n    // record the template value twice. For now I'm re-implementing the behavior here to keep the\n    // output consistent with TemplateDefinitionBuilder.\n    if (\n      value.flags & ir.I18nParamValueFlags.OpenTag &&\n      value.flags & ir.I18nParamValueFlags.CloseTag\n    ) {\n      return `${templateValue}${elementValue}${templateValue}`;\n    }\n    // To match the TemplateDefinitionBuilder output, flip the order depending on whether the\n    // values represent a closing or opening tag (or both).\n    // TODO(mmalerba): Figure out if this makes a difference in terms of either functionality,\n    // or the resulting message ID. If not, we can remove the special-casing in the future.\n    return value.flags & ir.I18nParamValueFlags.CloseTag\n      ? `${elementValue}${templateValue}`\n      : `${templateValue}${elementValue}`;\n  }\n\n  // Self-closing tags use a special form that concatenates the start and close tag values.\n  if (\n    value.flags & ir.I18nParamValueFlags.OpenTag &&\n    value.flags & ir.I18nParamValueFlags.CloseTag\n  ) {\n    return `${formatValue({\n      ...value,\n      flags: value.flags & ~ir.I18nParamValueFlags.CloseTag,\n    })}${formatValue({...value, flags: value.flags & ~ir.I18nParamValueFlags.OpenTag})}`;\n  }\n\n  // If there are no special flags, just return the raw value.\n  if (value.flags === ir.I18nParamValueFlags.None) {\n    return `${value.value}`;\n  }\n\n  // Encode the remaining flags as part of the value.\n  let tagMarker = '';\n  let closeMarker = '';\n  if (value.flags & ir.I18nParamValueFlags.ElementTag) {\n    tagMarker = ELEMENT_MARKER;\n  } else if (value.flags & ir.I18nParamValueFlags.TemplateTag) {\n    tagMarker = TEMPLATE_MARKER;\n  }\n  if (tagMarker !== '') {\n    closeMarker = value.flags & ir.I18nParamValueFlags.CloseTag ? TAG_CLOSE_MARKER : '';\n  }\n  const context =\n    value.subTemplateIndex === null ? '' : `${CONTEXT_MARKER}${value.subTemplateIndex}`;\n  return `${ESCAPE}${closeMarker}${tagMarker}${value.value}${context}${ESCAPE}`;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as ir from '../../ir';\nimport type {CompilationJob} from '../compilation';\n\n/**\n * Generate `ir.AdvanceOp`s in between `ir.UpdateOp`s that ensure the runtime's implicit slot\n * context will be advanced correctly.\n */\nexport function generateAdvance(job: CompilationJob): void {\n  for (const unit of job.units) {\n    // First build a map of all of the declarations in the view that have assigned slots.\n    const slotMap = new Map<ir.XrefId, number>();\n    for (const op of unit.create) {\n      if (!ir.hasConsumesSlotTrait(op)) {\n        continue;\n      } else if (op.handle.slot === null) {\n        throw new Error(\n          `AssertionError: expected slots to have been allocated before generating advance() calls`,\n        );\n      }\n\n      slotMap.set(op.xref, op.handle.slot);\n    }\n\n    // Next, step through the update operations and generate `ir.AdvanceOp`s as required to ensure\n    // the runtime's implicit slot counter will be set to the correct slot before executing each\n    // update operation which depends on it.\n    //\n    // To do that, we track what the runtime's slot counter will be through the update operations.\n    let slotContext = 0;\n    for (const op of unit.update) {\n      let consumer: ir.DependsOnSlotContextOpTrait | null = null;\n\n      if (ir.hasDependsOnSlotContextTrait(op)) {\n        consumer = op;\n      } else {\n        ir.visitExpressionsInOp(op, (expr) => {\n          if (consumer === null && ir.hasDependsOnSlotContextTrait(expr)) {\n            consumer = expr;\n          }\n        });\n      }\n\n      if (consumer === null) {\n        continue;\n      }\n\n      if (!slotMap.has(consumer.target)) {\n        // We expect ops that _do_ depend on the slot counter to point at declarations that exist in\n        // the `slotMap`.\n        throw new Error(`AssertionError: reference to unknown slot for target ${consumer.target}`);\n      }\n\n      const slot = slotMap.get(consumer.target)!;\n\n      // Does the slot counter need to be adjusted?\n      if (slotContext !== slot) {\n        // If so, generate an `ir.AdvanceOp` to advance the counter.\n        const delta = slot - slotContext;\n        if (delta < 0) {\n          throw new Error(`AssertionError: slot counter should never need to move backwards`);\n        }\n\n        ir.OpList.insertBefore<ir.UpdateOp>(ir.createAdvanceOp(delta, consumer.sourceSpan), op);\n        slotContext = slot;\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as ir from '../../ir';\n\nimport type {ComponentCompilationJob} from '../compilation';\n\n/**\n * Replaces the `storeLet` ops with variables that can be\n * used to reference the value within the same view.\n */\nexport function generateLocalLetReferences(job: ComponentCompilationJob): void {\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      if (op.kind !== ir.OpKind.StoreLet) {\n        continue;\n      }\n\n      const variable: ir.IdentifierVariable = {\n        kind: ir.SemanticVariableKind.Identifier,\n        name: null,\n        identifier: op.declaredName,\n        local: true,\n      };\n\n      ir.OpList.replace<ir.UpdateOp>(\n        op,\n        ir.createVariableOp<ir.UpdateOp>(\n          job.allocateXrefId(),\n          variable,\n          new ir.StoreLetExpr(op.target, op.value, op.sourceSpan),\n          ir.VariableFlags.None,\n        ),\n      );\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {parseSelectorToR3Selector} from '../../../../core';\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\nimport type {ComponentCompilationJob} from '../compilation';\nimport {literalOrArrayLiteral} from '../conversion';\n\n/**\n * Locate projection slots, populate the each component's `ngContentSelectors` literal field,\n * populate `project` arguments, and generate the required `projectionDef` instruction for the job's\n * root view.\n */\nexport function generateProjectionDefs(job: ComponentCompilationJob): void {\n  // TODO: Why does TemplateDefinitionBuilder force a shared constant?\n  const share = job.compatibility === ir.CompatibilityMode.TemplateDefinitionBuilder;\n\n  // Collect all selectors from this component, and its nested views. Also, assign each projection a\n  // unique ascending projection slot index.\n  const selectors = [];\n  let projectionSlotIndex = 0;\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === ir.OpKind.Projection) {\n        selectors.push(op.selector);\n        op.projectionSlotIndex = projectionSlotIndex++;\n      }\n    }\n  }\n\n  if (selectors.length > 0) {\n    // Create the projectionDef array. If we only found a single wildcard selector, then we use the\n    // default behavior with no arguments instead.\n    let defExpr: o.Expression | null = null;\n    if (selectors.length > 1 || selectors[0] !== '*') {\n      const def = selectors.map((s) => (s === '*' ? s : parseSelectorToR3Selector(s)));\n      defExpr = job.pool.getConstLiteral(literalOrArrayLiteral(def), share);\n    }\n\n    // Create the ngContentSelectors constant.\n    job.contentSelectors = job.pool.getConstLiteral(literalOrArrayLiteral(selectors), share);\n\n    // The projection def instruction goes at the beginning of the root view, before any\n    // `projection` instructions.\n    job.root.create.prepend([ir.createProjectionDefOp(defExpr)]);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\n\nimport type {ComponentCompilationJob, ViewCompilationUnit} from '../compilation';\n\n/**\n * Generate a preamble sequence for each view creation block and listener function which declares\n * any variables that be referenced in other operations in the block.\n *\n * Variables generated include:\n *   * a saved view context to be used to restore the current view in event listeners.\n *   * the context of the restored view within event listener handlers.\n *   * context variables from the current view as well as all parent views (including the root\n *     context if needed).\n *   * local references from elements within the current view and any lexical parents.\n *\n * Variables are generated here unconditionally, and may optimized away in future operations if it\n * turns out their values (and any side effects) are unused.\n */\nexport function generateVariables(job: ComponentCompilationJob): void {\n  recursivelyProcessView(job.root, /* there is no parent scope for the root view */ null);\n}\n\n/**\n * Process the given `ViewCompilation` and generate preambles for it and any listeners that it\n * declares.\n *\n * @param `parentScope` a scope extracted from the parent view which captures any variables which\n *     should be inherited by this view. `null` if the current view is the root view.\n */\nfunction recursivelyProcessView(view: ViewCompilationUnit, parentScope: Scope | null): void {\n  // Extract a `Scope` from this view.\n  const scope = getScopeForView(view, parentScope);\n\n  for (const op of view.create) {\n    switch (op.kind) {\n      case ir.OpKind.ConditionalCreate:\n      case ir.OpKind.ConditionalBranchCreate:\n      case ir.OpKind.Template:\n        // Descend into child embedded views.\n        recursivelyProcessView(view.job.views.get(op.xref)!, scope);\n        break;\n      case ir.OpKind.Projection:\n        if (op.fallbackView !== null) {\n          recursivelyProcessView(view.job.views.get(op.fallbackView)!, scope);\n        }\n        break;\n      case ir.OpKind.RepeaterCreate:\n        // Descend into child embedded views.\n        recursivelyProcessView(view.job.views.get(op.xref)!, scope);\n        if (op.emptyView) {\n          recursivelyProcessView(view.job.views.get(op.emptyView)!, scope);\n        }\n        if (op.trackByOps !== null) {\n          op.trackByOps.prepend(generateVariablesInScopeForView(view, scope, false));\n        }\n        break;\n      case ir.OpKind.Animation:\n      case ir.OpKind.AnimationListener:\n      case ir.OpKind.Listener:\n      case ir.OpKind.TwoWayListener:\n        // Prepend variables to listener handler functions.\n        op.handlerOps.prepend(generateVariablesInScopeForView(view, scope, true));\n        break;\n    }\n  }\n\n  view.update.prepend(generateVariablesInScopeForView(view, scope, false));\n}\n\n/**\n * Lexical scope of a view, including a reference to its parent view's scope, if any.\n */\ninterface Scope {\n  /**\n   * `XrefId` of the view to which this scope corresponds.\n   */\n  view: ir.XrefId;\n\n  viewContextVariable: ir.SemanticVariable;\n\n  contextVariables: Map<string, ir.SemanticVariable>;\n\n  aliases: Set<ir.AliasVariable>;\n\n  /**\n   * Local references collected from elements within the view.\n   */\n  references: Reference[];\n\n  /**\n   * `@let` declarations collected from the view.\n   */\n  letDeclarations: LetDeclaration[];\n\n  /**\n   * `Scope` of the parent view, if any.\n   */\n  parent: Scope | null;\n}\n\n/**\n * Information needed about a local reference collected from an element within a view.\n */\ninterface Reference {\n  /**\n   * Name given to the local reference variable within the template.\n   *\n   * This is not the name which will be used for the variable declaration in the generated\n   * template code.\n   */\n  name: string;\n\n  /**\n   * `XrefId` of the element-like node which this reference targets.\n   *\n   * The reference may be either to the element (or template) itself, or to a directive on it.\n   */\n  targetId: ir.XrefId;\n\n  targetSlot: ir.SlotHandle;\n\n  /**\n   * A generated offset of this reference among all the references on a specific element.\n   */\n  offset: number;\n\n  variable: ir.SemanticVariable;\n}\n\n/**\n * Information about `@let` declaration collected from a view.\n */\ninterface LetDeclaration {\n  /** `XrefId` of the `@let` declaration that the reference is pointing to. */\n  targetId: ir.XrefId;\n\n  /** Slot in which the declaration is stored. */\n  targetSlot: ir.SlotHandle;\n\n  /** Variable referring to the declaration. */\n  variable: ir.IdentifierVariable;\n}\n\n/**\n * Process a view and generate a `Scope` representing the variables available for reference within\n * that view.\n */\nfunction getScopeForView(view: ViewCompilationUnit, parent: Scope | null): Scope {\n  const scope: Scope = {\n    view: view.xref,\n    viewContextVariable: {\n      kind: ir.SemanticVariableKind.Context,\n      name: null,\n      view: view.xref,\n    },\n    contextVariables: new Map<string, ir.SemanticVariable>(),\n    aliases: view.aliases,\n    references: [],\n    letDeclarations: [],\n    parent,\n  };\n\n  for (const identifier of view.contextVariables.keys()) {\n    scope.contextVariables.set(identifier, {\n      kind: ir.SemanticVariableKind.Identifier,\n      name: null,\n      identifier,\n      local: false,\n    });\n  }\n\n  for (const op of view.create) {\n    switch (op.kind) {\n      case ir.OpKind.ElementStart:\n      case ir.OpKind.ConditionalCreate:\n      case ir.OpKind.ConditionalBranchCreate:\n      case ir.OpKind.Template:\n        if (!Array.isArray(op.localRefs)) {\n          throw new Error(`AssertionError: expected localRefs to be an array`);\n        }\n\n        // Record available local references from this element.\n        for (let offset = 0; offset < op.localRefs.length; offset++) {\n          scope.references.push({\n            name: op.localRefs[offset].name,\n            targetId: op.xref,\n            targetSlot: op.handle,\n            offset,\n            variable: {\n              kind: ir.SemanticVariableKind.Identifier,\n              name: null,\n              identifier: op.localRefs[offset].name,\n              local: false,\n            },\n          });\n        }\n        break;\n\n      case ir.OpKind.DeclareLet:\n        scope.letDeclarations.push({\n          targetId: op.xref,\n          targetSlot: op.handle,\n          variable: {\n            kind: ir.SemanticVariableKind.Identifier,\n            name: null,\n            identifier: op.declaredName,\n            local: false,\n          },\n        });\n        break;\n    }\n  }\n\n  return scope;\n}\n\n/**\n * Generate declarations for all variables that are in scope for a given view.\n *\n * This is a recursive process, as views inherit variables available from their parent view, which\n * itself may have inherited variables, etc.\n */\nfunction generateVariablesInScopeForView(\n  view: ViewCompilationUnit,\n  scope: Scope,\n  isCallback: boolean,\n): ir.VariableOp<ir.UpdateOp>[] {\n  const newOps: ir.VariableOp<ir.UpdateOp>[] = [];\n\n  if (scope.view !== view.xref) {\n    // Before generating variables for a parent view, we need to switch to the context of the parent\n    // view with a `nextContext` expression. This context switching operation itself declares a\n    // variable, because the context of the view may be referenced directly.\n    newOps.push(\n      ir.createVariableOp(\n        view.job.allocateXrefId(),\n        scope.viewContextVariable,\n        new ir.NextContextExpr(),\n        ir.VariableFlags.None,\n      ),\n    );\n  }\n\n  // Add variables for all context variables available in this scope's view.\n  const scopeView = view.job.views.get(scope.view)!;\n  for (const [name, value] of scopeView.contextVariables) {\n    const context = new ir.ContextExpr(scope.view);\n    // We either read the context, or, if the variable is CTX_REF, use the context directly.\n    const variable = value === ir.CTX_REF ? context : new o.ReadPropExpr(context, value);\n    // Add the variable declaration.\n    newOps.push(\n      ir.createVariableOp(\n        view.job.allocateXrefId(),\n        scope.contextVariables.get(name)!,\n        variable,\n        ir.VariableFlags.None,\n      ),\n    );\n  }\n\n  for (const alias of scopeView.aliases) {\n    newOps.push(\n      ir.createVariableOp(\n        view.job.allocateXrefId(),\n        alias,\n        alias.expression.clone(),\n        ir.VariableFlags.AlwaysInline,\n      ),\n    );\n  }\n\n  // Add variables for all local references declared for elements in this scope.\n  for (const ref of scope.references) {\n    newOps.push(\n      ir.createVariableOp(\n        view.job.allocateXrefId(),\n        ref.variable,\n        new ir.ReferenceExpr(ref.targetId, ref.targetSlot, ref.offset),\n        ir.VariableFlags.None,\n      ),\n    );\n  }\n\n  if (scope.view !== view.xref || isCallback) {\n    for (const decl of scope.letDeclarations) {\n      newOps.push(\n        ir.createVariableOp<ir.UpdateOp>(\n          view.job.allocateXrefId(),\n          decl.variable,\n          new ir.ContextLetReferenceExpr(decl.targetId, decl.targetSlot),\n          ir.VariableFlags.None,\n        ),\n      );\n    }\n  }\n\n  if (scope.parent !== null) {\n    // Recursively add variables from the parent scope.\n    newOps.push(...generateVariablesInScopeForView(view, scope.parent, false));\n  }\n  return newOps;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\nimport type {ComponentCompilationJob} from '../compilation';\n\n/**\n * `ir.ConstCollectedExpr` may be present in any IR expression. This means that expression needs to\n * be lifted into the component const array, and replaced with a reference to the const array at its\n *\n * usage site. This phase walks the IR and performs this transformation.\n */\nexport function collectConstExpressions(job: ComponentCompilationJob): void {\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      ir.transformExpressionsInOp(\n        op,\n        (expr) => {\n          if (!(expr instanceof ir.ConstCollectedExpr)) {\n            return expr;\n          }\n          return o.literal(job.addConst(expr.expr));\n        },\n        ir.VisitorContextFlag.None,\n      );\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as ir from '../../ir';\n\nimport type {CompilationJob} from '../compilation';\n\nconst STYLE_DOT = 'style.';\nconst CLASS_DOT = 'class.';\n\nconst STYLE_BANG = 'style!';\nconst CLASS_BANG = 'class!';\nconst BANG_IMPORTANT = '!important';\n\n/**\n * Host bindings are compiled using a different parser entrypoint, and are parsed quite differently\n * as a result. Therefore, we need to do some extra parsing for host style properties, as compared\n * to non-host style properties.\n * TODO: Unify host bindings and non-host bindings in the parser.\n */\nexport function parseHostStyleProperties(job: CompilationJob): void {\n  for (const op of job.root.update) {\n    if (!(op.kind === ir.OpKind.Binding && op.bindingKind === ir.BindingKind.Property)) {\n      continue;\n    }\n\n    if (op.name.endsWith(BANG_IMPORTANT)) {\n      // Delete any `!important` suffixes from the binding name.\n      op.name = op.name.substring(0, op.name.length - BANG_IMPORTANT.length);\n    }\n\n    if (op.name.startsWith(STYLE_DOT)) {\n      op.bindingKind = ir.BindingKind.StyleProperty;\n      op.name = op.name.substring(STYLE_DOT.length);\n\n      if (!isCssCustomProperty(op.name)) {\n        op.name = hyphenate(op.name);\n      }\n\n      const {property, suffix} = parseProperty(op.name);\n      op.name = property;\n      op.unit = suffix;\n    } else if (op.name.startsWith(STYLE_BANG)) {\n      op.bindingKind = ir.BindingKind.StyleProperty;\n      op.name = 'style';\n    } else if (op.name.startsWith(CLASS_DOT)) {\n      op.bindingKind = ir.BindingKind.ClassName;\n      op.name = parseProperty(op.name.substring(CLASS_DOT.length)).property;\n    } else if (op.name.startsWith(CLASS_BANG)) {\n      op.bindingKind = ir.BindingKind.ClassName;\n      op.name = parseProperty(op.name.substring(CLASS_BANG.length)).property;\n    }\n  }\n}\n\n/**\n * Checks whether property name is a custom CSS property.\n * See: https://www.w3.org/TR/css-variables-1\n */\nfunction isCssCustomProperty(name: string): boolean {\n  return name.startsWith('--');\n}\n\nfunction hyphenate(value: string): string {\n  return value\n    .replace(/[a-z][A-Z]/g, (v) => {\n      return v.charAt(0) + '-' + v.charAt(1);\n    })\n    .toLowerCase();\n}\n\nfunction parseProperty(name: string): {property: string; suffix: string | null} {\n  const overrideIndex = name.indexOf('!important');\n  if (overrideIndex !== -1) {\n    name = overrideIndex > 0 ? name.substring(0, overrideIndex) : '';\n  }\n\n  let suffix: string | null = null;\n  let property = name;\n  const unitIndex = name.lastIndexOf('.');\n  if (unitIndex > 0) {\n    suffix = name.slice(unitIndex + 1);\n    property = name.substring(0, unitIndex);\n  }\n\n  return {property, suffix};\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from './output_ast';\n\nexport type MapEntry = {\n  key: string;\n  quoted: boolean;\n  value: o.Expression;\n};\n\nexport type MapLiteral = MapEntry[];\n\nexport function mapEntry(key: string, value: o.Expression): MapEntry {\n  return {key, value, quoted: false};\n}\n\nexport function mapLiteral(\n  obj: {[key: string]: o.Expression},\n  quoted: boolean = false,\n): o.Expression {\n  return o.literalMap(\n    Object.keys(obj).map((key) => ({\n      key,\n      quoted,\n      value: obj[key],\n    })),\n  );\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as i18n from '../../../i18n/i18n_ast';\n\nimport {formatI18nPlaceholderName} from './util';\n\nclass IcuSerializerVisitor implements i18n.Visitor {\n  visitText(text: i18n.Text): any {\n    return text.value;\n  }\n\n  visitContainer(container: i18n.Container): any {\n    return container.children.map((child) => child.visit(this)).join('');\n  }\n\n  visitIcu(icu: i18n.Icu): any {\n    const strCases = Object.keys(icu.cases).map(\n      (k: string) => `${k} {${icu.cases[k].visit(this)}}`,\n    );\n    const result = `{${icu.expressionPlaceholder}, ${icu.type}, ${strCases.join(' ')}}`;\n    return result;\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder): any {\n    return ph.isVoid\n      ? this.formatPh(ph.startName)\n      : `${this.formatPh(ph.startName)}${ph.children\n          .map((child) => child.visit(this))\n          .join('')}${this.formatPh(ph.closeName)}`;\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder): any {\n    return this.formatPh(ph.name);\n  }\n\n  visitBlockPlaceholder(ph: i18n.BlockPlaceholder): any {\n    return `${this.formatPh(ph.startName)}${ph.children\n      .map((child) => child.visit(this))\n      .join('')}${this.formatPh(ph.closeName)}`;\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): any {\n    return this.formatPh(ph.name);\n  }\n\n  private formatPh(value: string): string {\n    return `{${formatI18nPlaceholderName(value, /* useCamelCase */ false)}}`;\n  }\n}\n\nconst serializer = new IcuSerializerVisitor();\nexport function serializeIcuNode(icu: i18n.Icu): string {\n  return icu.visit(serializer);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {I18nMeta} from '../i18n/i18n_ast';\nimport {ParseSourceSpan} from '../parse_util';\n\nimport {InterpolatedAttributeToken, InterpolatedTextToken} from './tokens';\n\ninterface BaseNode {\n  sourceSpan: ParseSourceSpan;\n  visit(visitor: Visitor, context: any): any;\n}\n\nexport type Node =\n  | Attribute\n  | Comment\n  | Element\n  | Expansion\n  | ExpansionCase\n  | Text\n  | Block\n  | BlockParameter\n  | Component\n  | Directive;\n\nexport abstract class NodeWithI18n implements BaseNode {\n  constructor(\n    public sourceSpan: ParseSourceSpan,\n    public i18n?: I18nMeta,\n  ) {}\n  abstract visit(visitor: Visitor, context: any): any;\n}\n\nexport class Text extends NodeWithI18n {\n  constructor(\n    public value: string,\n    sourceSpan: ParseSourceSpan,\n    public tokens: InterpolatedTextToken[],\n    i18n?: I18nMeta,\n  ) {\n    super(sourceSpan, i18n);\n  }\n  override visit(visitor: Visitor, context: any): any {\n    return visitor.visitText(this, context);\n  }\n}\n\nexport class Expansion extends NodeWithI18n {\n  constructor(\n    public switchValue: string,\n    public type: string,\n    public cases: ExpansionCase[],\n    sourceSpan: ParseSourceSpan,\n    public switchValueSourceSpan: ParseSourceSpan,\n    i18n?: I18nMeta,\n  ) {\n    super(sourceSpan, i18n);\n  }\n  override visit(visitor: Visitor, context: any): any {\n    return visitor.visitExpansion(this, context);\n  }\n}\n\nexport class ExpansionCase implements BaseNode {\n  constructor(\n    public value: string,\n    public expression: Node[],\n    public sourceSpan: ParseSourceSpan,\n    public valueSourceSpan: ParseSourceSpan,\n    public expSourceSpan: ParseSourceSpan,\n  ) {}\n\n  visit(visitor: Visitor, context: any): any {\n    return visitor.visitExpansionCase(this, context);\n  }\n}\n\nexport class Attribute extends NodeWithI18n {\n  constructor(\n    public name: string,\n    public value: string,\n    sourceSpan: ParseSourceSpan,\n    readonly keySpan: ParseSourceSpan | undefined,\n    public valueSpan: ParseSourceSpan | undefined,\n    public valueTokens: InterpolatedAttributeToken[] | undefined,\n    i18n: I18nMeta | undefined,\n  ) {\n    super(sourceSpan, i18n);\n  }\n  override visit(visitor: Visitor, context: any): any {\n    return visitor.visitAttribute(this, context);\n  }\n}\n\nexport class Element extends NodeWithI18n {\n  constructor(\n    public name: string,\n    public attrs: Attribute[],\n    readonly directives: Directive[],\n    public children: Node[],\n    readonly isSelfClosing: boolean,\n    sourceSpan: ParseSourceSpan,\n    public startSourceSpan: ParseSourceSpan,\n    public endSourceSpan: ParseSourceSpan | null = null,\n    readonly isVoid: boolean,\n    i18n?: I18nMeta,\n  ) {\n    super(sourceSpan, i18n);\n  }\n  override visit(visitor: Visitor, context: any): any {\n    return visitor.visitElement(this, context);\n  }\n}\n\nexport class Comment implements BaseNode {\n  constructor(\n    public value: string | null,\n    public sourceSpan: ParseSourceSpan,\n  ) {}\n  visit(visitor: Visitor, context: any): any {\n    return visitor.visitComment(this, context);\n  }\n}\n\nexport class Block extends NodeWithI18n {\n  constructor(\n    public name: string,\n    public parameters: BlockParameter[],\n    public children: Node[],\n    sourceSpan: ParseSourceSpan,\n    public nameSpan: ParseSourceSpan,\n    public startSourceSpan: ParseSourceSpan,\n    public endSourceSpan: ParseSourceSpan | null = null,\n    i18n?: I18nMeta,\n  ) {\n    super(sourceSpan, i18n);\n  }\n\n  override visit(visitor: Visitor, context: any) {\n    return visitor.visitBlock(this, context);\n  }\n}\n\nexport class Component extends NodeWithI18n {\n  constructor(\n    readonly componentName: string,\n    readonly tagName: string | null,\n    readonly fullName: string,\n    public attrs: Attribute[],\n    readonly directives: Directive[],\n    readonly children: Node[],\n    readonly isSelfClosing: boolean,\n    sourceSpan: ParseSourceSpan,\n    readonly startSourceSpan: ParseSourceSpan,\n    public endSourceSpan: ParseSourceSpan | null = null,\n    i18n?: I18nMeta,\n  ) {\n    super(sourceSpan, i18n);\n  }\n\n  override visit(visitor: Visitor, context: any): any {\n    return visitor.visitComponent(this, context);\n  }\n}\n\nexport class Directive implements BaseNode {\n  constructor(\n    readonly name: string,\n    readonly attrs: Attribute[],\n    readonly sourceSpan: ParseSourceSpan,\n    readonly startSourceSpan: ParseSourceSpan,\n    readonly endSourceSpan: ParseSourceSpan | null = null,\n  ) {}\n\n  visit(visitor: Visitor, context: any): any {\n    return visitor.visitDirective(this, context);\n  }\n}\n\nexport class BlockParameter implements BaseNode {\n  constructor(\n    public expression: string,\n    public sourceSpan: ParseSourceSpan,\n  ) {}\n\n  visit(visitor: Visitor, context: any): any {\n    return visitor.visitBlockParameter(this, context);\n  }\n}\n\nexport class LetDeclaration implements BaseNode {\n  constructor(\n    public name: string,\n    public value: string,\n    public sourceSpan: ParseSourceSpan,\n    readonly nameSpan: ParseSourceSpan,\n    public valueSpan: ParseSourceSpan,\n  ) {}\n\n  visit(visitor: Visitor, context: any): any {\n    return visitor.visitLetDeclaration(this, context);\n  }\n}\n\nexport interface Visitor {\n  // Returning a truthy value from `visit()` will prevent `visitAll()` from the call to the typed\n  // method and result returned will become the result included in `visitAll()`s result array.\n  visit?(node: Node, context: any): any;\n\n  visitElement(element: Element, context: any): any;\n  visitAttribute(attribute: Attribute, context: any): any;\n  visitText(text: Text, context: any): any;\n  visitComment(comment: Comment, context: any): any;\n  visitExpansion(expansion: Expansion, context: any): any;\n  visitExpansionCase(expansionCase: ExpansionCase, context: any): any;\n  visitBlock(block: Block, context: any): any;\n  visitBlockParameter(parameter: BlockParameter, context: any): any;\n  visitLetDeclaration(decl: LetDeclaration, context: any): any;\n  visitComponent(component: Component, context: any): any;\n  visitDirective(directive: Directive, context: any): any;\n}\n\nexport function visitAll(visitor: Visitor, nodes: Node[], context: any = null): any[] {\n  const result: any[] = [];\n\n  const visit = visitor.visit\n    ? (ast: Node) => visitor.visit!(ast, context) || ast.visit(visitor, context)\n    : (ast: Node) => ast.visit(visitor, context);\n  nodes.forEach((ast) => {\n    const astResult = visit(ast);\n    if (astResult) {\n      result.push(astResult);\n    }\n  });\n  return result;\n}\n\nexport class RecursiveVisitor implements Visitor {\n  constructor() {}\n\n  visitElement(ast: Element, context: any): any {\n    this.visitChildren(context, (visit) => {\n      visit(ast.attrs);\n      visit(ast.directives);\n      visit(ast.children);\n    });\n  }\n\n  visitAttribute(ast: Attribute, context: any): any {}\n  visitText(ast: Text, context: any): any {}\n  visitComment(ast: Comment, context: any): any {}\n\n  visitExpansion(ast: Expansion, context: any): any {\n    return this.visitChildren(context, (visit) => {\n      visit(ast.cases);\n    });\n  }\n\n  visitExpansionCase(ast: ExpansionCase, context: any): any {}\n\n  visitBlock(block: Block, context: any): any {\n    this.visitChildren(context, (visit) => {\n      visit(block.parameters);\n      visit(block.children);\n    });\n  }\n\n  visitBlockParameter(ast: BlockParameter, context: any): any {}\n\n  visitLetDeclaration(decl: LetDeclaration, context: any) {}\n\n  visitComponent(component: Component, context: any) {\n    this.visitChildren(context, (visit) => {\n      visit(component.attrs);\n      visit(component.children);\n    });\n  }\n\n  visitDirective(directive: Directive, context: any) {\n    this.visitChildren(context, (visit) => {\n      visit(directive.attrs);\n    });\n  }\n\n  private visitChildren(\n    context: any,\n    cb: (visit: <V extends Node>(children: V[] | undefined) => void) => void,\n  ) {\n    let results: any[][] = [];\n    let t = this;\n    function visit<T extends Node>(children: T[] | undefined) {\n      if (children) results.push(visitAll(t, children, context));\n    }\n    cb(visit);\n    return Array.prototype.concat.apply([], results);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n// Mapping between all HTML entity names and their unicode representation.\n// Generated from https://html.spec.whatwg.org/multipage/entities.json by stripping\n// the `&` and `;` from the keys and removing the duplicates.\n// see https://www.w3.org/TR/html51/syntax.html#named-character-references\nexport const NAMED_ENTITIES: Record<string, string> = {\n  'AElig': '\\u00C6',\n  'AMP': '\\u0026',\n  'amp': '\\u0026',\n  'Aacute': '\\u00C1',\n  'Abreve': '\\u0102',\n  'Acirc': '\\u00C2',\n  'Acy': '\\u0410',\n  'Afr': '\\uD835\\uDD04',\n  'Agrave': '\\u00C0',\n  'Alpha': '\\u0391',\n  'Amacr': '\\u0100',\n  'And': '\\u2A53',\n  'Aogon': '\\u0104',\n  'Aopf': '\\uD835\\uDD38',\n  'ApplyFunction': '\\u2061',\n  'af': '\\u2061',\n  'Aring': '\\u00C5',\n  'angst': '\\u00C5',\n  'Ascr': '\\uD835\\uDC9C',\n  'Assign': '\\u2254',\n  'colone': '\\u2254',\n  'coloneq': '\\u2254',\n  'Atilde': '\\u00C3',\n  'Auml': '\\u00C4',\n  'Backslash': '\\u2216',\n  'setminus': '\\u2216',\n  'setmn': '\\u2216',\n  'smallsetminus': '\\u2216',\n  'ssetmn': '\\u2216',\n  'Barv': '\\u2AE7',\n  'Barwed': '\\u2306',\n  'doublebarwedge': '\\u2306',\n  'Bcy': '\\u0411',\n  'Because': '\\u2235',\n  'becaus': '\\u2235',\n  'because': '\\u2235',\n  'Bernoullis': '\\u212C',\n  'Bscr': '\\u212C',\n  'bernou': '\\u212C',\n  'Beta': '\\u0392',\n  'Bfr': '\\uD835\\uDD05',\n  'Bopf': '\\uD835\\uDD39',\n  'Breve': '\\u02D8',\n  'breve': '\\u02D8',\n  'Bumpeq': '\\u224E',\n  'HumpDownHump': '\\u224E',\n  'bump': '\\u224E',\n  'CHcy': '\\u0427',\n  'COPY': '\\u00A9',\n  'copy': '\\u00A9',\n  'Cacute': '\\u0106',\n  'Cap': '\\u22D2',\n  'CapitalDifferentialD': '\\u2145',\n  'DD': '\\u2145',\n  'Cayleys': '\\u212D',\n  'Cfr': '\\u212D',\n  'Ccaron': '\\u010C',\n  'Ccedil': '\\u00C7',\n  'Ccirc': '\\u0108',\n  'Cconint': '\\u2230',\n  'Cdot': '\\u010A',\n  'Cedilla': '\\u00B8',\n  'cedil': '\\u00B8',\n  'CenterDot': '\\u00B7',\n  'centerdot': '\\u00B7',\n  'middot': '\\u00B7',\n  'Chi': '\\u03A7',\n  'CircleDot': '\\u2299',\n  'odot': '\\u2299',\n  'CircleMinus': '\\u2296',\n  'ominus': '\\u2296',\n  'CirclePlus': '\\u2295',\n  'oplus': '\\u2295',\n  'CircleTimes': '\\u2297',\n  'otimes': '\\u2297',\n  'ClockwiseContourIntegral': '\\u2232',\n  'cwconint': '\\u2232',\n  'CloseCurlyDoubleQuote': '\\u201D',\n  'rdquo': '\\u201D',\n  'rdquor': '\\u201D',\n  'CloseCurlyQuote': '\\u2019',\n  'rsquo': '\\u2019',\n  'rsquor': '\\u2019',\n  'Colon': '\\u2237',\n  'Proportion': '\\u2237',\n  'Colone': '\\u2A74',\n  'Congruent': '\\u2261',\n  'equiv': '\\u2261',\n  'Conint': '\\u222F',\n  'DoubleContourIntegral': '\\u222F',\n  'ContourIntegral': '\\u222E',\n  'conint': '\\u222E',\n  'oint': '\\u222E',\n  'Copf': '\\u2102',\n  'complexes': '\\u2102',\n  'Coproduct': '\\u2210',\n  'coprod': '\\u2210',\n  'CounterClockwiseContourIntegral': '\\u2233',\n  'awconint': '\\u2233',\n  'Cross': '\\u2A2F',\n  'Cscr': '\\uD835\\uDC9E',\n  'Cup': '\\u22D3',\n  'CupCap': '\\u224D',\n  'asympeq': '\\u224D',\n  'DDotrahd': '\\u2911',\n  'DJcy': '\\u0402',\n  'DScy': '\\u0405',\n  'DZcy': '\\u040F',\n  'Dagger': '\\u2021',\n  'ddagger': '\\u2021',\n  'Darr': '\\u21A1',\n  'Dashv': '\\u2AE4',\n  'DoubleLeftTee': '\\u2AE4',\n  'Dcaron': '\\u010E',\n  'Dcy': '\\u0414',\n  'Del': '\\u2207',\n  'nabla': '\\u2207',\n  'Delta': '\\u0394',\n  'Dfr': '\\uD835\\uDD07',\n  'DiacriticalAcute': '\\u00B4',\n  'acute': '\\u00B4',\n  'DiacriticalDot': '\\u02D9',\n  'dot': '\\u02D9',\n  'DiacriticalDoubleAcute': '\\u02DD',\n  'dblac': '\\u02DD',\n  'DiacriticalGrave': '\\u0060',\n  'grave': '\\u0060',\n  'DiacriticalTilde': '\\u02DC',\n  'tilde': '\\u02DC',\n  'Diamond': '\\u22C4',\n  'diam': '\\u22C4',\n  'diamond': '\\u22C4',\n  'DifferentialD': '\\u2146',\n  'dd': '\\u2146',\n  'Dopf': '\\uD835\\uDD3B',\n  'Dot': '\\u00A8',\n  'DoubleDot': '\\u00A8',\n  'die': '\\u00A8',\n  'uml': '\\u00A8',\n  'DotDot': '\\u20DC',\n  'DotEqual': '\\u2250',\n  'doteq': '\\u2250',\n  'esdot': '\\u2250',\n  'DoubleDownArrow': '\\u21D3',\n  'Downarrow': '\\u21D3',\n  'dArr': '\\u21D3',\n  'DoubleLeftArrow': '\\u21D0',\n  'Leftarrow': '\\u21D0',\n  'lArr': '\\u21D0',\n  'DoubleLeftRightArrow': '\\u21D4',\n  'Leftrightarrow': '\\u21D4',\n  'hArr': '\\u21D4',\n  'iff': '\\u21D4',\n  'DoubleLongLeftArrow': '\\u27F8',\n  'Longleftarrow': '\\u27F8',\n  'xlArr': '\\u27F8',\n  'DoubleLongLeftRightArrow': '\\u27FA',\n  'Longleftrightarrow': '\\u27FA',\n  'xhArr': '\\u27FA',\n  'DoubleLongRightArrow': '\\u27F9',\n  'Longrightarrow': '\\u27F9',\n  'xrArr': '\\u27F9',\n  'DoubleRightArrow': '\\u21D2',\n  'Implies': '\\u21D2',\n  'Rightarrow': '\\u21D2',\n  'rArr': '\\u21D2',\n  'DoubleRightTee': '\\u22A8',\n  'vDash': '\\u22A8',\n  'DoubleUpArrow': '\\u21D1',\n  'Uparrow': '\\u21D1',\n  'uArr': '\\u21D1',\n  'DoubleUpDownArrow': '\\u21D5',\n  'Updownarrow': '\\u21D5',\n  'vArr': '\\u21D5',\n  'DoubleVerticalBar': '\\u2225',\n  'par': '\\u2225',\n  'parallel': '\\u2225',\n  'shortparallel': '\\u2225',\n  'spar': '\\u2225',\n  'DownArrow': '\\u2193',\n  'ShortDownArrow': '\\u2193',\n  'darr': '\\u2193',\n  'downarrow': '\\u2193',\n  'DownArrowBar': '\\u2913',\n  'DownArrowUpArrow': '\\u21F5',\n  'duarr': '\\u21F5',\n  'DownBreve': '\\u0311',\n  'DownLeftRightVector': '\\u2950',\n  'DownLeftTeeVector': '\\u295E',\n  'DownLeftVector': '\\u21BD',\n  'leftharpoondown': '\\u21BD',\n  'lhard': '\\u21BD',\n  'DownLeftVectorBar': '\\u2956',\n  'DownRightTeeVector': '\\u295F',\n  'DownRightVector': '\\u21C1',\n  'rhard': '\\u21C1',\n  'rightharpoondown': '\\u21C1',\n  'DownRightVectorBar': '\\u2957',\n  'DownTee': '\\u22A4',\n  'top': '\\u22A4',\n  'DownTeeArrow': '\\u21A7',\n  'mapstodown': '\\u21A7',\n  'Dscr': '\\uD835\\uDC9F',\n  'Dstrok': '\\u0110',\n  'ENG': '\\u014A',\n  'ETH': '\\u00D0',\n  'Eacute': '\\u00C9',\n  'Ecaron': '\\u011A',\n  'Ecirc': '\\u00CA',\n  'Ecy': '\\u042D',\n  'Edot': '\\u0116',\n  'Efr': '\\uD835\\uDD08',\n  'Egrave': '\\u00C8',\n  'Element': '\\u2208',\n  'in': '\\u2208',\n  'isin': '\\u2208',\n  'isinv': '\\u2208',\n  'Emacr': '\\u0112',\n  'EmptySmallSquare': '\\u25FB',\n  'EmptyVerySmallSquare': '\\u25AB',\n  'Eogon': '\\u0118',\n  'Eopf': '\\uD835\\uDD3C',\n  'Epsilon': '\\u0395',\n  'Equal': '\\u2A75',\n  'EqualTilde': '\\u2242',\n  'eqsim': '\\u2242',\n  'esim': '\\u2242',\n  'Equilibrium': '\\u21CC',\n  'rightleftharpoons': '\\u21CC',\n  'rlhar': '\\u21CC',\n  'Escr': '\\u2130',\n  'expectation': '\\u2130',\n  'Esim': '\\u2A73',\n  'Eta': '\\u0397',\n  'Euml': '\\u00CB',\n  'Exists': '\\u2203',\n  'exist': '\\u2203',\n  'ExponentialE': '\\u2147',\n  'ee': '\\u2147',\n  'exponentiale': '\\u2147',\n  'Fcy': '\\u0424',\n  'Ffr': '\\uD835\\uDD09',\n  'FilledSmallSquare': '\\u25FC',\n  'FilledVerySmallSquare': '\\u25AA',\n  'blacksquare': '\\u25AA',\n  'squarf': '\\u25AA',\n  'squf': '\\u25AA',\n  'Fopf': '\\uD835\\uDD3D',\n  'ForAll': '\\u2200',\n  'forall': '\\u2200',\n  'Fouriertrf': '\\u2131',\n  'Fscr': '\\u2131',\n  'GJcy': '\\u0403',\n  'GT': '\\u003E',\n  'gt': '\\u003E',\n  'Gamma': '\\u0393',\n  'Gammad': '\\u03DC',\n  'Gbreve': '\\u011E',\n  'Gcedil': '\\u0122',\n  'Gcirc': '\\u011C',\n  'Gcy': '\\u0413',\n  'Gdot': '\\u0120',\n  'Gfr': '\\uD835\\uDD0A',\n  'Gg': '\\u22D9',\n  'ggg': '\\u22D9',\n  'Gopf': '\\uD835\\uDD3E',\n  'GreaterEqual': '\\u2265',\n  'ge': '\\u2265',\n  'geq': '\\u2265',\n  'GreaterEqualLess': '\\u22DB',\n  'gel': '\\u22DB',\n  'gtreqless': '\\u22DB',\n  'GreaterFullEqual': '\\u2267',\n  'gE': '\\u2267',\n  'geqq': '\\u2267',\n  'GreaterGreater': '\\u2AA2',\n  'GreaterLess': '\\u2277',\n  'gl': '\\u2277',\n  'gtrless': '\\u2277',\n  'GreaterSlantEqual': '\\u2A7E',\n  'geqslant': '\\u2A7E',\n  'ges': '\\u2A7E',\n  'GreaterTilde': '\\u2273',\n  'gsim': '\\u2273',\n  'gtrsim': '\\u2273',\n  'Gscr': '\\uD835\\uDCA2',\n  'Gt': '\\u226B',\n  'NestedGreaterGreater': '\\u226B',\n  'gg': '\\u226B',\n  'HARDcy': '\\u042A',\n  'Hacek': '\\u02C7',\n  'caron': '\\u02C7',\n  'Hat': '\\u005E',\n  'Hcirc': '\\u0124',\n  'Hfr': '\\u210C',\n  'Poincareplane': '\\u210C',\n  'HilbertSpace': '\\u210B',\n  'Hscr': '\\u210B',\n  'hamilt': '\\u210B',\n  'Hopf': '\\u210D',\n  'quaternions': '\\u210D',\n  'HorizontalLine': '\\u2500',\n  'boxh': '\\u2500',\n  'Hstrok': '\\u0126',\n  'HumpEqual': '\\u224F',\n  'bumpe': '\\u224F',\n  'bumpeq': '\\u224F',\n  'IEcy': '\\u0415',\n  'IJlig': '\\u0132',\n  'IOcy': '\\u0401',\n  'Iacute': '\\u00CD',\n  'Icirc': '\\u00CE',\n  'Icy': '\\u0418',\n  'Idot': '\\u0130',\n  'Ifr': '\\u2111',\n  'Im': '\\u2111',\n  'image': '\\u2111',\n  'imagpart': '\\u2111',\n  'Igrave': '\\u00CC',\n  'Imacr': '\\u012A',\n  'ImaginaryI': '\\u2148',\n  'ii': '\\u2148',\n  'Int': '\\u222C',\n  'Integral': '\\u222B',\n  'int': '\\u222B',\n  'Intersection': '\\u22C2',\n  'bigcap': '\\u22C2',\n  'xcap': '\\u22C2',\n  'InvisibleComma': '\\u2063',\n  'ic': '\\u2063',\n  'InvisibleTimes': '\\u2062',\n  'it': '\\u2062',\n  'Iogon': '\\u012E',\n  'Iopf': '\\uD835\\uDD40',\n  'Iota': '\\u0399',\n  'Iscr': '\\u2110',\n  'imagline': '\\u2110',\n  'Itilde': '\\u0128',\n  'Iukcy': '\\u0406',\n  'Iuml': '\\u00CF',\n  'Jcirc': '\\u0134',\n  'Jcy': '\\u0419',\n  'Jfr': '\\uD835\\uDD0D',\n  'Jopf': '\\uD835\\uDD41',\n  'Jscr': '\\uD835\\uDCA5',\n  'Jsercy': '\\u0408',\n  'Jukcy': '\\u0404',\n  'KHcy': '\\u0425',\n  'KJcy': '\\u040C',\n  'Kappa': '\\u039A',\n  'Kcedil': '\\u0136',\n  'Kcy': '\\u041A',\n  'Kfr': '\\uD835\\uDD0E',\n  'Kopf': '\\uD835\\uDD42',\n  'Kscr': '\\uD835\\uDCA6',\n  'LJcy': '\\u0409',\n  'LT': '\\u003C',\n  'lt': '\\u003C',\n  'Lacute': '\\u0139',\n  'Lambda': '\\u039B',\n  'Lang': '\\u27EA',\n  'Laplacetrf': '\\u2112',\n  'Lscr': '\\u2112',\n  'lagran': '\\u2112',\n  'Larr': '\\u219E',\n  'twoheadleftarrow': '\\u219E',\n  'Lcaron': '\\u013D',\n  'Lcedil': '\\u013B',\n  'Lcy': '\\u041B',\n  'LeftAngleBracket': '\\u27E8',\n  'lang': '\\u27E8',\n  'langle': '\\u27E8',\n  'LeftArrow': '\\u2190',\n  'ShortLeftArrow': '\\u2190',\n  'larr': '\\u2190',\n  'leftarrow': '\\u2190',\n  'slarr': '\\u2190',\n  'LeftArrowBar': '\\u21E4',\n  'larrb': '\\u21E4',\n  'LeftArrowRightArrow': '\\u21C6',\n  'leftrightarrows': '\\u21C6',\n  'lrarr': '\\u21C6',\n  'LeftCeiling': '\\u2308',\n  'lceil': '\\u2308',\n  'LeftDoubleBracket': '\\u27E6',\n  'lobrk': '\\u27E6',\n  'LeftDownTeeVector': '\\u2961',\n  'LeftDownVector': '\\u21C3',\n  'dharl': '\\u21C3',\n  'downharpoonleft': '\\u21C3',\n  'LeftDownVectorBar': '\\u2959',\n  'LeftFloor': '\\u230A',\n  'lfloor': '\\u230A',\n  'LeftRightArrow': '\\u2194',\n  'harr': '\\u2194',\n  'leftrightarrow': '\\u2194',\n  'LeftRightVector': '\\u294E',\n  'LeftTee': '\\u22A3',\n  'dashv': '\\u22A3',\n  'LeftTeeArrow': '\\u21A4',\n  'mapstoleft': '\\u21A4',\n  'LeftTeeVector': '\\u295A',\n  'LeftTriangle': '\\u22B2',\n  'vartriangleleft': '\\u22B2',\n  'vltri': '\\u22B2',\n  'LeftTriangleBar': '\\u29CF',\n  'LeftTriangleEqual': '\\u22B4',\n  'ltrie': '\\u22B4',\n  'trianglelefteq': '\\u22B4',\n  'LeftUpDownVector': '\\u2951',\n  'LeftUpTeeVector': '\\u2960',\n  'LeftUpVector': '\\u21BF',\n  'uharl': '\\u21BF',\n  'upharpoonleft': '\\u21BF',\n  'LeftUpVectorBar': '\\u2958',\n  'LeftVector': '\\u21BC',\n  'leftharpoonup': '\\u21BC',\n  'lharu': '\\u21BC',\n  'LeftVectorBar': '\\u2952',\n  'LessEqualGreater': '\\u22DA',\n  'leg': '\\u22DA',\n  'lesseqgtr': '\\u22DA',\n  'LessFullEqual': '\\u2266',\n  'lE': '\\u2266',\n  'leqq': '\\u2266',\n  'LessGreater': '\\u2276',\n  'lessgtr': '\\u2276',\n  'lg': '\\u2276',\n  'LessLess': '\\u2AA1',\n  'LessSlantEqual': '\\u2A7D',\n  'leqslant': '\\u2A7D',\n  'les': '\\u2A7D',\n  'LessTilde': '\\u2272',\n  'lesssim': '\\u2272',\n  'lsim': '\\u2272',\n  'Lfr': '\\uD835\\uDD0F',\n  'Ll': '\\u22D8',\n  'Lleftarrow': '\\u21DA',\n  'lAarr': '\\u21DA',\n  'Lmidot': '\\u013F',\n  'LongLeftArrow': '\\u27F5',\n  'longleftarrow': '\\u27F5',\n  'xlarr': '\\u27F5',\n  'LongLeftRightArrow': '\\u27F7',\n  'longleftrightarrow': '\\u27F7',\n  'xharr': '\\u27F7',\n  'LongRightArrow': '\\u27F6',\n  'longrightarrow': '\\u27F6',\n  'xrarr': '\\u27F6',\n  'Lopf': '\\uD835\\uDD43',\n  'LowerLeftArrow': '\\u2199',\n  'swarr': '\\u2199',\n  'swarrow': '\\u2199',\n  'LowerRightArrow': '\\u2198',\n  'searr': '\\u2198',\n  'searrow': '\\u2198',\n  'Lsh': '\\u21B0',\n  'lsh': '\\u21B0',\n  'Lstrok': '\\u0141',\n  'Lt': '\\u226A',\n  'NestedLessLess': '\\u226A',\n  'll': '\\u226A',\n  'Map': '\\u2905',\n  'Mcy': '\\u041C',\n  'MediumSpace': '\\u205F',\n  'Mellintrf': '\\u2133',\n  'Mscr': '\\u2133',\n  'phmmat': '\\u2133',\n  'Mfr': '\\uD835\\uDD10',\n  'MinusPlus': '\\u2213',\n  'mnplus': '\\u2213',\n  'mp': '\\u2213',\n  'Mopf': '\\uD835\\uDD44',\n  'Mu': '\\u039C',\n  'NJcy': '\\u040A',\n  'Nacute': '\\u0143',\n  'Ncaron': '\\u0147',\n  'Ncedil': '\\u0145',\n  'Ncy': '\\u041D',\n  'NegativeMediumSpace': '\\u200B',\n  'NegativeThickSpace': '\\u200B',\n  'NegativeThinSpace': '\\u200B',\n  'NegativeVeryThinSpace': '\\u200B',\n  'ZeroWidthSpace': '\\u200B',\n  'NewLine': '\\u000A',\n  'Nfr': '\\uD835\\uDD11',\n  'NoBreak': '\\u2060',\n  'NonBreakingSpace': '\\u00A0',\n  'nbsp': '\\u00A0',\n  'Nopf': '\\u2115',\n  'naturals': '\\u2115',\n  'Not': '\\u2AEC',\n  'NotCongruent': '\\u2262',\n  'nequiv': '\\u2262',\n  'NotCupCap': '\\u226D',\n  'NotDoubleVerticalBar': '\\u2226',\n  'npar': '\\u2226',\n  'nparallel': '\\u2226',\n  'nshortparallel': '\\u2226',\n  'nspar': '\\u2226',\n  'NotElement': '\\u2209',\n  'notin': '\\u2209',\n  'notinva': '\\u2209',\n  'NotEqual': '\\u2260',\n  'ne': '\\u2260',\n  'NotEqualTilde': '\\u2242\\u0338',\n  'nesim': '\\u2242\\u0338',\n  'NotExists': '\\u2204',\n  'nexist': '\\u2204',\n  'nexists': '\\u2204',\n  'NotGreater': '\\u226F',\n  'ngt': '\\u226F',\n  'ngtr': '\\u226F',\n  'NotGreaterEqual': '\\u2271',\n  'nge': '\\u2271',\n  'ngeq': '\\u2271',\n  'NotGreaterFullEqual': '\\u2267\\u0338',\n  'ngE': '\\u2267\\u0338',\n  'ngeqq': '\\u2267\\u0338',\n  'NotGreaterGreater': '\\u226B\\u0338',\n  'nGtv': '\\u226B\\u0338',\n  'NotGreaterLess': '\\u2279',\n  'ntgl': '\\u2279',\n  'NotGreaterSlantEqual': '\\u2A7E\\u0338',\n  'ngeqslant': '\\u2A7E\\u0338',\n  'nges': '\\u2A7E\\u0338',\n  'NotGreaterTilde': '\\u2275',\n  'ngsim': '\\u2275',\n  'NotHumpDownHump': '\\u224E\\u0338',\n  'nbump': '\\u224E\\u0338',\n  'NotHumpEqual': '\\u224F\\u0338',\n  'nbumpe': '\\u224F\\u0338',\n  'NotLeftTriangle': '\\u22EA',\n  'nltri': '\\u22EA',\n  'ntriangleleft': '\\u22EA',\n  'NotLeftTriangleBar': '\\u29CF\\u0338',\n  'NotLeftTriangleEqual': '\\u22EC',\n  'nltrie': '\\u22EC',\n  'ntrianglelefteq': '\\u22EC',\n  'NotLess': '\\u226E',\n  'nless': '\\u226E',\n  'nlt': '\\u226E',\n  'NotLessEqual': '\\u2270',\n  'nle': '\\u2270',\n  'nleq': '\\u2270',\n  'NotLessGreater': '\\u2278',\n  'ntlg': '\\u2278',\n  'NotLessLess': '\\u226A\\u0338',\n  'nLtv': '\\u226A\\u0338',\n  'NotLessSlantEqual': '\\u2A7D\\u0338',\n  'nleqslant': '\\u2A7D\\u0338',\n  'nles': '\\u2A7D\\u0338',\n  'NotLessTilde': '\\u2274',\n  'nlsim': '\\u2274',\n  'NotNestedGreaterGreater': '\\u2AA2\\u0338',\n  'NotNestedLessLess': '\\u2AA1\\u0338',\n  'NotPrecedes': '\\u2280',\n  'npr': '\\u2280',\n  'nprec': '\\u2280',\n  'NotPrecedesEqual': '\\u2AAF\\u0338',\n  'npre': '\\u2AAF\\u0338',\n  'npreceq': '\\u2AAF\\u0338',\n  'NotPrecedesSlantEqual': '\\u22E0',\n  'nprcue': '\\u22E0',\n  'NotReverseElement': '\\u220C',\n  'notni': '\\u220C',\n  'notniva': '\\u220C',\n  'NotRightTriangle': '\\u22EB',\n  'nrtri': '\\u22EB',\n  'ntriangleright': '\\u22EB',\n  'NotRightTriangleBar': '\\u29D0\\u0338',\n  'NotRightTriangleEqual': '\\u22ED',\n  'nrtrie': '\\u22ED',\n  'ntrianglerighteq': '\\u22ED',\n  'NotSquareSubset': '\\u228F\\u0338',\n  'NotSquareSubsetEqual': '\\u22E2',\n  'nsqsube': '\\u22E2',\n  'NotSquareSuperset': '\\u2290\\u0338',\n  'NotSquareSupersetEqual': '\\u22E3',\n  'nsqsupe': '\\u22E3',\n  'NotSubset': '\\u2282\\u20D2',\n  'nsubset': '\\u2282\\u20D2',\n  'vnsub': '\\u2282\\u20D2',\n  'NotSubsetEqual': '\\u2288',\n  'nsube': '\\u2288',\n  'nsubseteq': '\\u2288',\n  'NotSucceeds': '\\u2281',\n  'nsc': '\\u2281',\n  'nsucc': '\\u2281',\n  'NotSucceedsEqual': '\\u2AB0\\u0338',\n  'nsce': '\\u2AB0\\u0338',\n  'nsucceq': '\\u2AB0\\u0338',\n  'NotSucceedsSlantEqual': '\\u22E1',\n  'nsccue': '\\u22E1',\n  'NotSucceedsTilde': '\\u227F\\u0338',\n  'NotSuperset': '\\u2283\\u20D2',\n  'nsupset': '\\u2283\\u20D2',\n  'vnsup': '\\u2283\\u20D2',\n  'NotSupersetEqual': '\\u2289',\n  'nsupe': '\\u2289',\n  'nsupseteq': '\\u2289',\n  'NotTilde': '\\u2241',\n  'nsim': '\\u2241',\n  'NotTildeEqual': '\\u2244',\n  'nsime': '\\u2244',\n  'nsimeq': '\\u2244',\n  'NotTildeFullEqual': '\\u2247',\n  'ncong': '\\u2247',\n  'NotTildeTilde': '\\u2249',\n  'nap': '\\u2249',\n  'napprox': '\\u2249',\n  'NotVerticalBar': '\\u2224',\n  'nmid': '\\u2224',\n  'nshortmid': '\\u2224',\n  'nsmid': '\\u2224',\n  'Nscr': '\\uD835\\uDCA9',\n  'Ntilde': '\\u00D1',\n  'Nu': '\\u039D',\n  'OElig': '\\u0152',\n  'Oacute': '\\u00D3',\n  'Ocirc': '\\u00D4',\n  'Ocy': '\\u041E',\n  'Odblac': '\\u0150',\n  'Ofr': '\\uD835\\uDD12',\n  'Ograve': '\\u00D2',\n  'Omacr': '\\u014C',\n  'Omega': '\\u03A9',\n  'ohm': '\\u03A9',\n  'Omicron': '\\u039F',\n  'Oopf': '\\uD835\\uDD46',\n  'OpenCurlyDoubleQuote': '\\u201C',\n  'ldquo': '\\u201C',\n  'OpenCurlyQuote': '\\u2018',\n  'lsquo': '\\u2018',\n  'Or': '\\u2A54',\n  'Oscr': '\\uD835\\uDCAA',\n  'Oslash': '\\u00D8',\n  'Otilde': '\\u00D5',\n  'Otimes': '\\u2A37',\n  'Ouml': '\\u00D6',\n  'OverBar': '\\u203E',\n  'oline': '\\u203E',\n  'OverBrace': '\\u23DE',\n  'OverBracket': '\\u23B4',\n  'tbrk': '\\u23B4',\n  'OverParenthesis': '\\u23DC',\n  'PartialD': '\\u2202',\n  'part': '\\u2202',\n  'Pcy': '\\u041F',\n  'Pfr': '\\uD835\\uDD13',\n  'Phi': '\\u03A6',\n  'Pi': '\\u03A0',\n  'PlusMinus': '\\u00B1',\n  'plusmn': '\\u00B1',\n  'pm': '\\u00B1',\n  'Popf': '\\u2119',\n  'primes': '\\u2119',\n  'Pr': '\\u2ABB',\n  'Precedes': '\\u227A',\n  'pr': '\\u227A',\n  'prec': '\\u227A',\n  'PrecedesEqual': '\\u2AAF',\n  'pre': '\\u2AAF',\n  'preceq': '\\u2AAF',\n  'PrecedesSlantEqual': '\\u227C',\n  'prcue': '\\u227C',\n  'preccurlyeq': '\\u227C',\n  'PrecedesTilde': '\\u227E',\n  'precsim': '\\u227E',\n  'prsim': '\\u227E',\n  'Prime': '\\u2033',\n  'Product': '\\u220F',\n  'prod': '\\u220F',\n  'Proportional': '\\u221D',\n  'prop': '\\u221D',\n  'propto': '\\u221D',\n  'varpropto': '\\u221D',\n  'vprop': '\\u221D',\n  'Pscr': '\\uD835\\uDCAB',\n  'Psi': '\\u03A8',\n  'QUOT': '\\u0022',\n  'quot': '\\u0022',\n  'Qfr': '\\uD835\\uDD14',\n  'Qopf': '\\u211A',\n  'rationals': '\\u211A',\n  'Qscr': '\\uD835\\uDCAC',\n  'RBarr': '\\u2910',\n  'drbkarow': '\\u2910',\n  'REG': '\\u00AE',\n  'circledR': '\\u00AE',\n  'reg': '\\u00AE',\n  'Racute': '\\u0154',\n  'Rang': '\\u27EB',\n  'Rarr': '\\u21A0',\n  'twoheadrightarrow': '\\u21A0',\n  'Rarrtl': '\\u2916',\n  'Rcaron': '\\u0158',\n  'Rcedil': '\\u0156',\n  'Rcy': '\\u0420',\n  'Re': '\\u211C',\n  'Rfr': '\\u211C',\n  'real': '\\u211C',\n  'realpart': '\\u211C',\n  'ReverseElement': '\\u220B',\n  'SuchThat': '\\u220B',\n  'ni': '\\u220B',\n  'niv': '\\u220B',\n  'ReverseEquilibrium': '\\u21CB',\n  'leftrightharpoons': '\\u21CB',\n  'lrhar': '\\u21CB',\n  'ReverseUpEquilibrium': '\\u296F',\n  'duhar': '\\u296F',\n  'Rho': '\\u03A1',\n  'RightAngleBracket': '\\u27E9',\n  'rang': '\\u27E9',\n  'rangle': '\\u27E9',\n  'RightArrow': '\\u2192',\n  'ShortRightArrow': '\\u2192',\n  'rarr': '\\u2192',\n  'rightarrow': '\\u2192',\n  'srarr': '\\u2192',\n  'RightArrowBar': '\\u21E5',\n  'rarrb': '\\u21E5',\n  'RightArrowLeftArrow': '\\u21C4',\n  'rightleftarrows': '\\u21C4',\n  'rlarr': '\\u21C4',\n  'RightCeiling': '\\u2309',\n  'rceil': '\\u2309',\n  'RightDoubleBracket': '\\u27E7',\n  'robrk': '\\u27E7',\n  'RightDownTeeVector': '\\u295D',\n  'RightDownVector': '\\u21C2',\n  'dharr': '\\u21C2',\n  'downharpoonright': '\\u21C2',\n  'RightDownVectorBar': '\\u2955',\n  'RightFloor': '\\u230B',\n  'rfloor': '\\u230B',\n  'RightTee': '\\u22A2',\n  'vdash': '\\u22A2',\n  'RightTeeArrow': '\\u21A6',\n  'map': '\\u21A6',\n  'mapsto': '\\u21A6',\n  'RightTeeVector': '\\u295B',\n  'RightTriangle': '\\u22B3',\n  'vartriangleright': '\\u22B3',\n  'vrtri': '\\u22B3',\n  'RightTriangleBar': '\\u29D0',\n  'RightTriangleEqual': '\\u22B5',\n  'rtrie': '\\u22B5',\n  'trianglerighteq': '\\u22B5',\n  'RightUpDownVector': '\\u294F',\n  'RightUpTeeVector': '\\u295C',\n  'RightUpVector': '\\u21BE',\n  'uharr': '\\u21BE',\n  'upharpoonright': '\\u21BE',\n  'RightUpVectorBar': '\\u2954',\n  'RightVector': '\\u21C0',\n  'rharu': '\\u21C0',\n  'rightharpoonup': '\\u21C0',\n  'RightVectorBar': '\\u2953',\n  'Ropf': '\\u211D',\n  'reals': '\\u211D',\n  'RoundImplies': '\\u2970',\n  'Rrightarrow': '\\u21DB',\n  'rAarr': '\\u21DB',\n  'Rscr': '\\u211B',\n  'realine': '\\u211B',\n  'Rsh': '\\u21B1',\n  'rsh': '\\u21B1',\n  'RuleDelayed': '\\u29F4',\n  'SHCHcy': '\\u0429',\n  'SHcy': '\\u0428',\n  'SOFTcy': '\\u042C',\n  'Sacute': '\\u015A',\n  'Sc': '\\u2ABC',\n  'Scaron': '\\u0160',\n  'Scedil': '\\u015E',\n  'Scirc': '\\u015C',\n  'Scy': '\\u0421',\n  'Sfr': '\\uD835\\uDD16',\n  'ShortUpArrow': '\\u2191',\n  'UpArrow': '\\u2191',\n  'uarr': '\\u2191',\n  'uparrow': '\\u2191',\n  'Sigma': '\\u03A3',\n  'SmallCircle': '\\u2218',\n  'compfn': '\\u2218',\n  'Sopf': '\\uD835\\uDD4A',\n  'Sqrt': '\\u221A',\n  'radic': '\\u221A',\n  'Square': '\\u25A1',\n  'squ': '\\u25A1',\n  'square': '\\u25A1',\n  'SquareIntersection': '\\u2293',\n  'sqcap': '\\u2293',\n  'SquareSubset': '\\u228F',\n  'sqsub': '\\u228F',\n  'sqsubset': '\\u228F',\n  'SquareSubsetEqual': '\\u2291',\n  'sqsube': '\\u2291',\n  'sqsubseteq': '\\u2291',\n  'SquareSuperset': '\\u2290',\n  'sqsup': '\\u2290',\n  'sqsupset': '\\u2290',\n  'SquareSupersetEqual': '\\u2292',\n  'sqsupe': '\\u2292',\n  'sqsupseteq': '\\u2292',\n  'SquareUnion': '\\u2294',\n  'sqcup': '\\u2294',\n  'Sscr': '\\uD835\\uDCAE',\n  'Star': '\\u22C6',\n  'sstarf': '\\u22C6',\n  'Sub': '\\u22D0',\n  'Subset': '\\u22D0',\n  'SubsetEqual': '\\u2286',\n  'sube': '\\u2286',\n  'subseteq': '\\u2286',\n  'Succeeds': '\\u227B',\n  'sc': '\\u227B',\n  'succ': '\\u227B',\n  'SucceedsEqual': '\\u2AB0',\n  'sce': '\\u2AB0',\n  'succeq': '\\u2AB0',\n  'SucceedsSlantEqual': '\\u227D',\n  'sccue': '\\u227D',\n  'succcurlyeq': '\\u227D',\n  'SucceedsTilde': '\\u227F',\n  'scsim': '\\u227F',\n  'succsim': '\\u227F',\n  'Sum': '\\u2211',\n  'sum': '\\u2211',\n  'Sup': '\\u22D1',\n  'Supset': '\\u22D1',\n  'Superset': '\\u2283',\n  'sup': '\\u2283',\n  'supset': '\\u2283',\n  'SupersetEqual': '\\u2287',\n  'supe': '\\u2287',\n  'supseteq': '\\u2287',\n  'THORN': '\\u00DE',\n  'TRADE': '\\u2122',\n  'trade': '\\u2122',\n  'TSHcy': '\\u040B',\n  'TScy': '\\u0426',\n  'Tab': '\\u0009',\n  'Tau': '\\u03A4',\n  'Tcaron': '\\u0164',\n  'Tcedil': '\\u0162',\n  'Tcy': '\\u0422',\n  'Tfr': '\\uD835\\uDD17',\n  'Therefore': '\\u2234',\n  'there4': '\\u2234',\n  'therefore': '\\u2234',\n  'Theta': '\\u0398',\n  'ThickSpace': '\\u205F\\u200A',\n  'ThinSpace': '\\u2009',\n  'thinsp': '\\u2009',\n  'Tilde': '\\u223C',\n  'sim': '\\u223C',\n  'thicksim': '\\u223C',\n  'thksim': '\\u223C',\n  'TildeEqual': '\\u2243',\n  'sime': '\\u2243',\n  'simeq': '\\u2243',\n  'TildeFullEqual': '\\u2245',\n  'cong': '\\u2245',\n  'TildeTilde': '\\u2248',\n  'ap': '\\u2248',\n  'approx': '\\u2248',\n  'asymp': '\\u2248',\n  'thickapprox': '\\u2248',\n  'thkap': '\\u2248',\n  'Topf': '\\uD835\\uDD4B',\n  'TripleDot': '\\u20DB',\n  'tdot': '\\u20DB',\n  'Tscr': '\\uD835\\uDCAF',\n  'Tstrok': '\\u0166',\n  'Uacute': '\\u00DA',\n  'Uarr': '\\u219F',\n  'Uarrocir': '\\u2949',\n  'Ubrcy': '\\u040E',\n  'Ubreve': '\\u016C',\n  'Ucirc': '\\u00DB',\n  'Ucy': '\\u0423',\n  'Udblac': '\\u0170',\n  'Ufr': '\\uD835\\uDD18',\n  'Ugrave': '\\u00D9',\n  'Umacr': '\\u016A',\n  'UnderBar': '\\u005F',\n  'lowbar': '\\u005F',\n  'UnderBrace': '\\u23DF',\n  'UnderBracket': '\\u23B5',\n  'bbrk': '\\u23B5',\n  'UnderParenthesis': '\\u23DD',\n  'Union': '\\u22C3',\n  'bigcup': '\\u22C3',\n  'xcup': '\\u22C3',\n  'UnionPlus': '\\u228E',\n  'uplus': '\\u228E',\n  'Uogon': '\\u0172',\n  'Uopf': '\\uD835\\uDD4C',\n  'UpArrowBar': '\\u2912',\n  'UpArrowDownArrow': '\\u21C5',\n  'udarr': '\\u21C5',\n  'UpDownArrow': '\\u2195',\n  'updownarrow': '\\u2195',\n  'varr': '\\u2195',\n  'UpEquilibrium': '\\u296E',\n  'udhar': '\\u296E',\n  'UpTee': '\\u22A5',\n  'bot': '\\u22A5',\n  'bottom': '\\u22A5',\n  'perp': '\\u22A5',\n  'UpTeeArrow': '\\u21A5',\n  'mapstoup': '\\u21A5',\n  'UpperLeftArrow': '\\u2196',\n  'nwarr': '\\u2196',\n  'nwarrow': '\\u2196',\n  'UpperRightArrow': '\\u2197',\n  'nearr': '\\u2197',\n  'nearrow': '\\u2197',\n  'Upsi': '\\u03D2',\n  'upsih': '\\u03D2',\n  'Upsilon': '\\u03A5',\n  'Uring': '\\u016E',\n  'Uscr': '\\uD835\\uDCB0',\n  'Utilde': '\\u0168',\n  'Uuml': '\\u00DC',\n  'VDash': '\\u22AB',\n  'Vbar': '\\u2AEB',\n  'Vcy': '\\u0412',\n  'Vdash': '\\u22A9',\n  'Vdashl': '\\u2AE6',\n  'Vee': '\\u22C1',\n  'bigvee': '\\u22C1',\n  'xvee': '\\u22C1',\n  'Verbar': '\\u2016',\n  'Vert': '\\u2016',\n  'VerticalBar': '\\u2223',\n  'mid': '\\u2223',\n  'shortmid': '\\u2223',\n  'smid': '\\u2223',\n  'VerticalLine': '\\u007C',\n  'verbar': '\\u007C',\n  'vert': '\\u007C',\n  'VerticalSeparator': '\\u2758',\n  'VerticalTilde': '\\u2240',\n  'wr': '\\u2240',\n  'wreath': '\\u2240',\n  'VeryThinSpace': '\\u200A',\n  'hairsp': '\\u200A',\n  'Vfr': '\\uD835\\uDD19',\n  'Vopf': '\\uD835\\uDD4D',\n  'Vscr': '\\uD835\\uDCB1',\n  'Vvdash': '\\u22AA',\n  'Wcirc': '\\u0174',\n  'Wedge': '\\u22C0',\n  'bigwedge': '\\u22C0',\n  'xwedge': '\\u22C0',\n  'Wfr': '\\uD835\\uDD1A',\n  'Wopf': '\\uD835\\uDD4E',\n  'Wscr': '\\uD835\\uDCB2',\n  'Xfr': '\\uD835\\uDD1B',\n  'Xi': '\\u039E',\n  'Xopf': '\\uD835\\uDD4F',\n  'Xscr': '\\uD835\\uDCB3',\n  'YAcy': '\\u042F',\n  'YIcy': '\\u0407',\n  'YUcy': '\\u042E',\n  'Yacute': '\\u00DD',\n  'Ycirc': '\\u0176',\n  'Ycy': '\\u042B',\n  'Yfr': '\\uD835\\uDD1C',\n  'Yopf': '\\uD835\\uDD50',\n  'Yscr': '\\uD835\\uDCB4',\n  'Yuml': '\\u0178',\n  'ZHcy': '\\u0416',\n  'Zacute': '\\u0179',\n  'Zcaron': '\\u017D',\n  'Zcy': '\\u0417',\n  'Zdot': '\\u017B',\n  'Zeta': '\\u0396',\n  'Zfr': '\\u2128',\n  'zeetrf': '\\u2128',\n  'Zopf': '\\u2124',\n  'integers': '\\u2124',\n  'Zscr': '\\uD835\\uDCB5',\n  'aacute': '\\u00E1',\n  'abreve': '\\u0103',\n  'ac': '\\u223E',\n  'mstpos': '\\u223E',\n  'acE': '\\u223E\\u0333',\n  'acd': '\\u223F',\n  'acirc': '\\u00E2',\n  'acy': '\\u0430',\n  'aelig': '\\u00E6',\n  'afr': '\\uD835\\uDD1E',\n  'agrave': '\\u00E0',\n  'alefsym': '\\u2135',\n  'aleph': '\\u2135',\n  'alpha': '\\u03B1',\n  'amacr': '\\u0101',\n  'amalg': '\\u2A3F',\n  'and': '\\u2227',\n  'wedge': '\\u2227',\n  'andand': '\\u2A55',\n  'andd': '\\u2A5C',\n  'andslope': '\\u2A58',\n  'andv': '\\u2A5A',\n  'ang': '\\u2220',\n  'angle': '\\u2220',\n  'ange': '\\u29A4',\n  'angmsd': '\\u2221',\n  'measuredangle': '\\u2221',\n  'angmsdaa': '\\u29A8',\n  'angmsdab': '\\u29A9',\n  'angmsdac': '\\u29AA',\n  'angmsdad': '\\u29AB',\n  'angmsdae': '\\u29AC',\n  'angmsdaf': '\\u29AD',\n  'angmsdag': '\\u29AE',\n  'angmsdah': '\\u29AF',\n  'angrt': '\\u221F',\n  'angrtvb': '\\u22BE',\n  'angrtvbd': '\\u299D',\n  'angsph': '\\u2222',\n  'angzarr': '\\u237C',\n  'aogon': '\\u0105',\n  'aopf': '\\uD835\\uDD52',\n  'apE': '\\u2A70',\n  'apacir': '\\u2A6F',\n  'ape': '\\u224A',\n  'approxeq': '\\u224A',\n  'apid': '\\u224B',\n  'apos': '\\u0027',\n  'aring': '\\u00E5',\n  'ascr': '\\uD835\\uDCB6',\n  'ast': '\\u002A',\n  'midast': '\\u002A',\n  'atilde': '\\u00E3',\n  'auml': '\\u00E4',\n  'awint': '\\u2A11',\n  'bNot': '\\u2AED',\n  'backcong': '\\u224C',\n  'bcong': '\\u224C',\n  'backepsilon': '\\u03F6',\n  'bepsi': '\\u03F6',\n  'backprime': '\\u2035',\n  'bprime': '\\u2035',\n  'backsim': '\\u223D',\n  'bsim': '\\u223D',\n  'backsimeq': '\\u22CD',\n  'bsime': '\\u22CD',\n  'barvee': '\\u22BD',\n  'barwed': '\\u2305',\n  'barwedge': '\\u2305',\n  'bbrktbrk': '\\u23B6',\n  'bcy': '\\u0431',\n  'bdquo': '\\u201E',\n  'ldquor': '\\u201E',\n  'bemptyv': '\\u29B0',\n  'beta': '\\u03B2',\n  'beth': '\\u2136',\n  'between': '\\u226C',\n  'twixt': '\\u226C',\n  'bfr': '\\uD835\\uDD1F',\n  'bigcirc': '\\u25EF',\n  'xcirc': '\\u25EF',\n  'bigodot': '\\u2A00',\n  'xodot': '\\u2A00',\n  'bigoplus': '\\u2A01',\n  'xoplus': '\\u2A01',\n  'bigotimes': '\\u2A02',\n  'xotime': '\\u2A02',\n  'bigsqcup': '\\u2A06',\n  'xsqcup': '\\u2A06',\n  'bigstar': '\\u2605',\n  'starf': '\\u2605',\n  'bigtriangledown': '\\u25BD',\n  'xdtri': '\\u25BD',\n  'bigtriangleup': '\\u25B3',\n  'xutri': '\\u25B3',\n  'biguplus': '\\u2A04',\n  'xuplus': '\\u2A04',\n  'bkarow': '\\u290D',\n  'rbarr': '\\u290D',\n  'blacklozenge': '\\u29EB',\n  'lozf': '\\u29EB',\n  'blacktriangle': '\\u25B4',\n  'utrif': '\\u25B4',\n  'blacktriangledown': '\\u25BE',\n  'dtrif': '\\u25BE',\n  'blacktriangleleft': '\\u25C2',\n  'ltrif': '\\u25C2',\n  'blacktriangleright': '\\u25B8',\n  'rtrif': '\\u25B8',\n  'blank': '\\u2423',\n  'blk12': '\\u2592',\n  'blk14': '\\u2591',\n  'blk34': '\\u2593',\n  'block': '\\u2588',\n  'bne': '\\u003D\\u20E5',\n  'bnequiv': '\\u2261\\u20E5',\n  'bnot': '\\u2310',\n  'bopf': '\\uD835\\uDD53',\n  'bowtie': '\\u22C8',\n  'boxDL': '\\u2557',\n  'boxDR': '\\u2554',\n  'boxDl': '\\u2556',\n  'boxDr': '\\u2553',\n  'boxH': '\\u2550',\n  'boxHD': '\\u2566',\n  'boxHU': '\\u2569',\n  'boxHd': '\\u2564',\n  'boxHu': '\\u2567',\n  'boxUL': '\\u255D',\n  'boxUR': '\\u255A',\n  'boxUl': '\\u255C',\n  'boxUr': '\\u2559',\n  'boxV': '\\u2551',\n  'boxVH': '\\u256C',\n  'boxVL': '\\u2563',\n  'boxVR': '\\u2560',\n  'boxVh': '\\u256B',\n  'boxVl': '\\u2562',\n  'boxVr': '\\u255F',\n  'boxbox': '\\u29C9',\n  'boxdL': '\\u2555',\n  'boxdR': '\\u2552',\n  'boxdl': '\\u2510',\n  'boxdr': '\\u250C',\n  'boxhD': '\\u2565',\n  'boxhU': '\\u2568',\n  'boxhd': '\\u252C',\n  'boxhu': '\\u2534',\n  'boxminus': '\\u229F',\n  'minusb': '\\u229F',\n  'boxplus': '\\u229E',\n  'plusb': '\\u229E',\n  'boxtimes': '\\u22A0',\n  'timesb': '\\u22A0',\n  'boxuL': '\\u255B',\n  'boxuR': '\\u2558',\n  'boxul': '\\u2518',\n  'boxur': '\\u2514',\n  'boxv': '\\u2502',\n  'boxvH': '\\u256A',\n  'boxvL': '\\u2561',\n  'boxvR': '\\u255E',\n  'boxvh': '\\u253C',\n  'boxvl': '\\u2524',\n  'boxvr': '\\u251C',\n  'brvbar': '\\u00A6',\n  'bscr': '\\uD835\\uDCB7',\n  'bsemi': '\\u204F',\n  'bsol': '\\u005C',\n  'bsolb': '\\u29C5',\n  'bsolhsub': '\\u27C8',\n  'bull': '\\u2022',\n  'bullet': '\\u2022',\n  'bumpE': '\\u2AAE',\n  'cacute': '\\u0107',\n  'cap': '\\u2229',\n  'capand': '\\u2A44',\n  'capbrcup': '\\u2A49',\n  'capcap': '\\u2A4B',\n  'capcup': '\\u2A47',\n  'capdot': '\\u2A40',\n  'caps': '\\u2229\\uFE00',\n  'caret': '\\u2041',\n  'ccaps': '\\u2A4D',\n  'ccaron': '\\u010D',\n  'ccedil': '\\u00E7',\n  'ccirc': '\\u0109',\n  'ccups': '\\u2A4C',\n  'ccupssm': '\\u2A50',\n  'cdot': '\\u010B',\n  'cemptyv': '\\u29B2',\n  'cent': '\\u00A2',\n  'cfr': '\\uD835\\uDD20',\n  'chcy': '\\u0447',\n  'check': '\\u2713',\n  'checkmark': '\\u2713',\n  'chi': '\\u03C7',\n  'cir': '\\u25CB',\n  'cirE': '\\u29C3',\n  'circ': '\\u02C6',\n  'circeq': '\\u2257',\n  'cire': '\\u2257',\n  'circlearrowleft': '\\u21BA',\n  'olarr': '\\u21BA',\n  'circlearrowright': '\\u21BB',\n  'orarr': '\\u21BB',\n  'circledS': '\\u24C8',\n  'oS': '\\u24C8',\n  'circledast': '\\u229B',\n  'oast': '\\u229B',\n  'circledcirc': '\\u229A',\n  'ocir': '\\u229A',\n  'circleddash': '\\u229D',\n  'odash': '\\u229D',\n  'cirfnint': '\\u2A10',\n  'cirmid': '\\u2AEF',\n  'cirscir': '\\u29C2',\n  'clubs': '\\u2663',\n  'clubsuit': '\\u2663',\n  'colon': '\\u003A',\n  'comma': '\\u002C',\n  'commat': '\\u0040',\n  'comp': '\\u2201',\n  'complement': '\\u2201',\n  'congdot': '\\u2A6D',\n  'copf': '\\uD835\\uDD54',\n  'copysr': '\\u2117',\n  'crarr': '\\u21B5',\n  'cross': '\\u2717',\n  'cscr': '\\uD835\\uDCB8',\n  'csub': '\\u2ACF',\n  'csube': '\\u2AD1',\n  'csup': '\\u2AD0',\n  'csupe': '\\u2AD2',\n  'ctdot': '\\u22EF',\n  'cudarrl': '\\u2938',\n  'cudarrr': '\\u2935',\n  'cuepr': '\\u22DE',\n  'curlyeqprec': '\\u22DE',\n  'cuesc': '\\u22DF',\n  'curlyeqsucc': '\\u22DF',\n  'cularr': '\\u21B6',\n  'curvearrowleft': '\\u21B6',\n  'cularrp': '\\u293D',\n  'cup': '\\u222A',\n  'cupbrcap': '\\u2A48',\n  'cupcap': '\\u2A46',\n  'cupcup': '\\u2A4A',\n  'cupdot': '\\u228D',\n  'cupor': '\\u2A45',\n  'cups': '\\u222A\\uFE00',\n  'curarr': '\\u21B7',\n  'curvearrowright': '\\u21B7',\n  'curarrm': '\\u293C',\n  'curlyvee': '\\u22CE',\n  'cuvee': '\\u22CE',\n  'curlywedge': '\\u22CF',\n  'cuwed': '\\u22CF',\n  'curren': '\\u00A4',\n  'cwint': '\\u2231',\n  'cylcty': '\\u232D',\n  'dHar': '\\u2965',\n  'dagger': '\\u2020',\n  'daleth': '\\u2138',\n  'dash': '\\u2010',\n  'hyphen': '\\u2010',\n  'dbkarow': '\\u290F',\n  'rBarr': '\\u290F',\n  'dcaron': '\\u010F',\n  'dcy': '\\u0434',\n  'ddarr': '\\u21CA',\n  'downdownarrows': '\\u21CA',\n  'ddotseq': '\\u2A77',\n  'eDDot': '\\u2A77',\n  'deg': '\\u00B0',\n  'delta': '\\u03B4',\n  'demptyv': '\\u29B1',\n  'dfisht': '\\u297F',\n  'dfr': '\\uD835\\uDD21',\n  'diamondsuit': '\\u2666',\n  'diams': '\\u2666',\n  'digamma': '\\u03DD',\n  'gammad': '\\u03DD',\n  'disin': '\\u22F2',\n  'div': '\\u00F7',\n  'divide': '\\u00F7',\n  'divideontimes': '\\u22C7',\n  'divonx': '\\u22C7',\n  'djcy': '\\u0452',\n  'dlcorn': '\\u231E',\n  'llcorner': '\\u231E',\n  'dlcrop': '\\u230D',\n  'dollar': '\\u0024',\n  'dopf': '\\uD835\\uDD55',\n  'doteqdot': '\\u2251',\n  'eDot': '\\u2251',\n  'dotminus': '\\u2238',\n  'minusd': '\\u2238',\n  'dotplus': '\\u2214',\n  'plusdo': '\\u2214',\n  'dotsquare': '\\u22A1',\n  'sdotb': '\\u22A1',\n  'drcorn': '\\u231F',\n  'lrcorner': '\\u231F',\n  'drcrop': '\\u230C',\n  'dscr': '\\uD835\\uDCB9',\n  'dscy': '\\u0455',\n  'dsol': '\\u29F6',\n  'dstrok': '\\u0111',\n  'dtdot': '\\u22F1',\n  'dtri': '\\u25BF',\n  'triangledown': '\\u25BF',\n  'dwangle': '\\u29A6',\n  'dzcy': '\\u045F',\n  'dzigrarr': '\\u27FF',\n  'eacute': '\\u00E9',\n  'easter': '\\u2A6E',\n  'ecaron': '\\u011B',\n  'ecir': '\\u2256',\n  'eqcirc': '\\u2256',\n  'ecirc': '\\u00EA',\n  'ecolon': '\\u2255',\n  'eqcolon': '\\u2255',\n  'ecy': '\\u044D',\n  'edot': '\\u0117',\n  'efDot': '\\u2252',\n  'fallingdotseq': '\\u2252',\n  'efr': '\\uD835\\uDD22',\n  'eg': '\\u2A9A',\n  'egrave': '\\u00E8',\n  'egs': '\\u2A96',\n  'eqslantgtr': '\\u2A96',\n  'egsdot': '\\u2A98',\n  'el': '\\u2A99',\n  'elinters': '\\u23E7',\n  'ell': '\\u2113',\n  'els': '\\u2A95',\n  'eqslantless': '\\u2A95',\n  'elsdot': '\\u2A97',\n  'emacr': '\\u0113',\n  'empty': '\\u2205',\n  'emptyset': '\\u2205',\n  'emptyv': '\\u2205',\n  'varnothing': '\\u2205',\n  'emsp13': '\\u2004',\n  'emsp14': '\\u2005',\n  'emsp': '\\u2003',\n  'eng': '\\u014B',\n  'ensp': '\\u2002',\n  'eogon': '\\u0119',\n  'eopf': '\\uD835\\uDD56',\n  'epar': '\\u22D5',\n  'eparsl': '\\u29E3',\n  'eplus': '\\u2A71',\n  'epsi': '\\u03B5',\n  'epsilon': '\\u03B5',\n  'epsiv': '\\u03F5',\n  'straightepsilon': '\\u03F5',\n  'varepsilon': '\\u03F5',\n  'equals': '\\u003D',\n  'equest': '\\u225F',\n  'questeq': '\\u225F',\n  'equivDD': '\\u2A78',\n  'eqvparsl': '\\u29E5',\n  'erDot': '\\u2253',\n  'risingdotseq': '\\u2253',\n  'erarr': '\\u2971',\n  'escr': '\\u212F',\n  'eta': '\\u03B7',\n  'eth': '\\u00F0',\n  'euml': '\\u00EB',\n  'euro': '\\u20AC',\n  'excl': '\\u0021',\n  'fcy': '\\u0444',\n  'female': '\\u2640',\n  'ffilig': '\\uFB03',\n  'fflig': '\\uFB00',\n  'ffllig': '\\uFB04',\n  'ffr': '\\uD835\\uDD23',\n  'filig': '\\uFB01',\n  'fjlig': '\\u0066\\u006A',\n  'flat': '\\u266D',\n  'fllig': '\\uFB02',\n  'fltns': '\\u25B1',\n  'fnof': '\\u0192',\n  'fopf': '\\uD835\\uDD57',\n  'fork': '\\u22D4',\n  'pitchfork': '\\u22D4',\n  'forkv': '\\u2AD9',\n  'fpartint': '\\u2A0D',\n  'frac12': '\\u00BD',\n  'half': '\\u00BD',\n  'frac13': '\\u2153',\n  'frac14': '\\u00BC',\n  'frac15': '\\u2155',\n  'frac16': '\\u2159',\n  'frac18': '\\u215B',\n  'frac23': '\\u2154',\n  'frac25': '\\u2156',\n  'frac34': '\\u00BE',\n  'frac35': '\\u2157',\n  'frac38': '\\u215C',\n  'frac45': '\\u2158',\n  'frac56': '\\u215A',\n  'frac58': '\\u215D',\n  'frac78': '\\u215E',\n  'frasl': '\\u2044',\n  'frown': '\\u2322',\n  'sfrown': '\\u2322',\n  'fscr': '\\uD835\\uDCBB',\n  'gEl': '\\u2A8C',\n  'gtreqqless': '\\u2A8C',\n  'gacute': '\\u01F5',\n  'gamma': '\\u03B3',\n  'gap': '\\u2A86',\n  'gtrapprox': '\\u2A86',\n  'gbreve': '\\u011F',\n  'gcirc': '\\u011D',\n  'gcy': '\\u0433',\n  'gdot': '\\u0121',\n  'gescc': '\\u2AA9',\n  'gesdot': '\\u2A80',\n  'gesdoto': '\\u2A82',\n  'gesdotol': '\\u2A84',\n  'gesl': '\\u22DB\\uFE00',\n  'gesles': '\\u2A94',\n  'gfr': '\\uD835\\uDD24',\n  'gimel': '\\u2137',\n  'gjcy': '\\u0453',\n  'glE': '\\u2A92',\n  'gla': '\\u2AA5',\n  'glj': '\\u2AA4',\n  'gnE': '\\u2269',\n  'gneqq': '\\u2269',\n  'gnap': '\\u2A8A',\n  'gnapprox': '\\u2A8A',\n  'gne': '\\u2A88',\n  'gneq': '\\u2A88',\n  'gnsim': '\\u22E7',\n  'gopf': '\\uD835\\uDD58',\n  'gscr': '\\u210A',\n  'gsime': '\\u2A8E',\n  'gsiml': '\\u2A90',\n  'gtcc': '\\u2AA7',\n  'gtcir': '\\u2A7A',\n  'gtdot': '\\u22D7',\n  'gtrdot': '\\u22D7',\n  'gtlPar': '\\u2995',\n  'gtquest': '\\u2A7C',\n  'gtrarr': '\\u2978',\n  'gvertneqq': '\\u2269\\uFE00',\n  'gvnE': '\\u2269\\uFE00',\n  'hardcy': '\\u044A',\n  'harrcir': '\\u2948',\n  'harrw': '\\u21AD',\n  'leftrightsquigarrow': '\\u21AD',\n  'hbar': '\\u210F',\n  'hslash': '\\u210F',\n  'planck': '\\u210F',\n  'plankv': '\\u210F',\n  'hcirc': '\\u0125',\n  'hearts': '\\u2665',\n  'heartsuit': '\\u2665',\n  'hellip': '\\u2026',\n  'mldr': '\\u2026',\n  'hercon': '\\u22B9',\n  'hfr': '\\uD835\\uDD25',\n  'hksearow': '\\u2925',\n  'searhk': '\\u2925',\n  'hkswarow': '\\u2926',\n  'swarhk': '\\u2926',\n  'hoarr': '\\u21FF',\n  'homtht': '\\u223B',\n  'hookleftarrow': '\\u21A9',\n  'larrhk': '\\u21A9',\n  'hookrightarrow': '\\u21AA',\n  'rarrhk': '\\u21AA',\n  'hopf': '\\uD835\\uDD59',\n  'horbar': '\\u2015',\n  'hscr': '\\uD835\\uDCBD',\n  'hstrok': '\\u0127',\n  'hybull': '\\u2043',\n  'iacute': '\\u00ED',\n  'icirc': '\\u00EE',\n  'icy': '\\u0438',\n  'iecy': '\\u0435',\n  'iexcl': '\\u00A1',\n  'ifr': '\\uD835\\uDD26',\n  'igrave': '\\u00EC',\n  'iiiint': '\\u2A0C',\n  'qint': '\\u2A0C',\n  'iiint': '\\u222D',\n  'tint': '\\u222D',\n  'iinfin': '\\u29DC',\n  'iiota': '\\u2129',\n  'ijlig': '\\u0133',\n  'imacr': '\\u012B',\n  'imath': '\\u0131',\n  'inodot': '\\u0131',\n  'imof': '\\u22B7',\n  'imped': '\\u01B5',\n  'incare': '\\u2105',\n  'infin': '\\u221E',\n  'infintie': '\\u29DD',\n  'intcal': '\\u22BA',\n  'intercal': '\\u22BA',\n  'intlarhk': '\\u2A17',\n  'intprod': '\\u2A3C',\n  'iprod': '\\u2A3C',\n  'iocy': '\\u0451',\n  'iogon': '\\u012F',\n  'iopf': '\\uD835\\uDD5A',\n  'iota': '\\u03B9',\n  'iquest': '\\u00BF',\n  'iscr': '\\uD835\\uDCBE',\n  'isinE': '\\u22F9',\n  'isindot': '\\u22F5',\n  'isins': '\\u22F4',\n  'isinsv': '\\u22F3',\n  'itilde': '\\u0129',\n  'iukcy': '\\u0456',\n  'iuml': '\\u00EF',\n  'jcirc': '\\u0135',\n  'jcy': '\\u0439',\n  'jfr': '\\uD835\\uDD27',\n  'jmath': '\\u0237',\n  'jopf': '\\uD835\\uDD5B',\n  'jscr': '\\uD835\\uDCBF',\n  'jsercy': '\\u0458',\n  'jukcy': '\\u0454',\n  'kappa': '\\u03BA',\n  'kappav': '\\u03F0',\n  'varkappa': '\\u03F0',\n  'kcedil': '\\u0137',\n  'kcy': '\\u043A',\n  'kfr': '\\uD835\\uDD28',\n  'kgreen': '\\u0138',\n  'khcy': '\\u0445',\n  'kjcy': '\\u045C',\n  'kopf': '\\uD835\\uDD5C',\n  'kscr': '\\uD835\\uDCC0',\n  'lAtail': '\\u291B',\n  'lBarr': '\\u290E',\n  'lEg': '\\u2A8B',\n  'lesseqqgtr': '\\u2A8B',\n  'lHar': '\\u2962',\n  'lacute': '\\u013A',\n  'laemptyv': '\\u29B4',\n  'lambda': '\\u03BB',\n  'langd': '\\u2991',\n  'lap': '\\u2A85',\n  'lessapprox': '\\u2A85',\n  'laquo': '\\u00AB',\n  'larrbfs': '\\u291F',\n  'larrfs': '\\u291D',\n  'larrlp': '\\u21AB',\n  'looparrowleft': '\\u21AB',\n  'larrpl': '\\u2939',\n  'larrsim': '\\u2973',\n  'larrtl': '\\u21A2',\n  'leftarrowtail': '\\u21A2',\n  'lat': '\\u2AAB',\n  'latail': '\\u2919',\n  'late': '\\u2AAD',\n  'lates': '\\u2AAD\\uFE00',\n  'lbarr': '\\u290C',\n  'lbbrk': '\\u2772',\n  'lbrace': '\\u007B',\n  'lcub': '\\u007B',\n  'lbrack': '\\u005B',\n  'lsqb': '\\u005B',\n  'lbrke': '\\u298B',\n  'lbrksld': '\\u298F',\n  'lbrkslu': '\\u298D',\n  'lcaron': '\\u013E',\n  'lcedil': '\\u013C',\n  'lcy': '\\u043B',\n  'ldca': '\\u2936',\n  'ldrdhar': '\\u2967',\n  'ldrushar': '\\u294B',\n  'ldsh': '\\u21B2',\n  'le': '\\u2264',\n  'leq': '\\u2264',\n  'leftleftarrows': '\\u21C7',\n  'llarr': '\\u21C7',\n  'leftthreetimes': '\\u22CB',\n  'lthree': '\\u22CB',\n  'lescc': '\\u2AA8',\n  'lesdot': '\\u2A7F',\n  'lesdoto': '\\u2A81',\n  'lesdotor': '\\u2A83',\n  'lesg': '\\u22DA\\uFE00',\n  'lesges': '\\u2A93',\n  'lessdot': '\\u22D6',\n  'ltdot': '\\u22D6',\n  'lfisht': '\\u297C',\n  'lfr': '\\uD835\\uDD29',\n  'lgE': '\\u2A91',\n  'lharul': '\\u296A',\n  'lhblk': '\\u2584',\n  'ljcy': '\\u0459',\n  'llhard': '\\u296B',\n  'lltri': '\\u25FA',\n  'lmidot': '\\u0140',\n  'lmoust': '\\u23B0',\n  'lmoustache': '\\u23B0',\n  'lnE': '\\u2268',\n  'lneqq': '\\u2268',\n  'lnap': '\\u2A89',\n  'lnapprox': '\\u2A89',\n  'lne': '\\u2A87',\n  'lneq': '\\u2A87',\n  'lnsim': '\\u22E6',\n  'loang': '\\u27EC',\n  'loarr': '\\u21FD',\n  'longmapsto': '\\u27FC',\n  'xmap': '\\u27FC',\n  'looparrowright': '\\u21AC',\n  'rarrlp': '\\u21AC',\n  'lopar': '\\u2985',\n  'lopf': '\\uD835\\uDD5D',\n  'loplus': '\\u2A2D',\n  'lotimes': '\\u2A34',\n  'lowast': '\\u2217',\n  'loz': '\\u25CA',\n  'lozenge': '\\u25CA',\n  'lpar': '\\u0028',\n  'lparlt': '\\u2993',\n  'lrhard': '\\u296D',\n  'lrm': '\\u200E',\n  'lrtri': '\\u22BF',\n  'lsaquo': '\\u2039',\n  'lscr': '\\uD835\\uDCC1',\n  'lsime': '\\u2A8D',\n  'lsimg': '\\u2A8F',\n  'lsquor': '\\u201A',\n  'sbquo': '\\u201A',\n  'lstrok': '\\u0142',\n  'ltcc': '\\u2AA6',\n  'ltcir': '\\u2A79',\n  'ltimes': '\\u22C9',\n  'ltlarr': '\\u2976',\n  'ltquest': '\\u2A7B',\n  'ltrPar': '\\u2996',\n  'ltri': '\\u25C3',\n  'triangleleft': '\\u25C3',\n  'lurdshar': '\\u294A',\n  'luruhar': '\\u2966',\n  'lvertneqq': '\\u2268\\uFE00',\n  'lvnE': '\\u2268\\uFE00',\n  'mDDot': '\\u223A',\n  'macr': '\\u00AF',\n  'strns': '\\u00AF',\n  'male': '\\u2642',\n  'malt': '\\u2720',\n  'maltese': '\\u2720',\n  'marker': '\\u25AE',\n  'mcomma': '\\u2A29',\n  'mcy': '\\u043C',\n  'mdash': '\\u2014',\n  'mfr': '\\uD835\\uDD2A',\n  'mho': '\\u2127',\n  'micro': '\\u00B5',\n  'midcir': '\\u2AF0',\n  'minus': '\\u2212',\n  'minusdu': '\\u2A2A',\n  'mlcp': '\\u2ADB',\n  'models': '\\u22A7',\n  'mopf': '\\uD835\\uDD5E',\n  'mscr': '\\uD835\\uDCC2',\n  'mu': '\\u03BC',\n  'multimap': '\\u22B8',\n  'mumap': '\\u22B8',\n  'nGg': '\\u22D9\\u0338',\n  'nGt': '\\u226B\\u20D2',\n  'nLeftarrow': '\\u21CD',\n  'nlArr': '\\u21CD',\n  'nLeftrightarrow': '\\u21CE',\n  'nhArr': '\\u21CE',\n  'nLl': '\\u22D8\\u0338',\n  'nLt': '\\u226A\\u20D2',\n  'nRightarrow': '\\u21CF',\n  'nrArr': '\\u21CF',\n  'nVDash': '\\u22AF',\n  'nVdash': '\\u22AE',\n  'nacute': '\\u0144',\n  'nang': '\\u2220\\u20D2',\n  'napE': '\\u2A70\\u0338',\n  'napid': '\\u224B\\u0338',\n  'napos': '\\u0149',\n  'natur': '\\u266E',\n  'natural': '\\u266E',\n  'ncap': '\\u2A43',\n  'ncaron': '\\u0148',\n  'ncedil': '\\u0146',\n  'ncongdot': '\\u2A6D\\u0338',\n  'ncup': '\\u2A42',\n  'ncy': '\\u043D',\n  'ndash': '\\u2013',\n  'neArr': '\\u21D7',\n  'nearhk': '\\u2924',\n  'nedot': '\\u2250\\u0338',\n  'nesear': '\\u2928',\n  'toea': '\\u2928',\n  'nfr': '\\uD835\\uDD2B',\n  'nharr': '\\u21AE',\n  'nleftrightarrow': '\\u21AE',\n  'nhpar': '\\u2AF2',\n  'nis': '\\u22FC',\n  'nisd': '\\u22FA',\n  'njcy': '\\u045A',\n  'nlE': '\\u2266\\u0338',\n  'nleqq': '\\u2266\\u0338',\n  'nlarr': '\\u219A',\n  'nleftarrow': '\\u219A',\n  'nldr': '\\u2025',\n  'nopf': '\\uD835\\uDD5F',\n  'not': '\\u00AC',\n  'notinE': '\\u22F9\\u0338',\n  'notindot': '\\u22F5\\u0338',\n  'notinvb': '\\u22F7',\n  'notinvc': '\\u22F6',\n  'notnivb': '\\u22FE',\n  'notnivc': '\\u22FD',\n  'nparsl': '\\u2AFD\\u20E5',\n  'npart': '\\u2202\\u0338',\n  'npolint': '\\u2A14',\n  'nrarr': '\\u219B',\n  'nrightarrow': '\\u219B',\n  'nrarrc': '\\u2933\\u0338',\n  'nrarrw': '\\u219D\\u0338',\n  'nscr': '\\uD835\\uDCC3',\n  'nsub': '\\u2284',\n  'nsubE': '\\u2AC5\\u0338',\n  'nsubseteqq': '\\u2AC5\\u0338',\n  'nsup': '\\u2285',\n  'nsupE': '\\u2AC6\\u0338',\n  'nsupseteqq': '\\u2AC6\\u0338',\n  'ntilde': '\\u00F1',\n  'nu': '\\u03BD',\n  'num': '\\u0023',\n  'numero': '\\u2116',\n  'numsp': '\\u2007',\n  'nvDash': '\\u22AD',\n  'nvHarr': '\\u2904',\n  'nvap': '\\u224D\\u20D2',\n  'nvdash': '\\u22AC',\n  'nvge': '\\u2265\\u20D2',\n  'nvgt': '\\u003E\\u20D2',\n  'nvinfin': '\\u29DE',\n  'nvlArr': '\\u2902',\n  'nvle': '\\u2264\\u20D2',\n  'nvlt': '\\u003C\\u20D2',\n  'nvltrie': '\\u22B4\\u20D2',\n  'nvrArr': '\\u2903',\n  'nvrtrie': '\\u22B5\\u20D2',\n  'nvsim': '\\u223C\\u20D2',\n  'nwArr': '\\u21D6',\n  'nwarhk': '\\u2923',\n  'nwnear': '\\u2927',\n  'oacute': '\\u00F3',\n  'ocirc': '\\u00F4',\n  'ocy': '\\u043E',\n  'odblac': '\\u0151',\n  'odiv': '\\u2A38',\n  'odsold': '\\u29BC',\n  'oelig': '\\u0153',\n  'ofcir': '\\u29BF',\n  'ofr': '\\uD835\\uDD2C',\n  'ogon': '\\u02DB',\n  'ograve': '\\u00F2',\n  'ogt': '\\u29C1',\n  'ohbar': '\\u29B5',\n  'olcir': '\\u29BE',\n  'olcross': '\\u29BB',\n  'olt': '\\u29C0',\n  'omacr': '\\u014D',\n  'omega': '\\u03C9',\n  'omicron': '\\u03BF',\n  'omid': '\\u29B6',\n  'oopf': '\\uD835\\uDD60',\n  'opar': '\\u29B7',\n  'operp': '\\u29B9',\n  'or': '\\u2228',\n  'vee': '\\u2228',\n  'ord': '\\u2A5D',\n  'order': '\\u2134',\n  'orderof': '\\u2134',\n  'oscr': '\\u2134',\n  'ordf': '\\u00AA',\n  'ordm': '\\u00BA',\n  'origof': '\\u22B6',\n  'oror': '\\u2A56',\n  'orslope': '\\u2A57',\n  'orv': '\\u2A5B',\n  'oslash': '\\u00F8',\n  'osol': '\\u2298',\n  'otilde': '\\u00F5',\n  'otimesas': '\\u2A36',\n  'ouml': '\\u00F6',\n  'ovbar': '\\u233D',\n  'para': '\\u00B6',\n  'parsim': '\\u2AF3',\n  'parsl': '\\u2AFD',\n  'pcy': '\\u043F',\n  'percnt': '\\u0025',\n  'period': '\\u002E',\n  'permil': '\\u2030',\n  'pertenk': '\\u2031',\n  'pfr': '\\uD835\\uDD2D',\n  'phi': '\\u03C6',\n  'phiv': '\\u03D5',\n  'straightphi': '\\u03D5',\n  'varphi': '\\u03D5',\n  'phone': '\\u260E',\n  'pi': '\\u03C0',\n  'piv': '\\u03D6',\n  'varpi': '\\u03D6',\n  'planckh': '\\u210E',\n  'plus': '\\u002B',\n  'plusacir': '\\u2A23',\n  'pluscir': '\\u2A22',\n  'plusdu': '\\u2A25',\n  'pluse': '\\u2A72',\n  'plussim': '\\u2A26',\n  'plustwo': '\\u2A27',\n  'pointint': '\\u2A15',\n  'popf': '\\uD835\\uDD61',\n  'pound': '\\u00A3',\n  'prE': '\\u2AB3',\n  'prap': '\\u2AB7',\n  'precapprox': '\\u2AB7',\n  'precnapprox': '\\u2AB9',\n  'prnap': '\\u2AB9',\n  'precneqq': '\\u2AB5',\n  'prnE': '\\u2AB5',\n  'precnsim': '\\u22E8',\n  'prnsim': '\\u22E8',\n  'prime': '\\u2032',\n  'profalar': '\\u232E',\n  'profline': '\\u2312',\n  'profsurf': '\\u2313',\n  'prurel': '\\u22B0',\n  'pscr': '\\uD835\\uDCC5',\n  'psi': '\\u03C8',\n  'puncsp': '\\u2008',\n  'qfr': '\\uD835\\uDD2E',\n  'qopf': '\\uD835\\uDD62',\n  'qprime': '\\u2057',\n  'qscr': '\\uD835\\uDCC6',\n  'quatint': '\\u2A16',\n  'quest': '\\u003F',\n  'rAtail': '\\u291C',\n  'rHar': '\\u2964',\n  'race': '\\u223D\\u0331',\n  'racute': '\\u0155',\n  'raemptyv': '\\u29B3',\n  'rangd': '\\u2992',\n  'range': '\\u29A5',\n  'raquo': '\\u00BB',\n  'rarrap': '\\u2975',\n  'rarrbfs': '\\u2920',\n  'rarrc': '\\u2933',\n  'rarrfs': '\\u291E',\n  'rarrpl': '\\u2945',\n  'rarrsim': '\\u2974',\n  'rarrtl': '\\u21A3',\n  'rightarrowtail': '\\u21A3',\n  'rarrw': '\\u219D',\n  'rightsquigarrow': '\\u219D',\n  'ratail': '\\u291A',\n  'ratio': '\\u2236',\n  'rbbrk': '\\u2773',\n  'rbrace': '\\u007D',\n  'rcub': '\\u007D',\n  'rbrack': '\\u005D',\n  'rsqb': '\\u005D',\n  'rbrke': '\\u298C',\n  'rbrksld': '\\u298E',\n  'rbrkslu': '\\u2990',\n  'rcaron': '\\u0159',\n  'rcedil': '\\u0157',\n  'rcy': '\\u0440',\n  'rdca': '\\u2937',\n  'rdldhar': '\\u2969',\n  'rdsh': '\\u21B3',\n  'rect': '\\u25AD',\n  'rfisht': '\\u297D',\n  'rfr': '\\uD835\\uDD2F',\n  'rharul': '\\u296C',\n  'rho': '\\u03C1',\n  'rhov': '\\u03F1',\n  'varrho': '\\u03F1',\n  'rightrightarrows': '\\u21C9',\n  'rrarr': '\\u21C9',\n  'rightthreetimes': '\\u22CC',\n  'rthree': '\\u22CC',\n  'ring': '\\u02DA',\n  'rlm': '\\u200F',\n  'rmoust': '\\u23B1',\n  'rmoustache': '\\u23B1',\n  'rnmid': '\\u2AEE',\n  'roang': '\\u27ED',\n  'roarr': '\\u21FE',\n  'ropar': '\\u2986',\n  'ropf': '\\uD835\\uDD63',\n  'roplus': '\\u2A2E',\n  'rotimes': '\\u2A35',\n  'rpar': '\\u0029',\n  'rpargt': '\\u2994',\n  'rppolint': '\\u2A12',\n  'rsaquo': '\\u203A',\n  'rscr': '\\uD835\\uDCC7',\n  'rtimes': '\\u22CA',\n  'rtri': '\\u25B9',\n  'triangleright': '\\u25B9',\n  'rtriltri': '\\u29CE',\n  'ruluhar': '\\u2968',\n  'rx': '\\u211E',\n  'sacute': '\\u015B',\n  'scE': '\\u2AB4',\n  'scap': '\\u2AB8',\n  'succapprox': '\\u2AB8',\n  'scaron': '\\u0161',\n  'scedil': '\\u015F',\n  'scirc': '\\u015D',\n  'scnE': '\\u2AB6',\n  'succneqq': '\\u2AB6',\n  'scnap': '\\u2ABA',\n  'succnapprox': '\\u2ABA',\n  'scnsim': '\\u22E9',\n  'succnsim': '\\u22E9',\n  'scpolint': '\\u2A13',\n  'scy': '\\u0441',\n  'sdot': '\\u22C5',\n  'sdote': '\\u2A66',\n  'seArr': '\\u21D8',\n  'sect': '\\u00A7',\n  'semi': '\\u003B',\n  'seswar': '\\u2929',\n  'tosa': '\\u2929',\n  'sext': '\\u2736',\n  'sfr': '\\uD835\\uDD30',\n  'sharp': '\\u266F',\n  'shchcy': '\\u0449',\n  'shcy': '\\u0448',\n  'shy': '\\u00AD',\n  'sigma': '\\u03C3',\n  'sigmaf': '\\u03C2',\n  'sigmav': '\\u03C2',\n  'varsigma': '\\u03C2',\n  'simdot': '\\u2A6A',\n  'simg': '\\u2A9E',\n  'simgE': '\\u2AA0',\n  'siml': '\\u2A9D',\n  'simlE': '\\u2A9F',\n  'simne': '\\u2246',\n  'simplus': '\\u2A24',\n  'simrarr': '\\u2972',\n  'smashp': '\\u2A33',\n  'smeparsl': '\\u29E4',\n  'smile': '\\u2323',\n  'ssmile': '\\u2323',\n  'smt': '\\u2AAA',\n  'smte': '\\u2AAC',\n  'smtes': '\\u2AAC\\uFE00',\n  'softcy': '\\u044C',\n  'sol': '\\u002F',\n  'solb': '\\u29C4',\n  'solbar': '\\u233F',\n  'sopf': '\\uD835\\uDD64',\n  'spades': '\\u2660',\n  'spadesuit': '\\u2660',\n  'sqcaps': '\\u2293\\uFE00',\n  'sqcups': '\\u2294\\uFE00',\n  'sscr': '\\uD835\\uDCC8',\n  'star': '\\u2606',\n  'sub': '\\u2282',\n  'subset': '\\u2282',\n  'subE': '\\u2AC5',\n  'subseteqq': '\\u2AC5',\n  'subdot': '\\u2ABD',\n  'subedot': '\\u2AC3',\n  'submult': '\\u2AC1',\n  'subnE': '\\u2ACB',\n  'subsetneqq': '\\u2ACB',\n  'subne': '\\u228A',\n  'subsetneq': '\\u228A',\n  'subplus': '\\u2ABF',\n  'subrarr': '\\u2979',\n  'subsim': '\\u2AC7',\n  'subsub': '\\u2AD5',\n  'subsup': '\\u2AD3',\n  'sung': '\\u266A',\n  'sup1': '\\u00B9',\n  'sup2': '\\u00B2',\n  'sup3': '\\u00B3',\n  'supE': '\\u2AC6',\n  'supseteqq': '\\u2AC6',\n  'supdot': '\\u2ABE',\n  'supdsub': '\\u2AD8',\n  'supedot': '\\u2AC4',\n  'suphsol': '\\u27C9',\n  'suphsub': '\\u2AD7',\n  'suplarr': '\\u297B',\n  'supmult': '\\u2AC2',\n  'supnE': '\\u2ACC',\n  'supsetneqq': '\\u2ACC',\n  'supne': '\\u228B',\n  'supsetneq': '\\u228B',\n  'supplus': '\\u2AC0',\n  'supsim': '\\u2AC8',\n  'supsub': '\\u2AD4',\n  'supsup': '\\u2AD6',\n  'swArr': '\\u21D9',\n  'swnwar': '\\u292A',\n  'szlig': '\\u00DF',\n  'target': '\\u2316',\n  'tau': '\\u03C4',\n  'tcaron': '\\u0165',\n  'tcedil': '\\u0163',\n  'tcy': '\\u0442',\n  'telrec': '\\u2315',\n  'tfr': '\\uD835\\uDD31',\n  'theta': '\\u03B8',\n  'thetasym': '\\u03D1',\n  'thetav': '\\u03D1',\n  'vartheta': '\\u03D1',\n  'thorn': '\\u00FE',\n  'times': '\\u00D7',\n  'timesbar': '\\u2A31',\n  'timesd': '\\u2A30',\n  'topbot': '\\u2336',\n  'topcir': '\\u2AF1',\n  'topf': '\\uD835\\uDD65',\n  'topfork': '\\u2ADA',\n  'tprime': '\\u2034',\n  'triangle': '\\u25B5',\n  'utri': '\\u25B5',\n  'triangleq': '\\u225C',\n  'trie': '\\u225C',\n  'tridot': '\\u25EC',\n  'triminus': '\\u2A3A',\n  'triplus': '\\u2A39',\n  'trisb': '\\u29CD',\n  'tritime': '\\u2A3B',\n  'trpezium': '\\u23E2',\n  'tscr': '\\uD835\\uDCC9',\n  'tscy': '\\u0446',\n  'tshcy': '\\u045B',\n  'tstrok': '\\u0167',\n  'uHar': '\\u2963',\n  'uacute': '\\u00FA',\n  'ubrcy': '\\u045E',\n  'ubreve': '\\u016D',\n  'ucirc': '\\u00FB',\n  'ucy': '\\u0443',\n  'udblac': '\\u0171',\n  'ufisht': '\\u297E',\n  'ufr': '\\uD835\\uDD32',\n  'ugrave': '\\u00F9',\n  'uhblk': '\\u2580',\n  'ulcorn': '\\u231C',\n  'ulcorner': '\\u231C',\n  'ulcrop': '\\u230F',\n  'ultri': '\\u25F8',\n  'umacr': '\\u016B',\n  'uogon': '\\u0173',\n  'uopf': '\\uD835\\uDD66',\n  'upsi': '\\u03C5',\n  'upsilon': '\\u03C5',\n  'upuparrows': '\\u21C8',\n  'uuarr': '\\u21C8',\n  'urcorn': '\\u231D',\n  'urcorner': '\\u231D',\n  'urcrop': '\\u230E',\n  'uring': '\\u016F',\n  'urtri': '\\u25F9',\n  'uscr': '\\uD835\\uDCCA',\n  'utdot': '\\u22F0',\n  'utilde': '\\u0169',\n  'uuml': '\\u00FC',\n  'uwangle': '\\u29A7',\n  'vBar': '\\u2AE8',\n  'vBarv': '\\u2AE9',\n  'vangrt': '\\u299C',\n  'varsubsetneq': '\\u228A\\uFE00',\n  'vsubne': '\\u228A\\uFE00',\n  'varsubsetneqq': '\\u2ACB\\uFE00',\n  'vsubnE': '\\u2ACB\\uFE00',\n  'varsupsetneq': '\\u228B\\uFE00',\n  'vsupne': '\\u228B\\uFE00',\n  'varsupsetneqq': '\\u2ACC\\uFE00',\n  'vsupnE': '\\u2ACC\\uFE00',\n  'vcy': '\\u0432',\n  'veebar': '\\u22BB',\n  'veeeq': '\\u225A',\n  'vellip': '\\u22EE',\n  'vfr': '\\uD835\\uDD33',\n  'vopf': '\\uD835\\uDD67',\n  'vscr': '\\uD835\\uDCCB',\n  'vzigzag': '\\u299A',\n  'wcirc': '\\u0175',\n  'wedbar': '\\u2A5F',\n  'wedgeq': '\\u2259',\n  'weierp': '\\u2118',\n  'wp': '\\u2118',\n  'wfr': '\\uD835\\uDD34',\n  'wopf': '\\uD835\\uDD68',\n  'wscr': '\\uD835\\uDCCC',\n  'xfr': '\\uD835\\uDD35',\n  'xi': '\\u03BE',\n  'xnis': '\\u22FB',\n  'xopf': '\\uD835\\uDD69',\n  'xscr': '\\uD835\\uDCCD',\n  'yacute': '\\u00FD',\n  'yacy': '\\u044F',\n  'ycirc': '\\u0177',\n  'ycy': '\\u044B',\n  'yen': '\\u00A5',\n  'yfr': '\\uD835\\uDD36',\n  'yicy': '\\u0457',\n  'yopf': '\\uD835\\uDD6A',\n  'yscr': '\\uD835\\uDCCE',\n  'yucy': '\\u044E',\n  'yuml': '\\u00FF',\n  'zacute': '\\u017A',\n  'zcaron': '\\u017E',\n  'zcy': '\\u0437',\n  'zdot': '\\u017C',\n  'zeta': '\\u03B6',\n  'zfr': '\\uD835\\uDD37',\n  'zhcy': '\\u0436',\n  'zigrarr': '\\u21DD',\n  'zopf': '\\uD835\\uDD6B',\n  'zscr': '\\uD835\\uDCCF',\n  'zwj': '\\u200D',\n  'zwnj': '\\u200C',\n};\n\n// The &ngsp; pseudo-entity is denoting a space.\n// 0xE500 is a PUA (Private Use Areas) unicode character\n// This is inspired by the Angular Dart implementation.\nexport const NGSP_UNICODE = '\\uE500';\n\nNAMED_ENTITIES['ngsp'] = NGSP_UNICODE;\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as chars from '../chars';\nimport {ParseError, ParseLocation, ParseSourceFile, ParseSourceSpan} from '../parse_util';\n\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from './defaults';\nimport {NAMED_ENTITIES} from './entities';\nimport {TagContentType, TagDefinition} from './tags';\nimport {\n  ComponentOpenStartToken,\n  IncompleteComponentOpenToken,\n  IncompleteTagOpenToken,\n  TagOpenStartToken,\n  Token,\n  TokenType,\n} from './tokens';\n\nexport class TokenizeResult {\n  constructor(\n    public tokens: Token[],\n    public errors: ParseError[],\n    public nonNormalizedIcuExpressions: Token[],\n  ) {}\n}\n\nexport interface LexerRange {\n  startPos: number;\n  startLine: number;\n  startCol: number;\n  endPos: number;\n}\n\n/**\n * Options that modify how the text is tokenized.\n */\nexport interface TokenizeOptions {\n  /** Whether to tokenize ICU messages (considered as text nodes when false). */\n  tokenizeExpansionForms?: boolean;\n  /** How to tokenize interpolation markers. */\n  interpolationConfig?: InterpolationConfig;\n  /**\n   * The start and end point of the text to parse within the `source` string.\n   * The entire `source` string is parsed if this is not provided.\n   * */\n  range?: LexerRange;\n  /**\n   * If this text is stored in a JavaScript string, then we have to deal with escape sequences.\n   *\n   * **Example 1:**\n   *\n   * ```\n   * \"abc\\\"def\\nghi\"\n   * ```\n   *\n   * - The `\\\"` must be converted to `\"`.\n   * - The `\\n` must be converted to a new line character in a token,\n   *   but it should not increment the current line for source mapping.\n   *\n   * **Example 2:**\n   *\n   * ```\n   * \"abc\\\n   *  def\"\n   * ```\n   *\n   * The line continuation (`\\` followed by a newline) should be removed from a token\n   * but the new line should increment the current line for source mapping.\n   */\n  escapedString?: boolean;\n  /**\n   * If this text is stored in an external template (e.g. via `templateUrl`) then we need to decide\n   * whether or not to normalize the line-endings (from `\\r\\n` to `\\n`) when processing ICU\n   * expressions.\n   *\n   * If `true` then we will normalize ICU expression line endings.\n   * The default is `false`, but this will be switched in a future major release.\n   */\n  i18nNormalizeLineEndingsInICUs?: boolean;\n  /**\n   * An array of characters that should be considered as leading trivia.\n   * Leading trivia are characters that are not important to the developer, and so should not be\n   * included in source-map segments.  A common example is whitespace.\n   */\n  leadingTriviaChars?: string[];\n  /**\n   * If true, do not convert CRLF to LF.\n   */\n  preserveLineEndings?: boolean;\n\n  /**\n   * Whether to tokenize @ block syntax. Otherwise considered text,\n   * or ICU tokens if `tokenizeExpansionForms` is enabled.\n   */\n  tokenizeBlocks?: boolean;\n\n  /**\n   * Whether to tokenize the `@let` syntax. Otherwise will be considered either\n   * text or an incomplete block, depending on whether `tokenizeBlocks` is enabled.\n   */\n  tokenizeLet?: boolean;\n\n  /** Whether the selectorless syntax is enabled. */\n  selectorlessEnabled?: boolean;\n}\n\nexport function tokenize(\n  source: string,\n  url: string,\n  getTagDefinition: (tagName: string) => TagDefinition,\n  options: TokenizeOptions = {},\n): TokenizeResult {\n  const tokenizer = new _Tokenizer(new ParseSourceFile(source, url), getTagDefinition, options);\n  tokenizer.tokenize();\n  return new TokenizeResult(\n    mergeTextTokens(tokenizer.tokens),\n    tokenizer.errors,\n    tokenizer.nonNormalizedIcuExpressions,\n  );\n}\n\nconst _CR_OR_CRLF_REGEXP = /\\r\\n?/g;\n\nfunction _unexpectedCharacterErrorMsg(charCode: number): string {\n  const char = charCode === chars.$EOF ? 'EOF' : String.fromCharCode(charCode);\n  return `Unexpected character \"${char}\"`;\n}\n\nfunction _unknownEntityErrorMsg(entitySrc: string): string {\n  return `Unknown entity \"${entitySrc}\" - use the \"&#<decimal>;\" or  \"&#x<hex>;\" syntax`;\n}\n\nfunction _unparsableEntityErrorMsg(type: CharacterReferenceType, entityStr: string): string {\n  return `Unable to parse entity \"${entityStr}\" - ${type} character reference entities must end with \";\"`;\n}\n\nenum CharacterReferenceType {\n  HEX = 'hexadecimal',\n  DEC = 'decimal',\n}\n\nconst SUPPORTED_BLOCKS = [\n  '@if',\n  '@else', // Covers `@else if` as well\n  '@for',\n  '@switch',\n  '@case',\n  '@default',\n  '@empty',\n  '@defer',\n  '@placeholder',\n  '@loading',\n  '@error',\n];\n\n// See https://www.w3.org/TR/html51/syntax.html#writing-html-documents\nclass _Tokenizer {\n  private _cursor: CharacterCursor;\n  private _tokenizeIcu: boolean;\n  private _interpolationConfig: InterpolationConfig;\n  private _leadingTriviaCodePoints: number[] | undefined;\n  private _currentTokenStart: CharacterCursor | null = null;\n  private _currentTokenType: TokenType | null = null;\n  private _expansionCaseStack: TokenType[] = [];\n  private _openDirectiveCount = 0;\n  private _inInterpolation: boolean = false;\n  private readonly _preserveLineEndings: boolean;\n  private readonly _i18nNormalizeLineEndingsInICUs: boolean;\n  private readonly _tokenizeBlocks: boolean;\n  private readonly _tokenizeLet: boolean;\n  private readonly _selectorlessEnabled: boolean;\n  tokens: Token[] = [];\n  errors: ParseError[] = [];\n  nonNormalizedIcuExpressions: Token[] = [];\n\n  /**\n   * @param _file The html source file being tokenized.\n   * @param _getTagDefinition A function that will retrieve a tag definition for a given tag name.\n   * @param options Configuration of the tokenization.\n   */\n  constructor(\n    _file: ParseSourceFile,\n    private _getTagDefinition: (tagName: string) => TagDefinition,\n    options: TokenizeOptions,\n  ) {\n    this._tokenizeIcu = options.tokenizeExpansionForms || false;\n    this._interpolationConfig = options.interpolationConfig || DEFAULT_INTERPOLATION_CONFIG;\n    this._leadingTriviaCodePoints =\n      options.leadingTriviaChars && options.leadingTriviaChars.map((c) => c.codePointAt(0) || 0);\n    const range = options.range || {\n      endPos: _file.content.length,\n      startPos: 0,\n      startLine: 0,\n      startCol: 0,\n    };\n    this._cursor = options.escapedString\n      ? new EscapedCharacterCursor(_file, range)\n      : new PlainCharacterCursor(_file, range);\n    this._preserveLineEndings = options.preserveLineEndings || false;\n    this._i18nNormalizeLineEndingsInICUs = options.i18nNormalizeLineEndingsInICUs || false;\n    this._tokenizeBlocks = options.tokenizeBlocks ?? true;\n    this._tokenizeLet = options.tokenizeLet ?? true;\n    this._selectorlessEnabled = options.selectorlessEnabled ?? false;\n    try {\n      this._cursor.init();\n    } catch (e) {\n      this.handleError(e);\n    }\n  }\n\n  private _processCarriageReturns(content: string): string {\n    if (this._preserveLineEndings) {\n      return content;\n    }\n    // https://www.w3.org/TR/html51/syntax.html#preprocessing-the-input-stream\n    // In order to keep the original position in the source, we can not\n    // pre-process it.\n    // Instead CRs are processed right before instantiating the tokens.\n    return content.replace(_CR_OR_CRLF_REGEXP, '\\n');\n  }\n\n  tokenize(): void {\n    while (this._cursor.peek() !== chars.$EOF) {\n      const start = this._cursor.clone();\n      try {\n        if (this._attemptCharCode(chars.$LT)) {\n          if (this._attemptCharCode(chars.$BANG)) {\n            if (this._attemptCharCode(chars.$LBRACKET)) {\n              this._consumeCdata(start);\n            } else if (this._attemptCharCode(chars.$MINUS)) {\n              this._consumeComment(start);\n            } else {\n              this._consumeDocType(start);\n            }\n          } else if (this._attemptCharCode(chars.$SLASH)) {\n            this._consumeTagClose(start);\n          } else {\n            this._consumeTagOpen(start);\n          }\n        } else if (\n          this._tokenizeLet &&\n          // Use `peek` instead of `attempCharCode` since we\n          // don't want to advance in case it's not `@let`.\n          this._cursor.peek() === chars.$AT &&\n          !this._inInterpolation &&\n          this._isLetStart()\n        ) {\n          this._consumeLetDeclaration(start);\n        } else if (this._tokenizeBlocks && this._isBlockStart()) {\n          this._consumeBlockStart(start);\n        } else if (\n          this._tokenizeBlocks &&\n          !this._inInterpolation &&\n          !this._isInExpansionCase() &&\n          !this._isInExpansionForm() &&\n          this._attemptCharCode(chars.$RBRACE)\n        ) {\n          this._consumeBlockEnd(start);\n        } else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {\n          // In (possibly interpolated) text the end of the text is given by `isTextEnd()`, while\n          // the premature end of an interpolation is given by the start of a new HTML element.\n          this._consumeWithInterpolation(\n            TokenType.TEXT,\n            TokenType.INTERPOLATION,\n            () => this._isTextEnd(),\n            () => this._isTagStart(),\n          );\n        }\n      } catch (e) {\n        this.handleError(e);\n      }\n    }\n    this._beginToken(TokenType.EOF);\n    this._endToken([]);\n  }\n\n  private _getBlockName(): string {\n    // This allows us to capture up something like `@else if`, but not `@ if`.\n    let spacesInNameAllowed = false;\n    const nameCursor = this._cursor.clone();\n\n    this._attemptCharCodeUntilFn((code) => {\n      if (chars.isWhitespace(code)) {\n        return !spacesInNameAllowed;\n      }\n      if (isBlockNameChar(code)) {\n        spacesInNameAllowed = true;\n        return false;\n      }\n      return true;\n    });\n    return this._cursor.getChars(nameCursor).trim();\n  }\n\n  private _consumeBlockStart(start: CharacterCursor) {\n    this._requireCharCode(chars.$AT);\n    this._beginToken(TokenType.BLOCK_OPEN_START, start);\n    const startToken = this._endToken([this._getBlockName()]);\n\n    if (this._cursor.peek() === chars.$LPAREN) {\n      // Advance past the opening paren.\n      this._cursor.advance();\n      // Capture the parameters.\n      this._consumeBlockParameters();\n      // Allow spaces before the closing paren.\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n\n      if (this._attemptCharCode(chars.$RPAREN)) {\n        // Allow spaces after the paren.\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n      } else {\n        startToken.type = TokenType.INCOMPLETE_BLOCK_OPEN;\n        return;\n      }\n    }\n\n    if (this._attemptCharCode(chars.$LBRACE)) {\n      this._beginToken(TokenType.BLOCK_OPEN_END);\n      this._endToken([]);\n    } else {\n      startToken.type = TokenType.INCOMPLETE_BLOCK_OPEN;\n    }\n  }\n\n  private _consumeBlockEnd(start: CharacterCursor) {\n    this._beginToken(TokenType.BLOCK_CLOSE, start);\n    this._endToken([]);\n  }\n\n  private _consumeBlockParameters() {\n    // Trim the whitespace until the first parameter.\n    this._attemptCharCodeUntilFn(isBlockParameterChar);\n\n    while (this._cursor.peek() !== chars.$RPAREN && this._cursor.peek() !== chars.$EOF) {\n      this._beginToken(TokenType.BLOCK_PARAMETER);\n      const start = this._cursor.clone();\n      let inQuote: number | null = null;\n      let openParens = 0;\n\n      // Consume the parameter until the next semicolon or brace.\n      // Note that we skip over semicolons/braces inside of strings.\n      while (\n        (this._cursor.peek() !== chars.$SEMICOLON && this._cursor.peek() !== chars.$EOF) ||\n        inQuote !== null\n      ) {\n        const char = this._cursor.peek();\n\n        // Skip to the next character if it was escaped.\n        if (char === chars.$BACKSLASH) {\n          this._cursor.advance();\n        } else if (char === inQuote) {\n          inQuote = null;\n        } else if (inQuote === null && chars.isQuote(char)) {\n          inQuote = char;\n        } else if (char === chars.$LPAREN && inQuote === null) {\n          openParens++;\n        } else if (char === chars.$RPAREN && inQuote === null) {\n          if (openParens === 0) {\n            break;\n          } else if (openParens > 0) {\n            openParens--;\n          }\n        }\n\n        this._cursor.advance();\n      }\n\n      this._endToken([this._cursor.getChars(start)]);\n\n      // Skip to the next parameter.\n      this._attemptCharCodeUntilFn(isBlockParameterChar);\n    }\n  }\n\n  private _consumeLetDeclaration(start: CharacterCursor) {\n    this._requireStr('@let');\n    this._beginToken(TokenType.LET_START, start);\n\n    // Require at least one white space after the `@let`.\n    if (chars.isWhitespace(this._cursor.peek())) {\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n    } else {\n      const token = this._endToken([this._cursor.getChars(start)]);\n      token.type = TokenType.INCOMPLETE_LET;\n      return;\n    }\n\n    const startToken = this._endToken([this._getLetDeclarationName()]);\n\n    // Skip over white space before the equals character.\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    // Expect an equals sign.\n    if (!this._attemptCharCode(chars.$EQ)) {\n      startToken.type = TokenType.INCOMPLETE_LET;\n      return;\n    }\n\n    // Skip spaces after the equals.\n    this._attemptCharCodeUntilFn((code) => isNotWhitespace(code) && !chars.isNewLine(code));\n    this._consumeLetDeclarationValue();\n\n    // Terminate the `@let` with a semicolon.\n    const endChar = this._cursor.peek();\n    if (endChar === chars.$SEMICOLON) {\n      this._beginToken(TokenType.LET_END);\n      this._endToken([]);\n      this._cursor.advance();\n    } else {\n      startToken.type = TokenType.INCOMPLETE_LET;\n      startToken.sourceSpan = this._cursor.getSpan(start);\n    }\n  }\n\n  private _getLetDeclarationName(): string {\n    const nameCursor = this._cursor.clone();\n    let allowDigit = false;\n\n    this._attemptCharCodeUntilFn((code) => {\n      if (\n        chars.isAsciiLetter(code) ||\n        code === chars.$$ ||\n        code === chars.$_ ||\n        // `@let` names can't start with a digit, but digits are valid anywhere else in the name.\n        (allowDigit && chars.isDigit(code))\n      ) {\n        allowDigit = true;\n        return false;\n      }\n      return true;\n    });\n\n    return this._cursor.getChars(nameCursor).trim();\n  }\n\n  private _consumeLetDeclarationValue(): void {\n    const start = this._cursor.clone();\n    this._beginToken(TokenType.LET_VALUE, start);\n\n    while (this._cursor.peek() !== chars.$EOF) {\n      const char = this._cursor.peek();\n\n      // `@let` declarations terminate with a semicolon.\n      if (char === chars.$SEMICOLON) {\n        break;\n      }\n\n      // If we hit a quote, skip over its content since we don't care what's inside.\n      if (chars.isQuote(char)) {\n        this._cursor.advance();\n        this._attemptCharCodeUntilFn((inner) => {\n          if (inner === chars.$BACKSLASH) {\n            this._cursor.advance();\n            return false;\n          }\n          return inner === char;\n        });\n      }\n\n      this._cursor.advance();\n    }\n\n    this._endToken([this._cursor.getChars(start)]);\n  }\n\n  /**\n   * @returns whether an ICU token has been created\n   * @internal\n   */\n  private _tokenizeExpansionForm(): boolean {\n    if (this.isExpansionFormStart()) {\n      this._consumeExpansionFormStart();\n      return true;\n    }\n\n    if (isExpansionCaseStart(this._cursor.peek()) && this._isInExpansionForm()) {\n      this._consumeExpansionCaseStart();\n      return true;\n    }\n\n    if (this._cursor.peek() === chars.$RBRACE) {\n      if (this._isInExpansionCase()) {\n        this._consumeExpansionCaseEnd();\n        return true;\n      }\n\n      if (this._isInExpansionForm()) {\n        this._consumeExpansionFormEnd();\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private _beginToken(type: TokenType, start = this._cursor.clone()) {\n    this._currentTokenStart = start;\n    this._currentTokenType = type;\n  }\n\n  private _endToken(parts: string[], end?: CharacterCursor): Token {\n    if (this._currentTokenStart === null) {\n      throw new ParseError(\n        this._cursor.getSpan(end),\n        'Programming error - attempted to end a token when there was no start to the token',\n      );\n    }\n    if (this._currentTokenType === null) {\n      throw new ParseError(\n        this._cursor.getSpan(this._currentTokenStart),\n        'Programming error - attempted to end a token which has no token type',\n      );\n    }\n    const token = {\n      type: this._currentTokenType,\n      parts,\n      sourceSpan: (end ?? this._cursor).getSpan(\n        this._currentTokenStart,\n        this._leadingTriviaCodePoints,\n      ),\n    } as Token;\n    this.tokens.push(token);\n    this._currentTokenStart = null;\n    this._currentTokenType = null;\n    return token;\n  }\n\n  private _createError(msg: string, span: ParseSourceSpan): ParseError {\n    if (this._isInExpansionForm()) {\n      msg += ` (Do you have an unescaped \"{\" in your template? Use \"{{ '{' }}\") to escape it.)`;\n    }\n    const error = new ParseError(span, msg);\n    this._currentTokenStart = null;\n    this._currentTokenType = null;\n    return error;\n  }\n\n  private handleError(e: any) {\n    if (e instanceof CursorError) {\n      e = this._createError(e.msg, this._cursor.getSpan(e.cursor));\n    }\n    if (e instanceof ParseError) {\n      this.errors.push(e);\n    } else {\n      throw e;\n    }\n  }\n\n  private _attemptCharCode(charCode: number): boolean {\n    if (this._cursor.peek() === charCode) {\n      this._cursor.advance();\n      return true;\n    }\n    return false;\n  }\n\n  private _attemptCharCodeCaseInsensitive(charCode: number): boolean {\n    if (compareCharCodeCaseInsensitive(this._cursor.peek(), charCode)) {\n      this._cursor.advance();\n      return true;\n    }\n    return false;\n  }\n\n  private _requireCharCode(charCode: number) {\n    const location = this._cursor.clone();\n    if (!this._attemptCharCode(charCode)) {\n      throw this._createError(\n        _unexpectedCharacterErrorMsg(this._cursor.peek()),\n        this._cursor.getSpan(location),\n      );\n    }\n  }\n\n  private _attemptStr(chars: string): boolean {\n    const len = chars.length;\n    if (this._cursor.charsLeft() < len) {\n      return false;\n    }\n    const initialPosition = this._cursor.clone();\n    for (let i = 0; i < len; i++) {\n      if (!this._attemptCharCode(chars.charCodeAt(i))) {\n        // If attempting to parse the string fails, we want to reset the parser\n        // to where it was before the attempt\n        this._cursor = initialPosition;\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private _attemptStrCaseInsensitive(chars: string): boolean {\n    for (let i = 0; i < chars.length; i++) {\n      if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private _requireStr(chars: string) {\n    const location = this._cursor.clone();\n    if (!this._attemptStr(chars)) {\n      throw this._createError(\n        _unexpectedCharacterErrorMsg(this._cursor.peek()),\n        this._cursor.getSpan(location),\n      );\n    }\n  }\n\n  private _attemptCharCodeUntilFn(predicate: (code: number) => boolean) {\n    while (!predicate(this._cursor.peek())) {\n      this._cursor.advance();\n    }\n  }\n\n  private _requireCharCodeUntilFn(predicate: (code: number) => boolean, len: number) {\n    const start = this._cursor.clone();\n    this._attemptCharCodeUntilFn(predicate);\n    if (this._cursor.diff(start) < len) {\n      throw this._createError(\n        _unexpectedCharacterErrorMsg(this._cursor.peek()),\n        this._cursor.getSpan(start),\n      );\n    }\n  }\n\n  private _attemptUntilChar(char: number) {\n    while (this._cursor.peek() !== char) {\n      this._cursor.advance();\n    }\n  }\n\n  private _readChar(): string {\n    // Don't rely upon reading directly from `_input` as the actual char value\n    // may have been generated from an escape sequence.\n    const char = String.fromCodePoint(this._cursor.peek());\n    this._cursor.advance();\n    return char;\n  }\n\n  private _peekStr(chars: string): boolean {\n    const len = chars.length;\n    if (this._cursor.charsLeft() < len) {\n      return false;\n    }\n    const cursor = this._cursor.clone();\n    for (let i = 0; i < len; i++) {\n      if (cursor.peek() !== chars.charCodeAt(i)) {\n        return false;\n      }\n      cursor.advance();\n    }\n    return true;\n  }\n\n  private _isBlockStart(): boolean {\n    return (\n      this._cursor.peek() === chars.$AT &&\n      SUPPORTED_BLOCKS.some((blockName) => this._peekStr(blockName))\n    );\n  }\n\n  private _isLetStart(): boolean {\n    return this._cursor.peek() === chars.$AT && this._peekStr('@let');\n  }\n\n  private _consumeEntity(textTokenType: TokenType): void {\n    this._beginToken(TokenType.ENCODED_ENTITY);\n    const start = this._cursor.clone();\n    this._cursor.advance();\n    if (this._attemptCharCode(chars.$HASH)) {\n      const isHex = this._attemptCharCode(chars.$x) || this._attemptCharCode(chars.$X);\n      const codeStart = this._cursor.clone();\n      this._attemptCharCodeUntilFn(isDigitEntityEnd);\n      if (this._cursor.peek() != chars.$SEMICOLON) {\n        // Advance cursor to include the peeked character in the string provided to the error\n        // message.\n        this._cursor.advance();\n        const entityType = isHex ? CharacterReferenceType.HEX : CharacterReferenceType.DEC;\n        throw this._createError(\n          _unparsableEntityErrorMsg(entityType, this._cursor.getChars(start)),\n          this._cursor.getSpan(),\n        );\n      }\n      const strNum = this._cursor.getChars(codeStart);\n      this._cursor.advance();\n      try {\n        const charCode = parseInt(strNum, isHex ? 16 : 10);\n        this._endToken([String.fromCharCode(charCode), this._cursor.getChars(start)]);\n      } catch {\n        throw this._createError(\n          _unknownEntityErrorMsg(this._cursor.getChars(start)),\n          this._cursor.getSpan(),\n        );\n      }\n    } else {\n      const nameStart = this._cursor.clone();\n      this._attemptCharCodeUntilFn(isNamedEntityEnd);\n      if (this._cursor.peek() != chars.$SEMICOLON) {\n        // No semicolon was found so abort the encoded entity token that was in progress, and treat\n        // this as a text token\n        this._beginToken(textTokenType, start);\n        this._cursor = nameStart;\n        this._endToken(['&']);\n      } else {\n        const name = this._cursor.getChars(nameStart);\n        this._cursor.advance();\n        const char = NAMED_ENTITIES.hasOwnProperty(name) && NAMED_ENTITIES[name];\n        if (!char) {\n          throw this._createError(_unknownEntityErrorMsg(name), this._cursor.getSpan(start));\n        }\n        this._endToken([char, `&${name};`]);\n      }\n    }\n  }\n\n  private _consumeRawText(consumeEntities: boolean, endMarkerPredicate: () => boolean): void {\n    this._beginToken(consumeEntities ? TokenType.ESCAPABLE_RAW_TEXT : TokenType.RAW_TEXT);\n    const parts: string[] = [];\n    while (true) {\n      const tagCloseStart = this._cursor.clone();\n      const foundEndMarker = endMarkerPredicate();\n      this._cursor = tagCloseStart;\n      if (foundEndMarker) {\n        break;\n      }\n      if (consumeEntities && this._cursor.peek() === chars.$AMPERSAND) {\n        this._endToken([this._processCarriageReturns(parts.join(''))]);\n        parts.length = 0;\n        this._consumeEntity(TokenType.ESCAPABLE_RAW_TEXT);\n        this._beginToken(TokenType.ESCAPABLE_RAW_TEXT);\n      } else {\n        parts.push(this._readChar());\n      }\n    }\n    this._endToken([this._processCarriageReturns(parts.join(''))]);\n  }\n\n  private _consumeComment(start: CharacterCursor) {\n    this._beginToken(TokenType.COMMENT_START, start);\n    this._requireCharCode(chars.$MINUS);\n    this._endToken([]);\n    this._consumeRawText(false, () => this._attemptStr('-->'));\n    this._beginToken(TokenType.COMMENT_END);\n    this._requireStr('-->');\n    this._endToken([]);\n  }\n\n  private _consumeCdata(start: CharacterCursor) {\n    this._beginToken(TokenType.CDATA_START, start);\n    this._requireStr('CDATA[');\n    this._endToken([]);\n    this._consumeRawText(false, () => this._attemptStr(']]>'));\n    this._beginToken(TokenType.CDATA_END);\n    this._requireStr(']]>');\n    this._endToken([]);\n  }\n\n  private _consumeDocType(start: CharacterCursor) {\n    this._beginToken(TokenType.DOC_TYPE, start);\n    const contentStart = this._cursor.clone();\n    this._attemptUntilChar(chars.$GT);\n    const content = this._cursor.getChars(contentStart);\n    this._cursor.advance();\n    this._endToken([content]);\n  }\n\n  private _consumePrefixAndName(endPredicate: (code: number) => boolean): string[] {\n    const nameOrPrefixStart = this._cursor.clone();\n    let prefix: string = '';\n    while (this._cursor.peek() !== chars.$COLON && !isPrefixEnd(this._cursor.peek())) {\n      this._cursor.advance();\n    }\n    let nameStart: CharacterCursor;\n    if (this._cursor.peek() === chars.$COLON) {\n      prefix = this._cursor.getChars(nameOrPrefixStart);\n      this._cursor.advance();\n      nameStart = this._cursor.clone();\n    } else {\n      nameStart = nameOrPrefixStart;\n    }\n    this._requireCharCodeUntilFn(endPredicate, prefix === '' ? 0 : 1);\n    const name = this._cursor.getChars(nameStart);\n    return [prefix, name];\n  }\n\n  private _consumeTagOpen(start: CharacterCursor) {\n    let tagName: string;\n    let prefix: string;\n    let closingTagName: string;\n    let openToken:\n      | TagOpenStartToken\n      | IncompleteTagOpenToken\n      | ComponentOpenStartToken\n      | IncompleteComponentOpenToken\n      | undefined;\n\n    try {\n      if (this._selectorlessEnabled && isSelectorlessNameStart(this._cursor.peek())) {\n        openToken = this._consumeComponentOpenStart(start);\n        [closingTagName, prefix, tagName] = openToken.parts;\n        if (prefix) {\n          closingTagName += `:${prefix}`;\n        }\n        if (tagName) {\n          closingTagName += `:${tagName}`;\n        }\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n      } else {\n        if (!chars.isAsciiLetter(this._cursor.peek())) {\n          throw this._createError(\n            _unexpectedCharacterErrorMsg(this._cursor.peek()),\n            this._cursor.getSpan(start),\n          );\n        }\n\n        openToken = this._consumeTagOpenStart(start);\n        prefix = openToken.parts[0];\n        tagName = closingTagName = openToken.parts[1];\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n      }\n\n      while (!isAttributeTerminator(this._cursor.peek())) {\n        if (this._selectorlessEnabled && this._cursor.peek() === chars.$AT) {\n          const start = this._cursor.clone();\n          const nameStart = start.clone();\n          nameStart.advance();\n\n          if (isSelectorlessNameStart(nameStart.peek())) {\n            this._consumeDirective(start, nameStart);\n          }\n        } else {\n          this._consumeAttribute();\n        }\n      }\n\n      if (openToken.type === TokenType.COMPONENT_OPEN_START) {\n        this._consumeComponentOpenEnd();\n      } else {\n        this._consumeTagOpenEnd();\n      }\n    } catch (e) {\n      if (e instanceof ParseError) {\n        if (openToken) {\n          // We errored before we could close the opening tag, so it is incomplete.\n          openToken.type =\n            openToken.type === TokenType.COMPONENT_OPEN_START\n              ? TokenType.INCOMPLETE_COMPONENT_OPEN\n              : TokenType.INCOMPLETE_TAG_OPEN;\n        } else {\n          // When the start tag is invalid, assume we want a \"<\" as text.\n          // Back to back text tokens are merged at the end.\n          this._beginToken(TokenType.TEXT, start);\n          this._endToken(['<']);\n        }\n        return;\n      }\n\n      throw e;\n    }\n\n    const contentTokenType = this._getTagDefinition(tagName).getContentType(prefix);\n\n    if (contentTokenType === TagContentType.RAW_TEXT) {\n      this._consumeRawTextWithTagClose(openToken, closingTagName, false);\n    } else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {\n      this._consumeRawTextWithTagClose(openToken, closingTagName, true);\n    }\n  }\n\n  private _consumeRawTextWithTagClose(\n    openToken: TagOpenStartToken | ComponentOpenStartToken,\n    tagName: string,\n    consumeEntities: boolean,\n  ) {\n    this._consumeRawText(consumeEntities, () => {\n      if (!this._attemptCharCode(chars.$LT)) return false;\n      if (!this._attemptCharCode(chars.$SLASH)) return false;\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      if (!this._attemptStrCaseInsensitive(tagName)) return false;\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      return this._attemptCharCode(chars.$GT);\n    });\n    this._beginToken(\n      openToken.type === TokenType.COMPONENT_OPEN_START\n        ? TokenType.COMPONENT_CLOSE\n        : TokenType.TAG_CLOSE,\n    );\n    this._requireCharCodeUntilFn((code) => code === chars.$GT, 3);\n    this._cursor.advance(); // Consume the `>`\n    this._endToken(openToken.parts);\n  }\n\n  private _consumeTagOpenStart(start: CharacterCursor): TagOpenStartToken {\n    this._beginToken(TokenType.TAG_OPEN_START, start);\n    const parts = this._consumePrefixAndName(isNameEnd);\n    return this._endToken(parts) as TagOpenStartToken;\n  }\n\n  private _consumeComponentOpenStart(start: CharacterCursor): ComponentOpenStartToken {\n    this._beginToken(TokenType.COMPONENT_OPEN_START, start);\n    const parts = this._consumeComponentName();\n    return this._endToken(parts) as ComponentOpenStartToken;\n  }\n\n  private _consumeComponentName(): string[] {\n    const nameStart = this._cursor.clone();\n    while (isSelectorlessNameChar(this._cursor.peek())) {\n      this._cursor.advance();\n    }\n    const name = this._cursor.getChars(nameStart);\n    let prefix = '';\n    let tagName = '';\n    if (this._cursor.peek() === chars.$COLON) {\n      this._cursor.advance();\n      [prefix, tagName] = this._consumePrefixAndName(isNameEnd);\n    }\n    return [name, prefix, tagName];\n  }\n\n  private _consumeAttribute() {\n    this._consumeAttributeName();\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    if (this._attemptCharCode(chars.$EQ)) {\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      this._consumeAttributeValue();\n    }\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n  }\n\n  private _consumeAttributeName() {\n    const attrNameStart = this._cursor.peek();\n    if (attrNameStart === chars.$SQ || attrNameStart === chars.$DQ) {\n      throw this._createError(_unexpectedCharacterErrorMsg(attrNameStart), this._cursor.getSpan());\n    }\n    this._beginToken(TokenType.ATTR_NAME);\n    let nameEndPredicate: (code: number) => boolean;\n\n    if (this._openDirectiveCount > 0) {\n      // If we're parsing attributes inside of directive syntax, we have to terminate the name\n      // on the first non-matching closing paren. For example, if we have `@Dir(someAttr)`,\n      // `@Dir` and `(` will have already been captured as `DIRECTIVE_NAME` and `DIRECTIVE_OPEN`\n      // respectively, but the `)` will get captured as a part of the name for `someAttr`\n      // because normally that would be an event binding.\n      let openParens = 0;\n      nameEndPredicate = (code: number) => {\n        if (this._openDirectiveCount > 0) {\n          if (code === chars.$LPAREN) {\n            openParens++;\n          } else if (code === chars.$RPAREN) {\n            if (openParens === 0) {\n              return true;\n            }\n            openParens--;\n          }\n        }\n        return isNameEnd(code);\n      };\n    } else if (attrNameStart === chars.$LBRACKET) {\n      let openBrackets = 0;\n\n      // Be more permissive for which characters are allowed inside square-bracketed attributes,\n      // because they usually end up being bound as attribute values. Some third-party packages\n      // like Tailwind take advantage of this.\n      nameEndPredicate = (code: number) => {\n        if (code === chars.$LBRACKET) {\n          openBrackets++;\n        } else if (code === chars.$RBRACKET) {\n          openBrackets--;\n        }\n        // Only check for name-ending characters if the brackets are balanced or mismatched.\n        // Also interrupt the matching on new lines.\n        return openBrackets <= 0 ? isNameEnd(code) : chars.isNewLine(code);\n      };\n    } else {\n      nameEndPredicate = isNameEnd;\n    }\n\n    const prefixAndName = this._consumePrefixAndName(nameEndPredicate);\n    this._endToken(prefixAndName);\n  }\n\n  private _consumeAttributeValue() {\n    if (this._cursor.peek() === chars.$SQ || this._cursor.peek() === chars.$DQ) {\n      const quoteChar = this._cursor.peek();\n      this._consumeQuote(quoteChar);\n      // In an attribute then end of the attribute value and the premature end to an interpolation\n      // are both triggered by the `quoteChar`.\n      const endPredicate = () => this._cursor.peek() === quoteChar;\n      this._consumeWithInterpolation(\n        TokenType.ATTR_VALUE_TEXT,\n        TokenType.ATTR_VALUE_INTERPOLATION,\n        endPredicate,\n        endPredicate,\n      );\n      this._consumeQuote(quoteChar);\n    } else {\n      const endPredicate = () => isNameEnd(this._cursor.peek());\n      this._consumeWithInterpolation(\n        TokenType.ATTR_VALUE_TEXT,\n        TokenType.ATTR_VALUE_INTERPOLATION,\n        endPredicate,\n        endPredicate,\n      );\n    }\n  }\n\n  private _consumeQuote(quoteChar: number) {\n    this._beginToken(TokenType.ATTR_QUOTE);\n    this._requireCharCode(quoteChar);\n    this._endToken([String.fromCodePoint(quoteChar)]);\n  }\n\n  private _consumeTagOpenEnd() {\n    const tokenType = this._attemptCharCode(chars.$SLASH)\n      ? TokenType.TAG_OPEN_END_VOID\n      : TokenType.TAG_OPEN_END;\n    this._beginToken(tokenType);\n    this._requireCharCode(chars.$GT);\n    this._endToken([]);\n  }\n\n  private _consumeComponentOpenEnd() {\n    const tokenType = this._attemptCharCode(chars.$SLASH)\n      ? TokenType.COMPONENT_OPEN_END_VOID\n      : TokenType.COMPONENT_OPEN_END;\n    this._beginToken(tokenType);\n    this._requireCharCode(chars.$GT);\n    this._endToken([]);\n  }\n\n  private _consumeTagClose(start: CharacterCursor) {\n    if (this._selectorlessEnabled) {\n      const clone = start.clone();\n      while (clone.peek() !== chars.$GT && !isSelectorlessNameStart(clone.peek())) {\n        clone.advance();\n      }\n      if (isSelectorlessNameStart(clone.peek())) {\n        this._beginToken(TokenType.COMPONENT_CLOSE, start);\n        const parts = this._consumeComponentName();\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._requireCharCode(chars.$GT);\n        this._endToken(parts);\n        return;\n      }\n    }\n\n    this._beginToken(TokenType.TAG_CLOSE, start);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    const prefixAndName = this._consumePrefixAndName(isNameEnd);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    this._requireCharCode(chars.$GT);\n    this._endToken(prefixAndName);\n  }\n\n  private _consumeExpansionFormStart() {\n    this._beginToken(TokenType.EXPANSION_FORM_START);\n    this._requireCharCode(chars.$LBRACE);\n    this._endToken([]);\n\n    this._expansionCaseStack.push(TokenType.EXPANSION_FORM_START);\n\n    this._beginToken(TokenType.RAW_TEXT);\n    const condition = this._readUntil(chars.$COMMA);\n    const normalizedCondition = this._processCarriageReturns(condition);\n    if (this._i18nNormalizeLineEndingsInICUs) {\n      // We explicitly want to normalize line endings for this text.\n      this._endToken([normalizedCondition]);\n    } else {\n      // We are not normalizing line endings.\n      const conditionToken = this._endToken([condition]);\n      if (normalizedCondition !== condition) {\n        this.nonNormalizedIcuExpressions.push(conditionToken);\n      }\n    }\n    this._requireCharCode(chars.$COMMA);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._beginToken(TokenType.RAW_TEXT);\n    const type = this._readUntil(chars.$COMMA);\n    this._endToken([type]);\n    this._requireCharCode(chars.$COMMA);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n  }\n\n  private _consumeExpansionCaseStart() {\n    this._beginToken(TokenType.EXPANSION_CASE_VALUE);\n    const value = this._readUntil(chars.$LBRACE).trim();\n    this._endToken([value]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._beginToken(TokenType.EXPANSION_CASE_EXP_START);\n    this._requireCharCode(chars.$LBRACE);\n    this._endToken([]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._expansionCaseStack.push(TokenType.EXPANSION_CASE_EXP_START);\n  }\n\n  private _consumeExpansionCaseEnd() {\n    this._beginToken(TokenType.EXPANSION_CASE_EXP_END);\n    this._requireCharCode(chars.$RBRACE);\n    this._endToken([]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._expansionCaseStack.pop();\n  }\n\n  private _consumeExpansionFormEnd() {\n    this._beginToken(TokenType.EXPANSION_FORM_END);\n    this._requireCharCode(chars.$RBRACE);\n    this._endToken([]);\n\n    this._expansionCaseStack.pop();\n  }\n\n  /**\n   * Consume a string that may contain interpolation expressions.\n   *\n   * The first token consumed will be of `tokenType` and then there will be alternating\n   * `interpolationTokenType` and `tokenType` tokens until the `endPredicate()` returns true.\n   *\n   * If an interpolation token ends prematurely it will have no end marker in its `parts` array.\n   *\n   * @param textTokenType the kind of tokens to interleave around interpolation tokens.\n   * @param interpolationTokenType the kind of tokens that contain interpolation.\n   * @param endPredicate a function that should return true when we should stop consuming.\n   * @param endInterpolation a function that should return true if there is a premature end to an\n   *     interpolation expression - i.e. before we get to the normal interpolation closing marker.\n   */\n  private _consumeWithInterpolation(\n    textTokenType: TokenType,\n    interpolationTokenType: TokenType,\n    endPredicate: () => boolean,\n    endInterpolation: () => boolean,\n  ) {\n    this._beginToken(textTokenType);\n    const parts: string[] = [];\n\n    while (!endPredicate()) {\n      const current = this._cursor.clone();\n      if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {\n        this._endToken([this._processCarriageReturns(parts.join(''))], current);\n        parts.length = 0;\n        this._consumeInterpolation(interpolationTokenType, current, endInterpolation);\n        this._beginToken(textTokenType);\n      } else if (this._cursor.peek() === chars.$AMPERSAND) {\n        this._endToken([this._processCarriageReturns(parts.join(''))]);\n        parts.length = 0;\n        this._consumeEntity(textTokenType);\n        this._beginToken(textTokenType);\n      } else {\n        parts.push(this._readChar());\n      }\n    }\n\n    // It is possible that an interpolation was started but not ended inside this text token.\n    // Make sure that we reset the state of the lexer correctly.\n    this._inInterpolation = false;\n\n    this._endToken([this._processCarriageReturns(parts.join(''))]);\n  }\n\n  /**\n   * Consume a block of text that has been interpreted as an Angular interpolation.\n   *\n   * @param interpolationTokenType the type of the interpolation token to generate.\n   * @param interpolationStart a cursor that points to the start of this interpolation.\n   * @param prematureEndPredicate a function that should return true if the next characters indicate\n   *     an end to the interpolation before its normal closing marker.\n   */\n  private _consumeInterpolation(\n    interpolationTokenType: TokenType,\n    interpolationStart: CharacterCursor,\n    prematureEndPredicate: (() => boolean) | null,\n  ): void {\n    const parts: string[] = [];\n    this._beginToken(interpolationTokenType, interpolationStart);\n    parts.push(this._interpolationConfig.start);\n\n    // Find the end of the interpolation, ignoring content inside quotes.\n    const expressionStart = this._cursor.clone();\n    let inQuote: number | null = null;\n    let inComment = false;\n    while (\n      this._cursor.peek() !== chars.$EOF &&\n      (prematureEndPredicate === null || !prematureEndPredicate())\n    ) {\n      const current = this._cursor.clone();\n\n      if (this._isTagStart()) {\n        // We are starting what looks like an HTML element in the middle of this interpolation.\n        // Reset the cursor to before the `<` character and end the interpolation token.\n        // (This is actually wrong but here for backward compatibility).\n        this._cursor = current;\n        parts.push(this._getProcessedChars(expressionStart, current));\n        this._endToken(parts);\n        return;\n      }\n\n      if (inQuote === null) {\n        if (this._attemptStr(this._interpolationConfig.end)) {\n          // We are not in a string, and we hit the end interpolation marker\n          parts.push(this._getProcessedChars(expressionStart, current));\n          parts.push(this._interpolationConfig.end);\n          this._endToken(parts);\n          return;\n        } else if (this._attemptStr('//')) {\n          // Once we are in a comment we ignore any quotes\n          inComment = true;\n        }\n      }\n\n      const char = this._cursor.peek();\n      this._cursor.advance();\n      if (char === chars.$BACKSLASH) {\n        // Skip the next character because it was escaped.\n        this._cursor.advance();\n      } else if (char === inQuote) {\n        // Exiting the current quoted string\n        inQuote = null;\n      } else if (!inComment && inQuote === null && chars.isQuote(char)) {\n        // Entering a new quoted string\n        inQuote = char;\n      }\n    }\n\n    // We hit EOF without finding a closing interpolation marker\n    parts.push(this._getProcessedChars(expressionStart, this._cursor));\n    this._endToken(parts);\n  }\n\n  private _consumeDirective(start: CharacterCursor, nameStart: CharacterCursor) {\n    this._requireCharCode(chars.$AT);\n\n    // Skip over the @ since it's not part of the name.\n    this._cursor.advance();\n\n    // Capture the rest of the name.\n    while (isSelectorlessNameChar(this._cursor.peek())) {\n      this._cursor.advance();\n    }\n\n    // Capture the opening token.\n    this._beginToken(TokenType.DIRECTIVE_NAME, start);\n    const name = this._cursor.getChars(nameStart);\n    this._endToken([name]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    // Optionally there might be attributes bound to the specific directive.\n    // Stop parsing if there's no opening character for them.\n    if (this._cursor.peek() !== chars.$LPAREN) {\n      return;\n    }\n\n    this._openDirectiveCount++;\n    this._beginToken(TokenType.DIRECTIVE_OPEN);\n    this._cursor.advance();\n    this._endToken([]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    // Capture all the attributes until we hit a closing paren.\n    while (!isAttributeTerminator(this._cursor.peek()) && this._cursor.peek() !== chars.$RPAREN) {\n      this._consumeAttribute();\n    }\n\n    // Trim any trailing whitespace.\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    this._openDirectiveCount--;\n\n    if (this._cursor.peek() !== chars.$RPAREN) {\n      // Stop parsing, instead of throwing, if we've hit the end of the tag.\n      // This can be handled better later when turning the tokens into AST.\n      if (this._cursor.peek() === chars.$GT || this._cursor.peek() === chars.$SLASH) {\n        return;\n      }\n\n      throw this._createError(\n        _unexpectedCharacterErrorMsg(this._cursor.peek()),\n        this._cursor.getSpan(start),\n      );\n    }\n\n    // Capture the closing token.\n    this._beginToken(TokenType.DIRECTIVE_CLOSE);\n    this._cursor.advance();\n    this._endToken([]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n  }\n\n  private _getProcessedChars(start: CharacterCursor, end: CharacterCursor): string {\n    return this._processCarriageReturns(end.getChars(start));\n  }\n\n  private _isTextEnd(): boolean {\n    if (this._isTagStart() || this._cursor.peek() === chars.$EOF) {\n      return true;\n    }\n\n    if (this._tokenizeIcu && !this._inInterpolation) {\n      if (this.isExpansionFormStart()) {\n        // start of an expansion form\n        return true;\n      }\n\n      if (this._cursor.peek() === chars.$RBRACE && this._isInExpansionCase()) {\n        // end of and expansion case\n        return true;\n      }\n    }\n\n    if (\n      this._tokenizeBlocks &&\n      !this._inInterpolation &&\n      !this._isInExpansion() &&\n      (this._isBlockStart() || this._isLetStart() || this._cursor.peek() === chars.$RBRACE)\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Returns true if the current cursor is pointing to the start of a tag\n   * (opening/closing/comments/cdata/etc).\n   */\n  private _isTagStart(): boolean {\n    if (this._cursor.peek() === chars.$LT) {\n      // We assume that `<` followed by whitespace is not the start of an HTML element.\n      const tmp = this._cursor.clone();\n      tmp.advance();\n      // If the next character is alphabetic, ! nor / then it is a tag start\n      const code = tmp.peek();\n      if (\n        (chars.$a <= code && code <= chars.$z) ||\n        (chars.$A <= code && code <= chars.$Z) ||\n        code === chars.$SLASH ||\n        code === chars.$BANG\n      ) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private _readUntil(char: number): string {\n    const start = this._cursor.clone();\n    this._attemptUntilChar(char);\n    return this._cursor.getChars(start);\n  }\n\n  private _isInExpansion(): boolean {\n    return this._isInExpansionCase() || this._isInExpansionForm();\n  }\n\n  private _isInExpansionCase(): boolean {\n    return (\n      this._expansionCaseStack.length > 0 &&\n      this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\n        TokenType.EXPANSION_CASE_EXP_START\n    );\n  }\n\n  private _isInExpansionForm(): boolean {\n    return (\n      this._expansionCaseStack.length > 0 &&\n      this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\n        TokenType.EXPANSION_FORM_START\n    );\n  }\n\n  private isExpansionFormStart(): boolean {\n    if (this._cursor.peek() !== chars.$LBRACE) {\n      return false;\n    }\n    if (this._interpolationConfig) {\n      const start = this._cursor.clone();\n      const isInterpolation = this._attemptStr(this._interpolationConfig.start);\n      this._cursor = start;\n      return !isInterpolation;\n    }\n    return true;\n  }\n}\n\nfunction isNotWhitespace(code: number): boolean {\n  return !chars.isWhitespace(code) || code === chars.$EOF;\n}\n\nfunction isNameEnd(code: number): boolean {\n  return (\n    chars.isWhitespace(code) ||\n    code === chars.$GT ||\n    code === chars.$LT ||\n    code === chars.$SLASH ||\n    code === chars.$SQ ||\n    code === chars.$DQ ||\n    code === chars.$EQ ||\n    code === chars.$EOF\n  );\n}\n\nfunction isPrefixEnd(code: number): boolean {\n  return (\n    (code < chars.$a || chars.$z < code) &&\n    (code < chars.$A || chars.$Z < code) &&\n    (code < chars.$0 || code > chars.$9)\n  );\n}\n\nfunction isDigitEntityEnd(code: number): boolean {\n  return code === chars.$SEMICOLON || code === chars.$EOF || !chars.isAsciiHexDigit(code);\n}\n\nfunction isNamedEntityEnd(code: number): boolean {\n  return code === chars.$SEMICOLON || code === chars.$EOF || !chars.isAsciiLetter(code);\n}\n\nfunction isExpansionCaseStart(peek: number): boolean {\n  return peek !== chars.$RBRACE;\n}\n\nfunction compareCharCodeCaseInsensitive(code1: number, code2: number): boolean {\n  return toUpperCaseCharCode(code1) === toUpperCaseCharCode(code2);\n}\n\nfunction toUpperCaseCharCode(code: number): number {\n  return code >= chars.$a && code <= chars.$z ? code - chars.$a + chars.$A : code;\n}\n\nfunction isBlockNameChar(code: number): boolean {\n  return chars.isAsciiLetter(code) || chars.isDigit(code) || code === chars.$_;\n}\n\nfunction isBlockParameterChar(code: number): boolean {\n  return code !== chars.$SEMICOLON && isNotWhitespace(code);\n}\n\nfunction isSelectorlessNameStart(code: number): boolean {\n  return code === chars.$_ || (code >= chars.$A && code <= chars.$Z);\n}\n\nfunction isSelectorlessNameChar(code: number): boolean {\n  return chars.isAsciiLetter(code) || chars.isDigit(code) || code === chars.$_;\n}\n\nfunction isAttributeTerminator(code: number): boolean {\n  return code === chars.$SLASH || code === chars.$GT || code === chars.$LT || code === chars.$EOF;\n}\n\nfunction mergeTextTokens(srcTokens: Token[]): Token[] {\n  const dstTokens: Token[] = [];\n  let lastDstToken: Token | undefined = undefined;\n  for (let i = 0; i < srcTokens.length; i++) {\n    const token = srcTokens[i];\n    if (\n      (lastDstToken && lastDstToken.type === TokenType.TEXT && token.type === TokenType.TEXT) ||\n      (lastDstToken &&\n        lastDstToken.type === TokenType.ATTR_VALUE_TEXT &&\n        token.type === TokenType.ATTR_VALUE_TEXT)\n    ) {\n      lastDstToken.parts[0]! += token.parts[0];\n      lastDstToken.sourceSpan.end = token.sourceSpan.end;\n    } else {\n      lastDstToken = token;\n      dstTokens.push(lastDstToken);\n    }\n  }\n\n  return dstTokens;\n}\n\n/**\n * The _Tokenizer uses objects of this type to move through the input text,\n * extracting \"parsed characters\". These could be more than one actual character\n * if the text contains escape sequences.\n */\ninterface CharacterCursor {\n  /** Initialize the cursor. */\n  init(): void;\n  /** The parsed character at the current cursor position. */\n  peek(): number;\n  /** Advance the cursor by one parsed character. */\n  advance(): void;\n  /** Get a span from the marked start point to the current point. */\n  getSpan(start?: this, leadingTriviaCodePoints?: number[]): ParseSourceSpan;\n  /** Get the parsed characters from the marked start point to the current point. */\n  getChars(start: this): string;\n  /** The number of characters left before the end of the cursor. */\n  charsLeft(): number;\n  /** The number of characters between `this` cursor and `other` cursor. */\n  diff(other: this): number;\n  /** Make a copy of this cursor */\n  clone(): CharacterCursor;\n}\n\ninterface CursorState {\n  peek: number;\n  offset: number;\n  line: number;\n  column: number;\n}\n\nclass PlainCharacterCursor implements CharacterCursor {\n  protected state: CursorState;\n  protected file: ParseSourceFile;\n  protected input: string;\n  protected end: number;\n\n  constructor(fileOrCursor: PlainCharacterCursor);\n  constructor(fileOrCursor: ParseSourceFile, range: LexerRange);\n  constructor(fileOrCursor: ParseSourceFile | PlainCharacterCursor, range?: LexerRange) {\n    if (fileOrCursor instanceof PlainCharacterCursor) {\n      this.file = fileOrCursor.file;\n      this.input = fileOrCursor.input;\n      this.end = fileOrCursor.end;\n\n      const state = fileOrCursor.state;\n      // Note: avoid using `{...fileOrCursor.state}` here as that has a severe performance penalty.\n      // In ES5 bundles the object spread operator is translated into the `__assign` helper, which\n      // is not optimized by VMs as efficiently as a raw object literal. Since this constructor is\n      // called in tight loops, this difference matters.\n      this.state = {\n        peek: state.peek,\n        offset: state.offset,\n        line: state.line,\n        column: state.column,\n      };\n    } else {\n      if (!range) {\n        throw new Error(\n          'Programming error: the range argument must be provided with a file argument.',\n        );\n      }\n      this.file = fileOrCursor;\n      this.input = fileOrCursor.content;\n      this.end = range.endPos;\n      this.state = {\n        peek: -1,\n        offset: range.startPos,\n        line: range.startLine,\n        column: range.startCol,\n      };\n    }\n  }\n\n  clone(): PlainCharacterCursor {\n    return new PlainCharacterCursor(this);\n  }\n\n  peek() {\n    return this.state.peek;\n  }\n  charsLeft() {\n    return this.end - this.state.offset;\n  }\n  diff(other: this) {\n    return this.state.offset - other.state.offset;\n  }\n\n  advance(): void {\n    this.advanceState(this.state);\n  }\n\n  init(): void {\n    this.updatePeek(this.state);\n  }\n\n  getSpan(start?: this, leadingTriviaCodePoints?: number[]): ParseSourceSpan {\n    start = start || this;\n    let fullStart = start;\n    if (leadingTriviaCodePoints) {\n      while (this.diff(start) > 0 && leadingTriviaCodePoints.indexOf(start.peek()) !== -1) {\n        if (fullStart === start) {\n          start = start.clone() as this;\n        }\n        start.advance();\n      }\n    }\n    const startLocation = this.locationFromCursor(start);\n    const endLocation = this.locationFromCursor(this);\n    const fullStartLocation =\n      fullStart !== start ? this.locationFromCursor(fullStart) : startLocation;\n    return new ParseSourceSpan(startLocation, endLocation, fullStartLocation);\n  }\n\n  getChars(start: this): string {\n    return this.input.substring(start.state.offset, this.state.offset);\n  }\n\n  charAt(pos: number): number {\n    return this.input.charCodeAt(pos);\n  }\n\n  protected advanceState(state: CursorState) {\n    if (state.offset >= this.end) {\n      this.state = state;\n      throw new CursorError('Unexpected character \"EOF\"', this);\n    }\n    const currentChar = this.charAt(state.offset);\n    if (currentChar === chars.$LF) {\n      state.line++;\n      state.column = 0;\n    } else if (!chars.isNewLine(currentChar)) {\n      state.column++;\n    }\n    state.offset++;\n    this.updatePeek(state);\n  }\n\n  protected updatePeek(state: CursorState): void {\n    state.peek = state.offset >= this.end ? chars.$EOF : this.charAt(state.offset);\n  }\n\n  private locationFromCursor(cursor: this): ParseLocation {\n    return new ParseLocation(\n      cursor.file,\n      cursor.state.offset,\n      cursor.state.line,\n      cursor.state.column,\n    );\n  }\n}\n\nclass EscapedCharacterCursor extends PlainCharacterCursor {\n  protected internalState: CursorState;\n\n  constructor(fileOrCursor: EscapedCharacterCursor);\n  constructor(fileOrCursor: ParseSourceFile, range: LexerRange);\n  constructor(fileOrCursor: ParseSourceFile | EscapedCharacterCursor, range?: LexerRange) {\n    if (fileOrCursor instanceof EscapedCharacterCursor) {\n      super(fileOrCursor);\n      this.internalState = {...fileOrCursor.internalState};\n    } else {\n      super(fileOrCursor, range!);\n      this.internalState = this.state;\n    }\n  }\n\n  override advance(): void {\n    this.state = this.internalState;\n    super.advance();\n    this.processEscapeSequence();\n  }\n\n  override init(): void {\n    super.init();\n    this.processEscapeSequence();\n  }\n\n  override clone(): EscapedCharacterCursor {\n    return new EscapedCharacterCursor(this);\n  }\n\n  override getChars(start: this): string {\n    const cursor = start.clone();\n    let chars = '';\n    while (cursor.internalState.offset < this.internalState.offset) {\n      chars += String.fromCodePoint(cursor.peek());\n      cursor.advance();\n    }\n    return chars;\n  }\n\n  /**\n   * Process the escape sequence that starts at the current position in the text.\n   *\n   * This method is called to ensure that `peek` has the unescaped value of escape sequences.\n   */\n  protected processEscapeSequence(): void {\n    const peek = () => this.internalState.peek;\n\n    if (peek() === chars.$BACKSLASH) {\n      // We have hit an escape sequence so we need the internal state to become independent\n      // of the external state.\n      this.internalState = {...this.state};\n\n      // Move past the backslash\n      this.advanceState(this.internalState);\n\n      // First check for standard control char sequences\n      if (peek() === chars.$n) {\n        this.state.peek = chars.$LF;\n      } else if (peek() === chars.$r) {\n        this.state.peek = chars.$CR;\n      } else if (peek() === chars.$v) {\n        this.state.peek = chars.$VTAB;\n      } else if (peek() === chars.$t) {\n        this.state.peek = chars.$TAB;\n      } else if (peek() === chars.$b) {\n        this.state.peek = chars.$BSPACE;\n      } else if (peek() === chars.$f) {\n        this.state.peek = chars.$FF;\n      }\n\n      // Now consider more complex sequences\n      else if (peek() === chars.$u) {\n        // Unicode code-point sequence\n        this.advanceState(this.internalState); // advance past the `u` char\n        if (peek() === chars.$LBRACE) {\n          // Variable length Unicode, e.g. `\\x{123}`\n          this.advanceState(this.internalState); // advance past the `{` char\n          // Advance past the variable number of hex digits until we hit a `}` char\n          const digitStart = this.clone();\n          let length = 0;\n          while (peek() !== chars.$RBRACE) {\n            this.advanceState(this.internalState);\n            length++;\n          }\n          this.state.peek = this.decodeHexDigits(digitStart, length);\n        } else {\n          // Fixed length Unicode, e.g. `\\u1234`\n          const digitStart = this.clone();\n          this.advanceState(this.internalState);\n          this.advanceState(this.internalState);\n          this.advanceState(this.internalState);\n          this.state.peek = this.decodeHexDigits(digitStart, 4);\n        }\n      } else if (peek() === chars.$x) {\n        // Hex char code, e.g. `\\x2F`\n        this.advanceState(this.internalState); // advance past the `x` char\n        const digitStart = this.clone();\n        this.advanceState(this.internalState);\n        this.state.peek = this.decodeHexDigits(digitStart, 2);\n      } else if (chars.isOctalDigit(peek())) {\n        // Octal char code, e.g. `\\012`,\n        let octal = '';\n        let length = 0;\n        let previous = this.clone();\n        while (chars.isOctalDigit(peek()) && length < 3) {\n          previous = this.clone();\n          octal += String.fromCodePoint(peek());\n          this.advanceState(this.internalState);\n          length++;\n        }\n        this.state.peek = parseInt(octal, 8);\n        // Backup one char\n        this.internalState = previous.internalState;\n      } else if (chars.isNewLine(this.internalState.peek)) {\n        // Line continuation `\\` followed by a new line\n        this.advanceState(this.internalState); // advance over the newline\n        this.state = this.internalState;\n      } else {\n        // If none of the `if` blocks were executed then we just have an escaped normal character.\n        // In that case we just, effectively, skip the backslash from the character.\n        this.state.peek = this.internalState.peek;\n      }\n    }\n  }\n\n  protected decodeHexDigits(start: EscapedCharacterCursor, length: number): number {\n    const hex = this.input.slice(start.internalState.offset, start.internalState.offset + length);\n    const charCode = parseInt(hex, 16);\n    if (!isNaN(charCode)) {\n      return charCode;\n    } else {\n      start.state = start.internalState;\n      throw new CursorError('Invalid hexadecimal escape sequence', start);\n    }\n  }\n}\n\nexport class CursorError extends Error {\n  constructor(\n    public msg: string,\n    public cursor: CharacterCursor,\n  ) {\n    super(msg);\n\n    // Extending `Error` does not always work when code is transpiled. See:\n    // https://stackoverflow.com/questions/41102060/typescript-extending-error-class\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ParseError, ParseLocation, ParseSourceSpan} from '../parse_util';\n\nimport * as html from './ast';\nimport {NAMED_ENTITIES} from './entities';\nimport {tokenize, TokenizeOptions} from './lexer';\nimport {getNsPrefix, mergeNsAndName, splitNsName, TagDefinition} from './tags';\nimport {\n  AttributeNameToken,\n  AttributeQuoteToken,\n  BlockCloseToken,\n  BlockOpenStartToken,\n  BlockParameterToken,\n  CdataStartToken,\n  CommentStartToken,\n  ComponentCloseToken,\n  ComponentOpenStartToken,\n  DirectiveNameToken,\n  ExpansionCaseExpressionEndToken,\n  ExpansionCaseExpressionStartToken,\n  ExpansionCaseValueToken,\n  ExpansionFormStartToken,\n  IncompleteBlockOpenToken,\n  IncompleteComponentOpenToken,\n  IncompleteLetToken,\n  IncompleteTagOpenToken,\n  InterpolatedAttributeToken,\n  InterpolatedTextToken,\n  LetEndToken,\n  LetStartToken,\n  LetValueToken,\n  TagCloseToken,\n  TagOpenStartToken,\n  TextToken,\n  Token,\n  TokenType,\n} from './tokens';\n\n/** Nodes that can contain other nodes. */\ntype NodeContainer = html.Element | html.Block | html.Component;\n\n/** Class that can construct a `NodeContainer`. */\ninterface NodeContainerConstructor extends Function {\n  new (...args: any[]): NodeContainer;\n}\n\nexport class TreeError extends ParseError {\n  static create(elementName: string | null, span: ParseSourceSpan, msg: string): TreeError {\n    return new TreeError(elementName, span, msg);\n  }\n\n  constructor(\n    public elementName: string | null,\n    span: ParseSourceSpan,\n    msg: string,\n  ) {\n    super(span, msg);\n  }\n}\n\nexport class ParseTreeResult {\n  constructor(\n    public rootNodes: html.Node[],\n    public errors: ParseError[],\n  ) {}\n}\n\nexport class Parser {\n  constructor(public getTagDefinition: (tagName: string) => TagDefinition) {}\n\n  parse(source: string, url: string, options?: TokenizeOptions): ParseTreeResult {\n    const tokenizeResult = tokenize(source, url, this.getTagDefinition, options);\n    const parser = new _TreeBuilder(tokenizeResult.tokens, this.getTagDefinition);\n    parser.build();\n    return new ParseTreeResult(parser.rootNodes, [...tokenizeResult.errors, ...parser.errors]);\n  }\n}\n\nclass _TreeBuilder {\n  private _index: number = -1;\n  // `_peek` will be initialized by the call to `_advance()` in the constructor.\n  private _peek!: Token;\n  private _containerStack: NodeContainer[] = [];\n\n  rootNodes: html.Node[] = [];\n  errors: TreeError[] = [];\n\n  constructor(\n    private tokens: Token[],\n    private tagDefinitionResolver: (tagName: string) => TagDefinition,\n  ) {\n    this._advance();\n  }\n\n  build(): void {\n    while (this._peek.type !== TokenType.EOF) {\n      if (\n        this._peek.type === TokenType.TAG_OPEN_START ||\n        this._peek.type === TokenType.INCOMPLETE_TAG_OPEN\n      ) {\n        this._consumeElementStartTag(this._advance());\n      } else if (this._peek.type === TokenType.TAG_CLOSE) {\n        this._consumeElementEndTag(this._advance());\n      } else if (this._peek.type === TokenType.CDATA_START) {\n        this._closeVoidElement();\n        this._consumeCdata(this._advance());\n      } else if (this._peek.type === TokenType.COMMENT_START) {\n        this._closeVoidElement();\n        this._consumeComment(this._advance());\n      } else if (\n        this._peek.type === TokenType.TEXT ||\n        this._peek.type === TokenType.RAW_TEXT ||\n        this._peek.type === TokenType.ESCAPABLE_RAW_TEXT\n      ) {\n        this._closeVoidElement();\n        this._consumeText(this._advance());\n      } else if (this._peek.type === TokenType.EXPANSION_FORM_START) {\n        this._consumeExpansion(this._advance());\n      } else if (this._peek.type === TokenType.BLOCK_OPEN_START) {\n        this._closeVoidElement();\n        this._consumeBlockOpen(this._advance());\n      } else if (this._peek.type === TokenType.BLOCK_CLOSE) {\n        this._closeVoidElement();\n        this._consumeBlockClose(this._advance());\n      } else if (this._peek.type === TokenType.INCOMPLETE_BLOCK_OPEN) {\n        this._closeVoidElement();\n        this._consumeIncompleteBlock(this._advance());\n      } else if (this._peek.type === TokenType.LET_START) {\n        this._closeVoidElement();\n        this._consumeLet(this._advance());\n      } else if (this._peek.type === TokenType.INCOMPLETE_LET) {\n        this._closeVoidElement();\n        this._consumeIncompleteLet(this._advance());\n      } else if (\n        this._peek.type === TokenType.COMPONENT_OPEN_START ||\n        this._peek.type === TokenType.INCOMPLETE_COMPONENT_OPEN\n      ) {\n        this._consumeComponentStartTag(this._advance());\n      } else if (this._peek.type === TokenType.COMPONENT_CLOSE) {\n        this._consumeComponentEndTag(this._advance());\n      } else {\n        // Skip all other tokens...\n        this._advance();\n      }\n    }\n\n    for (const leftoverContainer of this._containerStack) {\n      // Unlike HTML elements, blocks aren't closed implicitly by the end of the file.\n      if (leftoverContainer instanceof html.Block) {\n        this.errors.push(\n          TreeError.create(\n            leftoverContainer.name,\n            leftoverContainer.sourceSpan,\n            `Unclosed block \"${leftoverContainer.name}\"`,\n          ),\n        );\n      }\n    }\n  }\n\n  private _advance<T extends Token>(): T {\n    const prev = this._peek;\n    if (this._index < this.tokens.length - 1) {\n      // Note: there is always an EOF token at the end\n      this._index++;\n    }\n    this._peek = this.tokens[this._index];\n    return prev as T;\n  }\n\n  private _advanceIf<T extends TokenType>(type: T): (Token & {type: T}) | null {\n    if (this._peek.type === type) {\n      return this._advance<Token & {type: T}>();\n    }\n    return null;\n  }\n\n  private _consumeCdata(_startToken: CdataStartToken) {\n    this._consumeText(this._advance<TextToken>());\n    this._advanceIf(TokenType.CDATA_END);\n  }\n\n  private _consumeComment(token: CommentStartToken) {\n    const text = this._advanceIf(TokenType.RAW_TEXT);\n    const endToken = this._advanceIf(TokenType.COMMENT_END);\n    const value = text != null ? text.parts[0].trim() : null;\n    const sourceSpan =\n      endToken == null\n        ? token.sourceSpan\n        : new ParseSourceSpan(\n            token.sourceSpan.start,\n            endToken.sourceSpan.end,\n            token.sourceSpan.fullStart,\n          );\n    this._addToParent(new html.Comment(value, sourceSpan));\n  }\n\n  private _consumeExpansion(token: ExpansionFormStartToken) {\n    const switchValue = this._advance<TextToken>();\n\n    const type = this._advance<TextToken>();\n    const cases: html.ExpansionCase[] = [];\n\n    // read =\n    while (this._peek.type === TokenType.EXPANSION_CASE_VALUE) {\n      const expCase = this._parseExpansionCase();\n      if (!expCase) return; // error\n      cases.push(expCase);\n    }\n\n    // read the final }\n    if (this._peek.type !== TokenType.EXPANSION_FORM_END) {\n      this.errors.push(\n        TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '}'.`),\n      );\n      return;\n    }\n    const sourceSpan = new ParseSourceSpan(\n      token.sourceSpan.start,\n      this._peek.sourceSpan.end,\n      token.sourceSpan.fullStart,\n    );\n    this._addToParent(\n      new html.Expansion(\n        switchValue.parts[0],\n        type.parts[0],\n        cases,\n        sourceSpan,\n        switchValue.sourceSpan,\n      ),\n    );\n\n    this._advance();\n  }\n\n  private _parseExpansionCase(): html.ExpansionCase | null {\n    const value = this._advance<ExpansionCaseValueToken>();\n\n    // read {\n    if (this._peek.type !== TokenType.EXPANSION_CASE_EXP_START) {\n      this.errors.push(\n        TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '{'.`),\n      );\n      return null;\n    }\n\n    // read until }\n    const start = this._advance<ExpansionCaseExpressionStartToken>();\n\n    const exp = this._collectExpansionExpTokens(start);\n    if (!exp) return null;\n\n    const end = this._advance<ExpansionCaseExpressionEndToken>();\n    exp.push({type: TokenType.EOF, parts: [], sourceSpan: end.sourceSpan});\n\n    // parse everything in between { and }\n    const expansionCaseParser = new _TreeBuilder(exp, this.tagDefinitionResolver);\n    expansionCaseParser.build();\n    if (expansionCaseParser.errors.length > 0) {\n      this.errors = this.errors.concat(expansionCaseParser.errors);\n      return null;\n    }\n\n    const sourceSpan = new ParseSourceSpan(\n      value.sourceSpan.start,\n      end.sourceSpan.end,\n      value.sourceSpan.fullStart,\n    );\n    const expSourceSpan = new ParseSourceSpan(\n      start.sourceSpan.start,\n      end.sourceSpan.end,\n      start.sourceSpan.fullStart,\n    );\n    return new html.ExpansionCase(\n      value.parts[0],\n      expansionCaseParser.rootNodes,\n      sourceSpan,\n      value.sourceSpan,\n      expSourceSpan,\n    );\n  }\n\n  private _collectExpansionExpTokens(start: Token): Token[] | null {\n    const exp: Token[] = [];\n    const expansionFormStack = [TokenType.EXPANSION_CASE_EXP_START];\n\n    while (true) {\n      if (\n        this._peek.type === TokenType.EXPANSION_FORM_START ||\n        this._peek.type === TokenType.EXPANSION_CASE_EXP_START\n      ) {\n        expansionFormStack.push(this._peek.type);\n      }\n\n      if (this._peek.type === TokenType.EXPANSION_CASE_EXP_END) {\n        if (lastOnStack(expansionFormStack, TokenType.EXPANSION_CASE_EXP_START)) {\n          expansionFormStack.pop();\n          if (expansionFormStack.length === 0) return exp;\n        } else {\n          this.errors.push(\n            TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`),\n          );\n          return null;\n        }\n      }\n\n      if (this._peek.type === TokenType.EXPANSION_FORM_END) {\n        if (lastOnStack(expansionFormStack, TokenType.EXPANSION_FORM_START)) {\n          expansionFormStack.pop();\n        } else {\n          this.errors.push(\n            TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`),\n          );\n          return null;\n        }\n      }\n\n      if (this._peek.type === TokenType.EOF) {\n        this.errors.push(\n          TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`),\n        );\n        return null;\n      }\n\n      exp.push(this._advance());\n    }\n  }\n\n  private _consumeText(token: InterpolatedTextToken) {\n    const tokens = [token];\n    const startSpan = token.sourceSpan;\n    let text = token.parts[0];\n    if (text.length > 0 && text[0] === '\\n') {\n      const parent = this._getContainer();\n\n      if (\n        parent != null &&\n        parent.children.length === 0 &&\n        this._getTagDefinition(parent)?.ignoreFirstLf\n      ) {\n        text = text.substring(1);\n        tokens[0] = {type: token.type, sourceSpan: token.sourceSpan, parts: [text]} as typeof token;\n      }\n    }\n\n    while (\n      this._peek.type === TokenType.INTERPOLATION ||\n      this._peek.type === TokenType.TEXT ||\n      this._peek.type === TokenType.ENCODED_ENTITY\n    ) {\n      token = this._advance();\n      tokens.push(token);\n      if (token.type === TokenType.INTERPOLATION) {\n        // For backward compatibility we decode HTML entities that appear in interpolation\n        // expressions. This is arguably a bug, but it could be a considerable breaking change to\n        // fix it. It should be addressed in a larger project to refactor the entire parser/lexer\n        // chain after View Engine has been removed.\n        text += token.parts.join('').replace(/&([^;]+);/g, decodeEntity);\n      } else if (token.type === TokenType.ENCODED_ENTITY) {\n        text += token.parts[0];\n      } else {\n        text += token.parts.join('');\n      }\n    }\n\n    if (text.length > 0) {\n      const endSpan = token.sourceSpan;\n      this._addToParent(\n        new html.Text(\n          text,\n          new ParseSourceSpan(startSpan.start, endSpan.end, startSpan.fullStart, startSpan.details),\n          tokens,\n        ),\n      );\n    }\n  }\n\n  private _closeVoidElement(): void {\n    const el = this._getContainer();\n    if (el !== null && this._getTagDefinition(el)?.isVoid) {\n      this._containerStack.pop();\n    }\n  }\n\n  private _consumeElementStartTag(startTagToken: TagOpenStartToken | IncompleteTagOpenToken) {\n    const attrs: html.Attribute[] = [];\n    const directives: html.Directive[] = [];\n    this._consumeAttributesAndDirectives(attrs, directives);\n\n    const fullName = this._getElementFullName(startTagToken, this._getClosestElementLikeParent());\n    const tagDef = this._getTagDefinition(fullName);\n    let selfClosing = false;\n    // Note: There could have been a tokenizer error\n    // so that we don't get a token for the end tag...\n    if (this._peek.type === TokenType.TAG_OPEN_END_VOID) {\n      this._advance();\n      selfClosing = true;\n      if (!(tagDef?.canSelfClose || getNsPrefix(fullName) !== null || tagDef?.isVoid)) {\n        this.errors.push(\n          TreeError.create(\n            fullName,\n            startTagToken.sourceSpan,\n            `Only void, custom and foreign elements can be self closed \"${startTagToken.parts[1]}\"`,\n          ),\n        );\n      }\n    } else if (this._peek.type === TokenType.TAG_OPEN_END) {\n      this._advance();\n      selfClosing = false;\n    }\n    const end = this._peek.sourceSpan.fullStart;\n    const span = new ParseSourceSpan(\n      startTagToken.sourceSpan.start,\n      end,\n      startTagToken.sourceSpan.fullStart,\n    );\n    // Create a separate `startSpan` because `span` will be modified when there is an `end` span.\n    const startSpan = new ParseSourceSpan(\n      startTagToken.sourceSpan.start,\n      end,\n      startTagToken.sourceSpan.fullStart,\n    );\n    const el = new html.Element(\n      fullName,\n      attrs,\n      directives,\n      [],\n      selfClosing,\n      span,\n      startSpan,\n      undefined,\n      tagDef?.isVoid ?? false,\n    );\n    const parent = this._getContainer();\n    const isClosedByChild =\n      parent !== null && !!this._getTagDefinition(parent)?.isClosedByChild(el.name);\n    this._pushContainer(el, isClosedByChild);\n\n    if (selfClosing) {\n      // Elements that are self-closed have their `endSourceSpan` set to the full span, as the\n      // element start tag also represents the end tag.\n      this._popContainer(fullName, html.Element, span);\n    } else if (startTagToken.type === TokenType.INCOMPLETE_TAG_OPEN) {\n      // We already know the opening tag is not complete, so it is unlikely it has a corresponding\n      // close tag. Let's optimistically parse it as a full element and emit an error.\n      this._popContainer(fullName, html.Element, null);\n      this.errors.push(\n        TreeError.create(fullName, span, `Opening tag \"${fullName}\" not terminated.`),\n      );\n    }\n  }\n\n  private _consumeComponentStartTag(\n    startToken: ComponentOpenStartToken | IncompleteComponentOpenToken,\n  ) {\n    const componentName = startToken.parts[0];\n    const attrs: html.Attribute[] = [];\n    const directives: html.Directive[] = [];\n    this._consumeAttributesAndDirectives(attrs, directives);\n\n    const closestElement = this._getClosestElementLikeParent();\n    const tagName = this._getComponentTagName(startToken, closestElement);\n    const fullName = this._getComponentFullName(startToken, closestElement);\n    const selfClosing = this._peek.type === TokenType.COMPONENT_OPEN_END_VOID;\n    this._advance();\n\n    const end = this._peek.sourceSpan.fullStart;\n    const span = new ParseSourceSpan(\n      startToken.sourceSpan.start,\n      end,\n      startToken.sourceSpan.fullStart,\n    );\n    const startSpan = new ParseSourceSpan(\n      startToken.sourceSpan.start,\n      end,\n      startToken.sourceSpan.fullStart,\n    );\n    const node = new html.Component(\n      componentName,\n      tagName,\n      fullName,\n      attrs,\n      directives,\n      [],\n      selfClosing,\n      span,\n      startSpan,\n      undefined,\n    );\n    const parent = this._getContainer();\n    const isClosedByChild =\n      parent !== null &&\n      node.tagName !== null &&\n      !!this._getTagDefinition(parent)?.isClosedByChild(node.tagName);\n    this._pushContainer(node, isClosedByChild);\n\n    if (selfClosing) {\n      this._popContainer(fullName, html.Component, span);\n    } else if (startToken.type === TokenType.INCOMPLETE_COMPONENT_OPEN) {\n      this._popContainer(fullName, html.Component, null);\n      this.errors.push(\n        TreeError.create(fullName, span, `Opening tag \"${fullName}\" not terminated.`),\n      );\n    }\n  }\n\n  private _consumeAttributesAndDirectives(\n    attributesResult: html.Attribute[],\n    directivesResult: html.Directive[],\n  ) {\n    while (\n      this._peek.type === TokenType.ATTR_NAME ||\n      this._peek.type === TokenType.DIRECTIVE_NAME\n    ) {\n      if (this._peek.type === TokenType.DIRECTIVE_NAME) {\n        directivesResult.push(this._consumeDirective(this._peek));\n      } else {\n        attributesResult.push(this._consumeAttr(this._advance<AttributeNameToken>()));\n      }\n    }\n  }\n\n  private _consumeComponentEndTag(endToken: ComponentCloseToken) {\n    const fullName = this._getComponentFullName(endToken, this._getClosestElementLikeParent());\n\n    if (!this._popContainer(fullName, html.Component, endToken.sourceSpan)) {\n      const container = this._containerStack[this._containerStack.length - 1];\n      let suffix: string;\n\n      if (container instanceof html.Component && container.componentName === endToken.parts[0]) {\n        suffix = `, did you mean \"${container.fullName}\"?`;\n      } else {\n        suffix = '. It may happen when the tag has already been closed by another tag.';\n      }\n\n      const errMsg = `Unexpected closing tag \"${fullName}\"${suffix}`;\n      this.errors.push(TreeError.create(fullName, endToken.sourceSpan, errMsg));\n    }\n  }\n\n  private _getTagDefinition(nodeOrName: html.Node | string): TagDefinition | null {\n    if (typeof nodeOrName === 'string') {\n      return this.tagDefinitionResolver(nodeOrName);\n    } else if (nodeOrName instanceof html.Element) {\n      return this.tagDefinitionResolver(nodeOrName.name);\n    } else if (nodeOrName instanceof html.Component && nodeOrName.tagName !== null) {\n      return this.tagDefinitionResolver(nodeOrName.tagName);\n    } else {\n      return null;\n    }\n  }\n\n  private _pushContainer(node: NodeContainer, isClosedByChild: boolean) {\n    if (isClosedByChild) {\n      this._containerStack.pop();\n    }\n\n    this._addToParent(node);\n    this._containerStack.push(node);\n  }\n\n  private _consumeElementEndTag(endTagToken: TagCloseToken) {\n    const fullName = this._getElementFullName(endTagToken, this._getClosestElementLikeParent());\n\n    if (this._getTagDefinition(fullName)?.isVoid) {\n      this.errors.push(\n        TreeError.create(\n          fullName,\n          endTagToken.sourceSpan,\n          `Void elements do not have end tags \"${endTagToken.parts[1]}\"`,\n        ),\n      );\n    } else if (!this._popContainer(fullName, html.Element, endTagToken.sourceSpan)) {\n      const errMsg = `Unexpected closing tag \"${fullName}\". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;\n      this.errors.push(TreeError.create(fullName, endTagToken.sourceSpan, errMsg));\n    }\n  }\n\n  /**\n   * Closes the nearest element with the tag name `fullName` in the parse tree.\n   * `endSourceSpan` is the span of the closing tag, or null if the element does\n   * not have a closing tag (for example, this happens when an incomplete\n   * opening tag is recovered).\n   */\n  private _popContainer(\n    expectedName: string | null,\n    expectedType: NodeContainerConstructor,\n    endSourceSpan: ParseSourceSpan | null,\n  ): boolean {\n    let unexpectedCloseTagDetected = false;\n    for (let stackIndex = this._containerStack.length - 1; stackIndex >= 0; stackIndex--) {\n      const node = this._containerStack[stackIndex];\n      const nodeName = node instanceof html.Component ? node.fullName : node.name;\n\n      if ((nodeName === expectedName || expectedName === null) && node instanceof expectedType) {\n        // Record the parse span with the element that is being closed. Any elements that are\n        // removed from the element stack at this point are closed implicitly, so they won't get\n        // an end source span (as there is no explicit closing element).\n        node.endSourceSpan = endSourceSpan;\n        node.sourceSpan.end = endSourceSpan !== null ? endSourceSpan.end : node.sourceSpan.end;\n        this._containerStack.splice(stackIndex, this._containerStack.length - stackIndex);\n        return !unexpectedCloseTagDetected;\n      }\n\n      // Blocks and most elements are not self closing.\n      if (node instanceof html.Block || !this._getTagDefinition(node)?.closedByParent) {\n        // Note that we encountered an unexpected close tag but continue processing the element\n        // stack so we can assign an `endSourceSpan` if there is a corresponding start tag for this\n        // end tag in the stack.\n        unexpectedCloseTagDetected = true;\n      }\n    }\n    return false;\n  }\n\n  private _consumeAttr(attrName: AttributeNameToken): html.Attribute {\n    const fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);\n    let attrEnd = attrName.sourceSpan.end;\n\n    // Consume any quote\n    if (this._peek.type === TokenType.ATTR_QUOTE) {\n      this._advance();\n    }\n\n    // Consume the attribute value\n    let value = '';\n    const valueTokens: InterpolatedAttributeToken[] = [];\n    let valueStartSpan: ParseSourceSpan | undefined = undefined;\n    let valueEnd: ParseLocation | undefined = undefined;\n    // NOTE: We need to use a new variable `nextTokenType` here to hide the actual type of\n    // `_peek.type` from TS. Otherwise TS will narrow the type of `_peek.type` preventing it from\n    // being able to consider `ATTR_VALUE_INTERPOLATION` as an option. This is because TS is not\n    // able to see that `_advance()` will actually mutate `_peek`.\n    const nextTokenType = this._peek.type as TokenType;\n    if (nextTokenType === TokenType.ATTR_VALUE_TEXT) {\n      valueStartSpan = this._peek.sourceSpan;\n      valueEnd = this._peek.sourceSpan.end;\n      while (\n        this._peek.type === TokenType.ATTR_VALUE_TEXT ||\n        this._peek.type === TokenType.ATTR_VALUE_INTERPOLATION ||\n        this._peek.type === TokenType.ENCODED_ENTITY\n      ) {\n        const valueToken = this._advance<InterpolatedAttributeToken>();\n        valueTokens.push(valueToken);\n        if (valueToken.type === TokenType.ATTR_VALUE_INTERPOLATION) {\n          // For backward compatibility we decode HTML entities that appear in interpolation\n          // expressions. This is arguably a bug, but it could be a considerable breaking change to\n          // fix it. It should be addressed in a larger project to refactor the entire parser/lexer\n          // chain after View Engine has been removed.\n          value += valueToken.parts.join('').replace(/&([^;]+);/g, decodeEntity);\n        } else if (valueToken.type === TokenType.ENCODED_ENTITY) {\n          value += valueToken.parts[0];\n        } else {\n          value += valueToken.parts.join('');\n        }\n        valueEnd = attrEnd = valueToken.sourceSpan.end;\n      }\n    }\n\n    // Consume any quote\n    if (this._peek.type === TokenType.ATTR_QUOTE) {\n      const quoteToken = this._advance<AttributeQuoteToken>();\n      attrEnd = quoteToken.sourceSpan.end;\n    }\n\n    const valueSpan =\n      valueStartSpan &&\n      valueEnd &&\n      new ParseSourceSpan(valueStartSpan.start, valueEnd, valueStartSpan.fullStart);\n    return new html.Attribute(\n      fullName,\n      value,\n      new ParseSourceSpan(attrName.sourceSpan.start, attrEnd, attrName.sourceSpan.fullStart),\n      attrName.sourceSpan,\n      valueSpan,\n      valueTokens.length > 0 ? valueTokens : undefined,\n      undefined,\n    );\n  }\n\n  private _consumeDirective(nameToken: DirectiveNameToken): html.Directive {\n    const attributes: html.Attribute[] = [];\n    let startSourceSpanEnd: ParseLocation = nameToken.sourceSpan.end;\n    let endSourceSpan: ParseSourceSpan | null = null;\n    this._advance();\n\n    if (this._peek.type === TokenType.DIRECTIVE_OPEN) {\n      // Capture the opening token in the start span.\n      startSourceSpanEnd = this._peek.sourceSpan.end;\n      this._advance();\n\n      // Cast here is necessary, because TS doesn't know that `_advance` changed `_peek`.\n      while ((this._peek as Token).type === TokenType.ATTR_NAME) {\n        attributes.push(this._consumeAttr(this._advance<AttributeNameToken>()));\n      }\n\n      if ((this._peek as Token).type === TokenType.DIRECTIVE_CLOSE) {\n        endSourceSpan = this._peek.sourceSpan;\n        this._advance();\n      } else {\n        this.errors.push(\n          TreeError.create(null, nameToken.sourceSpan, 'Unterminated directive definition'),\n        );\n      }\n    }\n\n    const startSourceSpan = new ParseSourceSpan(\n      nameToken.sourceSpan.start,\n      startSourceSpanEnd,\n      nameToken.sourceSpan.fullStart,\n    );\n\n    const sourceSpan = new ParseSourceSpan(\n      startSourceSpan.start,\n      endSourceSpan === null ? nameToken.sourceSpan.end : endSourceSpan.end,\n      startSourceSpan.fullStart,\n    );\n\n    return new html.Directive(\n      nameToken.parts[0],\n      attributes,\n      sourceSpan,\n      startSourceSpan,\n      endSourceSpan,\n    );\n  }\n\n  private _consumeBlockOpen(token: BlockOpenStartToken) {\n    const parameters: html.BlockParameter[] = [];\n\n    while (this._peek.type === TokenType.BLOCK_PARAMETER) {\n      const paramToken = this._advance<BlockParameterToken>();\n      parameters.push(new html.BlockParameter(paramToken.parts[0], paramToken.sourceSpan));\n    }\n\n    if (this._peek.type === TokenType.BLOCK_OPEN_END) {\n      this._advance();\n    }\n\n    const end = this._peek.sourceSpan.fullStart;\n    const span = new ParseSourceSpan(token.sourceSpan.start, end, token.sourceSpan.fullStart);\n    // Create a separate `startSpan` because `span` will be modified when there is an `end` span.\n    const startSpan = new ParseSourceSpan(token.sourceSpan.start, end, token.sourceSpan.fullStart);\n    const block = new html.Block(token.parts[0], parameters, [], span, token.sourceSpan, startSpan);\n    this._pushContainer(block, false);\n  }\n\n  private _consumeBlockClose(token: BlockCloseToken) {\n    if (!this._popContainer(null, html.Block, token.sourceSpan)) {\n      this.errors.push(\n        TreeError.create(\n          null,\n          token.sourceSpan,\n          `Unexpected closing block. The block may have been closed earlier. ` +\n            `If you meant to write the } character, you should use the \"&#125;\" ` +\n            `HTML entity instead.`,\n        ),\n      );\n    }\n  }\n\n  private _consumeIncompleteBlock(token: IncompleteBlockOpenToken) {\n    const parameters: html.BlockParameter[] = [];\n\n    while (this._peek.type === TokenType.BLOCK_PARAMETER) {\n      const paramToken = this._advance<BlockParameterToken>();\n      parameters.push(new html.BlockParameter(paramToken.parts[0], paramToken.sourceSpan));\n    }\n\n    const end = this._peek.sourceSpan.fullStart;\n    const span = new ParseSourceSpan(token.sourceSpan.start, end, token.sourceSpan.fullStart);\n    // Create a separate `startSpan` because `span` will be modified when there is an `end` span.\n    const startSpan = new ParseSourceSpan(token.sourceSpan.start, end, token.sourceSpan.fullStart);\n    const block = new html.Block(token.parts[0], parameters, [], span, token.sourceSpan, startSpan);\n    this._pushContainer(block, false);\n\n    // Incomplete blocks don't have children so we close them immediately and report an error.\n    this._popContainer(null, html.Block, null);\n\n    this.errors.push(\n      TreeError.create(\n        token.parts[0],\n        span,\n        `Incomplete block \"${token.parts[0]}\". If you meant to write the @ character, ` +\n          `you should use the \"&#64;\" HTML entity instead.`,\n      ),\n    );\n  }\n\n  private _consumeLet(startToken: LetStartToken) {\n    const name = startToken.parts[0];\n    let valueToken: LetValueToken;\n    let endToken: LetEndToken;\n\n    if (this._peek.type !== TokenType.LET_VALUE) {\n      this.errors.push(\n        TreeError.create(\n          startToken.parts[0],\n          startToken.sourceSpan,\n          `Invalid @let declaration \"${name}\". Declaration must have a value.`,\n        ),\n      );\n      return;\n    } else {\n      valueToken = this._advance();\n    }\n\n    // Type cast is necessary here since TS narrowed the type of `peek` above.\n    if ((this._peek as Token).type !== TokenType.LET_END) {\n      this.errors.push(\n        TreeError.create(\n          startToken.parts[0],\n          startToken.sourceSpan,\n          `Unterminated @let declaration \"${name}\". Declaration must be terminated with a semicolon.`,\n        ),\n      );\n      return;\n    } else {\n      endToken = this._advance();\n    }\n\n    const end = endToken.sourceSpan.fullStart;\n    const span = new ParseSourceSpan(\n      startToken.sourceSpan.start,\n      end,\n      startToken.sourceSpan.fullStart,\n    );\n\n    // The start token usually captures the `@let`. Construct a name span by\n    // offsetting the start by the length of any text before the name.\n    const startOffset = startToken.sourceSpan.toString().lastIndexOf(name);\n    const nameStart = startToken.sourceSpan.start.moveBy(startOffset);\n    const nameSpan = new ParseSourceSpan(nameStart, startToken.sourceSpan.end);\n    const node = new html.LetDeclaration(\n      name,\n      valueToken.parts[0],\n      span,\n      nameSpan,\n      valueToken.sourceSpan,\n    );\n\n    this._addToParent(node);\n  }\n\n  private _consumeIncompleteLet(token: IncompleteLetToken) {\n    // Incomplete `@let` declaration may end up with an empty name.\n    const name = token.parts[0] ?? '';\n    const nameString = name ? ` \"${name}\"` : '';\n\n    // If there's at least a name, we can salvage an AST node that can be used for completions.\n    if (name.length > 0) {\n      const startOffset = token.sourceSpan.toString().lastIndexOf(name);\n      const nameStart = token.sourceSpan.start.moveBy(startOffset);\n      const nameSpan = new ParseSourceSpan(nameStart, token.sourceSpan.end);\n      const valueSpan = new ParseSourceSpan(\n        token.sourceSpan.start,\n        token.sourceSpan.start.moveBy(0),\n      );\n      const node = new html.LetDeclaration(name, '', token.sourceSpan, nameSpan, valueSpan);\n      this._addToParent(node);\n    }\n\n    this.errors.push(\n      TreeError.create(\n        token.parts[0],\n        token.sourceSpan,\n        `Incomplete @let declaration${nameString}. ` +\n          `@let declarations must be written as \\`@let <name> = <value>;\\``,\n      ),\n    );\n  }\n\n  private _getContainer(): NodeContainer | null {\n    return this._containerStack.length > 0\n      ? this._containerStack[this._containerStack.length - 1]\n      : null;\n  }\n\n  private _getClosestElementLikeParent(): html.Element | html.Component | null {\n    for (let i = this._containerStack.length - 1; i > -1; i--) {\n      const current = this._containerStack[i];\n      if (current instanceof html.Element || current instanceof html.Component) {\n        return current;\n      }\n    }\n\n    return null;\n  }\n\n  private _addToParent(node: html.Node) {\n    const parent = this._getContainer();\n\n    if (parent === null) {\n      this.rootNodes.push(node);\n    } else {\n      parent.children.push(node);\n    }\n  }\n\n  private _getElementFullName(\n    token: TagOpenStartToken | IncompleteTagOpenToken | TagCloseToken,\n    parent: html.Element | html.Component | null,\n  ): string {\n    const prefix = this._getPrefix(token, parent);\n    return mergeNsAndName(prefix, token.parts[1]);\n  }\n\n  private _getComponentFullName(\n    token: ComponentOpenStartToken | IncompleteComponentOpenToken | ComponentCloseToken,\n    parent: html.Element | html.Component | null,\n  ): string {\n    const componentName = token.parts[0];\n    const tagName = this._getComponentTagName(token, parent);\n\n    if (tagName === null) {\n      return componentName;\n    }\n\n    return tagName.startsWith(':') ? componentName + tagName : `${componentName}:${tagName}`;\n  }\n\n  private _getComponentTagName(\n    token: ComponentOpenStartToken | IncompleteComponentOpenToken | ComponentCloseToken,\n    parent: html.Element | html.Component | null,\n  ): string | null {\n    const prefix = this._getPrefix(token, parent);\n    const tagName = token.parts[2];\n\n    if (!prefix && !tagName) {\n      return null;\n    } else if (!prefix && tagName) {\n      return tagName;\n    } else {\n      // TODO(crisbeto): re-evaluate this fallback. Maybe base it off the class name?\n      return mergeNsAndName(prefix, tagName || 'ng-component');\n    }\n  }\n\n  private _getPrefix(\n    token:\n      | TagOpenStartToken\n      | IncompleteTagOpenToken\n      | ComponentOpenStartToken\n      | IncompleteComponentOpenToken\n      | TagCloseToken\n      | ComponentCloseToken,\n    parent: html.Element | html.Component | null,\n  ): string {\n    let prefix: string;\n    let tagName: string;\n\n    if (\n      token.type === TokenType.COMPONENT_OPEN_START ||\n      token.type === TokenType.INCOMPLETE_COMPONENT_OPEN ||\n      token.type === TokenType.COMPONENT_CLOSE\n    ) {\n      prefix = token.parts[1];\n      tagName = token.parts[2];\n    } else {\n      prefix = token.parts[0];\n      tagName = token.parts[1];\n    }\n\n    prefix = prefix || this._getTagDefinition(tagName)?.implicitNamespacePrefix || '';\n\n    if (!prefix && parent) {\n      const parentName = parent instanceof html.Element ? parent.name : parent.tagName;\n      if (parentName !== null) {\n        const parentTagName = splitNsName(parentName)[1];\n        const parentTagDefinition = this._getTagDefinition(parentTagName);\n        if (parentTagDefinition !== null && !parentTagDefinition.preventNamespaceInheritance) {\n          prefix = getNsPrefix(parentName);\n        }\n      }\n    }\n\n    return prefix;\n  }\n}\n\nfunction lastOnStack(stack: any[], element: any): boolean {\n  return stack.length > 0 && stack[stack.length - 1] === element;\n}\n\n/**\n * Decode the `entity` string, which we believe is the contents of an HTML entity.\n *\n * If the string is not actually a valid/known entity then just return the original `match` string.\n */\nfunction decodeEntity(match: string, entity: string): string {\n  if (NAMED_ENTITIES[entity] !== undefined) {\n    return NAMED_ENTITIES[entity] || match;\n  }\n  if (/^#x[a-f0-9]+$/i.test(entity)) {\n    return String.fromCodePoint(parseInt(entity.slice(2), 16));\n  }\n  if (/^#\\d+$/.test(entity)) {\n    return String.fromCodePoint(parseInt(entity.slice(1), 10));\n  }\n  return match;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as html from './ast';\nimport {NGSP_UNICODE} from './entities';\nimport {ParseTreeResult} from './parser';\nimport {InterpolatedTextToken, TextToken, TokenType} from './tokens';\n\nexport const PRESERVE_WS_ATTR_NAME = 'ngPreserveWhitespaces';\n\nconst SKIP_WS_TRIM_TAGS = new Set(['pre', 'template', 'textarea', 'script', 'style']);\n\n// Equivalent to \\s with \\u00a0 (non-breaking space) excluded.\n// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\nconst WS_CHARS = ' \\f\\n\\r\\t\\v\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff';\nconst NO_WS_REGEXP = new RegExp(`[^${WS_CHARS}]`);\nconst WS_REPLACE_REGEXP = new RegExp(`[${WS_CHARS}]{2,}`, 'g');\n\nfunction hasPreserveWhitespacesAttr(attrs: html.Attribute[]): boolean {\n  return attrs.some((attr: html.Attribute) => attr.name === PRESERVE_WS_ATTR_NAME);\n}\n\n/**\n * &ngsp; is a placeholder for non-removable space\n * &ngsp; is converted to the 0xE500 PUA (Private Use Areas) unicode character\n * and later on replaced by a space.\n */\nexport function replaceNgsp(value: string): string {\n  // lexer is replacing the &ngsp; pseudo-entity with NGSP_UNICODE\n  return value.replace(new RegExp(NGSP_UNICODE, 'g'), ' ');\n}\n\n/**\n * This visitor can walk HTML parse tree and remove / trim text nodes using the following rules:\n * - consider spaces, tabs and new lines as whitespace characters;\n * - drop text nodes consisting of whitespace characters only;\n * - for all other text nodes replace consecutive whitespace characters with one space;\n * - convert &ngsp; pseudo-entity to a single space;\n *\n * Removal and trimming of whitespaces have positive performance impact (less code to generate\n * while compiling templates, faster view creation). At the same time it can be \"destructive\"\n * in some cases (whitespaces can influence layout). Because of the potential of breaking layout\n * this visitor is not activated by default in Angular 5 and people need to explicitly opt-in for\n * whitespace removal. The default option for whitespace removal will be revisited in Angular 6\n * and might be changed to \"on\" by default.\n *\n * If `originalNodeMap` is provided, the transformed nodes will be mapped back to their original\n * inputs. Any output nodes not in the map were not transformed. This supports correlating and\n * porting information between the trimmed nodes and original nodes (such as `i18n` properties)\n * such that trimming whitespace does not does not drop required information from the node.\n */\nexport class WhitespaceVisitor implements html.Visitor {\n  // How many ICU expansions which are currently being visited. ICUs can be nested, so this\n  // tracks the current depth of nesting. If this depth is greater than 0, then this visitor is\n  // currently processing content inside an ICU expansion.\n  private icuExpansionDepth = 0;\n\n  constructor(\n    private readonly preserveSignificantWhitespace: boolean,\n    private readonly originalNodeMap?: Map<html.Node, html.Node>,\n    private readonly requireContext = true,\n  ) {}\n\n  visitElement(element: html.Element, context: any): any {\n    if (SKIP_WS_TRIM_TAGS.has(element.name) || hasPreserveWhitespacesAttr(element.attrs)) {\n      // don't descent into elements where we need to preserve whitespaces\n      // but still visit all attributes to eliminate one used as a market to preserve WS\n      const newElement = new html.Element(\n        element.name,\n        visitAllWithSiblings(this, element.attrs),\n        visitAllWithSiblings(this, element.directives),\n        element.children,\n        element.isSelfClosing,\n        element.sourceSpan,\n        element.startSourceSpan,\n        element.endSourceSpan,\n        element.isVoid,\n        element.i18n,\n      );\n      this.originalNodeMap?.set(newElement, element);\n      return newElement;\n    }\n\n    const newElement = new html.Element(\n      element.name,\n      element.attrs,\n      element.directives,\n      visitAllWithSiblings(this, element.children),\n      element.isSelfClosing,\n      element.sourceSpan,\n      element.startSourceSpan,\n      element.endSourceSpan,\n      element.isVoid,\n      element.i18n,\n    );\n    this.originalNodeMap?.set(newElement, element);\n    return newElement;\n  }\n\n  visitAttribute(attribute: html.Attribute, context: any): any {\n    return attribute.name !== PRESERVE_WS_ATTR_NAME ? attribute : null;\n  }\n\n  visitText(text: html.Text, context: SiblingVisitorContext | null): any {\n    const isNotBlank = text.value.match(NO_WS_REGEXP);\n    const hasExpansionSibling =\n      context && (context.prev instanceof html.Expansion || context.next instanceof html.Expansion);\n\n    // Do not trim whitespace within ICU expansions when preserving significant whitespace.\n    // Historically, ICU whitespace was never trimmed and this is really a bug. However fixing it\n    // would change message IDs which we can't easily do. Instead we only trim ICU whitespace within\n    // ICU expansions when not preserving significant whitespace, which is the new behavior where it\n    // most matters.\n    const inIcuExpansion = this.icuExpansionDepth > 0;\n    if (inIcuExpansion && this.preserveSignificantWhitespace) return text;\n\n    if (isNotBlank || hasExpansionSibling) {\n      // Process the whitespace in the tokens of this Text node\n      const tokens = text.tokens.map((token) =>\n        token.type === TokenType.TEXT ? createWhitespaceProcessedTextToken(token) : token,\n      );\n\n      // Fully trim message when significant whitespace is not preserved.\n      if (!this.preserveSignificantWhitespace && tokens.length > 0) {\n        // The first token should only call `.trimStart()` and the last token\n        // should only call `.trimEnd()`, but there might be only one token which\n        // needs to call both.\n        const firstToken = tokens[0]!;\n        tokens.splice(0, 1, trimLeadingWhitespace(firstToken, context));\n\n        const lastToken = tokens[tokens.length - 1]; // Could be the same as the first token.\n        tokens.splice(tokens.length - 1, 1, trimTrailingWhitespace(lastToken, context));\n      }\n\n      // Process the whitespace of the value of this Text node. Also trim the leading/trailing\n      // whitespace when we don't need to preserve significant whitespace.\n      const processed = processWhitespace(text.value);\n      const value = this.preserveSignificantWhitespace\n        ? processed\n        : trimLeadingAndTrailingWhitespace(processed, context);\n      const result = new html.Text(value, text.sourceSpan, tokens, text.i18n);\n      this.originalNodeMap?.set(result, text);\n      return result;\n    }\n\n    return null;\n  }\n\n  visitComment(comment: html.Comment, context: any): any {\n    return comment;\n  }\n\n  visitExpansion(expansion: html.Expansion, context: any): any {\n    this.icuExpansionDepth++;\n    let newExpansion: html.Expansion;\n    try {\n      newExpansion = new html.Expansion(\n        expansion.switchValue,\n        expansion.type,\n        visitAllWithSiblings(this, expansion.cases),\n        expansion.sourceSpan,\n        expansion.switchValueSourceSpan,\n        expansion.i18n,\n      );\n    } finally {\n      this.icuExpansionDepth--;\n    }\n\n    this.originalNodeMap?.set(newExpansion, expansion);\n\n    return newExpansion;\n  }\n\n  visitExpansionCase(expansionCase: html.ExpansionCase, context: any): any {\n    const newExpansionCase = new html.ExpansionCase(\n      expansionCase.value,\n      visitAllWithSiblings(this, expansionCase.expression),\n      expansionCase.sourceSpan,\n      expansionCase.valueSourceSpan,\n      expansionCase.expSourceSpan,\n    );\n    this.originalNodeMap?.set(newExpansionCase, expansionCase);\n    return newExpansionCase;\n  }\n\n  visitBlock(block: html.Block, context: any): any {\n    const newBlock = new html.Block(\n      block.name,\n      block.parameters,\n      visitAllWithSiblings(this, block.children),\n      block.sourceSpan,\n      block.nameSpan,\n      block.startSourceSpan,\n      block.endSourceSpan,\n    );\n    this.originalNodeMap?.set(newBlock, block);\n    return newBlock;\n  }\n\n  visitBlockParameter(parameter: html.BlockParameter, context: any) {\n    return parameter;\n  }\n\n  visitLetDeclaration(decl: html.LetDeclaration, context: any) {\n    return decl;\n  }\n\n  visitComponent(node: html.Component, context: any): any {\n    if (\n      (node.tagName && SKIP_WS_TRIM_TAGS.has(node.tagName)) ||\n      hasPreserveWhitespacesAttr(node.attrs)\n    ) {\n      // don't descent into elements where we need to preserve whitespaces\n      // but still visit all attributes to eliminate one used as a market to preserve WS\n      const newElement = new html.Component(\n        node.componentName,\n        node.tagName,\n        node.fullName,\n        visitAllWithSiblings(this, node.attrs),\n        visitAllWithSiblings(this, node.directives),\n        node.children,\n        node.isSelfClosing,\n        node.sourceSpan,\n        node.startSourceSpan,\n        node.endSourceSpan,\n        node.i18n,\n      );\n      this.originalNodeMap?.set(newElement, node);\n      return newElement;\n    }\n\n    const newElement = new html.Component(\n      node.componentName,\n      node.tagName,\n      node.fullName,\n      node.attrs,\n      node.directives,\n      visitAllWithSiblings(this, node.children),\n      node.isSelfClosing,\n      node.sourceSpan,\n      node.startSourceSpan,\n      node.endSourceSpan,\n      node.i18n,\n    );\n    this.originalNodeMap?.set(newElement, node);\n    return newElement;\n  }\n\n  visitDirective(directive: html.Directive, context: any) {\n    return directive;\n  }\n\n  visit(_node: html.Node, context: any) {\n    // `visitAllWithSiblings` provides context necessary for ICU messages to be handled correctly.\n    // Prefer that over calling `html.visitAll` directly on this visitor.\n    if (this.requireContext && !context) {\n      throw new Error(\n        `WhitespaceVisitor requires context. Visit via \\`visitAllWithSiblings\\` to get this context.`,\n      );\n    }\n\n    return false;\n  }\n}\n\nfunction trimLeadingWhitespace(\n  token: InterpolatedTextToken,\n  context: SiblingVisitorContext | null,\n): InterpolatedTextToken {\n  if (token.type !== TokenType.TEXT) return token;\n\n  const isFirstTokenInTag = !context?.prev;\n  if (!isFirstTokenInTag) return token;\n\n  return transformTextToken(token, (text) => text.trimStart());\n}\n\nfunction trimTrailingWhitespace(\n  token: InterpolatedTextToken,\n  context: SiblingVisitorContext | null,\n): InterpolatedTextToken {\n  if (token.type !== TokenType.TEXT) return token;\n\n  const isLastTokenInTag = !context?.next;\n  if (!isLastTokenInTag) return token;\n\n  return transformTextToken(token, (text) => text.trimEnd());\n}\n\nfunction trimLeadingAndTrailingWhitespace(\n  text: string,\n  context: SiblingVisitorContext | null,\n): string {\n  const isFirstTokenInTag = !context?.prev;\n  const isLastTokenInTag = !context?.next;\n\n  const maybeTrimmedStart = isFirstTokenInTag ? text.trimStart() : text;\n  const maybeTrimmed = isLastTokenInTag ? maybeTrimmedStart.trimEnd() : maybeTrimmedStart;\n  return maybeTrimmed;\n}\n\nfunction createWhitespaceProcessedTextToken({type, parts, sourceSpan}: TextToken): TextToken {\n  return {type, parts: [processWhitespace(parts[0])], sourceSpan};\n}\n\nfunction transformTextToken(\n  {type, parts, sourceSpan}: TextToken,\n  transform: (parts: string) => string,\n): TextToken {\n  // `TextToken` only ever has one part as defined in its type, so we just transform the first element.\n  return {type, parts: [transform(parts[0])], sourceSpan};\n}\n\nfunction processWhitespace(text: string): string {\n  return replaceNgsp(text).replace(WS_REPLACE_REGEXP, ' ');\n}\n\nexport function removeWhitespaces(\n  htmlAstWithErrors: ParseTreeResult,\n  preserveSignificantWhitespace: boolean,\n): ParseTreeResult {\n  return new ParseTreeResult(\n    visitAllWithSiblings(\n      new WhitespaceVisitor(preserveSignificantWhitespace),\n      htmlAstWithErrors.rootNodes,\n    ),\n    htmlAstWithErrors.errors,\n  );\n}\n\ninterface SiblingVisitorContext {\n  prev: html.Node | undefined;\n  next: html.Node | undefined;\n}\n\nexport function visitAllWithSiblings(visitor: WhitespaceVisitor, nodes: html.Node[]): any[] {\n  const result: any[] = [];\n\n  nodes.forEach((ast, i) => {\n    const context: SiblingVisitorContext = {prev: nodes[i - 1], next: nodes[i + 1]};\n    const astResult = ast.visit(visitor, context);\n    if (astResult) {\n      result.push(astResult);\n    }\n  });\n  return result;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as chars from '../chars';\n\nexport enum TokenType {\n  Character,\n  Identifier,\n  PrivateIdentifier,\n  Keyword,\n  String,\n  Operator,\n  Number,\n  Error,\n}\n\nexport enum StringTokenKind {\n  Plain,\n  TemplateLiteralPart,\n  TemplateLiteralEnd,\n}\n\nconst KEYWORDS = [\n  'var',\n  'let',\n  'as',\n  'null',\n  'undefined',\n  'true',\n  'false',\n  'if',\n  'else',\n  'this',\n  'typeof',\n  'void',\n  'in',\n];\n\nexport class Lexer {\n  tokenize(text: string): Token[] {\n    return new _Scanner(text).scan();\n  }\n}\n\nexport class Token {\n  constructor(\n    public index: number,\n    public end: number,\n    public type: TokenType,\n    public numValue: number,\n    public strValue: string,\n  ) {}\n\n  isCharacter(code: number): boolean {\n    return this.type === TokenType.Character && this.numValue === code;\n  }\n\n  isNumber(): boolean {\n    return this.type === TokenType.Number;\n  }\n\n  isString(): this is StringToken {\n    return this.type === TokenType.String;\n  }\n\n  isOperator(operator: string): boolean {\n    return this.type === TokenType.Operator && this.strValue === operator;\n  }\n\n  isIdentifier(): boolean {\n    return this.type === TokenType.Identifier;\n  }\n\n  isPrivateIdentifier(): boolean {\n    return this.type === TokenType.PrivateIdentifier;\n  }\n\n  isKeyword(): boolean {\n    return this.type === TokenType.Keyword;\n  }\n\n  isKeywordLet(): boolean {\n    return this.type === TokenType.Keyword && this.strValue === 'let';\n  }\n\n  isKeywordAs(): boolean {\n    return this.type === TokenType.Keyword && this.strValue === 'as';\n  }\n\n  isKeywordNull(): boolean {\n    return this.type === TokenType.Keyword && this.strValue === 'null';\n  }\n\n  isKeywordUndefined(): boolean {\n    return this.type === TokenType.Keyword && this.strValue === 'undefined';\n  }\n\n  isKeywordTrue(): boolean {\n    return this.type === TokenType.Keyword && this.strValue === 'true';\n  }\n\n  isKeywordFalse(): boolean {\n    return this.type === TokenType.Keyword && this.strValue === 'false';\n  }\n\n  isKeywordThis(): boolean {\n    return this.type === TokenType.Keyword && this.strValue === 'this';\n  }\n\n  isKeywordTypeof(): boolean {\n    return this.type === TokenType.Keyword && this.strValue === 'typeof';\n  }\n\n  isKeywordVoid(): boolean {\n    return this.type === TokenType.Keyword && this.strValue === 'void';\n  }\n\n  isKeywordIn(): boolean {\n    return this.type === TokenType.Keyword && this.strValue === 'in';\n  }\n\n  isError(): boolean {\n    return this.type === TokenType.Error;\n  }\n\n  toNumber(): number {\n    return this.type === TokenType.Number ? this.numValue : -1;\n  }\n\n  isTemplateLiteralPart(): this is StringToken {\n    // Note: Explicit type is needed for Closure.\n    return this.isString() && (this as StringToken).kind === StringTokenKind.TemplateLiteralPart;\n  }\n\n  isTemplateLiteralEnd(): this is StringToken {\n    // Note: Explicit type is needed for Closure.\n    return this.isString() && (this as StringToken).kind === StringTokenKind.TemplateLiteralEnd;\n  }\n\n  isTemplateLiteralInterpolationStart(): boolean {\n    return this.isOperator('${');\n  }\n\n  toString(): string | null {\n    switch (this.type) {\n      case TokenType.Character:\n      case TokenType.Identifier:\n      case TokenType.Keyword:\n      case TokenType.Operator:\n      case TokenType.PrivateIdentifier:\n      case TokenType.String:\n      case TokenType.Error:\n        return this.strValue;\n      case TokenType.Number:\n        return this.numValue.toString();\n      default:\n        return null;\n    }\n  }\n}\n\nexport class StringToken extends Token {\n  constructor(\n    index: number,\n    end: number,\n    strValue: string,\n    readonly kind: StringTokenKind,\n  ) {\n    super(index, end, TokenType.String, 0, strValue);\n  }\n}\n\nfunction newCharacterToken(index: number, end: number, code: number): Token {\n  return new Token(index, end, TokenType.Character, code, String.fromCharCode(code));\n}\n\nfunction newIdentifierToken(index: number, end: number, text: string): Token {\n  return new Token(index, end, TokenType.Identifier, 0, text);\n}\n\nfunction newPrivateIdentifierToken(index: number, end: number, text: string): Token {\n  return new Token(index, end, TokenType.PrivateIdentifier, 0, text);\n}\n\nfunction newKeywordToken(index: number, end: number, text: string): Token {\n  return new Token(index, end, TokenType.Keyword, 0, text);\n}\n\nfunction newOperatorToken(index: number, end: number, text: string): Token {\n  return new Token(index, end, TokenType.Operator, 0, text);\n}\n\nfunction newNumberToken(index: number, end: number, n: number): Token {\n  return new Token(index, end, TokenType.Number, n, '');\n}\n\nfunction newErrorToken(index: number, end: number, message: string): Token {\n  return new Token(index, end, TokenType.Error, 0, message);\n}\n\nexport const EOF: Token = new Token(-1, -1, TokenType.Character, 0, '');\n\nclass _Scanner {\n  private readonly tokens: Token[] = [];\n  private readonly length: number;\n  private peek = 0;\n  private index = -1;\n  private braceStack: ('interpolation' | 'expression')[] = [];\n\n  constructor(private readonly input: string) {\n    this.length = input.length;\n    this.advance();\n  }\n\n  scan(): Token[] {\n    let token = this.scanToken();\n\n    while (token !== null) {\n      this.tokens.push(token);\n      token = this.scanToken();\n    }\n\n    return this.tokens;\n  }\n\n  private advance() {\n    this.peek = ++this.index >= this.length ? chars.$EOF : this.input.charCodeAt(this.index);\n  }\n\n  private scanToken(): Token | null {\n    const input = this.input;\n    const length = this.length;\n    let peek = this.peek;\n    let index = this.index;\n\n    // Skip whitespace.\n    while (peek <= chars.$SPACE) {\n      if (++index >= length) {\n        peek = chars.$EOF;\n        break;\n      } else {\n        peek = input.charCodeAt(index);\n      }\n    }\n\n    this.peek = peek;\n    this.index = index;\n\n    if (index >= length) {\n      return null;\n    }\n\n    // Handle identifiers and numbers.\n    if (isIdentifierStart(peek)) {\n      return this.scanIdentifier();\n    }\n\n    if (chars.isDigit(peek)) {\n      return this.scanNumber(index);\n    }\n\n    const start: number = index;\n    switch (peek) {\n      case chars.$PERIOD:\n        this.advance();\n        return chars.isDigit(this.peek)\n          ? this.scanNumber(start)\n          : newCharacterToken(start, this.index, chars.$PERIOD);\n      case chars.$LPAREN:\n      case chars.$RPAREN:\n      case chars.$LBRACKET:\n      case chars.$RBRACKET:\n      case chars.$COMMA:\n      case chars.$COLON:\n      case chars.$SEMICOLON:\n        return this.scanCharacter(start, peek);\n      case chars.$LBRACE:\n        return this.scanOpenBrace(start, peek);\n      case chars.$RBRACE:\n        return this.scanCloseBrace(start, peek);\n      case chars.$SQ:\n      case chars.$DQ:\n        return this.scanString();\n      case chars.$BT:\n        this.advance();\n        return this.scanTemplateLiteralPart(start);\n      case chars.$HASH:\n        return this.scanPrivateIdentifier();\n      case chars.$PLUS:\n        return this.scanComplexOperator(start, '+', chars.$EQ, '=');\n      case chars.$MINUS:\n        return this.scanComplexOperator(start, '-', chars.$EQ, '=');\n      case chars.$SLASH:\n        return this.scanComplexOperator(start, '/', chars.$EQ, '=');\n      case chars.$PERCENT:\n        return this.scanComplexOperator(start, '%', chars.$EQ, '=');\n      case chars.$CARET:\n        return this.scanOperator(start, '^');\n      case chars.$STAR:\n        return this.scanStar(start);\n      case chars.$QUESTION:\n        return this.scanQuestion(start);\n      case chars.$LT:\n      case chars.$GT:\n        return this.scanComplexOperator(start, String.fromCharCode(peek), chars.$EQ, '=');\n      case chars.$BANG:\n      case chars.$EQ:\n        return this.scanComplexOperator(\n          start,\n          String.fromCharCode(peek),\n          chars.$EQ,\n          '=',\n          chars.$EQ,\n          '=',\n        );\n      case chars.$AMPERSAND:\n        return this.scanComplexOperator(start, '&', chars.$AMPERSAND, '&', chars.$EQ, '=');\n      case chars.$BAR:\n        return this.scanComplexOperator(start, '|', chars.$BAR, '|', chars.$EQ, '=');\n      case chars.$NBSP:\n        while (chars.isWhitespace(this.peek)) this.advance();\n        return this.scanToken();\n    }\n\n    this.advance();\n    return this.error(`Unexpected character [${String.fromCharCode(peek)}]`, 0);\n  }\n\n  private scanCharacter(start: number, code: number): Token {\n    this.advance();\n    return newCharacterToken(start, this.index, code);\n  }\n\n  private scanOperator(start: number, str: string): Token {\n    this.advance();\n    return newOperatorToken(start, this.index, str);\n  }\n\n  private scanOpenBrace(start: number, code: number): Token {\n    this.braceStack.push('expression');\n    this.advance();\n    return newCharacterToken(start, this.index, code);\n  }\n\n  private scanCloseBrace(start: number, code: number): Token {\n    this.advance();\n\n    const currentBrace = this.braceStack.pop();\n    if (currentBrace === 'interpolation') {\n      this.tokens.push(newCharacterToken(start, this.index, chars.$RBRACE));\n      return this.scanTemplateLiteralPart(this.index);\n    }\n\n    return newCharacterToken(start, this.index, code);\n  }\n\n  /**\n   * Tokenize a 2/3 char long operator\n   *\n   * @param start start index in the expression\n   * @param one first symbol (always part of the operator)\n   * @param twoCode code point for the second symbol\n   * @param two second symbol (part of the operator when the second code point matches)\n   * @param threeCode code point for the third symbol\n   * @param three third symbol (part of the operator when provided and matches source expression)\n   */\n  private scanComplexOperator(\n    start: number,\n    one: string,\n    twoCode: number,\n    two: string,\n    threeCode?: number,\n    three?: string,\n  ): Token {\n    this.advance();\n    let str: string = one;\n    if (this.peek == twoCode) {\n      this.advance();\n      str += two;\n    }\n    if (threeCode != null && this.peek == threeCode) {\n      this.advance();\n      str += three;\n    }\n    return newOperatorToken(start, this.index, str);\n  }\n\n  private scanIdentifier(): Token {\n    const start: number = this.index;\n    this.advance();\n    while (isIdentifierPart(this.peek)) this.advance();\n    const str: string = this.input.substring(start, this.index);\n    return KEYWORDS.indexOf(str) > -1\n      ? newKeywordToken(start, this.index, str)\n      : newIdentifierToken(start, this.index, str);\n  }\n\n  /** Scans an ECMAScript private identifier. */\n  private scanPrivateIdentifier(): Token {\n    const start: number = this.index;\n    this.advance();\n    if (!isIdentifierStart(this.peek)) {\n      return this.error('Invalid character [#]', -1);\n    }\n    while (isIdentifierPart(this.peek)) this.advance();\n    const identifierName: string = this.input.substring(start, this.index);\n    return newPrivateIdentifierToken(start, this.index, identifierName);\n  }\n\n  private scanNumber(start: number): Token {\n    let simple = this.index === start;\n    let hasSeparators = false;\n    this.advance(); // Skip initial digit.\n    while (true) {\n      if (chars.isDigit(this.peek)) {\n        // Do nothing.\n      } else if (this.peek === chars.$_) {\n        // Separators are only valid when they're surrounded by digits. E.g. `1_0_1` is\n        // valid while `_101` and `101_` are not. The separator can't be next to the decimal\n        // point or another separator either. Note that it's unlikely that we'll hit a case where\n        // the underscore is at the start, because that's a valid identifier and it will be picked\n        // up earlier in the parsing. We validate for it anyway just in case.\n        if (\n          !chars.isDigit(this.input.charCodeAt(this.index - 1)) ||\n          !chars.isDigit(this.input.charCodeAt(this.index + 1))\n        ) {\n          return this.error('Invalid numeric separator', 0);\n        }\n        hasSeparators = true;\n      } else if (this.peek === chars.$PERIOD) {\n        simple = false;\n      } else if (isExponentStart(this.peek)) {\n        this.advance();\n        if (isExponentSign(this.peek)) this.advance();\n        if (!chars.isDigit(this.peek)) return this.error('Invalid exponent', -1);\n        simple = false;\n      } else {\n        break;\n      }\n      this.advance();\n    }\n\n    let str = this.input.substring(start, this.index);\n    if (hasSeparators) {\n      str = str.replace(/_/g, '');\n    }\n    const value = simple ? parseIntAutoRadix(str) : parseFloat(str);\n    return newNumberToken(start, this.index, value);\n  }\n\n  private scanString(): Token {\n    const start = this.index;\n    const quote = this.peek;\n    this.advance(); // Skip initial quote.\n\n    let buffer = '';\n    let marker = this.index;\n    const input = this.input;\n\n    while (this.peek != quote) {\n      if (this.peek == chars.$BACKSLASH) {\n        const result = this.scanStringBackslash(buffer, marker);\n        if (typeof result !== 'string') {\n          return result; // Error\n        }\n        buffer = result;\n        marker = this.index;\n      } else if (this.peek == chars.$EOF) {\n        return this.error('Unterminated quote', 0);\n      } else {\n        this.advance();\n      }\n    }\n\n    const last: string = input.substring(marker, this.index);\n    this.advance(); // Skip terminating quote.\n\n    return new StringToken(start, this.index, buffer + last, StringTokenKind.Plain);\n  }\n\n  private scanQuestion(start: number): Token {\n    this.advance();\n    let operator = '?';\n    // `a ?? b` or `a ??= b`.\n    if (this.peek === chars.$QUESTION) {\n      operator += '?';\n      this.advance();\n\n      // @ts-expect-error\n      if (this.peek === chars.$EQ) {\n        operator += '=';\n        this.advance();\n      }\n    } else if (this.peek === chars.$PERIOD) {\n      // `a?.b`\n      operator += '.';\n      this.advance();\n    }\n    return newOperatorToken(start, this.index, operator);\n  }\n\n  private scanTemplateLiteralPart(start: number): Token {\n    let buffer = '';\n    let marker = this.index;\n\n    while (this.peek !== chars.$BT) {\n      if (this.peek === chars.$BACKSLASH) {\n        const result = this.scanStringBackslash(buffer, marker);\n        if (typeof result !== 'string') {\n          return result; // Error\n        }\n        buffer = result;\n        marker = this.index;\n      } else if (this.peek === chars.$$) {\n        const dollar = this.index;\n        this.advance();\n\n        // @ts-expect-error\n        if (this.peek === chars.$LBRACE) {\n          this.braceStack.push('interpolation');\n          this.tokens.push(\n            new StringToken(\n              start,\n              dollar,\n              buffer + this.input.substring(marker, dollar),\n              StringTokenKind.TemplateLiteralPart,\n            ),\n          );\n          this.advance();\n          return newOperatorToken(dollar, this.index, this.input.substring(dollar, this.index));\n        }\n      } else if (this.peek === chars.$EOF) {\n        return this.error('Unterminated template literal', 0);\n      } else {\n        this.advance();\n      }\n    }\n\n    const last = this.input.substring(marker, this.index);\n    this.advance();\n    return new StringToken(start, this.index, buffer + last, StringTokenKind.TemplateLiteralEnd);\n  }\n\n  private error(message: string, offset: number): Token & {type: TokenType.Error} {\n    const position: number = this.index + offset;\n    return newErrorToken(\n      position,\n      this.index,\n      `Lexer Error: ${message} at column ${position} in expression [${this.input}]`,\n    ) as Token & {type: TokenType.Error};\n  }\n\n  private scanStringBackslash(\n    buffer: string,\n    marker: number,\n  ): string | (Token & {type: TokenType.Error}) {\n    buffer += this.input.substring(marker, this.index);\n    let unescapedCode: number;\n    this.advance();\n    if (this.peek === chars.$u) {\n      // 4 character hex code for unicode character.\n      const hex: string = this.input.substring(this.index + 1, this.index + 5);\n      if (/^[0-9a-f]+$/i.test(hex)) {\n        unescapedCode = parseInt(hex, 16);\n      } else {\n        return this.error(`Invalid unicode escape [\\\\u${hex}]`, 0);\n      }\n      for (let i = 0; i < 5; i++) {\n        this.advance();\n      }\n    } else {\n      unescapedCode = unescape(this.peek);\n      this.advance();\n    }\n    buffer += String.fromCharCode(unescapedCode);\n    return buffer;\n  }\n\n  private scanStar(start: number): Token {\n    this.advance();\n    // `*`, `**`, `**=` or `*=`\n    let operator = '*';\n\n    if (this.peek === chars.$STAR) {\n      operator += '*';\n      this.advance();\n\n      // @ts-expect-error\n      if (this.peek === chars.$EQ) {\n        operator += '=';\n        this.advance();\n      }\n    } else if (this.peek === chars.$EQ) {\n      operator += '=';\n      this.advance();\n    }\n\n    return newOperatorToken(start, this.index, operator);\n  }\n}\n\nfunction isIdentifierStart(code: number): boolean {\n  return (\n    (chars.$a <= code && code <= chars.$z) ||\n    (chars.$A <= code && code <= chars.$Z) ||\n    code == chars.$_ ||\n    code == chars.$$\n  );\n}\n\nfunction isIdentifierPart(code: number): boolean {\n  return chars.isAsciiLetter(code) || chars.isDigit(code) || code == chars.$_ || code == chars.$$;\n}\n\nfunction isExponentStart(code: number): boolean {\n  return code == chars.$e || code == chars.$E;\n}\n\nfunction isExponentSign(code: number): boolean {\n  return code == chars.$MINUS || code == chars.$PLUS;\n}\n\nfunction unescape(code: number): number {\n  switch (code) {\n    case chars.$n:\n      return chars.$LF;\n    case chars.$f:\n      return chars.$FF;\n    case chars.$r:\n      return chars.$CR;\n    case chars.$t:\n      return chars.$TAB;\n    case chars.$v:\n      return chars.$VTAB;\n    default:\n      return code;\n  }\n}\n\nfunction parseIntAutoRadix(text: string): number {\n  const result: number = parseInt(text);\n  if (isNaN(result)) {\n    throw new Error('Invalid integer literal when parsing ' + text);\n  }\n  return result;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as chars from '../chars';\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from '../ml_parser/defaults';\nimport {\n  InterpolatedAttributeToken,\n  InterpolatedTextToken,\n  TokenType as MlParserTokenType,\n} from '../ml_parser/tokens';\nimport {ParseError, ParseSourceSpan} from '../parse_util';\n\nimport {\n  AbsoluteSourceSpan,\n  AST,\n  ASTWithSource,\n  Binary,\n  BindingPipe,\n  BindingPipeType,\n  Call,\n  Chain,\n  Conditional,\n  EmptyExpr,\n  ExpressionBinding,\n  ImplicitReceiver,\n  Interpolation,\n  KeyedRead,\n  LiteralArray,\n  LiteralMap,\n  LiteralMapKey,\n  LiteralPrimitive,\n  NonNullAssert,\n  ParenthesizedExpression,\n  ParseSpan,\n  PrefixNot,\n  PropertyRead,\n  RecursiveAstVisitor,\n  SafeCall,\n  SafeKeyedRead,\n  SafePropertyRead,\n  TaggedTemplateLiteral,\n  TemplateBinding,\n  TemplateBindingIdentifier,\n  TemplateLiteral,\n  TemplateLiteralElement,\n  ThisReceiver,\n  TypeofExpression,\n  Unary,\n  VariableBinding,\n  VoidExpression,\n} from './ast';\nimport {EOF, Lexer, StringTokenKind, Token, TokenType} from './lexer';\nexport interface InterpolationPiece {\n  text: string;\n  start: number;\n  end: number;\n}\nexport class SplitInterpolation {\n  constructor(\n    public strings: InterpolationPiece[],\n    public expressions: InterpolationPiece[],\n    public offsets: number[],\n  ) {}\n}\n\nexport class TemplateBindingParseResult {\n  constructor(\n    public templateBindings: TemplateBinding[],\n    public warnings: string[],\n    public errors: ParseError[],\n  ) {}\n}\n\n/**\n * Represents the possible parse modes to be used as a bitmask.\n */\nexport const enum ParseFlags {\n  None = 0,\n\n  /**\n   * Whether an output binding is being parsed.\n   */\n  Action = 1 << 0,\n}\n\nfunction getLocation(span: ParseSourceSpan): string {\n  return span.start.toString() || '(unknown)';\n}\n\nexport class Parser {\n  constructor(\n    private readonly _lexer: Lexer,\n    private readonly _supportsDirectPipeReferences = false,\n  ) {}\n\n  parseAction(\n    input: string,\n    parseSourceSpan: ParseSourceSpan,\n    absoluteOffset: number,\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG,\n  ): ASTWithSource {\n    const errors: ParseError[] = [];\n    this._checkNoInterpolation(errors, input, parseSourceSpan, interpolationConfig);\n    const {stripped: sourceToLex} = this._stripComments(input);\n    const tokens = this._lexer.tokenize(sourceToLex);\n    const ast = new _ParseAST(\n      input,\n      parseSourceSpan,\n      absoluteOffset,\n      tokens,\n      ParseFlags.Action,\n      errors,\n      0,\n      this._supportsDirectPipeReferences,\n    ).parseChain();\n\n    return new ASTWithSource(ast, input, getLocation(parseSourceSpan), absoluteOffset, errors);\n  }\n\n  parseBinding(\n    input: string,\n    parseSourceSpan: ParseSourceSpan,\n    absoluteOffset: number,\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG,\n  ): ASTWithSource {\n    const errors: ParseError[] = [];\n    const ast = this._parseBindingAst(\n      input,\n      parseSourceSpan,\n      absoluteOffset,\n      interpolationConfig,\n      errors,\n    );\n    return new ASTWithSource(ast, input, getLocation(parseSourceSpan), absoluteOffset, errors);\n  }\n\n  private checkSimpleExpression(ast: AST): string[] {\n    const checker = new SimpleExpressionChecker();\n    ast.visit(checker);\n    return checker.errors;\n  }\n\n  // Host bindings parsed here\n  parseSimpleBinding(\n    input: string,\n    parseSourceSpan: ParseSourceSpan,\n    absoluteOffset: number,\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG,\n  ): ASTWithSource {\n    const errors: ParseError[] = [];\n    const ast = this._parseBindingAst(\n      input,\n      parseSourceSpan,\n      absoluteOffset,\n      interpolationConfig,\n      errors,\n    );\n    const simplExpressionErrors = this.checkSimpleExpression(ast);\n\n    if (simplExpressionErrors.length > 0) {\n      errors.push(\n        getParseError(\n          `Host binding expression cannot contain ${simplExpressionErrors.join(' ')}`,\n          input,\n          '',\n          parseSourceSpan,\n        ),\n      );\n    }\n    return new ASTWithSource(ast, input, getLocation(parseSourceSpan), absoluteOffset, errors);\n  }\n\n  private _parseBindingAst(\n    input: string,\n    parseSourceSpan: ParseSourceSpan,\n    absoluteOffset: number,\n    interpolationConfig: InterpolationConfig,\n    errors: ParseError[],\n  ): AST {\n    this._checkNoInterpolation(errors, input, parseSourceSpan, interpolationConfig);\n    const {stripped: sourceToLex} = this._stripComments(input);\n    const tokens = this._lexer.tokenize(sourceToLex);\n    return new _ParseAST(\n      input,\n      parseSourceSpan,\n      absoluteOffset,\n      tokens,\n      ParseFlags.None,\n      errors,\n      0,\n      this._supportsDirectPipeReferences,\n    ).parseChain();\n  }\n\n  /**\n   * Parse microsyntax template expression and return a list of bindings or\n   * parsing errors in case the given expression is invalid.\n   *\n   * For example,\n   * ```html\n   *   <div *ngFor=\"let item of items\">\n   *         ^      ^ absoluteValueOffset for `templateValue`\n   *         absoluteKeyOffset for `templateKey`\n   * ```\n   * contains three bindings:\n   * 1. ngFor -> null\n   * 2. item -> NgForOfContext.$implicit\n   * 3. ngForOf -> items\n   *\n   * This is apparent from the de-sugared template:\n   * ```html\n   *   <ng-template ngFor let-item [ngForOf]=\"items\">\n   * ```\n   *\n   * @param templateKey name of directive, without the * prefix. For example: ngIf, ngFor\n   * @param templateValue RHS of the microsyntax attribute\n   * @param templateUrl template filename if it's external, component filename if it's inline\n   * @param absoluteKeyOffset start of the `templateKey`\n   * @param absoluteValueOffset start of the `templateValue`\n   */\n  parseTemplateBindings(\n    templateKey: string,\n    templateValue: string,\n    parseSourceSpan: ParseSourceSpan,\n    absoluteKeyOffset: number,\n    absoluteValueOffset: number,\n  ): TemplateBindingParseResult {\n    const tokens = this._lexer.tokenize(templateValue);\n    const errors: ParseError[] = [];\n    const parser = new _ParseAST(\n      templateValue,\n      parseSourceSpan,\n      absoluteValueOffset,\n      tokens,\n      ParseFlags.None,\n      errors,\n      0 /* relative offset */,\n      this._supportsDirectPipeReferences,\n    );\n    return parser.parseTemplateBindings({\n      source: templateKey,\n      span: new AbsoluteSourceSpan(absoluteKeyOffset, absoluteKeyOffset + templateKey.length),\n    });\n  }\n\n  parseInterpolation(\n    input: string,\n    parseSourceSpan: ParseSourceSpan,\n    absoluteOffset: number,\n    interpolatedTokens: InterpolatedAttributeToken[] | InterpolatedTextToken[] | null,\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG,\n  ): ASTWithSource | null {\n    const errors: ParseError[] = [];\n    const {strings, expressions, offsets} = this.splitInterpolation(\n      input,\n      parseSourceSpan,\n      errors,\n      interpolatedTokens,\n      interpolationConfig,\n    );\n    if (expressions.length === 0) return null;\n\n    const expressionNodes: AST[] = [];\n\n    for (let i = 0; i < expressions.length; ++i) {\n      // If we have a token for the specific expression, it's preferrable to use it because it\n      // allows us to produce more accurate error messages. The expressions are always at the odd\n      // indexes inside the tokens.\n      const expressionSpan = interpolatedTokens?.[i * 2 + 1]?.sourceSpan;\n      const expressionText = expressions[i].text;\n      const {stripped: sourceToLex, hasComments} = this._stripComments(expressionText);\n      const tokens = this._lexer.tokenize(sourceToLex);\n\n      if (hasComments && sourceToLex.trim().length === 0 && tokens.length === 0) {\n        // Empty expressions error are handled futher down, here we only take care of the comment case\n        errors.push(\n          getParseError(\n            'Interpolation expression cannot only contain a comment',\n            input,\n            `at column ${expressions[i].start} in`,\n            parseSourceSpan,\n          ),\n        );\n        continue;\n      }\n\n      const ast = new _ParseAST(\n        expressionSpan ? expressionText : input,\n        expressionSpan || parseSourceSpan,\n        absoluteOffset,\n        tokens,\n        ParseFlags.None,\n        errors,\n        offsets[i],\n        this._supportsDirectPipeReferences,\n      ).parseChain();\n      expressionNodes.push(ast);\n    }\n\n    return this.createInterpolationAst(\n      strings.map((s) => s.text),\n      expressionNodes,\n      input,\n      getLocation(parseSourceSpan),\n      absoluteOffset,\n      errors,\n    );\n  }\n\n  /**\n   * Similar to `parseInterpolation`, but treats the provided string as a single expression\n   * element that would normally appear within the interpolation prefix and suffix (`{{` and `}}`).\n   * This is used for parsing the switch expression in ICUs.\n   */\n  parseInterpolationExpression(\n    expression: string,\n    parseSourceSpan: ParseSourceSpan,\n    absoluteOffset: number,\n  ): ASTWithSource {\n    const {stripped: sourceToLex} = this._stripComments(expression);\n    const tokens = this._lexer.tokenize(sourceToLex);\n    const errors: ParseError[] = [];\n    const ast = new _ParseAST(\n      expression,\n      parseSourceSpan,\n      absoluteOffset,\n      tokens,\n      ParseFlags.None,\n      errors,\n      0,\n      this._supportsDirectPipeReferences,\n    ).parseChain();\n    const strings = ['', '']; // The prefix and suffix strings are both empty\n    return this.createInterpolationAst(\n      strings,\n      [ast],\n      expression,\n      getLocation(parseSourceSpan),\n      absoluteOffset,\n      errors,\n    );\n  }\n\n  private createInterpolationAst(\n    strings: string[],\n    expressions: AST[],\n    input: string,\n    location: string,\n    absoluteOffset: number,\n    errors: ParseError[],\n  ): ASTWithSource {\n    const span = new ParseSpan(0, input.length);\n    const interpolation = new Interpolation(\n      span,\n      span.toAbsolute(absoluteOffset),\n      strings,\n      expressions,\n    );\n    return new ASTWithSource(interpolation, input, location, absoluteOffset, errors);\n  }\n\n  /**\n   * Splits a string of text into \"raw\" text segments and expressions present in interpolations in\n   * the string.\n   * Returns `null` if there are no interpolations, otherwise a\n   * `SplitInterpolation` with splits that look like\n   *   <raw text> <expression> <raw text> ... <raw text> <expression> <raw text>\n   */\n  splitInterpolation(\n    input: string,\n    parseSourceSpan: ParseSourceSpan,\n    errors: ParseError[],\n    interpolatedTokens: InterpolatedAttributeToken[] | InterpolatedTextToken[] | null,\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG,\n  ): SplitInterpolation {\n    const strings: InterpolationPiece[] = [];\n    const expressions: InterpolationPiece[] = [];\n    const offsets: number[] = [];\n    const inputToTemplateIndexMap = interpolatedTokens\n      ? getIndexMapForOriginalTemplate(interpolatedTokens)\n      : null;\n    let i = 0;\n    let atInterpolation = false;\n    let extendLastString = false;\n    let {start: interpStart, end: interpEnd} = interpolationConfig;\n    while (i < input.length) {\n      if (!atInterpolation) {\n        // parse until starting {{\n        const start = i;\n        i = input.indexOf(interpStart, i);\n        if (i === -1) {\n          i = input.length;\n        }\n        const text = input.substring(start, i);\n        strings.push({text, start, end: i});\n\n        atInterpolation = true;\n      } else {\n        // parse from starting {{ to ending }} while ignoring content inside quotes.\n        const fullStart = i;\n        const exprStart = fullStart + interpStart.length;\n        const exprEnd = this._getInterpolationEndIndex(input, interpEnd, exprStart);\n        if (exprEnd === -1) {\n          // Could not find the end of the interpolation; do not parse an expression.\n          // Instead we should extend the content on the last raw string.\n          atInterpolation = false;\n          extendLastString = true;\n          break;\n        }\n        const fullEnd = exprEnd + interpEnd.length;\n\n        const text = input.substring(exprStart, exprEnd);\n        if (text.trim().length === 0) {\n          errors.push(\n            getParseError(\n              'Blank expressions are not allowed in interpolated strings',\n              input,\n              `at column ${i} in`,\n              parseSourceSpan,\n            ),\n          );\n        }\n        expressions.push({text, start: fullStart, end: fullEnd});\n        const startInOriginalTemplate = inputToTemplateIndexMap?.get(fullStart) ?? fullStart;\n        const offset = startInOriginalTemplate + interpStart.length;\n        offsets.push(offset);\n\n        i = fullEnd;\n        atInterpolation = false;\n      }\n    }\n    if (!atInterpolation) {\n      // If we are now at a text section, add the remaining content as a raw string.\n      if (extendLastString) {\n        const piece = strings[strings.length - 1];\n        piece.text += input.substring(i);\n        piece.end = input.length;\n      } else {\n        strings.push({text: input.substring(i), start: i, end: input.length});\n      }\n    }\n    return new SplitInterpolation(strings, expressions, offsets);\n  }\n\n  wrapLiteralPrimitive(\n    input: string | null,\n    sourceSpanOrLocation: ParseSourceSpan | string,\n    absoluteOffset: number,\n  ): ASTWithSource {\n    const span = new ParseSpan(0, input == null ? 0 : input.length);\n    return new ASTWithSource(\n      new LiteralPrimitive(span, span.toAbsolute(absoluteOffset), input),\n      input,\n      typeof sourceSpanOrLocation === 'string'\n        ? sourceSpanOrLocation\n        : getLocation(sourceSpanOrLocation),\n      absoluteOffset,\n      [],\n    );\n  }\n\n  private _stripComments(input: string): {stripped: string; hasComments: boolean} {\n    const i = this._commentStart(input);\n    return i != null\n      ? {stripped: input.substring(0, i), hasComments: true}\n      : {stripped: input, hasComments: false};\n  }\n\n  private _commentStart(input: string): number | null {\n    let outerQuote: number | null = null;\n    for (let i = 0; i < input.length - 1; i++) {\n      const char = input.charCodeAt(i);\n      const nextChar = input.charCodeAt(i + 1);\n\n      if (char === chars.$SLASH && nextChar == chars.$SLASH && outerQuote == null) return i;\n\n      if (outerQuote === char) {\n        outerQuote = null;\n      } else if (outerQuote == null && chars.isQuote(char)) {\n        outerQuote = char;\n      }\n    }\n    return null;\n  }\n\n  private _checkNoInterpolation(\n    errors: ParseError[],\n    input: string,\n    parseSourceSpan: ParseSourceSpan,\n    {start, end}: InterpolationConfig,\n  ): void {\n    let startIndex = -1;\n    let endIndex = -1;\n\n    for (const charIndex of this._forEachUnquotedChar(input, 0)) {\n      if (startIndex === -1) {\n        if (input.startsWith(start)) {\n          startIndex = charIndex;\n        }\n      } else {\n        endIndex = this._getInterpolationEndIndex(input, end, charIndex);\n        if (endIndex > -1) {\n          break;\n        }\n      }\n    }\n\n    if (startIndex > -1 && endIndex > -1) {\n      errors.push(\n        getParseError(\n          `Got interpolation (${start}${end}) where expression was expected`,\n          input,\n          `at column ${startIndex} in`,\n          parseSourceSpan,\n        ),\n      );\n    }\n  }\n\n  /**\n   * Finds the index of the end of an interpolation expression\n   * while ignoring comments and quoted content.\n   */\n  private _getInterpolationEndIndex(input: string, expressionEnd: string, start: number): number {\n    for (const charIndex of this._forEachUnquotedChar(input, start)) {\n      if (input.startsWith(expressionEnd, charIndex)) {\n        return charIndex;\n      }\n\n      // Nothing else in the expression matters after we've\n      // hit a comment so look directly for the end token.\n      if (input.startsWith('//', charIndex)) {\n        return input.indexOf(expressionEnd, charIndex);\n      }\n    }\n\n    return -1;\n  }\n\n  /**\n   * Generator used to iterate over the character indexes of a string that are outside of quotes.\n   * @param input String to loop through.\n   * @param start Index within the string at which to start.\n   */\n  private *_forEachUnquotedChar(input: string, start: number) {\n    let currentQuote: string | null = null;\n    let escapeCount = 0;\n    for (let i = start; i < input.length; i++) {\n      const char = input[i];\n      // Skip the characters inside quotes. Note that we only care about the outer-most\n      // quotes matching up and we need to account for escape characters.\n      if (\n        chars.isQuote(input.charCodeAt(i)) &&\n        (currentQuote === null || currentQuote === char) &&\n        escapeCount % 2 === 0\n      ) {\n        currentQuote = currentQuote === null ? char : null;\n      } else if (currentQuote === null) {\n        yield i;\n      }\n      escapeCount = char === '\\\\' ? escapeCount + 1 : 0;\n    }\n  }\n}\n\n/** Describes a stateful context an expression parser is in. */\nenum ParseContextFlags {\n  None = 0,\n  /**\n   * A Writable context is one in which a value may be written to an lvalue.\n   * For example, after we see a property access, we may expect a write to the\n   * property via the \"=\" operator.\n   *   prop\n   *        ^ possible \"=\" after\n   */\n  Writable = 1,\n}\n\nclass _ParseAST {\n  private rparensExpected = 0;\n  private rbracketsExpected = 0;\n  private rbracesExpected = 0;\n  private context = ParseContextFlags.None;\n\n  // Cache of expression start and input indeces to the absolute source span they map to, used to\n  // prevent creating superfluous source spans in `sourceSpan`.\n  // A serial of the expression start and input index is used for mapping because both are stateful\n  // and may change for subsequent expressions visited by the parser.\n  private sourceSpanCache = new Map<string, AbsoluteSourceSpan>();\n\n  private index: number = 0;\n\n  constructor(\n    private input: string,\n    private parseSourceSpan: ParseSourceSpan,\n    private absoluteOffset: number,\n    private tokens: Token[],\n    private parseFlags: ParseFlags,\n    private errors: ParseError[],\n    private offset: number,\n    private supportsDirectPipeReferences: boolean,\n  ) {}\n\n  private peek(offset: number): Token {\n    const i = this.index + offset;\n    return i < this.tokens.length ? this.tokens[i] : EOF;\n  }\n\n  private get next(): Token {\n    return this.peek(0);\n  }\n\n  /** Whether all the parser input has been processed. */\n  private get atEOF(): boolean {\n    return this.index >= this.tokens.length;\n  }\n\n  /**\n   * Index of the next token to be processed, or the end of the last token if all have been\n   * processed.\n   */\n  private get inputIndex(): number {\n    return this.atEOF ? this.currentEndIndex : this.next.index + this.offset;\n  }\n\n  /**\n   * End index of the last processed token, or the start of the first token if none have been\n   * processed.\n   */\n  private get currentEndIndex(): number {\n    if (this.index > 0) {\n      const curToken = this.peek(-1);\n      return curToken.end + this.offset;\n    }\n    // No tokens have been processed yet; return the next token's start or the length of the input\n    // if there is no token.\n    if (this.tokens.length === 0) {\n      return this.input.length + this.offset;\n    }\n    return this.next.index + this.offset;\n  }\n\n  /**\n   * Returns the absolute offset of the start of the current token.\n   */\n  private get currentAbsoluteOffset(): number {\n    return this.absoluteOffset + this.inputIndex;\n  }\n\n  /**\n   * Retrieve a `ParseSpan` from `start` to the current position (or to `artificialEndIndex` if\n   * provided).\n   *\n   * @param start Position from which the `ParseSpan` will start.\n   * @param artificialEndIndex Optional ending index to be used if provided (and if greater than the\n   *     natural ending index)\n   */\n  private span(start: number, artificialEndIndex?: number): ParseSpan {\n    let endIndex = this.currentEndIndex;\n    if (artificialEndIndex !== undefined && artificialEndIndex > this.currentEndIndex) {\n      endIndex = artificialEndIndex;\n    }\n\n    // In some unusual parsing scenarios (like when certain tokens are missing and an `EmptyExpr` is\n    // being created), the current token may already be advanced beyond the `currentEndIndex`. This\n    // appears to be a deep-seated parser bug.\n    //\n    // As a workaround for now, swap the start and end indices to ensure a valid `ParseSpan`.\n    // TODO(alxhub): fix the bug upstream in the parser state, and remove this workaround.\n    if (start > endIndex) {\n      const tmp = endIndex;\n      endIndex = start;\n      start = tmp;\n    }\n\n    return new ParseSpan(start, endIndex);\n  }\n\n  private sourceSpan(start: number, artificialEndIndex?: number): AbsoluteSourceSpan {\n    const serial = `${start}@${this.inputIndex}:${artificialEndIndex}`;\n    if (!this.sourceSpanCache.has(serial)) {\n      this.sourceSpanCache.set(\n        serial,\n        this.span(start, artificialEndIndex).toAbsolute(this.absoluteOffset),\n      );\n    }\n    return this.sourceSpanCache.get(serial)!;\n  }\n\n  private advance() {\n    this.index++;\n  }\n\n  /**\n   * Executes a callback in the provided context.\n   */\n  private withContext<T>(context: ParseContextFlags, cb: () => T): T {\n    this.context |= context;\n    const ret = cb();\n    this.context ^= context;\n    return ret;\n  }\n\n  private consumeOptionalCharacter(code: number): boolean {\n    if (this.next.isCharacter(code)) {\n      this.advance();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  private peekKeywordLet(): boolean {\n    return this.next.isKeywordLet();\n  }\n\n  private peekKeywordAs(): boolean {\n    return this.next.isKeywordAs();\n  }\n\n  /**\n   * Consumes an expected character, otherwise emits an error about the missing expected character\n   * and skips over the token stream until reaching a recoverable point.\n   *\n   * See `this.error` and `this.skip` for more details.\n   */\n  private expectCharacter(code: number) {\n    if (this.consumeOptionalCharacter(code)) return;\n    this.error(`Missing expected ${String.fromCharCode(code)}`);\n  }\n\n  private consumeOptionalOperator(op: string): boolean {\n    if (this.next.isOperator(op)) {\n      this.advance();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  private isAssignmentOperator(token: Token): boolean {\n    return token.type === TokenType.Operator && Binary.isAssignmentOperation(token.strValue);\n  }\n\n  private expectOperator(operator: string) {\n    if (this.consumeOptionalOperator(operator)) return;\n    this.error(`Missing expected operator ${operator}`);\n  }\n\n  private prettyPrintToken(tok: Token): string {\n    return tok === EOF ? 'end of input' : `token ${tok}`;\n  }\n\n  private expectIdentifierOrKeyword(): string | null {\n    const n = this.next;\n    if (!n.isIdentifier() && !n.isKeyword()) {\n      if (n.isPrivateIdentifier()) {\n        this._reportErrorForPrivateIdentifier(n, 'expected identifier or keyword');\n      } else {\n        this.error(`Unexpected ${this.prettyPrintToken(n)}, expected identifier or keyword`);\n      }\n      return null;\n    }\n    this.advance();\n    return n.toString() as string;\n  }\n\n  private expectIdentifierOrKeywordOrString(): string {\n    const n = this.next;\n    if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {\n      if (n.isPrivateIdentifier()) {\n        this._reportErrorForPrivateIdentifier(n, 'expected identifier, keyword or string');\n      } else {\n        this.error(\n          `Unexpected ${this.prettyPrintToken(n)}, expected identifier, keyword, or string`,\n        );\n      }\n      return '';\n    }\n    this.advance();\n    return n.toString() as string;\n  }\n\n  parseChain(): AST {\n    const exprs: AST[] = [];\n    const start = this.inputIndex;\n    while (this.index < this.tokens.length) {\n      const expr = this.parsePipe();\n      exprs.push(expr);\n\n      if (this.consumeOptionalCharacter(chars.$SEMICOLON)) {\n        if (!(this.parseFlags & ParseFlags.Action)) {\n          this.error('Binding expression cannot contain chained expression');\n        }\n        while (this.consumeOptionalCharacter(chars.$SEMICOLON)) {} // read all semicolons\n      } else if (this.index < this.tokens.length) {\n        const errorIndex = this.index;\n        this.error(`Unexpected token '${this.next}'`);\n        // The `error` call above will skip ahead to the next recovery point in an attempt to\n        // recover part of the expression, but that might be the token we started from which will\n        // lead to an infinite loop. If that's the case, break the loop assuming that we can't\n        // parse further.\n        if (this.index === errorIndex) {\n          break;\n        }\n      }\n    }\n    if (exprs.length === 0) {\n      // We have no expressions so create an empty expression that spans the entire input length\n      const artificialStart = this.offset;\n      const artificialEnd = this.offset + this.input.length;\n      return new EmptyExpr(\n        this.span(artificialStart, artificialEnd),\n        this.sourceSpan(artificialStart, artificialEnd),\n      );\n    }\n    if (exprs.length == 1) return exprs[0];\n    return new Chain(this.span(start), this.sourceSpan(start), exprs);\n  }\n\n  private parsePipe(): AST {\n    const start = this.inputIndex;\n    let result = this.parseExpression();\n    if (this.consumeOptionalOperator('|')) {\n      if (this.parseFlags & ParseFlags.Action) {\n        this.error(`Cannot have a pipe in an action expression`);\n      }\n\n      do {\n        const nameStart = this.inputIndex;\n        let nameId = this.expectIdentifierOrKeyword();\n        let nameSpan: AbsoluteSourceSpan;\n        let fullSpanEnd: number | undefined = undefined;\n        if (nameId !== null) {\n          nameSpan = this.sourceSpan(nameStart);\n        } else {\n          // No valid identifier was found, so we'll assume an empty pipe name ('').\n          nameId = '';\n\n          // However, there may have been whitespace present between the pipe character and the next\n          // token in the sequence (or the end of input). We want to track this whitespace so that\n          // the `BindingPipe` we produce covers not just the pipe character, but any trailing\n          // whitespace beyond it. Another way of thinking about this is that the zero-length name\n          // is assumed to be at the end of any whitespace beyond the pipe character.\n          //\n          // Therefore, we push the end of the `ParseSpan` for this pipe all the way up to the\n          // beginning of the next token, or until the end of input if the next token is EOF.\n          fullSpanEnd = this.next.index !== -1 ? this.next.index : this.input.length + this.offset;\n\n          // The `nameSpan` for an empty pipe name is zero-length at the end of any whitespace\n          // beyond the pipe character.\n          nameSpan = new ParseSpan(fullSpanEnd, fullSpanEnd).toAbsolute(this.absoluteOffset);\n        }\n\n        const args: AST[] = [];\n        while (this.consumeOptionalCharacter(chars.$COLON)) {\n          args.push(this.parseExpression());\n\n          // If there are additional expressions beyond the name, then the artificial end for the\n          // name is no longer relevant.\n        }\n        let type: BindingPipeType;\n        if (this.supportsDirectPipeReferences) {\n          const charCode = nameId.charCodeAt(0);\n          type =\n            charCode === chars.$_ || (charCode >= chars.$A && charCode <= chars.$Z)\n              ? BindingPipeType.ReferencedDirectly\n              : BindingPipeType.ReferencedByName;\n        } else {\n          type = BindingPipeType.ReferencedByName;\n        }\n\n        result = new BindingPipe(\n          this.span(start),\n          this.sourceSpan(start, fullSpanEnd),\n          result,\n          nameId,\n          args,\n          type,\n          nameSpan,\n        );\n      } while (this.consumeOptionalOperator('|'));\n    }\n\n    return result;\n  }\n\n  private parseExpression(): AST {\n    return this.parseConditional();\n  }\n\n  private parseConditional(): AST {\n    const start = this.inputIndex;\n    const result = this.parseLogicalOr();\n\n    if (this.consumeOptionalOperator('?')) {\n      const yes = this.parsePipe();\n      let no: AST;\n      if (!this.consumeOptionalCharacter(chars.$COLON)) {\n        const end = this.inputIndex;\n        const expression = this.input.substring(start, end);\n        this.error(`Conditional expression ${expression} requires all 3 expressions`);\n        no = new EmptyExpr(this.span(start), this.sourceSpan(start));\n      } else {\n        no = this.parsePipe();\n      }\n      return new Conditional(this.span(start), this.sourceSpan(start), result, yes, no);\n    } else {\n      return result;\n    }\n  }\n\n  private parseLogicalOr(): AST {\n    // '||'\n    const start = this.inputIndex;\n    let result = this.parseLogicalAnd();\n    while (this.consumeOptionalOperator('||')) {\n      const right = this.parseLogicalAnd();\n      result = new Binary(this.span(start), this.sourceSpan(start), '||', result, right);\n    }\n    return result;\n  }\n\n  private parseLogicalAnd(): AST {\n    // '&&'\n    const start = this.inputIndex;\n    let result = this.parseNullishCoalescing();\n    while (this.consumeOptionalOperator('&&')) {\n      const right = this.parseNullishCoalescing();\n      result = new Binary(this.span(start), this.sourceSpan(start), '&&', result, right);\n    }\n    return result;\n  }\n\n  private parseNullishCoalescing(): AST {\n    // '??'\n    const start = this.inputIndex;\n    let result = this.parseEquality();\n    while (this.consumeOptionalOperator('??')) {\n      const right = this.parseEquality();\n      result = new Binary(this.span(start), this.sourceSpan(start), '??', result, right);\n    }\n    return result;\n  }\n\n  private parseEquality(): AST {\n    // '==','!=','===','!=='\n    const start = this.inputIndex;\n    let result = this.parseRelational();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '==':\n        case '===':\n        case '!=':\n        case '!==':\n          this.advance();\n          const right = this.parseRelational();\n          result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  private parseRelational(): AST {\n    // '<', '>', '<=', '>=', 'in'\n    const start = this.inputIndex;\n    let result = this.parseAdditive();\n    while (this.next.type == TokenType.Operator || this.next.isKeywordIn) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '<':\n        case '>':\n        case '<=':\n        case '>=':\n        case 'in':\n          this.advance();\n          const right = this.parseAdditive();\n          result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  private parseAdditive(): AST {\n    // '+', '-'\n    const start = this.inputIndex;\n    let result = this.parseMultiplicative();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '+':\n        case '-':\n          this.advance();\n          let right = this.parseMultiplicative();\n          result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  private parseMultiplicative(): AST {\n    // '*', '%', '/'\n    const start = this.inputIndex;\n    let result = this.parseExponentiation();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '*':\n        case '%':\n        case '/':\n          this.advance();\n          const right = this.parseExponentiation();\n          result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  private parseExponentiation(): AST {\n    // '**'\n    const start = this.inputIndex;\n    let result = this.parsePrefix();\n    while (this.next.type == TokenType.Operator && this.next.strValue === '**') {\n      // This aligns with Javascript semantics which require any unary operator preceeding the\n      // exponentiation operation to be explicitly grouped as either applying to the base or result\n      // of the exponentiation operation.\n      if (\n        result instanceof Unary ||\n        result instanceof PrefixNot ||\n        result instanceof TypeofExpression ||\n        result instanceof VoidExpression\n      ) {\n        this.error(\n          'Unary operator used immediately before exponentiation expression. Parenthesis must be used to disambiguate operator precedence',\n        );\n      }\n      this.advance();\n      const right = this.parseExponentiation();\n      result = new Binary(this.span(start), this.sourceSpan(start), '**', result, right);\n    }\n    return result;\n  }\n\n  private parsePrefix(): AST {\n    if (this.next.type == TokenType.Operator) {\n      const start = this.inputIndex;\n      const operator = this.next.strValue;\n      let result: AST;\n      switch (operator) {\n        case '+':\n          this.advance();\n          result = this.parsePrefix();\n          return Unary.createPlus(this.span(start), this.sourceSpan(start), result);\n        case '-':\n          this.advance();\n          result = this.parsePrefix();\n          return Unary.createMinus(this.span(start), this.sourceSpan(start), result);\n        case '!':\n          this.advance();\n          result = this.parsePrefix();\n          return new PrefixNot(this.span(start), this.sourceSpan(start), result);\n      }\n    } else if (this.next.isKeywordTypeof()) {\n      this.advance();\n      const start = this.inputIndex;\n      let result = this.parsePrefix();\n      return new TypeofExpression(this.span(start), this.sourceSpan(start), result);\n    } else if (this.next.isKeywordVoid()) {\n      this.advance();\n      const start = this.inputIndex;\n      let result = this.parsePrefix();\n      return new VoidExpression(this.span(start), this.sourceSpan(start), result);\n    }\n    return this.parseCallChain();\n  }\n\n  private parseCallChain(): AST {\n    const start = this.inputIndex;\n    let result = this.parsePrimary();\n    while (true) {\n      if (this.consumeOptionalCharacter(chars.$PERIOD)) {\n        result = this.parseAccessMember(result, start, false);\n      } else if (this.consumeOptionalOperator('?.')) {\n        if (this.consumeOptionalCharacter(chars.$LPAREN)) {\n          result = this.parseCall(result, start, true);\n        } else {\n          result = this.consumeOptionalCharacter(chars.$LBRACKET)\n            ? this.parseKeyedReadOrWrite(result, start, true)\n            : this.parseAccessMember(result, start, true);\n        }\n      } else if (this.consumeOptionalCharacter(chars.$LBRACKET)) {\n        result = this.parseKeyedReadOrWrite(result, start, false);\n      } else if (this.consumeOptionalCharacter(chars.$LPAREN)) {\n        result = this.parseCall(result, start, false);\n      } else if (this.consumeOptionalOperator('!')) {\n        result = new NonNullAssert(this.span(start), this.sourceSpan(start), result);\n      } else if (this.next.isTemplateLiteralEnd()) {\n        result = this.parseNoInterpolationTaggedTemplateLiteral(result, start);\n      } else if (this.next.isTemplateLiteralPart()) {\n        result = this.parseTaggedTemplateLiteral(result, start);\n      } else {\n        return result;\n      }\n    }\n  }\n\n  private parsePrimary(): AST {\n    const start = this.inputIndex;\n    if (this.consumeOptionalCharacter(chars.$LPAREN)) {\n      this.rparensExpected++;\n      const result = this.parsePipe();\n      if (!this.consumeOptionalCharacter(chars.$RPAREN)) {\n        this.error('Missing closing parentheses');\n        // Calling into `error` above will attempt to recover up until the next closing paren.\n        // If that's the case, consume it so we can partially recover the expression.\n        this.consumeOptionalCharacter(chars.$RPAREN);\n      }\n      this.rparensExpected--;\n      return new ParenthesizedExpression(this.span(start), this.sourceSpan(start), result);\n    } else if (this.next.isKeywordNull()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), null);\n    } else if (this.next.isKeywordUndefined()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), void 0);\n    } else if (this.next.isKeywordTrue()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), true);\n    } else if (this.next.isKeywordFalse()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), false);\n    } else if (this.next.isKeywordIn()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), 'in');\n    } else if (this.next.isKeywordThis()) {\n      this.advance();\n      return new ThisReceiver(this.span(start), this.sourceSpan(start));\n    } else if (this.consumeOptionalCharacter(chars.$LBRACKET)) {\n      this.rbracketsExpected++;\n      const elements = this.parseExpressionList(chars.$RBRACKET);\n      this.rbracketsExpected--;\n      this.expectCharacter(chars.$RBRACKET);\n      return new LiteralArray(this.span(start), this.sourceSpan(start), elements);\n    } else if (this.next.isCharacter(chars.$LBRACE)) {\n      return this.parseLiteralMap();\n    } else if (this.next.isIdentifier()) {\n      return this.parseAccessMember(\n        new ImplicitReceiver(this.span(start), this.sourceSpan(start)),\n        start,\n        false,\n      );\n    } else if (this.next.isNumber()) {\n      const value = this.next.toNumber();\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), value);\n    } else if (this.next.isTemplateLiteralEnd()) {\n      return this.parseNoInterpolationTemplateLiteral();\n    } else if (this.next.isTemplateLiteralPart()) {\n      return this.parseTemplateLiteral();\n    } else if (this.next.isString() && this.next.kind === StringTokenKind.Plain) {\n      const literalValue = this.next.toString();\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), literalValue);\n    } else if (this.next.isPrivateIdentifier()) {\n      this._reportErrorForPrivateIdentifier(this.next, null);\n      return new EmptyExpr(this.span(start), this.sourceSpan(start));\n    } else if (this.index >= this.tokens.length) {\n      this.error(`Unexpected end of expression: ${this.input}`);\n      return new EmptyExpr(this.span(start), this.sourceSpan(start));\n    } else {\n      this.error(`Unexpected token ${this.next}`);\n      return new EmptyExpr(this.span(start), this.sourceSpan(start));\n    }\n  }\n\n  private parseExpressionList(terminator: number): AST[] {\n    const result: AST[] = [];\n\n    do {\n      if (!this.next.isCharacter(terminator)) {\n        result.push(this.parsePipe());\n      } else {\n        break;\n      }\n    } while (this.consumeOptionalCharacter(chars.$COMMA));\n    return result;\n  }\n\n  private parseLiteralMap(): LiteralMap {\n    const keys: LiteralMapKey[] = [];\n    const values: AST[] = [];\n    const start = this.inputIndex;\n    this.expectCharacter(chars.$LBRACE);\n    if (!this.consumeOptionalCharacter(chars.$RBRACE)) {\n      this.rbracesExpected++;\n      do {\n        const keyStart = this.inputIndex;\n        const quoted = this.next.isString();\n        const key = this.expectIdentifierOrKeywordOrString();\n        const literalMapKey: LiteralMapKey = {key, quoted};\n        keys.push(literalMapKey);\n\n        // Properties with quoted keys can't use the shorthand syntax.\n        if (quoted) {\n          this.expectCharacter(chars.$COLON);\n          values.push(this.parsePipe());\n        } else if (this.consumeOptionalCharacter(chars.$COLON)) {\n          values.push(this.parsePipe());\n        } else {\n          literalMapKey.isShorthandInitialized = true;\n\n          const span = this.span(keyStart);\n          const sourceSpan = this.sourceSpan(keyStart);\n          values.push(\n            new PropertyRead(\n              span,\n              sourceSpan,\n              sourceSpan,\n              new ImplicitReceiver(span, sourceSpan),\n              key,\n            ),\n          );\n        }\n      } while (\n        this.consumeOptionalCharacter(chars.$COMMA) &&\n        !this.next.isCharacter(chars.$RBRACE)\n      );\n      this.rbracesExpected--;\n      this.expectCharacter(chars.$RBRACE);\n    }\n    return new LiteralMap(this.span(start), this.sourceSpan(start), keys, values);\n  }\n\n  private parseAccessMember(readReceiver: AST, start: number, isSafe: boolean): AST {\n    const nameStart = this.inputIndex;\n    const id = this.withContext(ParseContextFlags.Writable, () => {\n      const id = this.expectIdentifierOrKeyword() ?? '';\n      if (id.length === 0) {\n        this.error(`Expected identifier for property access`, readReceiver.span.end);\n      }\n      return id;\n    });\n    const nameSpan = this.sourceSpan(nameStart);\n\n    if (isSafe) {\n      if (this.isAssignmentOperator(this.next)) {\n        this.advance();\n        this.error(\"The '?.' operator cannot be used in the assignment\");\n        return new EmptyExpr(this.span(start), this.sourceSpan(start));\n      } else {\n        return new SafePropertyRead(\n          this.span(start),\n          this.sourceSpan(start),\n          nameSpan,\n          readReceiver,\n          id,\n        );\n      }\n    } else {\n      if (this.isAssignmentOperator(this.next)) {\n        const operation = this.next.strValue;\n\n        if (!(this.parseFlags & ParseFlags.Action)) {\n          this.advance();\n          this.error('Bindings cannot contain assignments');\n          return new EmptyExpr(this.span(start), this.sourceSpan(start));\n        }\n        const receiver = new PropertyRead(\n          this.span(start),\n          this.sourceSpan(start),\n          nameSpan,\n          readReceiver,\n          id,\n        );\n        this.advance();\n        const value = this.parseConditional();\n        return new Binary(this.span(start), this.sourceSpan(start), operation, receiver, value);\n      } else {\n        return new PropertyRead(\n          this.span(start),\n          this.sourceSpan(start),\n          nameSpan,\n          readReceiver,\n          id,\n        );\n      }\n    }\n  }\n\n  private parseCall(receiver: AST, start: number, isSafe: boolean): AST {\n    const argumentStart = this.inputIndex;\n    this.rparensExpected++;\n    const args = this.parseCallArguments();\n    const argumentSpan = this.span(argumentStart, this.inputIndex).toAbsolute(this.absoluteOffset);\n    this.expectCharacter(chars.$RPAREN);\n    this.rparensExpected--;\n    const span = this.span(start);\n    const sourceSpan = this.sourceSpan(start);\n    return isSafe\n      ? new SafeCall(span, sourceSpan, receiver, args, argumentSpan)\n      : new Call(span, sourceSpan, receiver, args, argumentSpan);\n  }\n\n  private parseCallArguments(): BindingPipe[] {\n    if (this.next.isCharacter(chars.$RPAREN)) return [];\n    const positionals: AST[] = [];\n    do {\n      positionals.push(this.parsePipe());\n    } while (this.consumeOptionalCharacter(chars.$COMMA));\n    return positionals as BindingPipe[];\n  }\n\n  /**\n   * Parses an identifier, a keyword, a string with an optional `-` in between,\n   * and returns the string along with its absolute source span.\n   */\n  private expectTemplateBindingKey(): TemplateBindingIdentifier {\n    let result = '';\n    let operatorFound = false;\n    const start = this.currentAbsoluteOffset;\n    do {\n      result += this.expectIdentifierOrKeywordOrString();\n      operatorFound = this.consumeOptionalOperator('-');\n      if (operatorFound) {\n        result += '-';\n      }\n    } while (operatorFound);\n    return {\n      source: result,\n      span: new AbsoluteSourceSpan(start, start + result.length),\n    };\n  }\n\n  /**\n   * Parse microsyntax template expression and return a list of bindings or\n   * parsing errors in case the given expression is invalid.\n   *\n   * For example,\n   * ```html\n   *   <div *ngFor=\"let item of items; index as i; trackBy: func\">\n   * ```\n   * contains five bindings:\n   * 1. ngFor -> null\n   * 2. item -> NgForOfContext.$implicit\n   * 3. ngForOf -> items\n   * 4. i -> NgForOfContext.index\n   * 5. ngForTrackBy -> func\n   *\n   * For a full description of the microsyntax grammar, see\n   * https://gist.github.com/mhevery/d3530294cff2e4a1b3fe15ff75d08855\n   *\n   * @param templateKey name of the microsyntax directive, like ngIf, ngFor,\n   * without the *, along with its absolute span.\n   */\n  parseTemplateBindings(templateKey: TemplateBindingIdentifier): TemplateBindingParseResult {\n    const bindings: TemplateBinding[] = [];\n\n    // The first binding is for the template key itself\n    // In *ngFor=\"let item of items\", key = \"ngFor\", value = null\n    // In *ngIf=\"cond | pipe\", key = \"ngIf\", value = \"cond | pipe\"\n    bindings.push(...this.parseDirectiveKeywordBindings(templateKey));\n\n    while (this.index < this.tokens.length) {\n      // If it starts with 'let', then this must be variable declaration\n      const letBinding = this.parseLetBinding();\n      if (letBinding) {\n        bindings.push(letBinding);\n      } else {\n        // Two possible cases here, either `value \"as\" key` or\n        // \"directive-keyword expression\". We don't know which case, but both\n        // \"value\" and \"directive-keyword\" are template binding key, so consume\n        // the key first.\n        const key = this.expectTemplateBindingKey();\n        // Peek at the next token, if it is \"as\" then this must be variable\n        // declaration.\n        const binding = this.parseAsBinding(key);\n        if (binding) {\n          bindings.push(binding);\n        } else {\n          // Otherwise the key must be a directive keyword, like \"of\". Transform\n          // the key to actual key. Eg. of -> ngForOf, trackBy -> ngForTrackBy\n          key.source =\n            templateKey.source + key.source.charAt(0).toUpperCase() + key.source.substring(1);\n          bindings.push(...this.parseDirectiveKeywordBindings(key));\n        }\n      }\n      this.consumeStatementTerminator();\n    }\n\n    return new TemplateBindingParseResult(bindings, [] /* warnings */, this.errors);\n  }\n\n  private parseKeyedReadOrWrite(receiver: AST, start: number, isSafe: boolean): AST {\n    return this.withContext(ParseContextFlags.Writable, () => {\n      this.rbracketsExpected++;\n      const key = this.parsePipe();\n      if (key instanceof EmptyExpr) {\n        this.error(`Key access cannot be empty`);\n      }\n      this.rbracketsExpected--;\n      this.expectCharacter(chars.$RBRACKET);\n      if (this.isAssignmentOperator(this.next)) {\n        const operation = this.next.strValue;\n\n        if (isSafe) {\n          this.advance();\n          this.error(\"The '?.' operator cannot be used in the assignment\");\n        } else {\n          const binaryReceiver = new KeyedRead(\n            this.span(start),\n            this.sourceSpan(start),\n            receiver,\n            key,\n          );\n          this.advance();\n          const value = this.parseConditional();\n          return new Binary(\n            this.span(start),\n            this.sourceSpan(start),\n            operation,\n            binaryReceiver,\n            value,\n          );\n        }\n      } else {\n        return isSafe\n          ? new SafeKeyedRead(this.span(start), this.sourceSpan(start), receiver, key)\n          : new KeyedRead(this.span(start), this.sourceSpan(start), receiver, key);\n      }\n\n      return new EmptyExpr(this.span(start), this.sourceSpan(start));\n    });\n  }\n\n  /**\n   * Parse a directive keyword, followed by a mandatory expression.\n   * For example, \"of items\", \"trackBy: func\".\n   * The bindings are: ngForOf -> items, ngForTrackBy -> func\n   * There could be an optional \"as\" binding that follows the expression.\n   * For example,\n   * ```\n   *   *ngFor=\"let item of items | slice:0:1 as collection\".\n   *                    ^^ ^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^\n   *               keyword    bound target   optional 'as' binding\n   * ```\n   *\n   * @param key binding key, for example, ngFor, ngIf, ngForOf, along with its\n   * absolute span.\n   */\n  private parseDirectiveKeywordBindings(key: TemplateBindingIdentifier): TemplateBinding[] {\n    const bindings: TemplateBinding[] = [];\n    this.consumeOptionalCharacter(chars.$COLON); // trackBy: trackByFunction\n    const value = this.getDirectiveBoundTarget();\n    let spanEnd = this.currentAbsoluteOffset;\n    // The binding could optionally be followed by \"as\". For example,\n    // *ngIf=\"cond | pipe as x\". In this case, the key in the \"as\" binding\n    // is \"x\" and the value is the template key itself (\"ngIf\"). Note that the\n    // 'key' in the current context now becomes the \"value\" in the next binding.\n    const asBinding = this.parseAsBinding(key);\n    if (!asBinding) {\n      this.consumeStatementTerminator();\n      spanEnd = this.currentAbsoluteOffset;\n    }\n    const sourceSpan = new AbsoluteSourceSpan(key.span.start, spanEnd);\n    bindings.push(new ExpressionBinding(sourceSpan, key, value));\n    if (asBinding) {\n      bindings.push(asBinding);\n    }\n    return bindings;\n  }\n\n  /**\n   * Return the expression AST for the bound target of a directive keyword\n   * binding. For example,\n   * ```\n   *   *ngIf=\"condition | pipe\"\n   *          ^^^^^^^^^^^^^^^^ bound target for \"ngIf\"\n   *   *ngFor=\"let item of items\"\n   *                       ^^^^^ bound target for \"ngForOf\"\n   * ```\n   */\n  private getDirectiveBoundTarget(): ASTWithSource | null {\n    if (this.next === EOF || this.peekKeywordAs() || this.peekKeywordLet()) {\n      return null;\n    }\n    const ast = this.parsePipe(); // example: \"condition | async\"\n    const {start, end} = ast.span;\n    const value = this.input.substring(start, end);\n    return new ASTWithSource(\n      ast,\n      value,\n      getLocation(this.parseSourceSpan),\n      this.absoluteOffset + start,\n      this.errors,\n    );\n  }\n\n  /**\n   * Return the binding for a variable declared using `as`. Note that the order\n   * of the key-value pair in this declaration is reversed. For example,\n   * ```\n   *   *ngFor=\"let item of items; index as i\"\n   *                              ^^^^^    ^\n   *                              value    key\n   * ```\n   *\n   * @param value name of the value in the declaration, \"ngIf\" in the example\n   * above, along with its absolute span.\n   */\n  private parseAsBinding(value: TemplateBindingIdentifier): TemplateBinding | null {\n    if (!this.peekKeywordAs()) {\n      return null;\n    }\n    this.advance(); // consume the 'as' keyword\n    const key = this.expectTemplateBindingKey();\n    this.consumeStatementTerminator();\n    const sourceSpan = new AbsoluteSourceSpan(value.span.start, this.currentAbsoluteOffset);\n    return new VariableBinding(sourceSpan, key, value);\n  }\n\n  /**\n   * Return the binding for a variable declared using `let`. For example,\n   * ```\n   *   *ngFor=\"let item of items; let i=index;\"\n   *           ^^^^^^^^           ^^^^^^^^^^^\n   * ```\n   * In the first binding, `item` is bound to `NgForOfContext.$implicit`.\n   * In the second binding, `i` is bound to `NgForOfContext.index`.\n   */\n  private parseLetBinding(): TemplateBinding | null {\n    if (!this.peekKeywordLet()) {\n      return null;\n    }\n    const spanStart = this.currentAbsoluteOffset;\n    this.advance(); // consume the 'let' keyword\n    const key = this.expectTemplateBindingKey();\n    let value: TemplateBindingIdentifier | null = null;\n    if (this.consumeOptionalOperator('=')) {\n      value = this.expectTemplateBindingKey();\n    }\n    this.consumeStatementTerminator();\n    const sourceSpan = new AbsoluteSourceSpan(spanStart, this.currentAbsoluteOffset);\n    return new VariableBinding(sourceSpan, key, value);\n  }\n\n  private parseNoInterpolationTaggedTemplateLiteral(tag: AST, start: number) {\n    const template = this.parseNoInterpolationTemplateLiteral();\n    return new TaggedTemplateLiteral(this.span(start), this.sourceSpan(start), tag, template);\n  }\n\n  private parseNoInterpolationTemplateLiteral(): TemplateLiteral {\n    const text = this.next.strValue;\n    const start = this.inputIndex;\n    this.advance();\n    const span = this.span(start);\n    const sourceSpan = this.sourceSpan(start);\n    return new TemplateLiteral(\n      span,\n      sourceSpan,\n      [new TemplateLiteralElement(span, sourceSpan, text)],\n      [],\n    );\n  }\n\n  private parseTaggedTemplateLiteral(tag: AST, start: number): AST {\n    const template = this.parseTemplateLiteral();\n    return new TaggedTemplateLiteral(this.span(start), this.sourceSpan(start), tag, template);\n  }\n\n  private parseTemplateLiteral(): TemplateLiteral {\n    const elements: TemplateLiteralElement[] = [];\n    const expressions: AST[] = [];\n    const start = this.inputIndex;\n\n    while (this.next !== EOF) {\n      const token = this.next;\n\n      if (token.isTemplateLiteralPart() || token.isTemplateLiteralEnd()) {\n        const partStart = this.inputIndex;\n        this.advance();\n        elements.push(\n          new TemplateLiteralElement(\n            this.span(partStart),\n            this.sourceSpan(partStart),\n            token.strValue,\n          ),\n        );\n        if (token.isTemplateLiteralEnd()) {\n          break;\n        }\n      } else if (token.isTemplateLiteralInterpolationStart()) {\n        this.advance();\n        this.rbracesExpected++;\n        const expression = this.parsePipe();\n        if (expression instanceof EmptyExpr) {\n          this.error('Template literal interpolation cannot be empty');\n        } else {\n          expressions.push(expression);\n        }\n        this.rbracesExpected--;\n      } else {\n        this.advance();\n      }\n    }\n\n    return new TemplateLiteral(this.span(start), this.sourceSpan(start), elements, expressions);\n  }\n\n  /**\n   * Consume the optional statement terminator: semicolon or comma.\n   */\n  private consumeStatementTerminator() {\n    this.consumeOptionalCharacter(chars.$SEMICOLON) || this.consumeOptionalCharacter(chars.$COMMA);\n  }\n\n  /**\n   * Records an error and skips over the token stream until reaching a recoverable point. See\n   * `this.skip` for more details on token skipping.\n   */\n  private error(message: string, index = this.index) {\n    this.errors.push(\n      getParseError(message, this.input, this.getErrorLocationText(index), this.parseSourceSpan),\n    );\n    this.skip();\n  }\n\n  private getErrorLocationText(index: number) {\n    return index < this.tokens.length\n      ? `at column ${this.tokens[index].index + 1} in`\n      : `at the end of the expression`;\n  }\n\n  /**\n   * Records an error for an unexpected private identifier being discovered.\n   * @param token Token representing a private identifier.\n   * @param extraMessage Optional additional message being appended to the error.\n   */\n  private _reportErrorForPrivateIdentifier(token: Token, extraMessage: string | null) {\n    let errorMessage = `Private identifiers are not supported. Unexpected private identifier: ${token}`;\n    if (extraMessage !== null) {\n      errorMessage += `, ${extraMessage}`;\n    }\n    this.error(errorMessage);\n  }\n\n  /**\n   * Error recovery should skip tokens until it encounters a recovery point.\n   *\n   * The following are treated as unconditional recovery points:\n   *   - end of input\n   *   - ';' (parseChain() is always the root production, and it expects a ';')\n   *   - '|' (since pipes may be chained and each pipe expression may be treated independently)\n   *\n   * The following are conditional recovery points:\n   *   - ')', '}', ']' if one of calling productions is expecting one of these symbols\n   *     - This allows skip() to recover from errors such as '(a.) + 1' allowing more of the AST to\n   *       be retained (it doesn't skip any tokens as the ')' is retained because of the '(' begins\n   *       an '(' <expr> ')' production).\n   *       The recovery points of grouping symbols must be conditional as they must be skipped if\n   *       none of the calling productions are not expecting the closing token else we will never\n   *       make progress in the case of an extraneous group closing symbol (such as a stray ')').\n   *       That is, we skip a closing symbol if we are not in a grouping production.\n   *   - Assignment in a `Writable` context\n   *     - In this context, we are able to recover after seeing the `=` operator, which\n   *       signals the presence of an independent rvalue expression following the `=` operator.\n   *\n   * If a production expects one of these token it increments the corresponding nesting count,\n   * and then decrements it just prior to checking if the token is in the input.\n   */\n  private skip() {\n    let n = this.next;\n    while (\n      this.index < this.tokens.length &&\n      !n.isCharacter(chars.$SEMICOLON) &&\n      !n.isOperator('|') &&\n      (this.rparensExpected <= 0 || !n.isCharacter(chars.$RPAREN)) &&\n      (this.rbracesExpected <= 0 || !n.isCharacter(chars.$RBRACE)) &&\n      (this.rbracketsExpected <= 0 || !n.isCharacter(chars.$RBRACKET)) &&\n      (!(this.context & ParseContextFlags.Writable) || !this.isAssignmentOperator(n))\n    ) {\n      if (this.next.isError()) {\n        this.errors.push(\n          getParseError(\n            this.next.toString()!,\n            this.input,\n            this.getErrorLocationText(this.next.index),\n            this.parseSourceSpan,\n          ),\n        );\n      }\n      this.advance();\n      n = this.next;\n    }\n  }\n}\n\nfunction getParseError(\n  message: string,\n  input: string,\n  locationText: string,\n  parseSourceSpan: ParseSourceSpan,\n) {\n  if (locationText.length > 0) {\n    locationText = ` ${locationText} `;\n  }\n  const location = getLocation(parseSourceSpan);\n  const error = `Parser Error: ${message}${locationText}[${input}] in ${location}`;\n  return new ParseError(parseSourceSpan, error);\n}\n\nclass SimpleExpressionChecker extends RecursiveAstVisitor {\n  errors: string[] = [];\n\n  override visitPipe() {\n    this.errors.push('pipes');\n  }\n}\n/**\n * Computes the real offset in the original template for indexes in an interpolation.\n *\n * Because templates can have encoded HTML entities and the input passed to the parser at this stage\n * of the compiler is the _decoded_ value, we need to compute the real offset using the original\n * encoded values in the interpolated tokens. Note that this is only a special case handling for\n * `MlParserTokenType.ENCODED_ENTITY` token types. All other interpolated tokens are expected to\n * have parts which exactly match the input string for parsing the interpolation.\n *\n * @param interpolatedTokens The tokens for the interpolated value.\n *\n * @returns A map of index locations in the decoded template to indexes in the original template\n */\nfunction getIndexMapForOriginalTemplate(\n  interpolatedTokens: InterpolatedAttributeToken[] | InterpolatedTextToken[],\n): Map<number, number> {\n  let offsetMap = new Map<number, number>();\n  let consumedInOriginalTemplate = 0;\n  let consumedInInput = 0;\n  let tokenIndex = 0;\n  while (tokenIndex < interpolatedTokens.length) {\n    const currentToken = interpolatedTokens[tokenIndex];\n    if (currentToken.type === MlParserTokenType.ENCODED_ENTITY) {\n      const [decoded, encoded] = currentToken.parts;\n      consumedInOriginalTemplate += encoded.length;\n      consumedInInput += decoded.length;\n    } else {\n      const lengthOfParts = currentToken.parts.reduce((sum, current) => sum + current.length, 0);\n      consumedInInput += lengthOfParts;\n      consumedInOriginalTemplate += lengthOfParts;\n    }\n    offsetMap.set(consumedInInput, consumedInOriginalTemplate);\n    tokenIndex++;\n  }\n  return offsetMap;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as expr from './ast';\n\n/** Serializes the given AST into a normalized string format. */\nexport function serialize(expression: expr.ASTWithSource): string {\n  return expression.visit(new SerializeExpressionVisitor());\n}\n\nclass SerializeExpressionVisitor implements expr.AstVisitor {\n  visitUnary(ast: expr.Unary, context: any): string {\n    return `${ast.operator}${ast.expr.visit(this, context)}`;\n  }\n\n  visitBinary(ast: expr.Binary, context: any): string {\n    return `${ast.left.visit(this, context)} ${ast.operation} ${ast.right.visit(this, context)}`;\n  }\n\n  visitChain(ast: expr.Chain, context: any): string {\n    return ast.expressions.map((e) => e.visit(this, context)).join('; ');\n  }\n\n  visitConditional(ast: expr.Conditional, context: any): string {\n    return `${ast.condition.visit(this, context)} ? ${ast.trueExp.visit(\n      this,\n      context,\n    )} : ${ast.falseExp.visit(this, context)}`;\n  }\n\n  visitThisReceiver(): string {\n    return 'this';\n  }\n\n  visitImplicitReceiver(): string {\n    return '';\n  }\n\n  visitInterpolation(ast: expr.Interpolation, context: any): string {\n    return interleave(\n      ast.strings,\n      ast.expressions.map((e) => e.visit(this, context)),\n    ).join('');\n  }\n\n  visitKeyedRead(ast: expr.KeyedRead, context: any): string {\n    return `${ast.receiver.visit(this, context)}[${ast.key.visit(this, context)}]`;\n  }\n\n  visitLiteralArray(ast: expr.LiteralArray, context: any): string {\n    return `[${ast.expressions.map((e) => e.visit(this, context)).join(', ')}]`;\n  }\n\n  visitLiteralMap(ast: expr.LiteralMap, context: any): string {\n    return `{${zip(\n      ast.keys.map((literal) => (literal.quoted ? `'${literal.key}'` : literal.key)),\n      ast.values.map((value) => value.visit(this, context)),\n    )\n      .map(([key, value]) => `${key}: ${value}`)\n      .join(', ')}}`;\n  }\n\n  visitLiteralPrimitive(ast: expr.LiteralPrimitive): string {\n    if (ast.value === null) return 'null';\n\n    switch (typeof ast.value) {\n      case 'number':\n      case 'boolean':\n        return ast.value.toString();\n      case 'undefined':\n        return 'undefined';\n      case 'string':\n        return `'${ast.value.replace(/'/g, `\\\\'`)}'`;\n      default:\n        throw new Error(`Unsupported primitive type: ${ast.value}`);\n    }\n  }\n\n  visitPipe(ast: expr.BindingPipe, context: any): string {\n    return `${ast.exp.visit(this, context)} | ${ast.name}`;\n  }\n\n  visitPrefixNot(ast: expr.PrefixNot, context: any): string {\n    return `!${ast.expression.visit(this, context)}`;\n  }\n\n  visitNonNullAssert(ast: expr.NonNullAssert, context: any): string {\n    return `${ast.expression.visit(this, context)}!`;\n  }\n\n  visitPropertyRead(ast: expr.PropertyRead, context: any): string {\n    if (ast.receiver instanceof expr.ImplicitReceiver) {\n      return ast.name;\n    } else {\n      return `${ast.receiver.visit(this, context)}.${ast.name}`;\n    }\n  }\n\n  visitSafePropertyRead(ast: expr.SafePropertyRead, context: any): string {\n    return `${ast.receiver.visit(this, context)}?.${ast.name}`;\n  }\n\n  visitSafeKeyedRead(ast: expr.SafeKeyedRead, context: any): string {\n    return `${ast.receiver.visit(this, context)}?.[${ast.key.visit(this, context)}]`;\n  }\n\n  visitCall(ast: expr.Call, context: any): string {\n    return `${ast.receiver.visit(this, context)}(${ast.args\n      .map((e) => e.visit(this, context))\n      .join(', ')})`;\n  }\n\n  visitSafeCall(ast: expr.SafeCall, context: any): string {\n    return `${ast.receiver.visit(this, context)}?.(${ast.args\n      .map((e) => e.visit(this, context))\n      .join(', ')})`;\n  }\n\n  visitTypeofExpression(ast: expr.TypeofExpression, context: any) {\n    return `typeof ${ast.expression.visit(this, context)}`;\n  }\n\n  visitVoidExpression(ast: expr.VoidExpression, context: any) {\n    return `void ${ast.expression.visit(this, context)}`;\n  }\n\n  visitASTWithSource(ast: expr.ASTWithSource, context: any): string {\n    return ast.ast.visit(this, context);\n  }\n\n  visitTemplateLiteral(ast: expr.TemplateLiteral, context: any) {\n    let result = '';\n    for (let i = 0; i < ast.elements.length; i++) {\n      result += ast.elements[i].visit(this, context);\n      const expression = i < ast.expressions.length ? ast.expressions[i] : null;\n      if (expression !== null) {\n        result += '${' + expression.visit(this, context) + '}';\n      }\n    }\n    return '`' + result + '`';\n  }\n\n  visitTemplateLiteralElement(ast: expr.TemplateLiteralElement, context: any) {\n    return ast.text;\n  }\n\n  visitTaggedTemplateLiteral(ast: expr.TaggedTemplateLiteral, context: any) {\n    return ast.tag.visit(this, context) + ast.template.visit(this, context);\n  }\n\n  visitParenthesizedExpression(ast: expr.ParenthesizedExpression, context: any) {\n    return '(' + ast.expression.visit(this, context) + ')';\n  }\n}\n\n/** Zips the two input arrays into a single array of pairs of elements at the same index. */\nfunction zip<Left, Right>(left: Left[], right: Right[]): Array<[Left, Right]> {\n  if (left.length !== right.length) throw new Error('Array lengths must match');\n\n  return left.map((l, i) => [l, right[i]]);\n}\n\n/**\n * Interleaves the two arrays, starting with the first item on the left, then the first item\n * on the right, second item from the left, and so on. When the first array's items are exhausted,\n * the remaining items from the other array are included with no interleaving.\n */\nfunction interleave<Left, Right>(left: Left[], right: Right[]): Array<Left | Right> {\n  const result: Array<Left | Right> = [];\n\n  for (let index = 0; index < Math.max(left.length, right.length); index++) {\n    if (index < left.length) result.push(left[index]);\n    if (index < right.length) result.push(right[index]);\n  }\n\n  return result;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {SecurityContext} from '../core';\n\n// =================================================================================================\n// =================================================================================================\n// =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========\n// =================================================================================================\n// =================================================================================================\n//\n//        DO NOT EDIT THIS LIST OF SECURITY SENSITIVE PROPERTIES WITHOUT A SECURITY REVIEW!\n//                               Reach out to mprobst for details.\n//\n// =================================================================================================\n\n/** Map from tagName|propertyName to SecurityContext. Properties applying to all tags use '*'. */\nlet _SECURITY_SCHEMA!: {[k: string]: SecurityContext};\n\nexport function SECURITY_SCHEMA(): {[k: string]: SecurityContext} {\n  if (!_SECURITY_SCHEMA) {\n    _SECURITY_SCHEMA = {};\n    // Case is insignificant below, all element and attribute names are lower-cased for lookup.\n\n    registerContext(SecurityContext.HTML, ['iframe|srcdoc', '*|innerHTML', '*|outerHTML']);\n    registerContext(SecurityContext.STYLE, ['*|style']);\n    // NB: no SCRIPT contexts here, they are never allowed due to the parser stripping them.\n    registerContext(SecurityContext.URL, [\n      '*|formAction',\n      'area|href',\n      'area|ping',\n      'audio|src',\n      'a|href',\n      'a|ping',\n      'blockquote|cite',\n      'body|background',\n      'del|cite',\n      'form|action',\n      'img|src',\n      'input|src',\n      'ins|cite',\n      'q|cite',\n      'source|src',\n      'track|src',\n      'video|poster',\n      'video|src',\n    ]);\n    registerContext(SecurityContext.RESOURCE_URL, [\n      'applet|code',\n      'applet|codebase',\n      'base|href',\n      'embed|src',\n      'frame|src',\n      'head|profile',\n      'html|manifest',\n      'iframe|src',\n      'link|href',\n      'media|src',\n      'object|codebase',\n      'object|data',\n      'script|src',\n    ]);\n  }\n  return _SECURITY_SCHEMA;\n}\n\nfunction registerContext(ctx: SecurityContext, specs: string[]) {\n  for (const spec of specs) _SECURITY_SCHEMA[spec.toLowerCase()] = ctx;\n}\n\n/**\n * The set of security-sensitive attributes of an `<iframe>` that *must* be\n * applied as a static attribute only. This ensures that all security-sensitive\n * attributes are taken into account while creating an instance of an `<iframe>`\n * at runtime.\n *\n * Note: avoid using this set directly, use the `isIframeSecuritySensitiveAttr` function\n * in the code instead.\n */\nexport const IFRAME_SECURITY_SENSITIVE_ATTRS = new Set([\n  'sandbox',\n  'allow',\n  'allowfullscreen',\n  'referrerpolicy',\n  'csp',\n  'fetchpriority',\n]);\n\n/**\n * Checks whether a given attribute name might represent a security-sensitive\n * attribute of an <iframe>.\n */\nexport function isIframeSecuritySensitiveAttr(attrName: string): boolean {\n  // The `setAttribute` DOM API is case-insensitive, so we lowercase the value\n  // before checking it against a known security-sensitive attributes.\n  return IFRAME_SECURITY_SENSITIVE_ATTRS.has(attrName.toLowerCase());\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {SchemaMetadata, SecurityContext} from '../core';\n\nexport abstract class ElementSchemaRegistry {\n  abstract hasProperty(tagName: string, propName: string, schemaMetas: SchemaMetadata[]): boolean;\n  abstract hasElement(tagName: string, schemaMetas: SchemaMetadata[]): boolean;\n  abstract securityContext(\n    elementName: string,\n    propName: string,\n    isAttribute: boolean,\n  ): SecurityContext;\n  abstract allKnownElementNames(): string[];\n  abstract getMappedPropName(propName: string): string;\n  abstract getDefaultComponentElementName(): string;\n  abstract validateProperty(name: string): {error: boolean; msg?: string};\n  abstract validateAttribute(name: string): {error: boolean; msg?: string};\n  abstract normalizeAnimationStyleProperty(propName: string): string;\n  abstract normalizeAnimationStyleValue(\n    camelCaseProp: string,\n    userProvidedProp: string,\n    val: string | number,\n  ): {error: string; value: string};\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {CUSTOM_ELEMENTS_SCHEMA, NO_ERRORS_SCHEMA, SchemaMetadata, SecurityContext} from '../core';\nimport {isNgContainer, isNgContent} from '../ml_parser/tags';\nimport {dashCaseToCamelCase} from '../util';\n\nimport {SECURITY_SCHEMA} from './dom_security_schema';\nimport {ElementSchemaRegistry} from './element_schema_registry';\n\nconst BOOLEAN = 'boolean';\nconst NUMBER = 'number';\nconst STRING = 'string';\nconst OBJECT = 'object';\n\n/**\n * This array represents the DOM schema. It encodes inheritance, properties, and events.\n *\n * ## Overview\n *\n * Each line represents one kind of element. The `element_inheritance` and properties are joined\n * using `element_inheritance|properties` syntax.\n *\n * ## Element Inheritance\n *\n * The `element_inheritance` can be further subdivided as `element1,element2,...^parentElement`.\n * Here the individual elements are separated by `,` (commas). Every element in the list\n * has identical properties.\n *\n * An `element` may inherit additional properties from `parentElement` If no `^parentElement` is\n * specified then `\"\"` (blank) element is assumed.\n *\n * NOTE: The blank element inherits from root `[Element]` element, the super element of all\n * elements.\n *\n * NOTE an element prefix such as `:svg:` has no special meaning to the schema.\n *\n * ## Properties\n *\n * Each element has a set of properties separated by `,` (commas). Each property can be prefixed\n * by a special character designating its type:\n *\n * - (no prefix): property is a string.\n * - `*`: property represents an event.\n * - `!`: property is a boolean.\n * - `#`: property is a number.\n * - `%`: property is an object.\n *\n * ## Query\n *\n * The class creates an internal squas representation which allows to easily answer the query of\n * if a given property exist on a given element.\n *\n * NOTE: We don't yet support querying for types or events.\n * NOTE: This schema is auto extracted from `schema_extractor.ts` located in the test folder,\n *       see dom_element_schema_registry_spec.ts\n */\n\n// =================================================================================================\n// =================================================================================================\n// =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========\n// =================================================================================================\n// =================================================================================================\n//\n//                       DO NOT EDIT THIS DOM SCHEMA WITHOUT A SECURITY REVIEW!\n//\n// Newly added properties must be security reviewed and assigned an appropriate SecurityContext in\n// dom_security_schema.ts. Reach out to mprobst & rjamet for details.\n//\n// =================================================================================================\n\nexport const SCHEMA: string[] = [\n  '[Element]|textContent,%ariaAtomic,%ariaAutoComplete,%ariaBusy,%ariaChecked,%ariaColCount,%ariaColIndex,%ariaColSpan,%ariaCurrent,%ariaDescription,%ariaDisabled,%ariaExpanded,%ariaHasPopup,%ariaHidden,%ariaInvalid,%ariaKeyShortcuts,%ariaLabel,%ariaLevel,%ariaLive,%ariaModal,%ariaMultiLine,%ariaMultiSelectable,%ariaOrientation,%ariaPlaceholder,%ariaPosInSet,%ariaPressed,%ariaReadOnly,%ariaRelevant,%ariaRequired,%ariaRoleDescription,%ariaRowCount,%ariaRowIndex,%ariaRowSpan,%ariaSelected,%ariaSetSize,%ariaSort,%ariaValueMax,%ariaValueMin,%ariaValueNow,%ariaValueText,%classList,className,elementTiming,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*fullscreenchange,*fullscreenerror,*search,*webkitfullscreenchange,*webkitfullscreenerror,outerHTML,%part,#scrollLeft,#scrollTop,slot' +\n    /* added manually to avoid breaking changes */\n    ',*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored',\n  '[HTMLElement]^[Element]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,!inert,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy',\n  'abbr,address,article,aside,b,bdi,bdo,cite,content,code,dd,dfn,dt,em,figcaption,figure,footer,header,hgroup,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,search,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy',\n  'media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,!preservesPitch,src,%srcObject,#volume',\n  ':svg:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex',\n  ':svg:graphics^:svg:|',\n  ':svg:animation^:svg:|*begin,*end,*repeat',\n  ':svg:geometry^:svg:|',\n  ':svg:componentTransferFunction^:svg:|',\n  ':svg:gradient^:svg:|',\n  ':svg:textContent^:svg:graphics|',\n  ':svg:textPositioning^:svg:textContent|',\n  'a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,rev,search,shape,target,text,type,username',\n  'area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,search,shape,target,username',\n  'audio^media|',\n  'br^[HTMLElement]|clear',\n  'base^[HTMLElement]|href,target',\n  'body^[HTMLElement]|aLink,background,bgColor,link,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink',\n  'button^[HTMLElement]|!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value',\n  'canvas^[HTMLElement]|#height,#width',\n  'content^[HTMLElement]|select',\n  'dl^[HTMLElement]|!compact',\n  'data^[HTMLElement]|value',\n  'datalist^[HTMLElement]|',\n  'details^[HTMLElement]|!open',\n  'dialog^[HTMLElement]|!open,returnValue',\n  'dir^[HTMLElement]|!compact',\n  'div^[HTMLElement]|align',\n  'embed^[HTMLElement]|align,height,name,src,type,width',\n  'fieldset^[HTMLElement]|!disabled,name',\n  'font^[HTMLElement]|color,face,size',\n  'form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target',\n  'frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src',\n  'frameset^[HTMLElement]|cols,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows',\n  'hr^[HTMLElement]|align,color,!noShade,size,width',\n  'head^[HTMLElement]|',\n  'h1,h2,h3,h4,h5,h6^[HTMLElement]|align',\n  'html^[HTMLElement]|version',\n  'iframe^[HTMLElement]|align,allow,!allowFullscreen,!allowPaymentRequest,csp,frameBorder,height,loading,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width',\n  'img^[HTMLElement]|align,alt,border,%crossOrigin,decoding,#height,#hspace,!isMap,loading,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width',\n  'input^[HTMLElement]|accept,align,alt,autocomplete,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width',\n  'li^[HTMLElement]|type,#value',\n  'label^[HTMLElement]|htmlFor',\n  'legend^[HTMLElement]|align',\n  'link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,imageSizes,imageSrcset,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type',\n  'map^[HTMLElement]|name',\n  'marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width',\n  'menu^[HTMLElement]|!compact',\n  'meta^[HTMLElement]|content,httpEquiv,media,name,scheme',\n  'meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value',\n  'ins,del^[HTMLElement]|cite,dateTime',\n  'ol^[HTMLElement]|!compact,!reversed,#start,type',\n  'object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width',\n  'optgroup^[HTMLElement]|!disabled,label',\n  'option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value',\n  'output^[HTMLElement]|defaultValue,%htmlFor,name,value',\n  'p^[HTMLElement]|align',\n  'param^[HTMLElement]|name,type,value,valueType',\n  'picture^[HTMLElement]|',\n  'pre^[HTMLElement]|#width',\n  'progress^[HTMLElement]|#max,#value',\n  'q,blockquote,cite^[HTMLElement]|',\n  'script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,!noModule,%referrerPolicy,src,text,type',\n  'select^[HTMLElement]|autocomplete,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value',\n  'selectedcontent^[HTMLElement]|',\n  'slot^[HTMLElement]|name',\n  'source^[HTMLElement]|#height,media,sizes,src,srcset,type,#width',\n  'span^[HTMLElement]|',\n  'style^[HTMLElement]|!disabled,media,type',\n  'search^[HTMLELement]|',\n  'caption^[HTMLElement]|align',\n  'th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width',\n  'col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width',\n  'table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width',\n  'tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign',\n  'tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign',\n  'template^[HTMLElement]|',\n  'textarea^[HTMLElement]|autocomplete,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap',\n  'time^[HTMLElement]|dateTime',\n  'title^[HTMLElement]|text',\n  'track^[HTMLElement]|!default,kind,label,src,srclang',\n  'ul^[HTMLElement]|!compact,type',\n  'unknown^[HTMLElement]|',\n  'video^media|!disablePictureInPicture,#height,*enterpictureinpicture,*leavepictureinpicture,!playsInline,poster,#width',\n  ':svg:a^:svg:graphics|',\n  ':svg:animate^:svg:animation|',\n  ':svg:animateMotion^:svg:animation|',\n  ':svg:animateTransform^:svg:animation|',\n  ':svg:circle^:svg:geometry|',\n  ':svg:clipPath^:svg:graphics|',\n  ':svg:defs^:svg:graphics|',\n  ':svg:desc^:svg:|',\n  ':svg:discard^:svg:|',\n  ':svg:ellipse^:svg:geometry|',\n  ':svg:feBlend^:svg:|',\n  ':svg:feColorMatrix^:svg:|',\n  ':svg:feComponentTransfer^:svg:|',\n  ':svg:feComposite^:svg:|',\n  ':svg:feConvolveMatrix^:svg:|',\n  ':svg:feDiffuseLighting^:svg:|',\n  ':svg:feDisplacementMap^:svg:|',\n  ':svg:feDistantLight^:svg:|',\n  ':svg:feDropShadow^:svg:|',\n  ':svg:feFlood^:svg:|',\n  ':svg:feFuncA^:svg:componentTransferFunction|',\n  ':svg:feFuncB^:svg:componentTransferFunction|',\n  ':svg:feFuncG^:svg:componentTransferFunction|',\n  ':svg:feFuncR^:svg:componentTransferFunction|',\n  ':svg:feGaussianBlur^:svg:|',\n  ':svg:feImage^:svg:|',\n  ':svg:feMerge^:svg:|',\n  ':svg:feMergeNode^:svg:|',\n  ':svg:feMorphology^:svg:|',\n  ':svg:feOffset^:svg:|',\n  ':svg:fePointLight^:svg:|',\n  ':svg:feSpecularLighting^:svg:|',\n  ':svg:feSpotLight^:svg:|',\n  ':svg:feTile^:svg:|',\n  ':svg:feTurbulence^:svg:|',\n  ':svg:filter^:svg:|',\n  ':svg:foreignObject^:svg:graphics|',\n  ':svg:g^:svg:graphics|',\n  ':svg:image^:svg:graphics|decoding',\n  ':svg:line^:svg:geometry|',\n  ':svg:linearGradient^:svg:gradient|',\n  ':svg:mpath^:svg:|',\n  ':svg:marker^:svg:|',\n  ':svg:mask^:svg:|',\n  ':svg:metadata^:svg:|',\n  ':svg:path^:svg:geometry|',\n  ':svg:pattern^:svg:|',\n  ':svg:polygon^:svg:geometry|',\n  ':svg:polyline^:svg:geometry|',\n  ':svg:radialGradient^:svg:gradient|',\n  ':svg:rect^:svg:geometry|',\n  ':svg:svg^:svg:graphics|#currentScale,#zoomAndPan',\n  ':svg:script^:svg:|type',\n  ':svg:set^:svg:animation|',\n  ':svg:stop^:svg:|',\n  ':svg:style^:svg:|!disabled,media,title,type',\n  ':svg:switch^:svg:graphics|',\n  ':svg:symbol^:svg:|',\n  ':svg:tspan^:svg:textPositioning|',\n  ':svg:text^:svg:textPositioning|',\n  ':svg:textPath^:svg:textContent|',\n  ':svg:title^:svg:|',\n  ':svg:use^:svg:graphics|',\n  ':svg:view^:svg:|#zoomAndPan',\n  'data^[HTMLElement]|value',\n  'keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name',\n  'menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default',\n  'summary^[HTMLElement]|',\n  'time^[HTMLElement]|dateTime',\n  ':svg:cursor^:svg:|',\n  ':math:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforeinput,*beforematch,*beforetoggle,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contentvisibilityautostatechange,*contextlost,*contextmenu,*contextrestored,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*scrollend,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex',\n  ':math:math^:math:|',\n  ':math:maction^:math:|',\n  ':math:menclose^:math:|',\n  ':math:merror^:math:|',\n  ':math:mfenced^:math:|',\n  ':math:mfrac^:math:|',\n  ':math:mi^:math:|',\n  ':math:mmultiscripts^:math:|',\n  ':math:mn^:math:|',\n  ':math:mo^:math:|',\n  ':math:mover^:math:|',\n  ':math:mpadded^:math:|',\n  ':math:mphantom^:math:|',\n  ':math:mroot^:math:|',\n  ':math:mrow^:math:|',\n  ':math:ms^:math:|',\n  ':math:mspace^:math:|',\n  ':math:msqrt^:math:|',\n  ':math:mstyle^:math:|',\n  ':math:msub^:math:|',\n  ':math:msubsup^:math:|',\n  ':math:msup^:math:|',\n  ':math:mtable^:math:|',\n  ':math:mtd^:math:|',\n  ':math:mtext^:math:|',\n  ':math:mtr^:math:|',\n  ':math:munder^:math:|',\n  ':math:munderover^:math:|',\n  ':math:semantics^:math:|',\n];\n\nexport const _ATTR_TO_PROP = new Map(\n  Object.entries({\n    'class': 'className',\n    'for': 'htmlFor',\n    'formaction': 'formAction',\n    'innerHtml': 'innerHTML',\n    'readonly': 'readOnly',\n    'tabindex': 'tabIndex',\n\n    // https://www.w3.org/TR/wai-aria-1.2/#accessibilityroleandproperties-correspondence\n    'aria-atomic': 'ariaAtomic',\n    'aria-autocomplete': 'ariaAutoComplete',\n    'aria-busy': 'ariaBusy',\n    'aria-checked': 'ariaChecked',\n    'aria-colcount': 'ariaColCount',\n    'aria-colindex': 'ariaColIndex',\n    'aria-colspan': 'ariaColSpan',\n    'aria-current': 'ariaCurrent',\n    'aria-disabled': 'ariaDisabled',\n    'aria-expanded': 'ariaExpanded',\n    'aria-haspopup': 'ariaHasPopup',\n    'aria-hidden': 'ariaHidden',\n    'aria-invalid': 'ariaInvalid',\n    'aria-keyshortcuts': 'ariaKeyShortcuts',\n    'aria-label': 'ariaLabel',\n    'aria-level': 'ariaLevel',\n    'aria-live': 'ariaLive',\n    'aria-modal': 'ariaModal',\n    'aria-multiline': 'ariaMultiLine',\n    'aria-multiselectable': 'ariaMultiSelectable',\n    'aria-orientation': 'ariaOrientation',\n    'aria-placeholder': 'ariaPlaceholder',\n    'aria-posinset': 'ariaPosInSet',\n    'aria-pressed': 'ariaPressed',\n    'aria-readonly': 'ariaReadOnly',\n    'aria-required': 'ariaRequired',\n    'aria-roledescription': 'ariaRoleDescription',\n    'aria-rowcount': 'ariaRowCount',\n    'aria-rowindex': 'ariaRowIndex',\n    'aria-rowspan': 'ariaRowSpan',\n    'aria-selected': 'ariaSelected',\n    'aria-setsize': 'ariaSetSize',\n    'aria-sort': 'ariaSort',\n    'aria-valuemax': 'ariaValueMax',\n    'aria-valuemin': 'ariaValueMin',\n    'aria-valuenow': 'ariaValueNow',\n    'aria-valuetext': 'ariaValueText',\n  }),\n);\n\n// Invert _ATTR_TO_PROP.\nconst _PROP_TO_ATTR = Array.from(_ATTR_TO_PROP).reduce(\n  (inverted, [propertyName, attributeName]) => {\n    inverted.set(propertyName, attributeName);\n    return inverted;\n  },\n  new Map<string, string>(),\n);\n\nexport class DomElementSchemaRegistry extends ElementSchemaRegistry {\n  private _schema = new Map<string, Map<string, string>>();\n  // We don't allow binding to events for security reasons. Allowing event bindings would almost\n  // certainly introduce bad XSS vulnerabilities. Instead, we store events in a separate schema.\n  private _eventSchema = new Map<string, Set<string>>();\n\n  constructor() {\n    super();\n    SCHEMA.forEach((encodedType) => {\n      const type = new Map<string, string>();\n      const events: Set<string> = new Set();\n      const [strType, strProperties] = encodedType.split('|');\n      const properties = strProperties.split(',');\n      const [typeNames, superName] = strType.split('^');\n      typeNames.split(',').forEach((tag) => {\n        this._schema.set(tag.toLowerCase(), type);\n        this._eventSchema.set(tag.toLowerCase(), events);\n      });\n      const superType = superName && this._schema.get(superName.toLowerCase());\n      if (superType) {\n        for (const [prop, value] of superType) {\n          type.set(prop, value);\n        }\n        for (const superEvent of this._eventSchema.get(superName.toLowerCase())!) {\n          events.add(superEvent);\n        }\n      }\n      properties.forEach((property: string) => {\n        if (property.length > 0) {\n          switch (property[0]) {\n            case '*':\n              events.add(property.substring(1));\n              break;\n            case '!':\n              type.set(property.substring(1), BOOLEAN);\n              break;\n            case '#':\n              type.set(property.substring(1), NUMBER);\n              break;\n            case '%':\n              type.set(property.substring(1), OBJECT);\n              break;\n            default:\n              type.set(property, STRING);\n          }\n        }\n      });\n    });\n  }\n\n  override hasProperty(tagName: string, propName: string, schemaMetas: SchemaMetadata[]): boolean {\n    if (schemaMetas.some((schema) => schema.name === NO_ERRORS_SCHEMA.name)) {\n      return true;\n    }\n\n    if (tagName.indexOf('-') > -1) {\n      if (isNgContainer(tagName) || isNgContent(tagName)) {\n        return false;\n      }\n\n      if (schemaMetas.some((schema) => schema.name === CUSTOM_ELEMENTS_SCHEMA.name)) {\n        // Can't tell now as we don't know which properties a custom element will get\n        // once it is instantiated\n        return true;\n      }\n    }\n\n    const elementProperties =\n      this._schema.get(tagName.toLowerCase()) || this._schema.get('unknown')!;\n    return elementProperties.has(propName);\n  }\n\n  override hasElement(tagName: string, schemaMetas: SchemaMetadata[]): boolean {\n    if (schemaMetas.some((schema) => schema.name === NO_ERRORS_SCHEMA.name)) {\n      return true;\n    }\n\n    if (tagName.indexOf('-') > -1) {\n      if (isNgContainer(tagName) || isNgContent(tagName)) {\n        return true;\n      }\n\n      if (schemaMetas.some((schema) => schema.name === CUSTOM_ELEMENTS_SCHEMA.name)) {\n        // Allow any custom elements\n        return true;\n      }\n    }\n\n    return this._schema.has(tagName.toLowerCase());\n  }\n\n  /**\n   * securityContext returns the security context for the given property on the given DOM tag.\n   *\n   * Tag and property name are statically known and cannot change at runtime, i.e. it is not\n   * possible to bind a value into a changing attribute or tag name.\n   *\n   * The filtering is based on a list of allowed tags|attributes. All attributes in the schema\n   * above are assumed to have the 'NONE' security context, i.e. that they are safe inert\n   * string values. Only specific well known attack vectors are assigned their appropriate context.\n   */\n  override securityContext(\n    tagName: string,\n    propName: string,\n    isAttribute: boolean,\n  ): SecurityContext {\n    if (isAttribute) {\n      // NB: For security purposes, use the mapped property name, not the attribute name.\n      propName = this.getMappedPropName(propName);\n    }\n\n    // Make sure comparisons are case insensitive, so that case differences between attribute and\n    // property names do not have a security impact.\n    tagName = tagName.toLowerCase();\n    propName = propName.toLowerCase();\n    let ctx = SECURITY_SCHEMA()[tagName + '|' + propName];\n    if (ctx) {\n      return ctx;\n    }\n    ctx = SECURITY_SCHEMA()['*|' + propName];\n    return ctx ? ctx : SecurityContext.NONE;\n  }\n\n  override getMappedPropName(propName: string): string {\n    return _ATTR_TO_PROP.get(propName) ?? propName;\n  }\n\n  override getDefaultComponentElementName(): string {\n    return 'ng-component';\n  }\n\n  override validateProperty(name: string): {error: boolean; msg?: string} {\n    if (name.toLowerCase().startsWith('on')) {\n      const msg =\n        `Binding to event property '${name}' is disallowed for security reasons, ` +\n        `please use (${name.slice(2)})=...` +\n        `\\nIf '${name}' is a directive input, make sure the directive is imported by the` +\n        ` current module.`;\n      return {error: true, msg: msg};\n    } else {\n      return {error: false};\n    }\n  }\n\n  override validateAttribute(name: string): {error: boolean; msg?: string} {\n    if (name.toLowerCase().startsWith('on')) {\n      const msg =\n        `Binding to event attribute '${name}' is disallowed for security reasons, ` +\n        `please use (${name.slice(2)})=...`;\n      return {error: true, msg: msg};\n    } else {\n      return {error: false};\n    }\n  }\n\n  override allKnownElementNames(): string[] {\n    return Array.from(this._schema.keys());\n  }\n\n  allKnownAttributesOfElement(tagName: string): string[] {\n    const elementProperties =\n      this._schema.get(tagName.toLowerCase()) || this._schema.get('unknown')!;\n    // Convert properties to attributes.\n    return Array.from(elementProperties.keys()).map((prop) => _PROP_TO_ATTR.get(prop) ?? prop);\n  }\n\n  allKnownEventsOfElement(tagName: string): string[] {\n    return Array.from(this._eventSchema.get(tagName.toLowerCase()) ?? []);\n  }\n\n  override normalizeAnimationStyleProperty(propName: string): string {\n    return dashCaseToCamelCase(propName);\n  }\n\n  override normalizeAnimationStyleValue(\n    camelCaseProp: string,\n    userProvidedProp: string,\n    val: string | number,\n  ): {error: string; value: string} {\n    let unit: string = '';\n    const strVal = val.toString().trim();\n    let errorMsg: string = null!;\n\n    if (_isPixelDimensionStyle(camelCaseProp) && val !== 0 && val !== '0') {\n      if (typeof val === 'number') {\n        unit = 'px';\n      } else {\n        const valAndSuffixMatch = val.match(/^[+-]?[\\d\\.]+([a-z]*)$/);\n        if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {\n          errorMsg = `Please provide a CSS unit value for ${userProvidedProp}:${val}`;\n        }\n      }\n    }\n    return {error: errorMsg, value: strVal + unit};\n  }\n}\n\nfunction _isPixelDimensionStyle(prop: string): boolean {\n  switch (prop) {\n    case 'width':\n    case 'height':\n    case 'minWidth':\n    case 'minHeight':\n    case 'maxWidth':\n    case 'maxHeight':\n    case 'left':\n    case 'top':\n    case 'bottom':\n    case 'right':\n    case 'fontSize':\n    case 'outlineWidth':\n    case 'outlineOffset':\n    case 'paddingTop':\n    case 'paddingLeft':\n    case 'paddingBottom':\n    case 'paddingRight':\n    case 'marginTop':\n    case 'marginLeft':\n    case 'marginBottom':\n    case 'marginRight':\n    case 'borderRadius':\n    case 'borderWidth':\n    case 'borderTopWidth':\n    case 'borderLeftWidth':\n    case 'borderRightWidth':\n    case 'borderBottomWidth':\n    case 'textIndent':\n      return true;\n\n    default:\n      return false;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {DomElementSchemaRegistry} from '../schema/dom_element_schema_registry';\n\nimport {getNsPrefix, TagContentType, TagDefinition} from './tags';\n\nexport class HtmlTagDefinition implements TagDefinition {\n  private closedByChildren: {[key: string]: boolean} = {};\n  private contentType:\n    | TagContentType\n    | {default: TagContentType; [namespace: string]: TagContentType};\n\n  closedByParent = false;\n  implicitNamespacePrefix: string | null;\n  isVoid: boolean;\n  ignoreFirstLf: boolean;\n  canSelfClose: boolean;\n  preventNamespaceInheritance: boolean;\n\n  constructor({\n    closedByChildren,\n    implicitNamespacePrefix,\n    contentType = TagContentType.PARSABLE_DATA,\n    closedByParent = false,\n    isVoid = false,\n    ignoreFirstLf = false,\n    preventNamespaceInheritance = false,\n    canSelfClose = false,\n  }: {\n    closedByChildren?: string[];\n    closedByParent?: boolean;\n    implicitNamespacePrefix?: string;\n    contentType?: TagContentType | {default: TagContentType; [namespace: string]: TagContentType};\n    isVoid?: boolean;\n    ignoreFirstLf?: boolean;\n    preventNamespaceInheritance?: boolean;\n    canSelfClose?: boolean;\n  } = {}) {\n    if (closedByChildren && closedByChildren.length > 0) {\n      closedByChildren.forEach((tagName) => (this.closedByChildren[tagName] = true));\n    }\n    this.isVoid = isVoid;\n    this.closedByParent = closedByParent || isVoid;\n    this.implicitNamespacePrefix = implicitNamespacePrefix || null;\n    this.contentType = contentType;\n    this.ignoreFirstLf = ignoreFirstLf;\n    this.preventNamespaceInheritance = preventNamespaceInheritance;\n    this.canSelfClose = canSelfClose ?? isVoid;\n  }\n\n  isClosedByChild(name: string): boolean {\n    return this.isVoid || name.toLowerCase() in this.closedByChildren;\n  }\n\n  getContentType(prefix?: string): TagContentType {\n    if (typeof this.contentType === 'object') {\n      const overrideType = prefix === undefined ? undefined : this.contentType[prefix];\n      return overrideType ?? this.contentType.default;\n    }\n    return this.contentType;\n  }\n}\n\nlet DEFAULT_TAG_DEFINITION!: HtmlTagDefinition;\n\n// see https://www.w3.org/TR/html51/syntax.html#optional-tags\n// This implementation does not fully conform to the HTML5 spec.\nlet TAG_DEFINITIONS!: {[key: string]: HtmlTagDefinition};\n\nexport function getHtmlTagDefinition(tagName: string): HtmlTagDefinition {\n  if (!TAG_DEFINITIONS) {\n    DEFAULT_TAG_DEFINITION = new HtmlTagDefinition({canSelfClose: true});\n    TAG_DEFINITIONS = Object.assign(Object.create(null), {\n      'base': new HtmlTagDefinition({isVoid: true}),\n      'meta': new HtmlTagDefinition({isVoid: true}),\n      'area': new HtmlTagDefinition({isVoid: true}),\n      'embed': new HtmlTagDefinition({isVoid: true}),\n      'link': new HtmlTagDefinition({isVoid: true}),\n      'img': new HtmlTagDefinition({isVoid: true}),\n      'input': new HtmlTagDefinition({isVoid: true}),\n      'param': new HtmlTagDefinition({isVoid: true}),\n      'hr': new HtmlTagDefinition({isVoid: true}),\n      'br': new HtmlTagDefinition({isVoid: true}),\n      'source': new HtmlTagDefinition({isVoid: true}),\n      'track': new HtmlTagDefinition({isVoid: true}),\n      'wbr': new HtmlTagDefinition({isVoid: true}),\n      'p': new HtmlTagDefinition({\n        closedByChildren: [\n          'address',\n          'article',\n          'aside',\n          'blockquote',\n          'div',\n          'dl',\n          'fieldset',\n          'footer',\n          'form',\n          'h1',\n          'h2',\n          'h3',\n          'h4',\n          'h5',\n          'h6',\n          'header',\n          'hgroup',\n          'hr',\n          'main',\n          'nav',\n          'ol',\n          'p',\n          'pre',\n          'section',\n          'table',\n          'ul',\n        ],\n        closedByParent: true,\n      }),\n      'thead': new HtmlTagDefinition({closedByChildren: ['tbody', 'tfoot']}),\n      'tbody': new HtmlTagDefinition({closedByChildren: ['tbody', 'tfoot'], closedByParent: true}),\n      'tfoot': new HtmlTagDefinition({closedByChildren: ['tbody'], closedByParent: true}),\n      'tr': new HtmlTagDefinition({closedByChildren: ['tr'], closedByParent: true}),\n      'td': new HtmlTagDefinition({closedByChildren: ['td', 'th'], closedByParent: true}),\n      'th': new HtmlTagDefinition({closedByChildren: ['td', 'th'], closedByParent: true}),\n      'col': new HtmlTagDefinition({isVoid: true}),\n      'svg': new HtmlTagDefinition({implicitNamespacePrefix: 'svg'}),\n      'foreignObject': new HtmlTagDefinition({\n        // Usually the implicit namespace here would be redundant since it will be inherited from\n        // the parent `svg`, but we have to do it for `foreignObject`, because the way the parser\n        // works is that the parent node of an end tag is its own start tag which means that\n        // the `preventNamespaceInheritance` on `foreignObject` would have it default to the\n        // implicit namespace which is `html`, unless specified otherwise.\n        implicitNamespacePrefix: 'svg',\n        // We want to prevent children of foreignObject from inheriting its namespace, because\n        // the point of the element is to allow nodes from other namespaces to be inserted.\n        preventNamespaceInheritance: true,\n      }),\n      'math': new HtmlTagDefinition({implicitNamespacePrefix: 'math'}),\n      'li': new HtmlTagDefinition({closedByChildren: ['li'], closedByParent: true}),\n      'dt': new HtmlTagDefinition({closedByChildren: ['dt', 'dd']}),\n      'dd': new HtmlTagDefinition({closedByChildren: ['dt', 'dd'], closedByParent: true}),\n      'rb': new HtmlTagDefinition({\n        closedByChildren: ['rb', 'rt', 'rtc', 'rp'],\n        closedByParent: true,\n      }),\n      'rt': new HtmlTagDefinition({\n        closedByChildren: ['rb', 'rt', 'rtc', 'rp'],\n        closedByParent: true,\n      }),\n      'rtc': new HtmlTagDefinition({closedByChildren: ['rb', 'rtc', 'rp'], closedByParent: true}),\n      'rp': new HtmlTagDefinition({\n        closedByChildren: ['rb', 'rt', 'rtc', 'rp'],\n        closedByParent: true,\n      }),\n      'optgroup': new HtmlTagDefinition({closedByChildren: ['optgroup'], closedByParent: true}),\n      'option': new HtmlTagDefinition({\n        closedByChildren: ['option', 'optgroup'],\n        closedByParent: true,\n      }),\n      'pre': new HtmlTagDefinition({ignoreFirstLf: true}),\n      'listing': new HtmlTagDefinition({ignoreFirstLf: true}),\n      'style': new HtmlTagDefinition({contentType: TagContentType.RAW_TEXT}),\n      'script': new HtmlTagDefinition({contentType: TagContentType.RAW_TEXT}),\n      'title': new HtmlTagDefinition({\n        // The browser supports two separate `title` tags which have to use\n        // a different content type: `HTMLTitleElement` and `SVGTitleElement`\n        contentType: {\n          default: TagContentType.ESCAPABLE_RAW_TEXT,\n          svg: TagContentType.PARSABLE_DATA,\n        },\n      }),\n      'textarea': new HtmlTagDefinition({\n        contentType: TagContentType.ESCAPABLE_RAW_TEXT,\n        ignoreFirstLf: true,\n      }),\n    });\n\n    new DomElementSchemaRegistry().allKnownElementNames().forEach((knownTagName) => {\n      if (!TAG_DEFINITIONS[knownTagName] && getNsPrefix(knownTagName) === null) {\n        TAG_DEFINITIONS[knownTagName] = new HtmlTagDefinition({canSelfClose: false});\n      }\n    });\n  }\n  // We have to make both a case-sensitive and a case-insensitive lookup, because\n  // HTML tag names are case insensitive, whereas some SVG tags are case sensitive.\n  return (\n    TAG_DEFINITIONS[tagName] ?? TAG_DEFINITIONS[tagName.toLowerCase()] ?? DEFAULT_TAG_DEFINITION\n  );\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nconst TAG_TO_PLACEHOLDER_NAMES: {[k: string]: string} = {\n  'A': 'LINK',\n  'B': 'BOLD_TEXT',\n  'BR': 'LINE_BREAK',\n  'EM': 'EMPHASISED_TEXT',\n  'H1': 'HEADING_LEVEL1',\n  'H2': 'HEADING_LEVEL2',\n  'H3': 'HEADING_LEVEL3',\n  'H4': 'HEADING_LEVEL4',\n  'H5': 'HEADING_LEVEL5',\n  'H6': 'HEADING_LEVEL6',\n  'HR': 'HORIZONTAL_RULE',\n  'I': 'ITALIC_TEXT',\n  'LI': 'LIST_ITEM',\n  'LINK': 'MEDIA_LINK',\n  'OL': 'ORDERED_LIST',\n  'P': 'PARAGRAPH',\n  'Q': 'QUOTATION',\n  'S': 'STRIKETHROUGH_TEXT',\n  'SMALL': 'SMALL_TEXT',\n  'SUB': 'SUBSTRIPT',\n  'SUP': 'SUPERSCRIPT',\n  'TBODY': 'TABLE_BODY',\n  'TD': 'TABLE_CELL',\n  'TFOOT': 'TABLE_FOOTER',\n  'TH': 'TABLE_HEADER_CELL',\n  'THEAD': 'TABLE_HEADER',\n  'TR': 'TABLE_ROW',\n  'TT': 'MONOSPACED_TEXT',\n  'U': 'UNDERLINED_TEXT',\n  'UL': 'UNORDERED_LIST',\n};\n\n/**\n * Creates unique names for placeholder with different content.\n *\n * Returns the same placeholder name when the content is identical.\n */\nexport class PlaceholderRegistry {\n  // Count the occurrence of the base name top generate a unique name\n  private _placeHolderNameCounts: {[k: string]: number} = {};\n  // Maps signature to placeholder names\n  private _signatureToName: {[k: string]: string} = {};\n\n  getStartTagPlaceholderName(tag: string, attrs: {[k: string]: string}, isVoid: boolean): string {\n    const signature = this._hashTag(tag, attrs, isVoid);\n    if (this._signatureToName[signature]) {\n      return this._signatureToName[signature];\n    }\n\n    const upperTag = tag.toUpperCase();\n    const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\n    const name = this._generateUniqueName(isVoid ? baseName : `START_${baseName}`);\n\n    this._signatureToName[signature] = name;\n\n    return name;\n  }\n\n  getCloseTagPlaceholderName(tag: string): string {\n    const signature = this._hashClosingTag(tag);\n    if (this._signatureToName[signature]) {\n      return this._signatureToName[signature];\n    }\n\n    const upperTag = tag.toUpperCase();\n    const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\n    const name = this._generateUniqueName(`CLOSE_${baseName}`);\n\n    this._signatureToName[signature] = name;\n\n    return name;\n  }\n\n  getPlaceholderName(name: string, content: string): string {\n    const upperName = name.toUpperCase();\n    const signature = `PH: ${upperName}=${content}`;\n    if (this._signatureToName[signature]) {\n      return this._signatureToName[signature];\n    }\n\n    const uniqueName = this._generateUniqueName(upperName);\n    this._signatureToName[signature] = uniqueName;\n\n    return uniqueName;\n  }\n\n  getUniquePlaceholder(name: string): string {\n    return this._generateUniqueName(name.toUpperCase());\n  }\n\n  getStartBlockPlaceholderName(name: string, parameters: string[]): string {\n    const signature = this._hashBlock(name, parameters);\n    if (this._signatureToName[signature]) {\n      return this._signatureToName[signature];\n    }\n\n    const placeholder = this._generateUniqueName(`START_BLOCK_${this._toSnakeCase(name)}`);\n    this._signatureToName[signature] = placeholder;\n    return placeholder;\n  }\n\n  getCloseBlockPlaceholderName(name: string): string {\n    const signature = this._hashClosingBlock(name);\n    if (this._signatureToName[signature]) {\n      return this._signatureToName[signature];\n    }\n\n    const placeholder = this._generateUniqueName(`CLOSE_BLOCK_${this._toSnakeCase(name)}`);\n    this._signatureToName[signature] = placeholder;\n    return placeholder;\n  }\n\n  // Generate a hash for a tag - does not take attribute order into account\n  private _hashTag(tag: string, attrs: {[k: string]: string}, isVoid: boolean): string {\n    const start = `<${tag}`;\n    const strAttrs = Object.keys(attrs)\n      .sort()\n      .map((name) => ` ${name}=${attrs[name]}`)\n      .join('');\n    const end = isVoid ? '/>' : `></${tag}>`;\n\n    return start + strAttrs + end;\n  }\n\n  private _hashClosingTag(tag: string): string {\n    return this._hashTag(`/${tag}`, {}, false);\n  }\n\n  private _hashBlock(name: string, parameters: string[]): string {\n    const params = parameters.length === 0 ? '' : ` (${parameters.sort().join('; ')})`;\n    return `@${name}${params} {}`;\n  }\n\n  private _hashClosingBlock(name: string): string {\n    return this._hashBlock(`close_${name}`, []);\n  }\n\n  private _toSnakeCase(name: string) {\n    return name.toUpperCase().replace(/[^A-Z0-9]/g, '_');\n  }\n\n  private _generateUniqueName(base: string): string {\n    const seen = this._placeHolderNameCounts.hasOwnProperty(base);\n    if (!seen) {\n      this._placeHolderNameCounts[base] = 1;\n      return base;\n    }\n\n    const id = this._placeHolderNameCounts[base];\n    this._placeHolderNameCounts[base] = id + 1;\n    return `${base}_${id}`;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Lexer as ExpressionLexer} from '../expression_parser/lexer';\nimport {Parser as ExpressionParser} from '../expression_parser/parser';\nimport {serialize as serializeExpression} from '../expression_parser/serializer';\nimport * as html from '../ml_parser/ast';\nimport {InterpolationConfig} from '../ml_parser/defaults';\nimport {getHtmlTagDefinition} from '../ml_parser/html_tags';\nimport {\n  AttributeValueInterpolationToken,\n  InterpolatedAttributeToken,\n  InterpolatedTextToken,\n  InterpolationToken,\n  TokenType,\n} from '../ml_parser/tokens';\nimport {ParseSourceSpan} from '../parse_util';\n\nimport * as i18n from './i18n_ast';\nimport {PlaceholderRegistry} from './serializers/placeholder';\n\nconst _expParser = new ExpressionParser(new ExpressionLexer());\n\nexport type VisitNodeFn = (html: html.Node, i18n: i18n.Node) => i18n.Node;\n\nexport interface I18nMessageFactory {\n  (\n    nodes: html.Node[],\n    meaning: string | undefined,\n    description: string | undefined,\n    customId: string | undefined,\n    visitNodeFn?: VisitNodeFn,\n  ): i18n.Message;\n}\n\n/**\n * Returns a function converting html nodes to an i18n Message given an interpolationConfig\n */\nexport function createI18nMessageFactory(\n  interpolationConfig: InterpolationConfig,\n  containerBlocks: Set<string>,\n  retainEmptyTokens: boolean,\n  preserveExpressionWhitespace: boolean,\n): I18nMessageFactory {\n  const visitor = new _I18nVisitor(\n    _expParser,\n    interpolationConfig,\n    containerBlocks,\n    retainEmptyTokens,\n    preserveExpressionWhitespace,\n  );\n  return (nodes, meaning, description, customId, visitNodeFn) =>\n    visitor.toI18nMessage(nodes, meaning, description, customId, visitNodeFn);\n}\n\ninterface I18nMessageVisitorContext {\n  isIcu: boolean;\n  icuDepth: number;\n  placeholderRegistry: PlaceholderRegistry;\n  placeholderToContent: {[phName: string]: i18n.MessagePlaceholder};\n  placeholderToMessage: {[phName: string]: i18n.Message};\n  visitNodeFn: VisitNodeFn;\n}\n\nfunction noopVisitNodeFn(_html: html.Node, i18n: i18n.Node): i18n.Node {\n  return i18n;\n}\n\nclass _I18nVisitor implements html.Visitor {\n  constructor(\n    private _expressionParser: ExpressionParser,\n    private _interpolationConfig: InterpolationConfig,\n    private _containerBlocks: Set<string>,\n    private readonly _retainEmptyTokens: boolean,\n    private readonly _preserveExpressionWhitespace: boolean,\n  ) {}\n\n  public toI18nMessage(\n    nodes: html.Node[],\n    meaning = '',\n    description = '',\n    customId = '',\n    visitNodeFn: VisitNodeFn | undefined,\n  ): i18n.Message {\n    const context: I18nMessageVisitorContext = {\n      isIcu: nodes.length == 1 && nodes[0] instanceof html.Expansion,\n      icuDepth: 0,\n      placeholderRegistry: new PlaceholderRegistry(),\n      placeholderToContent: {},\n      placeholderToMessage: {},\n      visitNodeFn: visitNodeFn || noopVisitNodeFn,\n    };\n\n    const i18nodes: i18n.Node[] = html.visitAll(this, nodes, context);\n\n    return new i18n.Message(\n      i18nodes,\n      context.placeholderToContent,\n      context.placeholderToMessage,\n      meaning,\n      description,\n      customId,\n    );\n  }\n\n  visitElement(el: html.Element, context: I18nMessageVisitorContext): i18n.Node {\n    return this._visitElementLike(el, context);\n  }\n\n  visitComponent(component: html.Component, context: I18nMessageVisitorContext) {\n    return this._visitElementLike(component, context);\n  }\n\n  visitDirective(directive: html.Directive, context: any) {\n    throw new Error('Unreachable code');\n  }\n\n  visitAttribute(attribute: html.Attribute, context: I18nMessageVisitorContext): i18n.Node {\n    const node =\n      attribute.valueTokens === undefined || attribute.valueTokens.length === 1\n        ? new i18n.Text(attribute.value, attribute.valueSpan || attribute.sourceSpan)\n        : this._visitTextWithInterpolation(\n            attribute.valueTokens,\n            attribute.valueSpan || attribute.sourceSpan,\n            context,\n            attribute.i18n,\n          );\n    return context.visitNodeFn(attribute, node);\n  }\n\n  visitText(text: html.Text, context: I18nMessageVisitorContext): i18n.Node {\n    const node =\n      text.tokens.length === 1\n        ? new i18n.Text(text.value, text.sourceSpan)\n        : this._visitTextWithInterpolation(text.tokens, text.sourceSpan, context, text.i18n);\n    return context.visitNodeFn(text, node);\n  }\n\n  visitComment(comment: html.Comment, context: I18nMessageVisitorContext): i18n.Node | null {\n    return null;\n  }\n\n  visitExpansion(icu: html.Expansion, context: I18nMessageVisitorContext): i18n.Node {\n    context.icuDepth++;\n    const i18nIcuCases: {[k: string]: i18n.Node} = {};\n    const i18nIcu = new i18n.Icu(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);\n    icu.cases.forEach((caze): void => {\n      i18nIcuCases[caze.value] = new i18n.Container(\n        caze.expression.map((node) => node.visit(this, context)),\n        caze.expSourceSpan,\n      );\n    });\n    context.icuDepth--;\n\n    if (context.isIcu || context.icuDepth > 0) {\n      // Returns an ICU node when:\n      // - the message (vs a part of the message) is an ICU message, or\n      // - the ICU message is nested.\n      const expPh = context.placeholderRegistry.getUniquePlaceholder(`VAR_${icu.type}`);\n      i18nIcu.expressionPlaceholder = expPh;\n      context.placeholderToContent[expPh] = {\n        text: icu.switchValue,\n        sourceSpan: icu.switchValueSourceSpan,\n      };\n      return context.visitNodeFn(icu, i18nIcu);\n    }\n\n    // Else returns a placeholder\n    // ICU placeholders should not be replaced with their original content but with the their\n    // translations.\n    // TODO(vicb): add a html.Node -> i18n.Message cache to avoid having to re-create the msg\n    const phName = context.placeholderRegistry.getPlaceholderName('ICU', icu.sourceSpan.toString());\n    context.placeholderToMessage[phName] = this.toI18nMessage([icu], '', '', '', undefined);\n    const node = new i18n.IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);\n    return context.visitNodeFn(icu, node);\n  }\n\n  visitExpansionCase(_icuCase: html.ExpansionCase, _context: I18nMessageVisitorContext): i18n.Node {\n    throw new Error('Unreachable code');\n  }\n\n  visitBlock(block: html.Block, context: I18nMessageVisitorContext) {\n    const children = html.visitAll(this, block.children, context);\n\n    if (this._containerBlocks.has(block.name)) {\n      return new i18n.Container(children, block.sourceSpan);\n    }\n\n    const parameters = block.parameters.map((param) => param.expression);\n    const startPhName = context.placeholderRegistry.getStartBlockPlaceholderName(\n      block.name,\n      parameters,\n    );\n    const closePhName = context.placeholderRegistry.getCloseBlockPlaceholderName(block.name);\n\n    context.placeholderToContent[startPhName] = {\n      text: block.startSourceSpan.toString(),\n      sourceSpan: block.startSourceSpan,\n    };\n\n    context.placeholderToContent[closePhName] = {\n      text: block.endSourceSpan ? block.endSourceSpan.toString() : '}',\n      sourceSpan: block.endSourceSpan ?? block.sourceSpan,\n    };\n\n    const node = new i18n.BlockPlaceholder(\n      block.name,\n      parameters,\n      startPhName,\n      closePhName,\n      children,\n      block.sourceSpan,\n      block.startSourceSpan,\n      block.endSourceSpan,\n    );\n    return context.visitNodeFn(block, node);\n  }\n\n  visitBlockParameter(_parameter: html.BlockParameter, _context: I18nMessageVisitorContext) {\n    throw new Error('Unreachable code');\n  }\n\n  visitLetDeclaration(decl: html.LetDeclaration, context: any) {\n    return null;\n  }\n\n  private _visitElementLike(\n    node: html.Element | html.Component,\n    context: I18nMessageVisitorContext,\n  ): i18n.Node {\n    const children = html.visitAll(this, node.children, context);\n    const attrs: {[k: string]: string} = {};\n    const visitAttribute = (attr: html.Attribute) => {\n      // Do not visit the attributes, translatable ones are top-level ASTs\n      attrs[attr.name] = attr.value;\n    };\n\n    let nodeName: string;\n    let isVoid: boolean;\n\n    if (node instanceof html.Element) {\n      nodeName = node.name;\n      isVoid = getHtmlTagDefinition(node.name).isVoid;\n    } else {\n      nodeName = node.fullName;\n      isVoid = node.tagName ? getHtmlTagDefinition(node.tagName).isVoid : false;\n    }\n\n    node.attrs.forEach(visitAttribute);\n    node.directives.forEach((dir) => dir.attrs.forEach(visitAttribute));\n\n    const startPhName = context.placeholderRegistry.getStartTagPlaceholderName(\n      nodeName,\n      attrs,\n      isVoid,\n    );\n    context.placeholderToContent[startPhName] = {\n      text: node.startSourceSpan.toString(),\n      sourceSpan: node.startSourceSpan,\n    };\n\n    let closePhName = '';\n\n    if (!isVoid) {\n      closePhName = context.placeholderRegistry.getCloseTagPlaceholderName(nodeName);\n      context.placeholderToContent[closePhName] = {\n        text: `</${nodeName}>`,\n        sourceSpan: node.endSourceSpan ?? node.sourceSpan,\n      };\n    }\n\n    const i18nNode = new i18n.TagPlaceholder(\n      nodeName,\n      attrs,\n      startPhName,\n      closePhName,\n      children,\n      isVoid,\n      node.sourceSpan,\n      node.startSourceSpan,\n      node.endSourceSpan,\n    );\n    return context.visitNodeFn(node, i18nNode);\n  }\n\n  /**\n   * Convert, text and interpolated tokens up into text and placeholder pieces.\n   *\n   * @param tokens The text and interpolated tokens.\n   * @param sourceSpan The span of the whole of the `text` string.\n   * @param context The current context of the visitor, used to compute and store placeholders.\n   * @param previousI18n Any i18n metadata associated with this `text` from a previous pass.\n   */\n  private _visitTextWithInterpolation(\n    tokens: (InterpolatedTextToken | InterpolatedAttributeToken)[],\n    sourceSpan: ParseSourceSpan,\n    context: I18nMessageVisitorContext,\n    previousI18n: i18n.I18nMeta | undefined,\n  ): i18n.Node {\n    // Return a sequence of `Text` and `Placeholder` nodes grouped in a `Container`.\n    const nodes: i18n.Node[] = [];\n    // We will only create a container if there are actually interpolations,\n    // so this flag tracks that.\n    let hasInterpolation = false;\n    for (const token of tokens) {\n      switch (token.type) {\n        case TokenType.INTERPOLATION:\n        case TokenType.ATTR_VALUE_INTERPOLATION:\n          hasInterpolation = true;\n          const [startMarker, expression, endMarker] = token.parts;\n          const baseName = extractPlaceholderName(expression) || 'INTERPOLATION';\n          const phName = context.placeholderRegistry.getPlaceholderName(baseName, expression);\n\n          if (this._preserveExpressionWhitespace) {\n            context.placeholderToContent[phName] = {\n              text: token.parts.join(''),\n              sourceSpan: token.sourceSpan,\n            };\n            nodes.push(new i18n.Placeholder(expression, phName, token.sourceSpan));\n          } else {\n            const normalized = this.normalizeExpression(token);\n            context.placeholderToContent[phName] = {\n              text: `${startMarker}${normalized}${endMarker}`,\n              sourceSpan: token.sourceSpan,\n            };\n            nodes.push(new i18n.Placeholder(normalized, phName, token.sourceSpan));\n          }\n          break;\n        default:\n          // Try to merge text tokens with previous tokens. We do this even for all tokens\n          // when `retainEmptyTokens == true` because whitespace tokens may have non-zero\n          // length, but will be trimmed by `WhitespaceVisitor` in one extraction pass and\n          // be considered \"empty\" there. Therefore a whitespace token with\n          // `retainEmptyTokens === true` should be treated like an empty token and either\n          // retained or merged into the previous node. Since extraction does two passes with\n          // different trimming behavior, the second pass needs to have identical node count\n          // to reuse source spans, so we need this check to get the same answer when both\n          // trimming and not trimming.\n          if (token.parts[0].length > 0 || this._retainEmptyTokens) {\n            // This token is text or an encoded entity.\n            // If it is following on from a previous text node then merge it into that node\n            // Otherwise, if it is following an interpolation, then add a new node.\n            const previous = nodes[nodes.length - 1];\n            if (previous instanceof i18n.Text) {\n              previous.value += token.parts[0];\n              previous.sourceSpan = new ParseSourceSpan(\n                previous.sourceSpan.start,\n                token.sourceSpan.end,\n                previous.sourceSpan.fullStart,\n                previous.sourceSpan.details,\n              );\n            } else {\n              nodes.push(new i18n.Text(token.parts[0], token.sourceSpan));\n            }\n          } else {\n            // Retain empty tokens to avoid breaking dropping entire nodes such that source\n            // spans should not be reusable across multiple parses of a template. We *should*\n            // do this all the time, however we need to maintain backwards compatibility\n            // with existing message IDs so we can't do it by default and should only enable\n            // this when removing significant whitespace.\n            if (this._retainEmptyTokens) {\n              nodes.push(new i18n.Text(token.parts[0], token.sourceSpan));\n            }\n          }\n\n          break;\n      }\n    }\n\n    if (hasInterpolation) {\n      // Whitespace removal may have invalidated the interpolation source-spans.\n      reusePreviousSourceSpans(nodes, previousI18n);\n      return new i18n.Container(nodes, sourceSpan);\n    } else {\n      return nodes[0];\n    }\n  }\n\n  // Normalize expression whitespace by parsing and re-serializing it. This makes\n  // message IDs more durable to insignificant whitespace changes.\n  normalizeExpression(token: InterpolationToken | AttributeValueInterpolationToken): string {\n    const expression = token.parts[1];\n    const expr = this._expressionParser.parseBinding(\n      expression,\n      /* location */ token.sourceSpan,\n      /* absoluteOffset */ token.sourceSpan.start.offset,\n      this._interpolationConfig,\n    );\n    return serializeExpression(expr);\n  }\n}\n\n/**\n * Re-use the source-spans from `previousI18n` metadata for the `nodes`.\n *\n * Whitespace removal can invalidate the source-spans of interpolation nodes, so we\n * reuse the source-span stored from a previous pass before the whitespace was removed.\n *\n * @param nodes The `Text` and `Placeholder` nodes to be processed.\n * @param previousI18n Any i18n metadata for these `nodes` stored from a previous pass.\n */\nfunction reusePreviousSourceSpans(\n  nodes: i18n.Node[],\n  previousI18n: i18n.I18nMeta | undefined,\n): void {\n  if (previousI18n instanceof i18n.Message) {\n    // The `previousI18n` is an i18n `Message`, so we are processing an `Attribute` with i18n\n    // metadata. The `Message` should consist only of a single `Container` that contains the\n    // parts (`Text` and `Placeholder`) to process.\n    assertSingleContainerMessage(previousI18n);\n    previousI18n = previousI18n.nodes[0];\n  }\n\n  if (previousI18n instanceof i18n.Container) {\n    // The `previousI18n` is a `Container`, which means that this is a second i18n extraction pass\n    // after whitespace has been removed from the AST nodes.\n    assertEquivalentNodes(previousI18n.children, nodes);\n\n    // Reuse the source-spans from the first pass.\n    for (let i = 0; i < nodes.length; i++) {\n      nodes[i].sourceSpan = previousI18n.children[i].sourceSpan;\n    }\n  }\n}\n\n/**\n * Asserts that the `message` contains exactly one `Container` node.\n */\nfunction assertSingleContainerMessage(message: i18n.Message): void {\n  const nodes = message.nodes;\n  if (nodes.length !== 1 || !(nodes[0] instanceof i18n.Container)) {\n    throw new Error(\n      'Unexpected previous i18n message - expected it to consist of only a single `Container` node.',\n    );\n  }\n}\n\n/**\n * Asserts that the `previousNodes` and `node` collections have the same number of elements and\n * corresponding elements have the same node type.\n */\nfunction assertEquivalentNodes(previousNodes: i18n.Node[], nodes: i18n.Node[]): void {\n  if (previousNodes.length !== nodes.length) {\n    throw new Error(\n      `\nThe number of i18n message children changed between first and second pass.\n\nFirst pass (${previousNodes.length} tokens):\n${previousNodes.map((node) => `\"${node.sourceSpan.toString()}\"`).join('\\n')}\n\nSecond pass (${nodes.length} tokens):\n${nodes.map((node) => `\"${node.sourceSpan.toString()}\"`).join('\\n')}\n    `.trim(),\n    );\n  }\n  if (previousNodes.some((node, i) => nodes[i].constructor !== node.constructor)) {\n    throw new Error(\n      'The types of the i18n message children changed between first and second pass.',\n    );\n  }\n}\n\nconst _CUSTOM_PH_EXP =\n  /\\/\\/[\\s\\S]*i18n[\\s\\S]*\\([\\s\\S]*ph[\\s\\S]*=[\\s\\S]*(\"|')([\\s\\S]*?)\\1[\\s\\S]*\\)/g;\n\nfunction extractPlaceholderName(input: string): string {\n  return input.split(_CUSTOM_PH_EXP)[2];\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/**\n * Set of tagName|propertyName corresponding to Trusted Types sinks. Properties applying to all\n * tags use '*'.\n *\n * Extracted from, and should be kept in sync with\n * https://w3c.github.io/webappsec-trusted-types/dist/spec/#integrations\n */\nconst TRUSTED_TYPES_SINKS = new Set<string>([\n  // NOTE: All strings in this set *must* be lowercase!\n\n  // TrustedHTML\n  'iframe|srcdoc',\n  '*|innerhtml',\n  '*|outerhtml',\n\n  // NB: no TrustedScript here, as the corresponding tags are stripped by the compiler.\n\n  // TrustedScriptURL\n  'embed|src',\n  'object|codebase',\n  'object|data',\n]);\n\n/**\n * isTrustedTypesSink returns true if the given property on the given DOM tag is a Trusted Types\n * sink. In that case, use `ElementSchemaRegistry.securityContext` to determine which particular\n * Trusted Type is required for values passed to the sink:\n * - SecurityContext.HTML corresponds to TrustedHTML\n * - SecurityContext.RESOURCE_URL corresponds to TrustedScriptURL\n */\nexport function isTrustedTypesSink(tagName: string, propName: string): boolean {\n  // Make sure comparisons are case insensitive, so that case differences between attribute and\n  // property names do not have a security impact.\n  tagName = tagName.toLowerCase();\n  propName = propName.toLowerCase();\n\n  return (\n    TRUSTED_TYPES_SINKS.has(tagName + '|' + propName) || TRUSTED_TYPES_SINKS.has('*|' + propName)\n  );\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {WhitespaceVisitor, visitAllWithSiblings} from '../../../ml_parser/html_whitespaces';\nimport {computeDecimalDigest, computeDigest, decimalDigest} from '../../../i18n/digest';\nimport * as i18n from '../../../i18n/i18n_ast';\nimport {createI18nMessageFactory, VisitNodeFn} from '../../../i18n/i18n_parser';\nimport * as html from '../../../ml_parser/ast';\nimport {\n  DEFAULT_CONTAINER_BLOCKS,\n  DEFAULT_INTERPOLATION_CONFIG,\n  InterpolationConfig,\n} from '../../../ml_parser/defaults';\nimport {ParseTreeResult} from '../../../ml_parser/parser';\nimport * as o from '../../../output/output_ast';\nimport {isTrustedTypesSink} from '../../../schema/trusted_types_sinks';\n\nimport {hasI18nAttrs, I18N_ATTR, I18N_ATTR_PREFIX, icuFromI18nMessage} from './util';\nimport {ParseError} from '../../../parse_util';\n\nexport type I18nMeta = {\n  id?: string;\n  customId?: string;\n  legacyIds?: string[];\n  description?: string;\n  meaning?: string;\n};\n\nconst setI18nRefs = (originalNodeMap: Map<html.Node, html.Node>): VisitNodeFn => {\n  return (trimmedNode, i18nNode) => {\n    // We need to set i18n properties on the original, untrimmed AST nodes. The i18n nodes needs to\n    // use the trimmed content for message IDs to make messages more stable to whitespace changes.\n    // But we don't want to actually trim the content, so we can't use the trimmed HTML AST for\n    // general code gen. Instead we map the trimmed HTML AST back to the original AST and then\n    // attach the i18n nodes so we get trimmed i18n nodes on the original (untrimmed) HTML AST.\n    const originalNode = originalNodeMap.get(trimmedNode) ?? trimmedNode;\n\n    if (originalNode instanceof html.NodeWithI18n) {\n      if (i18nNode instanceof i18n.IcuPlaceholder && originalNode.i18n instanceof i18n.Message) {\n        // This html node represents an ICU but this is a second processing pass, and the legacy id\n        // was computed in the previous pass and stored in the `i18n` property as a message.\n        // We are about to wipe out that property so capture the previous message to be reused when\n        // generating the message for this ICU later. See `_generateI18nMessage()`.\n        i18nNode.previousMessage = originalNode.i18n;\n      }\n      originalNode.i18n = i18nNode;\n    }\n    return i18nNode;\n  };\n};\n\n/**\n * This visitor walks over HTML parse tree and converts information stored in\n * i18n-related attributes (\"i18n\" and \"i18n-*\") into i18n meta object that is\n * stored with other element's and attribute's information.\n */\nexport class I18nMetaVisitor implements html.Visitor {\n  // whether visited nodes contain i18n information\n  public hasI18nMeta: boolean = false;\n  private _errors: ParseError[] = [];\n\n  constructor(\n    private interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG,\n    private keepI18nAttrs = false,\n    private enableI18nLegacyMessageIdFormat = false,\n    private containerBlocks: Set<string> = DEFAULT_CONTAINER_BLOCKS,\n    private readonly preserveSignificantWhitespace: boolean = true,\n\n    // When dropping significant whitespace we need to retain empty tokens or\n    // else we won't be able to reuse source spans because empty tokens would be\n    // removed and cause a mismatch. Unfortunately this still needs to be\n    // configurable and sometimes needs to be set independently in order to make\n    // sure the number of nodes don't change between parses, even when\n    // `preserveSignificantWhitespace` changes.\n    private readonly retainEmptyTokens: boolean = !preserveSignificantWhitespace,\n  ) {}\n\n  private _generateI18nMessage(\n    nodes: html.Node[],\n    meta: string | i18n.I18nMeta = '',\n    visitNodeFn?: VisitNodeFn,\n  ): i18n.Message {\n    const {meaning, description, customId} = this._parseMetadata(meta);\n    const createI18nMessage = createI18nMessageFactory(\n      this.interpolationConfig,\n      this.containerBlocks,\n      this.retainEmptyTokens,\n      /* preserveExpressionWhitespace */ this.preserveSignificantWhitespace,\n    );\n    const message = createI18nMessage(nodes, meaning, description, customId, visitNodeFn);\n    this._setMessageId(message, meta);\n    this._setLegacyIds(message, meta);\n    return message;\n  }\n\n  visitAllWithErrors(nodes: html.Node[]): ParseTreeResult {\n    const result = nodes.map((node) => node.visit(this, null));\n    return new ParseTreeResult(result, this._errors);\n  }\n\n  visitElement(element: html.Element): any {\n    this._visitElementLike(element);\n    return element;\n  }\n\n  visitComponent(component: html.Component, context: any) {\n    this._visitElementLike(component);\n    return component;\n  }\n\n  visitExpansion(expansion: html.Expansion, currentMessage: i18n.Message | null): any {\n    let message;\n    const meta = expansion.i18n;\n    this.hasI18nMeta = true;\n    if (meta instanceof i18n.IcuPlaceholder) {\n      // set ICU placeholder name (e.g. \"ICU_1\"),\n      // generated while processing root element contents,\n      // so we can reference it when we output translation\n      const name = meta.name;\n      message = this._generateI18nMessage([expansion], meta);\n      const icu = icuFromI18nMessage(message);\n      icu.name = name;\n      if (currentMessage !== null) {\n        // Also update the placeholderToMessage map with this new message\n        currentMessage.placeholderToMessage[name] = message;\n      }\n    } else {\n      // ICU is a top level message, try to use metadata from container element if provided via\n      // `context` argument. Note: context may not be available for standalone ICUs (without\n      // wrapping element), so fallback to ICU metadata in this case.\n      message = this._generateI18nMessage([expansion], currentMessage || meta);\n    }\n    expansion.i18n = message;\n    return expansion;\n  }\n\n  visitText(text: html.Text): any {\n    return text;\n  }\n  visitAttribute(attribute: html.Attribute): any {\n    return attribute;\n  }\n  visitComment(comment: html.Comment): any {\n    return comment;\n  }\n  visitExpansionCase(expansionCase: html.ExpansionCase): any {\n    return expansionCase;\n  }\n\n  visitBlock(block: html.Block, context: any) {\n    html.visitAll(this, block.children, context);\n    return block;\n  }\n\n  visitBlockParameter(parameter: html.BlockParameter, context: any) {\n    return parameter;\n  }\n\n  visitLetDeclaration(decl: html.LetDeclaration, context: any) {\n    return decl;\n  }\n\n  visitDirective(directive: html.Directive, context: any) {\n    return directive;\n  }\n\n  private _visitElementLike(node: html.Element | html.Component): void {\n    let message: i18n.Message | undefined = undefined;\n\n    if (hasI18nAttrs(node)) {\n      this.hasI18nMeta = true;\n      const attrs: html.Attribute[] = [];\n      const attrsMeta: {[key: string]: string} = {};\n\n      for (const attr of node.attrs) {\n        if (attr.name === I18N_ATTR) {\n          // root 'i18n' node attribute\n          const i18n = node.i18n || attr.value;\n\n          // Generate a new AST with whitespace trimmed, but also generate a map\n          // to correlate each new node to its original so we can apply i18n\n          // information to the original node based on the trimmed content.\n          //\n          // `WhitespaceVisitor` removes *insignificant* whitespace as well as\n          // significant whitespace. Enabling this visitor should be conditional\n          // on `preserveWhitespace` rather than `preserveSignificantWhitespace`,\n          // however this would be a breaking change for existing behavior where\n          // `preserveWhitespace` was not respected correctly when generating\n          // message IDs. This is really a bug but one we need to keep to maintain\n          // backwards compatibility.\n          const originalNodeMap = new Map<html.Node, html.Node>();\n          const trimmedNodes = this.preserveSignificantWhitespace\n            ? node.children\n            : visitAllWithSiblings(\n                new WhitespaceVisitor(false /* preserveSignificantWhitespace */, originalNodeMap),\n                node.children,\n              );\n          message = this._generateI18nMessage(trimmedNodes, i18n, setI18nRefs(originalNodeMap));\n          if (message.nodes.length === 0) {\n            // Ignore the message if it is empty.\n            message = undefined;\n          }\n          // Store the message on the element\n          node.i18n = message;\n        } else if (attr.name.startsWith(I18N_ATTR_PREFIX)) {\n          // 'i18n-*' attributes\n          const name = attr.name.slice(I18N_ATTR_PREFIX.length);\n          let isTrustedType: boolean;\n          if (node instanceof html.Component) {\n            isTrustedType = node.tagName === null ? false : isTrustedTypesSink(node.tagName, name);\n          } else {\n            isTrustedType = isTrustedTypesSink(node.name, name);\n          }\n\n          if (isTrustedType) {\n            this._reportError(\n              attr,\n              `Translating attribute '${name}' is disallowed for security reasons.`,\n            );\n          } else {\n            attrsMeta[name] = attr.value;\n          }\n        } else {\n          // non-i18n attributes\n          attrs.push(attr);\n        }\n      }\n\n      // set i18n meta for attributes\n      if (Object.keys(attrsMeta).length) {\n        for (const attr of attrs) {\n          const meta = attrsMeta[attr.name];\n          // do not create translation for empty attributes\n          if (meta !== undefined && attr.value) {\n            attr.i18n = this._generateI18nMessage([attr], attr.i18n || meta);\n          }\n        }\n      }\n\n      if (!this.keepI18nAttrs) {\n        // update element's attributes,\n        // keeping only non-i18n related ones\n        node.attrs = attrs;\n      }\n    }\n    html.visitAll(this, node.children, message);\n  }\n\n  /**\n   * Parse the general form `meta` passed into extract the explicit metadata needed to create a\n   * `Message`.\n   *\n   * There are three possibilities for the `meta` variable\n   * 1) a string from an `i18n` template attribute: parse it to extract the metadata values.\n   * 2) a `Message` from a previous processing pass: reuse the metadata values in the message.\n   * 4) other: ignore this and just process the message metadata as normal\n   *\n   * @param meta the bucket that holds information about the message\n   * @returns the parsed metadata.\n   */\n  private _parseMetadata(meta: string | i18n.I18nMeta): I18nMeta {\n    return typeof meta === 'string'\n      ? parseI18nMeta(meta)\n      : meta instanceof i18n.Message\n        ? meta\n        : {};\n  }\n\n  /**\n   * Generate (or restore) message id if not specified already.\n   */\n  private _setMessageId(message: i18n.Message, meta: string | i18n.I18nMeta): void {\n    if (!message.id) {\n      message.id = (meta instanceof i18n.Message && meta.id) || decimalDigest(message);\n    }\n  }\n\n  /**\n   * Update the `message` with a `legacyId` if necessary.\n   *\n   * @param message the message whose legacy id should be set\n   * @param meta information about the message being processed\n   */\n  private _setLegacyIds(message: i18n.Message, meta: string | i18n.I18nMeta): void {\n    if (this.enableI18nLegacyMessageIdFormat) {\n      message.legacyIds = [computeDigest(message), computeDecimalDigest(message)];\n    } else if (typeof meta !== 'string') {\n      // This occurs if we are doing the 2nd pass after whitespace removal (see `parseTemplate()` in\n      // `packages/compiler/src/render3/view/template.ts`).\n      // In that case we want to reuse the legacy message generated in the 1st pass (see\n      // `setI18nRefs()`).\n      const previousMessage =\n        meta instanceof i18n.Message\n          ? meta\n          : meta instanceof i18n.IcuPlaceholder\n            ? meta.previousMessage\n            : undefined;\n      message.legacyIds = previousMessage ? previousMessage.legacyIds : [];\n    }\n  }\n\n  private _reportError(node: html.Node, msg: string): void {\n    this._errors.push(new ParseError(node.sourceSpan, msg));\n  }\n}\n\n/** I18n separators for metadata **/\nconst I18N_MEANING_SEPARATOR = '|';\nconst I18N_ID_SEPARATOR = '@@';\n\n/**\n * Parses i18n metas like:\n *  - \"@@id\",\n *  - \"description[@@id]\",\n *  - \"meaning|description[@@id]\"\n * and returns an object with parsed output.\n *\n * @param meta String that represents i18n meta\n * @returns Object with id, meaning and description fields\n */\nexport function parseI18nMeta(meta: string = ''): I18nMeta {\n  let customId: string | undefined;\n  let meaning: string | undefined;\n  let description: string | undefined;\n\n  meta = meta.trim();\n  if (meta) {\n    const idIndex = meta.indexOf(I18N_ID_SEPARATOR);\n    const descIndex = meta.indexOf(I18N_MEANING_SEPARATOR);\n    let meaningAndDesc: string;\n    [meaningAndDesc, customId] =\n      idIndex > -1 ? [meta.slice(0, idIndex), meta.slice(idIndex + 2)] : [meta, ''];\n    [meaning, description] =\n      descIndex > -1\n        ? [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)]\n        : ['', meaningAndDesc];\n  }\n\n  return {customId, meaning, description};\n}\n\n// Converts i18n meta information for a message (id, description, meaning)\n// to a JsDoc statement formatted as expected by the Closure compiler.\nexport function i18nMetaToJSDoc(meta: I18nMeta): o.JSDocComment {\n  const tags: o.JSDocTag[] = [];\n  if (meta.description) {\n    tags.push({tagName: o.JSDocTagName.Desc, text: meta.description});\n  } else {\n    // Suppress the JSCompiler warning that a `@desc` was not given for this message.\n    tags.push({tagName: o.JSDocTagName.Suppress, text: '{msgDescriptions}'});\n  }\n  if (meta.meaning) {\n    tags.push({tagName: o.JSDocTagName.Meaning, text: meta.meaning});\n  }\n  return o.jsDocComment(tags);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport * as i18n from '../../../i18n/i18n_ast';\nimport {mapLiteral} from '../../../output/map_util';\nimport * as o from '../../../output/output_ast';\n\nimport {serializeIcuNode} from './icu_serializer';\nimport {i18nMetaToJSDoc} from './meta';\nimport {formatI18nPlaceholderName, formatI18nPlaceholderNamesInMap} from './util';\n\n/** Closure uses `goog.getMsg(message)` to lookup translations */\nconst GOOG_GET_MSG = 'goog.getMsg';\n\n/**\n * Generates a `goog.getMsg()` statement and reassignment. The template:\n *\n * ```html\n * <div i18n>Sent from {{ sender }} to <span class=\"receiver\">{{ receiver }}</span></div>\n * ```\n *\n * Generates:\n *\n * ```ts\n * const MSG_FOO = goog.getMsg(\n *   // Message template.\n *   'Sent from {$interpolation} to {$startTagSpan}{$interpolation_1}{$closeTagSpan}.',\n *   // Placeholder values, set to magic strings which get replaced by the Angular runtime.\n *   {\n *     'interpolation': '\\uFFFD0\\uFFFD',\n *     'startTagSpan': '\\uFFFD1\\uFFFD',\n *     'interpolation_1': '\\uFFFD2\\uFFFD',\n *     'closeTagSpan': '\\uFFFD3\\uFFFD',\n *   },\n *   // Options bag.\n *   {\n *     // Maps each placeholder to the original Angular source code which generates it's value.\n *     original_code: {\n *       'interpolation': '{{ sender }}',\n *       'startTagSpan': '<span class=\"receiver\">',\n *       'interpolation_1': '{{ receiver }}',\n *       'closeTagSpan': '</span>',\n *     },\n *   },\n * );\n * const I18N_0 = MSG_FOO;\n * ```\n */\nexport function createGoogleGetMsgStatements(\n  variable: o.ReadVarExpr,\n  message: i18n.Message,\n  closureVar: o.ReadVarExpr,\n  placeholderValues: {[name: string]: o.Expression},\n): o.Statement[] {\n  const messageString = serializeI18nMessageForGetMsg(message);\n  const args = [o.literal(messageString) as o.Expression];\n  if (Object.keys(placeholderValues).length) {\n    // Message template parameters containing the magic strings replaced by the Angular runtime with\n    // real data, e.g. `{'interpolation': '\\uFFFD0\\uFFFD'}`.\n    args.push(\n      mapLiteral(\n        formatI18nPlaceholderNamesInMap(placeholderValues, true /* useCamelCase */),\n        true /* quoted */,\n      ),\n    );\n\n    // Message options object, which contains original source code for placeholders (as they are\n    // present in a template, e.g.\n    // `{original_code: {'interpolation': '{{ name }}', 'startTagSpan': '<span>'}}`.\n    args.push(\n      mapLiteral({\n        original_code: o.literalMap(\n          Object.keys(placeholderValues).map((param) => ({\n            key: formatI18nPlaceholderName(param),\n            quoted: true,\n            value: message.placeholders[param]\n              ? // Get source span for typical placeholder if it exists.\n                o.literal(message.placeholders[param].sourceSpan.toString())\n              : // Otherwise must be an ICU expression, get it's source span.\n                o.literal(\n                  message.placeholderToMessage[param].nodes\n                    .map((node) => node.sourceSpan.toString())\n                    .join(''),\n                ),\n          })),\n        ),\n      }),\n    );\n  }\n\n  // /**\n  //  * @desc description of message\n  //  * @meaning meaning of message\n  //  */\n  // const MSG_... = goog.getMsg(..);\n  // I18N_X = MSG_...;\n  const googGetMsgStmt = new o.DeclareVarStmt(\n    closureVar.name,\n    o.variable(GOOG_GET_MSG).callFn(args),\n    o.INFERRED_TYPE,\n    o.StmtModifier.Final,\n  );\n  googGetMsgStmt.addLeadingComment(i18nMetaToJSDoc(message));\n  const i18nAssignmentStmt = new o.ExpressionStatement(variable.set(closureVar));\n  return [googGetMsgStmt, i18nAssignmentStmt];\n}\n\n/**\n * This visitor walks over i18n tree and generates its string representation, including ICUs and\n * placeholders in `{$placeholder}` (for plain messages) or `{PLACEHOLDER}` (inside ICUs) format.\n */\nclass GetMsgSerializerVisitor implements i18n.Visitor {\n  private formatPh(value: string): string {\n    return `{$${formatI18nPlaceholderName(value)}}`;\n  }\n\n  visitText(text: i18n.Text): any {\n    return text.value;\n  }\n\n  visitContainer(container: i18n.Container): any {\n    return container.children.map((child) => child.visit(this)).join('');\n  }\n\n  visitIcu(icu: i18n.Icu): any {\n    return serializeIcuNode(icu);\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder): any {\n    return ph.isVoid\n      ? this.formatPh(ph.startName)\n      : `${this.formatPh(ph.startName)}${ph.children\n          .map((child) => child.visit(this))\n          .join('')}${this.formatPh(ph.closeName)}`;\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder): any {\n    return this.formatPh(ph.name);\n  }\n\n  visitBlockPlaceholder(ph: i18n.BlockPlaceholder): any {\n    return `${this.formatPh(ph.startName)}${ph.children\n      .map((child) => child.visit(this))\n      .join('')}${this.formatPh(ph.closeName)}`;\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): any {\n    return this.formatPh(ph.name);\n  }\n}\n\nconst serializerVisitor = new GetMsgSerializerVisitor();\n\nexport function serializeI18nMessageForGetMsg(message: i18n.Message): string {\n  return message.nodes.map((node) => node.visit(serializerVisitor, null)).join('');\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport * as i18n from '../../../i18n/i18n_ast';\nimport * as o from '../../../output/output_ast';\nimport {ParseLocation, ParseSourceSpan} from '../../../parse_util';\n\nimport {serializeIcuNode} from './icu_serializer';\nimport {formatI18nPlaceholderName} from './util';\n\nexport function createLocalizeStatements(\n  variable: o.ReadVarExpr,\n  message: i18n.Message,\n  params: {[name: string]: o.Expression},\n): o.Statement[] {\n  const {messageParts, placeHolders} = serializeI18nMessageForLocalize(message);\n  const sourceSpan = getSourceSpan(message);\n  const expressions = placeHolders.map((ph) => params[ph.text]);\n  const localizedString = o.localizedString(\n    message,\n    messageParts,\n    placeHolders,\n    expressions,\n    sourceSpan,\n  );\n  const variableInitialization = variable.set(localizedString);\n  return [new o.ExpressionStatement(variableInitialization)];\n}\n\n/**\n * This visitor walks over an i18n tree, capturing literal strings and placeholders.\n *\n * The result can be used for generating the `$localize` tagged template literals.\n */\nclass LocalizeSerializerVisitor implements i18n.Visitor {\n  constructor(\n    private placeholderToMessage: {[phName: string]: i18n.Message},\n    private pieces: o.MessagePiece[],\n  ) {}\n\n  visitText(text: i18n.Text): any {\n    if (this.pieces[this.pieces.length - 1] instanceof o.LiteralPiece) {\n      // Two literal pieces in a row means that there was some comment node in-between.\n      this.pieces[this.pieces.length - 1].text += text.value;\n    } else {\n      const sourceSpan = new ParseSourceSpan(\n        text.sourceSpan.fullStart,\n        text.sourceSpan.end,\n        text.sourceSpan.fullStart,\n        text.sourceSpan.details,\n      );\n      this.pieces.push(new o.LiteralPiece(text.value, sourceSpan));\n    }\n  }\n\n  visitContainer(container: i18n.Container): any {\n    container.children.forEach((child) => child.visit(this));\n  }\n\n  visitIcu(icu: i18n.Icu): any {\n    this.pieces.push(new o.LiteralPiece(serializeIcuNode(icu), icu.sourceSpan));\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder): any {\n    this.pieces.push(\n      this.createPlaceholderPiece(ph.startName, ph.startSourceSpan ?? ph.sourceSpan),\n    );\n    if (!ph.isVoid) {\n      ph.children.forEach((child) => child.visit(this));\n      this.pieces.push(\n        this.createPlaceholderPiece(ph.closeName, ph.endSourceSpan ?? ph.sourceSpan),\n      );\n    }\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder): any {\n    this.pieces.push(this.createPlaceholderPiece(ph.name, ph.sourceSpan));\n  }\n\n  visitBlockPlaceholder(ph: i18n.BlockPlaceholder): any {\n    this.pieces.push(\n      this.createPlaceholderPiece(ph.startName, ph.startSourceSpan ?? ph.sourceSpan),\n    );\n    ph.children.forEach((child) => child.visit(this));\n    this.pieces.push(this.createPlaceholderPiece(ph.closeName, ph.endSourceSpan ?? ph.sourceSpan));\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder): any {\n    this.pieces.push(\n      this.createPlaceholderPiece(ph.name, ph.sourceSpan, this.placeholderToMessage[ph.name]),\n    );\n  }\n\n  private createPlaceholderPiece(\n    name: string,\n    sourceSpan: ParseSourceSpan,\n    associatedMessage?: i18n.Message,\n  ): o.PlaceholderPiece {\n    return new o.PlaceholderPiece(\n      formatI18nPlaceholderName(name, /* useCamelCase */ false),\n      sourceSpan,\n      associatedMessage,\n    );\n  }\n}\n\n/**\n * Serialize an i18n message into two arrays: messageParts and placeholders.\n *\n * These arrays will be used to generate `$localize` tagged template literals.\n *\n * @param message The message to be serialized.\n * @returns an object containing the messageParts and placeholders.\n */\nexport function serializeI18nMessageForLocalize(message: i18n.Message): {\n  messageParts: o.LiteralPiece[];\n  placeHolders: o.PlaceholderPiece[];\n} {\n  const pieces: o.MessagePiece[] = [];\n  const serializerVisitor = new LocalizeSerializerVisitor(message.placeholderToMessage, pieces);\n  message.nodes.forEach((node) => node.visit(serializerVisitor));\n  return processMessagePieces(pieces);\n}\n\nfunction getSourceSpan(message: i18n.Message): ParseSourceSpan {\n  const startNode = message.nodes[0];\n  const endNode = message.nodes[message.nodes.length - 1];\n  return new ParseSourceSpan(\n    startNode.sourceSpan.fullStart,\n    endNode.sourceSpan.end,\n    startNode.sourceSpan.fullStart,\n    startNode.sourceSpan.details,\n  );\n}\n\n/**\n * Convert the list of serialized MessagePieces into two arrays.\n *\n * One contains the literal string pieces and the other the placeholders that will be replaced by\n * expressions when rendering `$localize` tagged template literals.\n *\n * @param pieces The pieces to process.\n * @returns an object containing the messageParts and placeholders.\n */\nfunction processMessagePieces(pieces: o.MessagePiece[]): {\n  messageParts: o.LiteralPiece[];\n  placeHolders: o.PlaceholderPiece[];\n} {\n  const messageParts: o.LiteralPiece[] = [];\n  const placeHolders: o.PlaceholderPiece[] = [];\n\n  if (pieces[0] instanceof o.PlaceholderPiece) {\n    // The first piece was a placeholder so we need to add an initial empty message part.\n    messageParts.push(createEmptyMessagePart(pieces[0].sourceSpan.start));\n  }\n\n  for (let i = 0; i < pieces.length; i++) {\n    const part = pieces[i];\n    if (part instanceof o.LiteralPiece) {\n      messageParts.push(part);\n    } else {\n      placeHolders.push(part);\n      if (pieces[i - 1] instanceof o.PlaceholderPiece) {\n        // There were two placeholders in a row, so we need to add an empty message part.\n        messageParts.push(createEmptyMessagePart(pieces[i - 1].sourceSpan.end));\n      }\n    }\n  }\n  if (pieces[pieces.length - 1] instanceof o.PlaceholderPiece) {\n    // The last piece was a placeholder so we need to add a final empty message part.\n    messageParts.push(createEmptyMessagePart(pieces[pieces.length - 1].sourceSpan.end));\n  }\n  return {messageParts, placeHolders};\n}\n\nfunction createEmptyMessagePart(location: ParseLocation): o.LiteralPiece {\n  return new o.LiteralPiece('', new ParseSourceSpan(location, location));\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {type ConstantPool} from '../../../../constant_pool';\nimport * as i18n from '../../../../i18n/i18n_ast';\nimport {mapLiteral} from '../../../../output/map_util';\nimport * as o from '../../../../output/output_ast';\nimport {sanitizeIdentifier} from '../../../../parse_util';\nimport {Identifiers} from '../../../../render3/r3_identifiers';\nimport {createGoogleGetMsgStatements} from '../../../../render3/view/i18n/get_msg_utils';\nimport {createLocalizeStatements} from '../../../../render3/view/i18n/localize_utils';\nimport {formatI18nPlaceholderNamesInMap} from '../../../../render3/view/i18n/util';\nimport * as ir from '../../ir';\nimport {ComponentCompilationJob} from '../compilation';\n\n/** Name of the global variable that is used to determine if we use Closure translations or not */\nconst NG_I18N_CLOSURE_MODE = 'ngI18nClosureMode';\n\n/**\n * Prefix for non-`goog.getMsg` i18n-related vars.\n * Note: the prefix uses lowercase characters intentionally due to a Closure behavior that\n * considers variables like `I18N_0` as constants and throws an error when their value changes.\n */\nconst TRANSLATION_VAR_PREFIX = 'i18n_';\n\n/** Prefix of ICU expressions for post processing */\nexport const I18N_ICU_MAPPING_PREFIX = 'I18N_EXP_';\n\n/**\n * The escape sequence used for message param values.\n */\nconst ESCAPE = '\\uFFFD';\n\n/* Closure variables holding messages must be named `MSG_[A-Z0-9]+` */\nconst CLOSURE_TRANSLATION_VAR_PREFIX = 'MSG_';\n\n/**\n * Generates a prefix for translation const name.\n *\n * @param extra Additional local prefix that should be injected into translation var name\n * @returns Complete translation const prefix\n */\nexport function getTranslationConstPrefix(extra: string): string {\n  return `${CLOSURE_TRANSLATION_VAR_PREFIX}${extra}`.toUpperCase();\n}\n\n/**\n * Generate AST to declare a variable. E.g. `var I18N_1;`.\n * @param variable the name of the variable to declare.\n */\nexport function declareI18nVariable(variable: o.ReadVarExpr): o.Statement {\n  return new o.DeclareVarStmt(\n    variable.name!,\n    undefined,\n    o.INFERRED_TYPE,\n    undefined,\n    variable.sourceSpan,\n  );\n}\n\n/**\n * Lifts i18n properties into the consts array.\n * TODO: Can we use `ConstCollectedExpr`?\n * TODO: The way the various attributes are linked together is very complex. Perhaps we could\n * simplify the process, maybe by combining the context and message ops?\n */\nexport function collectI18nConsts(job: ComponentCompilationJob): void {\n  const fileBasedI18nSuffix =\n    job.relativeContextFilePath.replace(/[^A-Za-z0-9]/g, '_').toUpperCase() + '_';\n  // Step One: Build up various lookup maps we need to collect all the consts.\n\n  // Context Xref -> Extracted Attribute Ops\n  const extractedAttributesByI18nContext = new Map<ir.XrefId, ir.ExtractedAttributeOp[]>();\n  // Element/ElementStart Xref -> I18n Attributes config op\n  const i18nAttributesByElement = new Map<ir.XrefId, ir.I18nAttributesOp>();\n  // Element/ElementStart Xref -> All I18n Expression ops for attrs on that target\n  const i18nExpressionsByElement = new Map<ir.XrefId, ir.I18nExpressionOp[]>();\n  // I18n Message Xref -> I18n Message Op (TODO: use a central op map)\n  const messages = new Map<ir.XrefId, ir.I18nMessageOp>();\n\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      if (op.kind === ir.OpKind.ExtractedAttribute && op.i18nContext !== null) {\n        const attributes = extractedAttributesByI18nContext.get(op.i18nContext) ?? [];\n        attributes.push(op);\n        extractedAttributesByI18nContext.set(op.i18nContext, attributes);\n      } else if (op.kind === ir.OpKind.I18nAttributes) {\n        i18nAttributesByElement.set(op.target, op);\n      } else if (\n        op.kind === ir.OpKind.I18nExpression &&\n        op.usage === ir.I18nExpressionFor.I18nAttribute\n      ) {\n        const expressions = i18nExpressionsByElement.get(op.target) ?? [];\n        expressions.push(op);\n        i18nExpressionsByElement.set(op.target, expressions);\n      } else if (op.kind === ir.OpKind.I18nMessage) {\n        messages.set(op.xref, op);\n      }\n    }\n  }\n\n  // Step Two: Serialize the extracted i18n messages for root i18n blocks and i18n attributes into\n  // the const array.\n  //\n  // Also, each i18n message will have a variable expression that can refer to its\n  // value. Store these expressions in the appropriate place:\n  // 1. For normal i18n content, it also goes in the const array. We save the const index to use\n  // later.\n  // 2. For extracted attributes, it becomes the value of the extracted attribute instruction.\n  // 3. For i18n bindings, it will go in a separate const array instruction below; for now, we just\n  // save it.\n\n  const i18nValuesByContext = new Map<ir.XrefId, o.Expression>();\n  const messageConstIndices = new Map<ir.XrefId, ir.ConstIndex>();\n\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === ir.OpKind.I18nMessage) {\n        if (op.messagePlaceholder === null) {\n          const {mainVar, statements} = collectMessage(job, fileBasedI18nSuffix, messages, op);\n          if (op.i18nBlock !== null) {\n            // This is a regular i18n message with a corresponding i18n block. Collect it into the\n            // const array.\n            const i18nConst = job.addConst(mainVar, statements);\n            messageConstIndices.set(op.i18nBlock, i18nConst);\n          } else {\n            // This is an i18n attribute. Extract the initializers into the const pool.\n            job.constsInitializers.push(...statements);\n\n            // Save the i18n variable value for later.\n            i18nValuesByContext.set(op.i18nContext, mainVar);\n\n            // This i18n message may correspond to an individual extracted attribute. If so, The\n            // value of that attribute is updated to read the extracted i18n variable.\n            const attributesForMessage = extractedAttributesByI18nContext.get(op.i18nContext);\n            if (attributesForMessage !== undefined) {\n              for (const attr of attributesForMessage) {\n                attr.expression = mainVar.clone();\n              }\n            }\n          }\n        }\n        ir.OpList.remove<ir.CreateOp>(op);\n      }\n    }\n  }\n\n  // Step Three: Serialize I18nAttributes configurations into the const array. Each I18nAttributes\n  // instruction has a config array, which contains k-v pairs describing each binding name, and the\n  // i18n variable that provides the value.\n\n  for (const unit of job.units) {\n    for (const elem of unit.create) {\n      if (ir.isElementOrContainerOp(elem)) {\n        const i18nAttributes = i18nAttributesByElement.get(elem.xref);\n        if (i18nAttributes === undefined) {\n          // This element is not associated with an i18n attributes configuration instruction.\n          continue;\n        }\n\n        let i18nExpressions = i18nExpressionsByElement.get(elem.xref);\n        if (i18nExpressions === undefined) {\n          // Unused i18nAttributes should have already been removed.\n          // TODO: Should the removal of those dead instructions be merged with this phase?\n          throw new Error(\n            'AssertionError: Could not find any i18n expressions associated with an I18nAttributes instruction',\n          );\n        }\n\n        // Find expressions for all the unique property names, removing duplicates.\n        const seenPropertyNames = new Set<string>();\n        i18nExpressions = i18nExpressions.filter((i18nExpr) => {\n          const seen = seenPropertyNames.has(i18nExpr.name);\n          seenPropertyNames.add(i18nExpr.name);\n          return !seen;\n        });\n\n        const i18nAttributeConfig = i18nExpressions.flatMap((i18nExpr) => {\n          const i18nExprValue = i18nValuesByContext.get(i18nExpr.context);\n          if (i18nExprValue === undefined) {\n            throw new Error(\"AssertionError: Could not find i18n expression's value\");\n          }\n          return [o.literal(i18nExpr.name), i18nExprValue];\n        });\n\n        i18nAttributes.i18nAttributesConfig = job.addConst(\n          new o.LiteralArrayExpr(i18nAttributeConfig),\n        );\n      }\n    }\n  }\n\n  // Step Four: Propagate the extracted const index into i18n ops that messages were extracted from.\n\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === ir.OpKind.I18nStart) {\n        const msgIndex = messageConstIndices.get(op.root);\n        if (msgIndex === undefined) {\n          throw new Error(\n            'AssertionError: Could not find corresponding i18n block index for an i18n message op; was an i18n message incorrectly assumed to correspond to an attribute?',\n          );\n        }\n        op.messageIndex = msgIndex;\n      }\n    }\n  }\n}\n\n/**\n * Collects the given message into a set of statements that can be added to the const array.\n * This will recursively collect any sub-messages referenced from the parent message as well.\n */\nfunction collectMessage(\n  job: ComponentCompilationJob,\n  fileBasedI18nSuffix: string,\n  messages: Map<ir.XrefId, ir.I18nMessageOp>,\n  messageOp: ir.I18nMessageOp,\n): {mainVar: o.ReadVarExpr; statements: o.Statement[]} {\n  // Recursively collect any sub-messages, record each sub-message's main variable under its\n  // placeholder so that we can add them to the params for the parent message. It is possible\n  // that multiple sub-messages will share the same placeholder, so we need to track an array of\n  // variables for each placeholder.\n  const statements: o.Statement[] = [];\n  const subMessagePlaceholders = new Map<string, o.Expression[]>();\n  for (const subMessageId of messageOp.subMessages) {\n    const subMessage = messages.get(subMessageId)!;\n    const {mainVar: subMessageVar, statements: subMessageStatements} = collectMessage(\n      job,\n      fileBasedI18nSuffix,\n      messages,\n      subMessage,\n    );\n    statements.push(...subMessageStatements);\n    const subMessages = subMessagePlaceholders.get(subMessage.messagePlaceholder!) ?? [];\n    subMessages.push(subMessageVar);\n    subMessagePlaceholders.set(subMessage.messagePlaceholder!, subMessages);\n  }\n  addSubMessageParams(messageOp, subMessagePlaceholders);\n\n  // Sort the params for consistency with TemaplateDefinitionBuilder output.\n  messageOp.params = new Map([...messageOp.params.entries()].sort());\n\n  const mainVar = o.variable(job.pool.uniqueName(TRANSLATION_VAR_PREFIX));\n  // Closure Compiler requires const names to start with `MSG_` but disallows any other\n  // const to start with `MSG_`. We define a variable starting with `MSG_` just for the\n  // `goog.getMsg` call\n  const closureVar = i18nGenerateClosureVar(\n    job.pool,\n    messageOp.message.id,\n    fileBasedI18nSuffix,\n    job.i18nUseExternalIds,\n  );\n  let transformFn = undefined;\n\n  // If nescessary, add a post-processing step and resolve any placeholder params that are\n  // set in post-processing.\n  if (messageOp.needsPostprocessing || messageOp.postprocessingParams.size > 0) {\n    // Sort the post-processing params for consistency with TemaplateDefinitionBuilder output.\n    const postprocessingParams = Object.fromEntries(\n      [...messageOp.postprocessingParams.entries()].sort(),\n    );\n    const formattedPostprocessingParams = formatI18nPlaceholderNamesInMap(\n      postprocessingParams,\n      /* useCamelCase */ false,\n    );\n    const extraTransformFnParams: o.Expression[] = [];\n    if (messageOp.postprocessingParams.size > 0) {\n      extraTransformFnParams.push(mapLiteral(formattedPostprocessingParams, /* quoted */ true));\n    }\n    transformFn = (expr: o.ReadVarExpr) =>\n      o.importExpr(Identifiers.i18nPostprocess).callFn([expr, ...extraTransformFnParams]);\n  }\n\n  // Add the message's statements\n  statements.push(\n    ...getTranslationDeclStmts(\n      messageOp.message,\n      mainVar,\n      closureVar,\n      messageOp.params,\n      transformFn,\n    ),\n  );\n\n  return {mainVar, statements};\n}\n\n/**\n * Adds the given subMessage placeholders to the given message op.\n *\n * If a placeholder only corresponds to a single sub-message variable, we just set that variable\n * as the param value. However, if the placeholder corresponds to multiple sub-message\n * variables, we need to add a special placeholder value that is handled by the post-processing\n * step. We then add the array of variables as a post-processing param.\n */\nfunction addSubMessageParams(\n  messageOp: ir.I18nMessageOp,\n  subMessagePlaceholders: Map<string, o.Expression[]>,\n) {\n  for (const [placeholder, subMessages] of subMessagePlaceholders) {\n    if (subMessages.length === 1) {\n      messageOp.params.set(placeholder, subMessages[0]);\n    } else {\n      messageOp.params.set(\n        placeholder,\n        o.literal(`${ESCAPE}${I18N_ICU_MAPPING_PREFIX}${placeholder}${ESCAPE}`),\n      );\n      messageOp.postprocessingParams.set(placeholder, o.literalArr(subMessages));\n    }\n  }\n}\n\n/**\n * Generate statements that define a given translation message.\n *\n * ```ts\n * var I18N_1;\n * if (typeof ngI18nClosureMode !== undefined && ngI18nClosureMode) {\n *     var MSG_EXTERNAL_XXX = goog.getMsg(\n *          \"Some message with {$interpolation}!\",\n *          { \"interpolation\": \"\\uFFFD0\\uFFFD\" }\n *     );\n *     I18N_1 = MSG_EXTERNAL_XXX;\n * }\n * else {\n *     I18N_1 = $localize`Some message with ${'\\uFFFD0\\uFFFD'}!`;\n * }\n * ```\n *\n * @param message The original i18n AST message node\n * @param variable The variable that will be assigned the translation, e.g. `I18N_1`.\n * @param closureVar The variable for Closure `goog.getMsg` calls, e.g. `MSG_EXTERNAL_XXX`.\n * @param params Object mapping placeholder names to their values (e.g.\n * `{ \"interpolation\": \"\\uFFFD0\\uFFFD\" }`).\n * @param transformFn Optional transformation function that will be applied to the translation\n *     (e.g.\n * post-processing).\n * @returns An array of statements that defined a given translation.\n */\nfunction getTranslationDeclStmts(\n  message: i18n.Message,\n  variable: o.ReadVarExpr,\n  closureVar: o.ReadVarExpr,\n  params: Map<string, o.Expression>,\n  transformFn?: (raw: o.ReadVarExpr) => o.Expression,\n): o.Statement[] {\n  const paramsObject = Object.fromEntries(params);\n  const statements: o.Statement[] = [\n    declareI18nVariable(variable),\n    o.ifStmt(\n      createClosureModeGuard(),\n      createGoogleGetMsgStatements(variable, message, closureVar, paramsObject),\n      createLocalizeStatements(\n        variable,\n        message,\n        formatI18nPlaceholderNamesInMap(paramsObject, /* useCamelCase */ false),\n      ),\n    ),\n  ];\n\n  if (transformFn) {\n    statements.push(new o.ExpressionStatement(variable.set(transformFn(variable))));\n  }\n\n  return statements;\n}\n\n/**\n * Create the expression that will be used to guard the closure mode block\n * It is equivalent to:\n *\n * ```ts\n * typeof ngI18nClosureMode !== undefined && ngI18nClosureMode\n * ```\n */\nfunction createClosureModeGuard(): o.BinaryOperatorExpr {\n  return o\n    .typeofExpr(o.variable(NG_I18N_CLOSURE_MODE))\n    .notIdentical(o.literal('undefined', o.STRING_TYPE))\n    .and(o.variable(NG_I18N_CLOSURE_MODE));\n}\n\n/**\n * Generates vars with Closure-specific names for i18n blocks (i.e. `MSG_XXX`).\n */\nfunction i18nGenerateClosureVar(\n  pool: ConstantPool,\n  messageId: string,\n  fileBasedI18nSuffix: string,\n  useExternalIds: boolean,\n): o.ReadVarExpr {\n  let name: string;\n  const suffix = fileBasedI18nSuffix;\n  if (useExternalIds) {\n    const prefix = getTranslationConstPrefix(`EXTERNAL_`);\n    const uniqueSuffix = pool.uniqueName(suffix);\n    name = `${prefix}${sanitizeIdentifier(messageId)}$$${uniqueSuffix}`;\n  } else {\n    const prefix = getTranslationConstPrefix(suffix);\n    name = pool.uniqueName(prefix);\n  }\n  return o.variable(name);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as ir from '../../ir';\nimport {CompilationJob} from '../compilation';\n\n/**\n * Removes text nodes within i18n blocks since they are already hardcoded into the i18n message.\n * Also, replaces interpolations on these text nodes with i18n expressions of the non-text portions,\n * which will be applied later.\n */\nexport function convertI18nText(job: CompilationJob): void {\n  for (const unit of job.units) {\n    // Remove all text nodes within i18n blocks, their content is already captured in the i18n\n    // message.\n    let currentI18n: ir.I18nStartOp | null = null;\n    let currentIcu: ir.IcuStartOp | null = null;\n    const textNodeI18nBlocks = new Map<ir.XrefId, ir.I18nStartOp>();\n    const textNodeIcus = new Map<ir.XrefId, ir.IcuStartOp | null>();\n    const icuPlaceholderByText = new Map<ir.XrefId, ir.IcuPlaceholderOp>();\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case ir.OpKind.I18nStart:\n          if (op.context === null) {\n            throw Error('I18n op should have its context set.');\n          }\n          currentI18n = op;\n          break;\n        case ir.OpKind.I18nEnd:\n          currentI18n = null;\n          break;\n        case ir.OpKind.IcuStart:\n          if (op.context === null) {\n            throw Error('Icu op should have its context set.');\n          }\n          currentIcu = op;\n          break;\n        case ir.OpKind.IcuEnd:\n          currentIcu = null;\n          break;\n        case ir.OpKind.Text:\n          if (currentI18n !== null) {\n            textNodeI18nBlocks.set(op.xref, currentI18n);\n            textNodeIcus.set(op.xref, currentIcu);\n            if (op.icuPlaceholder !== null) {\n              // Create an op to represent the ICU placeholder. Initially set its static text to the\n              // value of the text op, though this may be overwritten later if this text op is a\n              // placeholder for an interpolation.\n              const icuPlaceholderOp = ir.createIcuPlaceholderOp(\n                job.allocateXrefId(),\n                op.icuPlaceholder,\n                [op.initialValue],\n              );\n              ir.OpList.replace<ir.CreateOp>(op, icuPlaceholderOp);\n              icuPlaceholderByText.set(op.xref, icuPlaceholderOp);\n            } else {\n              // Otherwise just remove the text op, since its value is already accounted for in the\n              // translated message.\n              ir.OpList.remove<ir.CreateOp>(op);\n            }\n          }\n          break;\n      }\n    }\n\n    // Update any interpolations to the removed text, and instead represent them as a series of i18n\n    // expressions that we then apply.\n    for (const op of unit.update) {\n      switch (op.kind) {\n        case ir.OpKind.InterpolateText:\n          if (!textNodeI18nBlocks.has(op.target)) {\n            continue;\n          }\n\n          const i18nOp = textNodeI18nBlocks.get(op.target)!;\n          const icuOp = textNodeIcus.get(op.target);\n          const icuPlaceholder = icuPlaceholderByText.get(op.target);\n          const contextId = icuOp ? icuOp.context : i18nOp.context;\n          const resolutionTime = icuOp\n            ? ir.I18nParamResolutionTime.Postproccessing\n            : ir.I18nParamResolutionTime.Creation;\n          const ops: ir.I18nExpressionOp[] = [];\n          for (let i = 0; i < op.interpolation.expressions.length; i++) {\n            const expr = op.interpolation.expressions[i];\n            // For now, this i18nExpression depends on the slot context of the enclosing i18n block.\n            // Later, we will modify this, and advance to a different point.\n            ops.push(\n              ir.createI18nExpressionOp(\n                contextId!,\n                i18nOp.xref,\n                i18nOp.xref,\n                i18nOp.handle,\n                expr,\n                icuPlaceholder?.xref ?? null,\n                op.interpolation.i18nPlaceholders[i] ?? null,\n                resolutionTime,\n                ir.I18nExpressionFor.I18nText,\n                '',\n                expr.sourceSpan ?? op.sourceSpan,\n              ),\n            );\n          }\n          ir.OpList.replaceWithMany(op as ir.UpdateOp, ops);\n          // If this interpolation is part of an ICU placeholder, add the strings and expressions to\n          // the placeholder.\n          if (icuPlaceholder !== undefined) {\n            icuPlaceholder.strings = op.interpolation.strings;\n          }\n          break;\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\n\nimport type {ComponentCompilationJob} from '../compilation';\n\n/**\n * Lifts local reference declarations on element-like structures within each view into an entry in\n * the `consts` array for the whole component.\n */\nexport function liftLocalRefs(job: ComponentCompilationJob): void {\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case ir.OpKind.ElementStart:\n        case ir.OpKind.ConditionalCreate:\n        case ir.OpKind.ConditionalBranchCreate:\n        case ir.OpKind.Template:\n          if (!Array.isArray(op.localRefs)) {\n            throw new Error(`AssertionError: expected localRefs to be an array still`);\n          }\n          op.numSlotsUsed += op.localRefs.length;\n\n          if (op.localRefs.length > 0) {\n            const localRefs = serializeLocalRefs(op.localRefs);\n            op.localRefs = job.addConst(localRefs);\n          } else {\n            op.localRefs = null;\n          }\n          break;\n      }\n    }\n  }\n}\n\nfunction serializeLocalRefs(refs: ir.LocalRef[]): o.Expression {\n  const constRefs: o.Expression[] = [];\n  for (const ref of refs) {\n    constRefs.push(o.literal(ref.name), o.literal(ref.target));\n  }\n  return o.literalArr(constRefs);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as ir from '../../ir';\nimport type {CompilationJob} from '../compilation';\n\n/**\n * Change namespaces between HTML, SVG and MathML, depending on the next element.\n */\nexport function emitNamespaceChanges(job: CompilationJob): void {\n  for (const unit of job.units) {\n    let activeNamespace = ir.Namespace.HTML;\n\n    for (const op of unit.create) {\n      if (op.kind !== ir.OpKind.ElementStart) {\n        continue;\n      }\n      if (op.namespace !== activeNamespace) {\n        ir.OpList.insertBefore<ir.CreateOp>(ir.createNamespaceOp(op.namespace), op);\n        activeNamespace = op.namespace;\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {SecurityContext} from '../../../../core';\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\n\nimport type {CompilationJob} from '../compilation';\n\n// Any changes here should be ported to the Angular Domino fork.\n// https://github.com/angular/domino/blob/main/lib/style_parser.js\n\nconst enum Char {\n  OpenParen = 40,\n  CloseParen = 41,\n  Colon = 58,\n  Semicolon = 59,\n  BackSlash = 92,\n  QuoteNone = 0, // indicating we are not inside a quote\n  QuoteDouble = 34,\n  QuoteSingle = 39,\n}\n\n/**\n * Parses string representation of a style and converts it into object literal.\n *\n * @param value string representation of style as used in the `style` attribute in HTML.\n *   Example: `color: red; height: auto`.\n * @returns An array of style property name and value pairs, e.g. `['color', 'red', 'height',\n * 'auto']`\n */\nexport function parse(value: string): string[] {\n  // we use a string array here instead of a string map\n  // because a string-map is not guaranteed to retain the\n  // order of the entries whereas a string array can be\n  // constructed in a [key, value, key, value] format.\n  const styles: string[] = [];\n\n  let i = 0;\n  let parenDepth = 0;\n  let quote: Char = Char.QuoteNone;\n  let valueStart = 0;\n  let propStart = 0;\n  let currentProp: string | null = null;\n  while (i < value.length) {\n    const token = value.charCodeAt(i++) as Char;\n    switch (token) {\n      case Char.OpenParen:\n        parenDepth++;\n        break;\n      case Char.CloseParen:\n        parenDepth--;\n        break;\n      case Char.QuoteSingle:\n        // valueStart needs to be there since prop values don't\n        // have quotes in CSS\n        if (quote === Char.QuoteNone) {\n          quote = Char.QuoteSingle;\n        } else if (quote === Char.QuoteSingle && value.charCodeAt(i - 1) !== Char.BackSlash) {\n          quote = Char.QuoteNone;\n        }\n        break;\n      case Char.QuoteDouble:\n        // same logic as above\n        if (quote === Char.QuoteNone) {\n          quote = Char.QuoteDouble;\n        } else if (quote === Char.QuoteDouble && value.charCodeAt(i - 1) !== Char.BackSlash) {\n          quote = Char.QuoteNone;\n        }\n        break;\n      case Char.Colon:\n        if (!currentProp && parenDepth === 0 && quote === Char.QuoteNone) {\n          // TODO: Do not hyphenate CSS custom property names like: `--intentionallyCamelCase`\n          currentProp = hyphenate(value.substring(propStart, i - 1).trim());\n          valueStart = i;\n        }\n        break;\n      case Char.Semicolon:\n        if (currentProp && valueStart > 0 && parenDepth === 0 && quote === Char.QuoteNone) {\n          const styleVal = value.substring(valueStart, i - 1).trim();\n          styles.push(currentProp, styleVal);\n          propStart = i;\n          valueStart = 0;\n          currentProp = null;\n        }\n        break;\n    }\n  }\n\n  if (currentProp && valueStart) {\n    const styleVal = value.slice(valueStart).trim();\n    styles.push(currentProp, styleVal);\n  }\n\n  return styles;\n}\n\nexport function hyphenate(value: string): string {\n  return value\n    .replace(/[a-z][A-Z]/g, (v) => {\n      return v.charAt(0) + '-' + v.charAt(1);\n    })\n    .toLowerCase();\n}\n\n/**\n * Parses extracted style and class attributes into separate ExtractedAttributeOps per style or\n * class property.\n */\nexport function parseExtractedStyles(job: CompilationJob) {\n  const elements = new Map<ir.XrefId, ir.CreateOp>();\n\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (ir.isElementOrContainerOp(op)) {\n        elements.set(op.xref, op);\n      }\n    }\n  }\n\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (\n        op.kind === ir.OpKind.ExtractedAttribute &&\n        op.bindingKind === ir.BindingKind.Attribute &&\n        ir.isStringLiteral(op.expression!)\n      ) {\n        const target = elements.get(op.target)!;\n\n        if (\n          target !== undefined &&\n          (target.kind === ir.OpKind.Template ||\n            target.kind === ir.OpKind.ConditionalCreate ||\n            target.kind === ir.OpKind.ConditionalBranchCreate) &&\n          target.templateKind === ir.TemplateKind.Structural\n        ) {\n          // TemplateDefinitionBuilder will not apply class and style bindings to structural\n          // directives; instead, it will leave them as attributes.\n          // (It's not clear what that would mean, anyway -- classes and styles on a structural\n          // element should probably be a parse error.)\n          // TODO: We may be able to remove this once Template Pipeline is the default.\n          continue;\n        }\n\n        if (op.name === 'style') {\n          const parsedStyles = parse(op.expression.value);\n          for (let i = 0; i < parsedStyles.length - 1; i += 2) {\n            ir.OpList.insertBefore<ir.CreateOp>(\n              ir.createExtractedAttributeOp(\n                op.target,\n                ir.BindingKind.StyleProperty,\n                null,\n                parsedStyles[i],\n                o.literal(parsedStyles[i + 1]),\n                null,\n                null,\n                SecurityContext.STYLE,\n              ),\n              op,\n            );\n          }\n          ir.OpList.remove<ir.CreateOp>(op);\n        } else if (op.name === 'class') {\n          const parsedClasses = op.expression.value.trim().split(/\\s+/g);\n          for (const parsedClass of parsedClasses) {\n            ir.OpList.insertBefore<ir.CreateOp>(\n              ir.createExtractedAttributeOp(\n                op.target,\n                ir.BindingKind.ClassName,\n                null,\n                parsedClass,\n                null,\n                null,\n                null,\n                SecurityContext.NONE,\n              ),\n              op,\n            );\n          }\n          ir.OpList.remove<ir.CreateOp>(op);\n        }\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {sanitizeIdentifier} from '../../../../parse_util';\nimport * as ir from '../../ir';\n\nimport {hyphenate} from './parse_extracted_styles';\n\nimport {type CompilationJob, type CompilationUnit, ViewCompilationUnit} from '../compilation';\n\n/**\n * Generate names for functions and variables across all views.\n *\n * This includes propagating those names into any `ir.ReadVariableExpr`s of those variables, so that\n * the reads can be emitted correctly.\n */\nexport function nameFunctionsAndVariables(job: CompilationJob): void {\n  addNamesToView(\n    job.root,\n    job.componentName,\n    {index: 0},\n    job.compatibility === ir.CompatibilityMode.TemplateDefinitionBuilder,\n  );\n}\n\nfunction addNamesToView(\n  unit: CompilationUnit,\n  baseName: string,\n  state: {index: number},\n  compatibility: boolean,\n): void {\n  if (unit.fnName === null) {\n    // Ensure unique names for view units. This is necessary because there might be multiple\n    // components with same names in the context of the same pool. Only add the suffix\n    // if really needed.\n    unit.fnName = unit.job.pool.uniqueName(\n      sanitizeIdentifier(`${baseName}_${unit.job.fnSuffix}`),\n      /* alwaysIncludeSuffix */ false,\n    );\n  }\n\n  // Keep track of the names we assign to variables in the view. We'll need to propagate these\n  // into reads of those variables afterwards.\n  const varNames = new Map<ir.XrefId, string>();\n\n  for (const op of unit.ops()) {\n    switch (op.kind) {\n      case ir.OpKind.Property:\n      case ir.OpKind.DomProperty:\n        if (op.bindingKind === ir.BindingKind.LegacyAnimation) {\n          op.name = '@' + op.name;\n        }\n        break;\n      case ir.OpKind.Animation:\n        if (op.handlerFnName === null) {\n          const animationKind = op.name.replace('.', '');\n          op.handlerFnName = `${unit.fnName}_${animationKind}_cb`;\n          op.handlerFnName = sanitizeIdentifier(op.handlerFnName);\n        }\n        break;\n      case ir.OpKind.AnimationListener:\n        if (op.handlerFnName !== null) {\n          break;\n        }\n        if (!op.hostListener && op.targetSlot.slot === null) {\n          throw new Error(`Expected a slot to be assigned`);\n        }\n        const animationKind = op.name.replace('.', '');\n        if (op.hostListener) {\n          op.handlerFnName = `${baseName}_${animationKind}_HostBindingHandler`;\n        } else {\n          op.handlerFnName = `${unit.fnName}_${op.tag!.replace('-', '_')}_${animationKind}_${\n            op.targetSlot.slot\n          }_listener`;\n        }\n        op.handlerFnName = sanitizeIdentifier(op.handlerFnName);\n        break;\n      case ir.OpKind.Listener:\n        if (op.handlerFnName !== null) {\n          break;\n        }\n        if (!op.hostListener && op.targetSlot.slot === null) {\n          throw new Error(`Expected a slot to be assigned`);\n        }\n        let animation = '';\n        if (op.isLegacyAnimationListener) {\n          op.name = `@${op.name}.${op.legacyAnimationPhase}`;\n          animation = 'animation';\n        }\n        if (op.hostListener) {\n          op.handlerFnName = `${baseName}_${animation}${op.name}_HostBindingHandler`;\n        } else {\n          op.handlerFnName = `${unit.fnName}_${op.tag!.replace('-', '_')}_${animation}${op.name}_${\n            op.targetSlot.slot\n          }_listener`;\n        }\n        op.handlerFnName = sanitizeIdentifier(op.handlerFnName);\n        break;\n      case ir.OpKind.TwoWayListener:\n        if (op.handlerFnName !== null) {\n          break;\n        }\n        if (op.targetSlot.slot === null) {\n          throw new Error(`Expected a slot to be assigned`);\n        }\n        op.handlerFnName = sanitizeIdentifier(\n          `${unit.fnName}_${op.tag!.replace('-', '_')}_${op.name}_${op.targetSlot.slot}_listener`,\n        );\n        break;\n      case ir.OpKind.Variable:\n        varNames.set(op.xref, getVariableName(unit, op.variable, state));\n        break;\n      case ir.OpKind.RepeaterCreate:\n        if (!(unit instanceof ViewCompilationUnit)) {\n          throw new Error(`AssertionError: must be compiling a component`);\n        }\n        if (op.handle.slot === null) {\n          throw new Error(`Expected slot to be assigned`);\n        }\n        if (op.emptyView !== null) {\n          const emptyView = unit.job.views.get(op.emptyView)!;\n          // Repeater empty view function is at slot +2 (metadata is in the first slot).\n          addNamesToView(\n            emptyView,\n            `${baseName}_${op.functionNameSuffix}Empty_${op.handle.slot + 2}`,\n            state,\n            compatibility,\n          );\n        }\n        // Repeater primary view function is at slot +1 (metadata is in the first slot).\n        addNamesToView(\n          unit.job.views.get(op.xref)!,\n          `${baseName}_${op.functionNameSuffix}_${op.handle.slot + 1}`,\n          state,\n          compatibility,\n        );\n        break;\n      case ir.OpKind.Projection:\n        if (!(unit instanceof ViewCompilationUnit)) {\n          throw new Error(`AssertionError: must be compiling a component`);\n        }\n        if (op.handle.slot === null) {\n          throw new Error(`Expected slot to be assigned`);\n        }\n        if (op.fallbackView !== null) {\n          const fallbackView = unit.job.views.get(op.fallbackView)!;\n          addNamesToView(\n            fallbackView,\n            `${baseName}_ProjectionFallback_${op.handle.slot}`,\n            state,\n            compatibility,\n          );\n        }\n        break;\n      case ir.OpKind.ConditionalCreate:\n      case ir.OpKind.ConditionalBranchCreate:\n      case ir.OpKind.Template:\n        if (!(unit instanceof ViewCompilationUnit)) {\n          throw new Error(`AssertionError: must be compiling a component`);\n        }\n        const childView = unit.job.views.get(op.xref)!;\n        if (op.handle.slot === null) {\n          throw new Error(`Expected slot to be assigned`);\n        }\n        const suffix = op.functionNameSuffix.length === 0 ? '' : `_${op.functionNameSuffix}`;\n        addNamesToView(childView, `${baseName}${suffix}_${op.handle.slot}`, state, compatibility);\n        break;\n      case ir.OpKind.StyleProp:\n        op.name = normalizeStylePropName(op.name);\n        if (compatibility) {\n          op.name = stripImportant(op.name);\n        }\n        break;\n      case ir.OpKind.ClassProp:\n        if (compatibility) {\n          op.name = stripImportant(op.name);\n        }\n        break;\n    }\n  }\n\n  // Having named all variables declared in the view, now we can push those names into the\n  // `ir.ReadVariableExpr` expressions which represent reads of those variables.\n  for (const op of unit.ops()) {\n    ir.visitExpressionsInOp(op, (expr) => {\n      if (!(expr instanceof ir.ReadVariableExpr) || expr.name !== null) {\n        return;\n      }\n      if (!varNames.has(expr.xref)) {\n        throw new Error(`Variable ${expr.xref} not yet named`);\n      }\n      expr.name = varNames.get(expr.xref)!;\n    });\n  }\n}\n\nfunction getVariableName(\n  unit: CompilationUnit,\n  variable: ir.SemanticVariable,\n  state: {index: number},\n): string {\n  if (variable.name === null) {\n    switch (variable.kind) {\n      case ir.SemanticVariableKind.Context:\n        variable.name = `ctx_r${state.index++}`;\n        break;\n      case ir.SemanticVariableKind.Identifier:\n        if (unit.job.compatibility === ir.CompatibilityMode.TemplateDefinitionBuilder) {\n          // TODO: Prefix increment and `_r` are for compatibility with the old naming scheme.\n          // This has the potential to cause collisions when `ctx` is the identifier, so we need a\n          // special check for that as well.\n          const compatPrefix = variable.identifier === 'ctx' ? 'i' : '';\n          variable.name = `${variable.identifier}_${compatPrefix}r${++state.index}`;\n        } else {\n          variable.name = `${variable.identifier}_i${state.index++}`;\n        }\n\n        break;\n      default:\n        // TODO: Prefix increment for compatibility only.\n        variable.name = `_r${++state.index}`;\n        break;\n    }\n  }\n  return variable.name;\n}\n\n/**\n * Normalizes a style prop name by hyphenating it (unless its a CSS variable).\n */\nfunction normalizeStylePropName(name: string) {\n  return name.startsWith('--') ? name : hyphenate(name);\n}\n\n/**\n * Strips `!important` out of the given style or class name.\n */\nfunction stripImportant(name: string) {\n  const importantIndex = name.indexOf('!important');\n  if (importantIndex > -1) {\n    return name.substring(0, importantIndex);\n  }\n  return name;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\n\nimport type {CompilationJob} from '../compilation';\n\n/**\n * Merges logically sequential `NextContextExpr` operations.\n *\n * `NextContextExpr` can be referenced repeatedly, \"popping\" the runtime's context stack each time.\n * When two such expressions appear back-to-back, it's possible to merge them together into a single\n * `NextContextExpr` that steps multiple contexts. This merging is possible if all conditions are\n * met:\n *\n *   * The result of the `NextContextExpr` that's folded into the subsequent one is not stored (that\n *     is, the call is purely side-effectful).\n *   * No operations in between them uses the implicit context.\n */\nexport function mergeNextContextExpressions(job: CompilationJob): void {\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (\n        op.kind === ir.OpKind.Listener ||\n        op.kind === ir.OpKind.Animation ||\n        op.kind === ir.OpKind.AnimationListener ||\n        op.kind === ir.OpKind.TwoWayListener\n      ) {\n        mergeNextContextsInOps(op.handlerOps);\n      }\n    }\n    mergeNextContextsInOps(unit.update);\n  }\n}\n\nfunction mergeNextContextsInOps(ops: ir.OpList<ir.UpdateOp>): void {\n  for (const op of ops) {\n    // Look for a candidate operation to maybe merge.\n    if (\n      op.kind !== ir.OpKind.Statement ||\n      !(op.statement instanceof o.ExpressionStatement) ||\n      !(op.statement.expr instanceof ir.NextContextExpr)\n    ) {\n      continue;\n    }\n\n    const mergeSteps = op.statement.expr.steps;\n\n    // Try to merge this `ir.NextContextExpr`.\n    let tryToMerge = true;\n    for (\n      let candidate = op.next!;\n      candidate.kind !== ir.OpKind.ListEnd && tryToMerge;\n      candidate = candidate.next!\n    ) {\n      ir.visitExpressionsInOp(candidate, (expr, flags) => {\n        if (!ir.isIrExpression(expr)) {\n          return expr;\n        }\n\n        if (!tryToMerge) {\n          // Either we've already merged, or failed to merge.\n          return;\n        }\n\n        if (flags & ir.VisitorContextFlag.InChildOperation) {\n          // We cannot merge into child operations.\n          return;\n        }\n\n        switch (expr.kind) {\n          case ir.ExpressionKind.NextContext:\n            // Merge the previous `ir.NextContextExpr` into this one.\n            expr.steps += mergeSteps;\n            ir.OpList.remove(op as ir.UpdateOp);\n            tryToMerge = false;\n            break;\n          case ir.ExpressionKind.GetCurrentView:\n          case ir.ExpressionKind.Reference:\n          case ir.ExpressionKind.ContextLetReference:\n            // Can't merge past a dependency on the context.\n            tryToMerge = false;\n            break;\n        }\n        return;\n      });\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as ir from '../../ir';\nimport type {CompilationJob} from '../compilation';\n\nconst CONTAINER_TAG = 'ng-container';\n\n/**\n * Replace an `Element` or `ElementStart` whose tag is `ng-container` with a specific op.\n */\nexport function generateNgContainerOps(job: CompilationJob): void {\n  for (const unit of job.units) {\n    const updatedElementXrefs = new Set<ir.XrefId>();\n    for (const op of unit.create) {\n      if (op.kind === ir.OpKind.ElementStart && op.tag === CONTAINER_TAG) {\n        // Transmute the `ElementStart` instruction to `ContainerStart`.\n        (op as ir.Op<ir.CreateOp>).kind = ir.OpKind.ContainerStart;\n        updatedElementXrefs.add(op.xref);\n      }\n\n      if (op.kind === ir.OpKind.ElementEnd && updatedElementXrefs.has(op.xref)) {\n        // This `ElementEnd` is associated with an `ElementStart` we already transmuted.\n        (op as ir.Op<ir.CreateOp>).kind = ir.OpKind.ContainerEnd;\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as ir from '../../ir';\nimport type {CompilationJob} from '../compilation';\n\n/**\n * Looks up an element in the given map by xref ID.\n */\nfunction lookupElement(\n  elements: Map<ir.XrefId, ir.ElementOrContainerOps>,\n  xref: ir.XrefId,\n): ir.ElementOrContainerOps {\n  const el = elements.get(xref);\n  if (el === undefined) {\n    throw new Error('All attributes should have an element-like target.');\n  }\n  return el;\n}\n\n/**\n * When a container is marked with `ngNonBindable`, the non-bindable characteristic also applies to\n * all descendants of that container. Therefore, we must emit `disableBindings` and `enableBindings`\n * instructions for every such container.\n */\nexport function disableBindings(job: CompilationJob): void {\n  const elements = new Map<ir.XrefId, ir.ElementOrContainerOps>();\n  for (const view of job.units) {\n    for (const op of view.create) {\n      if (!ir.isElementOrContainerOp(op)) {\n        continue;\n      }\n      elements.set(op.xref, op);\n    }\n  }\n\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (\n        (op.kind === ir.OpKind.ElementStart || op.kind === ir.OpKind.ContainerStart) &&\n        op.nonBindable\n      ) {\n        ir.OpList.insertAfter<ir.CreateOp>(ir.createDisableBindingsOp(op.xref), op);\n      }\n      if (\n        (op.kind === ir.OpKind.ElementEnd || op.kind === ir.OpKind.ContainerEnd) &&\n        lookupElement(elements, op.xref).nonBindable\n      ) {\n        ir.OpList.insertBefore<ir.CreateOp>(ir.createEnableBindingsOp(op.xref), op);\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as ir from '../../ir';\nimport {CompilationJobKind, type CompilationJob} from '../compilation';\n\nfunction kindTest(kind: ir.OpKind): (op: ir.UpdateOp) => boolean {\n  return (op: ir.UpdateOp) => op.kind === kind;\n}\n\nfunction kindWithInterpolationTest(\n  kind: ir.OpKind.Attribute | ir.OpKind.Property | ir.OpKind.DomProperty,\n  interpolation: boolean,\n): (op: ir.UpdateOp) => boolean {\n  return (op: ir.UpdateOp) => {\n    return op.kind === kind && interpolation === op.expression instanceof ir.Interpolation;\n  };\n}\n\nfunction basicListenerKindTest(op: ir.CreateOp): boolean {\n  return (\n    (op.kind === ir.OpKind.Listener && !(op.hostListener && op.isLegacyAnimationListener)) ||\n    op.kind === ir.OpKind.TwoWayListener ||\n    op.kind === ir.OpKind.Animation ||\n    op.kind === ir.OpKind.AnimationListener\n  );\n}\n\nfunction nonInterpolationPropertyKindTest(op: ir.UpdateOp): boolean {\n  return (\n    (op.kind === ir.OpKind.Property || op.kind === ir.OpKind.TwoWayProperty) &&\n    !(op.expression instanceof ir.Interpolation)\n  );\n}\n\ninterface Rule<T extends ir.CreateOp | ir.UpdateOp> {\n  test: (op: T) => boolean;\n  transform?: (ops: Array<T>) => Array<T>;\n}\n\n/**\n * Defines the groups based on `OpKind` that ops will be divided into, for the various create\n * op kinds. Ops will be collected into groups, then optionally transformed, before recombining\n * the groups in the order defined here.\n */\nconst CREATE_ORDERING: Array<Rule<ir.CreateOp>> = [\n  {test: (op) => op.kind === ir.OpKind.Listener && op.hostListener && op.isLegacyAnimationListener},\n  {test: basicListenerKindTest},\n];\n\n/**\n * Defines the groups based on `OpKind` that ops will be divided into, for the various update\n * op kinds.\n */\nconst UPDATE_ORDERING: Array<Rule<ir.UpdateOp>> = [\n  {test: kindTest(ir.OpKind.StyleMap), transform: keepLast},\n  {test: kindTest(ir.OpKind.ClassMap), transform: keepLast},\n  {test: kindTest(ir.OpKind.StyleProp)},\n  {test: kindTest(ir.OpKind.ClassProp)},\n  {test: kindWithInterpolationTest(ir.OpKind.Attribute, true)},\n  {test: kindWithInterpolationTest(ir.OpKind.Property, true)},\n  {test: nonInterpolationPropertyKindTest},\n  {test: kindWithInterpolationTest(ir.OpKind.Attribute, false)},\n];\n\n/**\n * Host bindings have their own update ordering.\n */\nconst UPDATE_HOST_ORDERING: Array<Rule<ir.UpdateOp>> = [\n  {test: kindWithInterpolationTest(ir.OpKind.DomProperty, true)},\n  {test: kindWithInterpolationTest(ir.OpKind.DomProperty, false)},\n  {test: kindTest(ir.OpKind.Attribute)},\n  {test: kindTest(ir.OpKind.StyleMap), transform: keepLast},\n  {test: kindTest(ir.OpKind.ClassMap), transform: keepLast},\n  {test: kindTest(ir.OpKind.StyleProp)},\n  {test: kindTest(ir.OpKind.ClassProp)},\n];\n\n/**\n * The set of all op kinds we handle in the reordering phase.\n */\nconst handledOpKinds = new Set([\n  ir.OpKind.Listener,\n  ir.OpKind.TwoWayListener,\n  ir.OpKind.AnimationListener,\n  ir.OpKind.StyleMap,\n  ir.OpKind.ClassMap,\n  ir.OpKind.StyleProp,\n  ir.OpKind.ClassProp,\n  ir.OpKind.Property,\n  ir.OpKind.TwoWayProperty,\n  ir.OpKind.DomProperty,\n  ir.OpKind.Attribute,\n  ir.OpKind.Animation,\n]);\n\n/**\n * Many type of operations have ordering constraints that must be respected. For example, a\n * `ClassMap` instruction must be ordered after a `StyleMap` instruction, in order to have\n * predictable semantics that match TemplateDefinitionBuilder and don't break applications.\n */\nexport function orderOps(job: CompilationJob) {\n  for (const unit of job.units) {\n    // First, we pull out ops that need to be ordered. Then, when we encounter an op that shouldn't\n    // be reordered, put the ones we've pulled so far back in the correct order. Finally, if we\n    // still have ops pulled at the end, put them back in the correct order.\n\n    // Create mode:\n    orderWithin(unit.create, CREATE_ORDERING as Array<Rule<ir.CreateOp | ir.UpdateOp>>);\n\n    // Update mode:\n    const ordering =\n      unit.job.kind === CompilationJobKind.Host ? UPDATE_HOST_ORDERING : UPDATE_ORDERING;\n    orderWithin(unit.update, ordering as Array<Rule<ir.CreateOp | ir.UpdateOp>>);\n  }\n}\n\n/**\n * Order all the ops within the specified group.\n */\nfunction orderWithin(\n  opList: ir.OpList<ir.CreateOp | ir.UpdateOp>,\n  ordering: Array<Rule<ir.CreateOp | ir.UpdateOp>>,\n) {\n  let opsToOrder: Array<ir.CreateOp | ir.UpdateOp> = [];\n  // Only reorder ops that target the same xref; do not mix ops that target different xrefs.\n  let firstTargetInGroup: ir.XrefId | null = null;\n  for (const op of opList) {\n    const currentTarget = ir.hasDependsOnSlotContextTrait(op) ? op.target : null;\n    if (\n      !handledOpKinds.has(op.kind) ||\n      (currentTarget !== firstTargetInGroup &&\n        firstTargetInGroup !== null &&\n        currentTarget !== null)\n    ) {\n      ir.OpList.insertBefore(reorder(opsToOrder, ordering), op);\n      opsToOrder = [];\n      firstTargetInGroup = null;\n    }\n    if (handledOpKinds.has(op.kind)) {\n      opsToOrder.push(op);\n      ir.OpList.remove(op);\n      firstTargetInGroup = currentTarget ?? firstTargetInGroup;\n    }\n  }\n  opList.push(reorder(opsToOrder, ordering));\n}\n\n/**\n * Reorders the given list of ops according to the ordering defined by `ORDERING`.\n */\nfunction reorder<T extends ir.CreateOp | ir.UpdateOp>(\n  ops: Array<T>,\n  ordering: Array<Rule<T>>,\n): Array<T> {\n  // Break the ops list into groups based on OpKind.\n  const groups = Array.from(ordering, () => new Array<T>());\n  for (const op of ops) {\n    const groupIndex = ordering.findIndex((o) => o.test(op));\n    groups[groupIndex].push(op);\n  }\n  // Reassemble the groups into a single list, in the correct order.\n  return groups.flatMap((group, i) => {\n    const transform = ordering[i].transform;\n    return transform ? transform(group) : group;\n  });\n}\n\n/**\n * Keeps only the last op in a list of ops.\n */\nfunction keepLast<T>(ops: Array<T>) {\n  return ops.slice(ops.length - 1);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as ir from '../../ir';\nimport type {CompilationJob} from '../compilation';\nimport {createOpXrefMap} from '../util/elements';\n\n/**\n * Attributes of `ng-content` named 'select' are specifically removed, because they control which\n * content matches as a property of the `projection`, and are not a plain attribute.\n */\nexport function removeContentSelectors(job: CompilationJob): void {\n  for (const unit of job.units) {\n    const elements = createOpXrefMap(unit);\n    for (const op of unit.ops()) {\n      switch (op.kind) {\n        case ir.OpKind.Binding:\n          const target = lookupInXrefMap(elements, op.target);\n          if (isSelectAttribute(op.name) && target.kind === ir.OpKind.Projection) {\n            ir.OpList.remove<ir.UpdateOp>(op);\n          }\n          break;\n      }\n    }\n  }\n}\n\nfunction isSelectAttribute(name: string) {\n  return name.toLowerCase() === 'select';\n}\n\n/**\n * Looks up an element in the given map by xref ID.\n */\nfunction lookupInXrefMap(\n  map: Map<ir.XrefId, ir.ConsumesSlotOpTrait & ir.CreateOp>,\n  xref: ir.XrefId,\n): ir.ConsumesSlotOpTrait & ir.CreateOp {\n  const el = map.get(xref);\n  if (el === undefined) {\n    throw new Error('All attributes should have an slottable target.');\n  }\n  return el;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as ir from '../../ir';\nimport type {CompilationJob, CompilationUnit} from '../compilation';\n\n/**\n * This phase generates pipe creation instructions. We do this based on the pipe bindings found in\n * the update block, in the order we see them.\n *\n * When not in compatibility mode, we can simply group all these creation instructions together, to\n * maximize chaining opportunities.\n */\nexport function createPipes(job: CompilationJob): void {\n  for (const unit of job.units) {\n    processPipeBindingsInView(unit);\n  }\n}\n\nfunction processPipeBindingsInView(unit: CompilationUnit): void {\n  for (const updateOp of unit.update) {\n    ir.visitExpressionsInOp(updateOp, (expr, flags) => {\n      if (!ir.isIrExpression(expr)) {\n        return;\n      }\n\n      if (expr.kind !== ir.ExpressionKind.PipeBinding) {\n        return;\n      }\n\n      if (flags & ir.VisitorContextFlag.InChildOperation) {\n        throw new Error(`AssertionError: pipe bindings should not appear in child expressions`);\n      }\n\n      if (unit.job.compatibility) {\n        // TODO: We can delete this cast and check once compatibility mode is removed.\n        const slotHandle = (updateOp as any).target;\n        if (slotHandle == undefined) {\n          throw new Error(`AssertionError: expected slot handle to be assigned for pipe creation`);\n        }\n        addPipeToCreationBlock(unit, (updateOp as any).target, expr);\n      } else {\n        // When not in compatibility mode, we just add the pipe to the end of the create block. This\n        // is not only simpler and faster, but allows more chaining opportunities for other\n        // instructions.\n        unit.create.push(ir.createPipeOp(expr.target, expr.targetSlot, expr.name));\n      }\n    });\n  }\n}\n\nfunction addPipeToCreationBlock(\n  unit: CompilationUnit,\n  afterTargetXref: ir.XrefId,\n  binding: ir.PipeBindingExpr,\n): void {\n  // Find the appropriate point to insert the Pipe creation operation.\n  // We're looking for `afterTargetXref` (and also want to insert after any other pipe operations\n  // which might be beyond it).\n  for (let op = unit.create.head.next!; op.kind !== ir.OpKind.ListEnd; op = op.next!) {\n    if (!ir.hasConsumesSlotTrait<ir.CreateOp>(op)) {\n      continue;\n    }\n\n    if (op.xref !== afterTargetXref) {\n      continue;\n    }\n\n    // We've found a tentative insertion point; however, we also want to skip past any _other_ pipe\n    // operations present.\n    while (op.next!.kind === ir.OpKind.Pipe) {\n      op = op.next!;\n    }\n\n    const pipe = ir.createPipeOp(binding.target, binding.targetSlot, binding.name) as ir.CreateOp;\n    ir.OpList.insertBefore(pipe, op.next!);\n\n    // This completes adding the pipe to the creation block.\n    return;\n  }\n\n  // At this point, we've failed to add the pipe to the creation block.\n  throw new Error(`AssertionError: unable to find insertion point for pipe ${binding.name}`);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\n\nimport type {CompilationJob, ComponentCompilationJob} from '../compilation';\n\n/**\n * Pipes that accept more than 4 arguments are variadic, and are handled with a different runtime\n * instruction.\n */\nexport function createVariadicPipes(job: CompilationJob): void {\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      ir.transformExpressionsInOp(\n        op,\n        (expr) => {\n          if (!(expr instanceof ir.PipeBindingExpr)) {\n            return expr;\n          }\n\n          // Pipes are variadic if they have more than 4 arguments.\n          if (expr.args.length <= 4) {\n            return expr;\n          }\n\n          return new ir.PipeBindingVariadicExpr(\n            expr.target,\n            expr.targetSlot,\n            expr.name,\n            o.literalArr(expr.args),\n            expr.args.length,\n          );\n        },\n        ir.VisitorContextFlag.None,\n      );\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as i18n from '../../../../i18n/i18n_ast';\nimport * as ir from '../../ir';\nimport {ComponentCompilationJob, ViewCompilationUnit} from '../compilation';\n\n/**\n * Propagate i18n blocks down through child templates that act as placeholders in the root i18n\n * message. Specifically, perform an in-order traversal of all the views, and add i18nStart/i18nEnd\n * op pairs into descending views. Also, assign an increasing sub-template index to each\n * descending view.\n */\nexport function propagateI18nBlocks(job: ComponentCompilationJob): void {\n  propagateI18nBlocksToTemplates(job.root, 0);\n}\n\n/**\n * Propagates i18n ops in the given view through to any child views recursively.\n */\nfunction propagateI18nBlocksToTemplates(\n  unit: ViewCompilationUnit,\n  subTemplateIndex: number,\n): number {\n  let i18nBlock: ir.I18nStartOp | null = null;\n  for (const op of unit.create) {\n    switch (op.kind) {\n      case ir.OpKind.I18nStart:\n        op.subTemplateIndex = subTemplateIndex === 0 ? null : subTemplateIndex;\n        i18nBlock = op;\n        break;\n      case ir.OpKind.I18nEnd:\n        // When we exit a root-level i18n block, reset the sub-template index counter.\n        if (i18nBlock!.subTemplateIndex === null) {\n          subTemplateIndex = 0;\n        }\n        i18nBlock = null;\n        break;\n      case ir.OpKind.ConditionalCreate:\n      case ir.OpKind.ConditionalBranchCreate:\n      case ir.OpKind.Template:\n        subTemplateIndex = propagateI18nBlocksForView(\n          unit.job.views.get(op.xref)!,\n          i18nBlock,\n          op.i18nPlaceholder,\n          subTemplateIndex,\n        );\n        break;\n      case ir.OpKind.RepeaterCreate:\n        // Propagate i18n blocks to the @for template.\n        const forView = unit.job.views.get(op.xref)!;\n        subTemplateIndex = propagateI18nBlocksForView(\n          forView,\n          i18nBlock,\n          op.i18nPlaceholder,\n          subTemplateIndex,\n        );\n        // Then if there's an @empty template, propagate the i18n blocks for it as well.\n        if (op.emptyView !== null) {\n          subTemplateIndex = propagateI18nBlocksForView(\n            unit.job.views.get(op.emptyView)!,\n            i18nBlock,\n            op.emptyI18nPlaceholder,\n            subTemplateIndex,\n          );\n        }\n        break;\n      case ir.OpKind.Projection:\n        if (op.fallbackView !== null) {\n          subTemplateIndex = propagateI18nBlocksForView(\n            unit.job.views.get(op.fallbackView)!,\n            i18nBlock,\n            op.fallbackViewI18nPlaceholder,\n            subTemplateIndex,\n          );\n        }\n        break;\n    }\n  }\n  return subTemplateIndex;\n}\n\n/**\n * Propagate i18n blocks for a view.\n */\nfunction propagateI18nBlocksForView(\n  view: ViewCompilationUnit,\n  i18nBlock: ir.I18nStartOp | null,\n  i18nPlaceholder: i18n.TagPlaceholder | i18n.BlockPlaceholder | undefined,\n  subTemplateIndex: number,\n) {\n  // We found an <ng-template> inside an i18n block; increment the sub-template counter and\n  // wrap the template's view in a child i18n block.\n  if (i18nPlaceholder !== undefined) {\n    if (i18nBlock === null) {\n      throw Error('Expected template with i18n placeholder to be in an i18n block.');\n    }\n    subTemplateIndex++;\n    wrapTemplateWithI18n(view, i18nBlock);\n  }\n\n  // Continue traversing inside the template's view.\n  return propagateI18nBlocksToTemplates(view, subTemplateIndex);\n}\n\n/**\n * Wraps a template view with i18n start and end ops.\n */\nfunction wrapTemplateWithI18n(unit: ViewCompilationUnit, parentI18n: ir.I18nStartOp) {\n  // Only add i18n ops if they have not already been propagated to this template.\n  if (unit.create.head.next?.kind !== ir.OpKind.I18nStart) {\n    const id = unit.job.allocateXrefId();\n    ir.OpList.insertAfter(\n      // Nested ng-template i18n start/end ops should not receive source spans.\n      ir.createI18nStartOp(id, parentI18n.message, parentI18n.root, null),\n      unit.create.head,\n    );\n    ir.OpList.insertBefore(ir.createI18nEndOp(id, null), unit.create.tail);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {GenericKeyFn, SharedConstantDefinition} from '../../../../constant_pool';\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\n\nimport type {CompilationJob} from '../compilation';\n\nexport function extractPureFunctions(job: CompilationJob): void {\n  for (const view of job.units) {\n    for (const op of view.ops()) {\n      ir.visitExpressionsInOp(op, (expr) => {\n        if (!(expr instanceof ir.PureFunctionExpr) || expr.body === null) {\n          return;\n        }\n\n        const constantDef = new PureFunctionConstant(expr.args.length);\n        expr.fn = job.pool.getSharedConstant(constantDef, expr.body);\n        expr.body = null;\n      });\n    }\n  }\n}\n\nclass PureFunctionConstant extends GenericKeyFn implements SharedConstantDefinition {\n  constructor(private numArgs: number) {\n    super();\n  }\n\n  override keyOf(expr: o.Expression): string {\n    if (expr instanceof ir.PureFunctionParameterExpr) {\n      return `param(${expr.index})`;\n    } else {\n      return super.keyOf(expr);\n    }\n  }\n\n  // TODO: Use the new pool method `getSharedFunctionReference`\n  toSharedConstantDeclaration(declName: string, keyExpr: o.Expression): o.Statement {\n    const fnParams: o.FnParam[] = [];\n    for (let idx = 0; idx < this.numArgs; idx++) {\n      fnParams.push(new o.FnParam('a' + idx));\n    }\n\n    // We will never visit `ir.PureFunctionParameterExpr`s that don't belong to us, because this\n    // transform runs inside another visitor which will visit nested pure functions before this one.\n    const returnExpr = ir.transformExpressionsInExpression(\n      keyExpr,\n      (expr) => {\n        if (!(expr instanceof ir.PureFunctionParameterExpr)) {\n          return expr;\n        }\n\n        return o.variable('a' + expr.index);\n      },\n      ir.VisitorContextFlag.None,\n    );\n\n    return new o.DeclareVarStmt(\n      declName,\n      new o.ArrowFunctionExpr(fnParams, returnExpr),\n      undefined,\n      o.StmtModifier.Final,\n    );\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\nimport type {CompilationJob} from '../compilation';\n\nexport function generatePureLiteralStructures(job: CompilationJob): void {\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      ir.transformExpressionsInOp(\n        op,\n        (expr, flags) => {\n          if (flags & ir.VisitorContextFlag.InChildOperation) {\n            return expr;\n          }\n\n          if (expr instanceof o.LiteralArrayExpr) {\n            return transformLiteralArray(expr);\n          } else if (expr instanceof o.LiteralMapExpr) {\n            return transformLiteralMap(expr);\n          }\n\n          return expr;\n        },\n        ir.VisitorContextFlag.None,\n      );\n    }\n  }\n}\n\nfunction transformLiteralArray(expr: o.LiteralArrayExpr): o.Expression {\n  const derivedEntries: o.Expression[] = [];\n  const nonConstantArgs: o.Expression[] = [];\n  for (const entry of expr.entries) {\n    if (entry.isConstant()) {\n      derivedEntries.push(entry);\n    } else {\n      const idx = nonConstantArgs.length;\n      nonConstantArgs.push(entry);\n      derivedEntries.push(new ir.PureFunctionParameterExpr(idx));\n    }\n  }\n  return new ir.PureFunctionExpr(o.literalArr(derivedEntries), nonConstantArgs);\n}\n\nfunction transformLiteralMap(expr: o.LiteralMapExpr): o.Expression {\n  let derivedEntries: o.LiteralMapEntry[] = [];\n  const nonConstantArgs: o.Expression[] = [];\n  for (const entry of expr.entries) {\n    if (entry.value.isConstant()) {\n      derivedEntries.push(entry);\n    } else {\n      const idx = nonConstantArgs.length;\n      nonConstantArgs.push(entry.value);\n      derivedEntries.push(\n        new o.LiteralMapEntry(entry.key, new ir.PureFunctionParameterExpr(idx), entry.quoted),\n      );\n    }\n  }\n  return new ir.PureFunctionExpr(o.literalMap(derivedEntries), nonConstantArgs);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../output/output_ast';\nimport {ParseSourceSpan} from '../../../parse_util';\nimport {Identifiers} from '../../../render3/r3_identifiers';\nimport * as ir from '../ir';\n\n// This file contains helpers for generating calls to Ivy instructions. In particular, each\n// instruction type is represented as a function, which may select a specific instruction variant\n// depending on the exact arguments.\n\nexport function element(\n  slot: number,\n  tag: string,\n  constIndex: number | null,\n  localRefIndex: number | null,\n  sourceSpan: ParseSourceSpan,\n): ir.CreateOp {\n  return elementOrContainerBase(\n    Identifiers.element,\n    slot,\n    tag,\n    constIndex,\n    localRefIndex,\n    sourceSpan,\n  );\n}\n\nexport function elementStart(\n  slot: number,\n  tag: string,\n  constIndex: number | null,\n  localRefIndex: number | null,\n  sourceSpan: ParseSourceSpan,\n): ir.CreateOp {\n  return elementOrContainerBase(\n    Identifiers.elementStart,\n    slot,\n    tag,\n    constIndex,\n    localRefIndex,\n    sourceSpan,\n  );\n}\n\nfunction elementOrContainerBase(\n  instruction: o.ExternalReference,\n  slot: number,\n  tag: string | null,\n  constIndex: number | null,\n  localRefIndex: number | null,\n  sourceSpan: ParseSourceSpan,\n): ir.CreateOp {\n  const args: o.Expression[] = [o.literal(slot)];\n  if (tag !== null) {\n    args.push(o.literal(tag));\n  }\n  if (localRefIndex !== null) {\n    args.push(\n      o.literal(constIndex), // might be null, but that's okay.\n      o.literal(localRefIndex),\n    );\n  } else if (constIndex !== null) {\n    args.push(o.literal(constIndex));\n  }\n\n  return call(instruction, args, sourceSpan);\n}\n\nfunction templateBase(\n  instruction: o.ExternalReference,\n  slot: number,\n  templateFnRef: o.Expression,\n  decls: number,\n  vars: number,\n  tag: string | null,\n  constIndex: number | null,\n  localRefs: number | null,\n  sourceSpan: ParseSourceSpan,\n): ir.CreateOp {\n  const args = [\n    o.literal(slot),\n    templateFnRef,\n    o.literal(decls),\n    o.literal(vars),\n    o.literal(tag),\n    o.literal(constIndex),\n  ];\n  if (localRefs !== null) {\n    args.push(o.literal(localRefs));\n    args.push(o.importExpr(Identifiers.templateRefExtractor));\n  }\n  while (args[args.length - 1].isEquivalent(o.NULL_EXPR)) {\n    args.pop();\n  }\n  return call(instruction, args, sourceSpan);\n}\n\nfunction propertyBase(\n  instruction: o.ExternalReference,\n  name: string,\n  expression: o.Expression | ir.Interpolation,\n  sanitizer: o.Expression | null,\n  sourceSpan: ParseSourceSpan,\n): ir.UpdateOp {\n  const args: o.Expression[] = [o.literal(name)];\n\n  if (expression instanceof ir.Interpolation) {\n    args.push(interpolationToExpression(expression, sourceSpan));\n  } else {\n    args.push(expression);\n  }\n\n  if (sanitizer !== null) {\n    args.push(sanitizer);\n  }\n  return call(instruction, args, sourceSpan);\n}\n\nexport function elementEnd(sourceSpan: ParseSourceSpan | null): ir.CreateOp {\n  return call(Identifiers.elementEnd, [], sourceSpan);\n}\n\nexport function elementContainerStart(\n  slot: number,\n  constIndex: number | null,\n  localRefIndex: number | null,\n  sourceSpan: ParseSourceSpan,\n): ir.CreateOp {\n  return elementOrContainerBase(\n    Identifiers.elementContainerStart,\n    slot,\n    /* tag */ null,\n    constIndex,\n    localRefIndex,\n    sourceSpan,\n  );\n}\n\nexport function elementContainer(\n  slot: number,\n  constIndex: number | null,\n  localRefIndex: number | null,\n  sourceSpan: ParseSourceSpan,\n): ir.CreateOp {\n  return elementOrContainerBase(\n    Identifiers.elementContainer,\n    slot,\n    /* tag */ null,\n    constIndex,\n    localRefIndex,\n    sourceSpan,\n  );\n}\n\nexport function elementContainerEnd(): ir.CreateOp {\n  return call(Identifiers.elementContainerEnd, [], null);\n}\n\nexport function template(\n  slot: number,\n  templateFnRef: o.Expression,\n  decls: number,\n  vars: number,\n  tag: string | null,\n  constIndex: number | null,\n  localRefs: number | null,\n  sourceSpan: ParseSourceSpan,\n): ir.CreateOp {\n  return templateBase(\n    Identifiers.templateCreate,\n    slot,\n    templateFnRef,\n    decls,\n    vars,\n    tag,\n    constIndex,\n    localRefs,\n    sourceSpan,\n  );\n}\n\nexport function disableBindings(): ir.CreateOp {\n  return call(Identifiers.disableBindings, [], null);\n}\n\nexport function enableBindings(): ir.CreateOp {\n  return call(Identifiers.enableBindings, [], null);\n}\n\nexport function listener(\n  name: string,\n  handlerFn: o.Expression,\n  eventTargetResolver: o.ExternalReference | null,\n  syntheticHost: boolean,\n  sourceSpan: ParseSourceSpan,\n): ir.CreateOp {\n  const args = [o.literal(name), handlerFn];\n  if (eventTargetResolver !== null) {\n    args.push(o.importExpr(eventTargetResolver));\n  }\n  return call(\n    syntheticHost ? Identifiers.syntheticHostListener : Identifiers.listener,\n    args,\n    sourceSpan,\n  );\n}\n\nexport function twoWayBindingSet(target: o.Expression, value: o.Expression): o.Expression {\n  return o.importExpr(Identifiers.twoWayBindingSet).callFn([target, value]);\n}\n\nexport function twoWayListener(\n  name: string,\n  handlerFn: o.Expression,\n  sourceSpan: ParseSourceSpan,\n): ir.CreateOp {\n  return call(Identifiers.twoWayListener, [o.literal(name), handlerFn], sourceSpan);\n}\n\nexport function pipe(slot: number, name: string): ir.CreateOp {\n  return call(Identifiers.pipe, [o.literal(slot), o.literal(name)], null);\n}\n\nexport function namespaceHTML(): ir.CreateOp {\n  return call(Identifiers.namespaceHTML, [], null);\n}\n\nexport function namespaceSVG(): ir.CreateOp {\n  return call(Identifiers.namespaceSVG, [], null);\n}\n\nexport function namespaceMath(): ir.CreateOp {\n  return call(Identifiers.namespaceMathML, [], null);\n}\n\nexport function advance(delta: number, sourceSpan: ParseSourceSpan): ir.UpdateOp {\n  return call(Identifiers.advance, delta > 1 ? [o.literal(delta)] : [], sourceSpan);\n}\n\nexport function reference(slot: number): o.Expression {\n  return o.importExpr(Identifiers.reference).callFn([o.literal(slot)]);\n}\n\nexport function nextContext(steps: number): o.Expression {\n  return o.importExpr(Identifiers.nextContext).callFn(steps === 1 ? [] : [o.literal(steps)]);\n}\n\nexport function getCurrentView(): o.Expression {\n  return o.importExpr(Identifiers.getCurrentView).callFn([]);\n}\n\nexport function restoreView(savedView: o.Expression): o.Expression {\n  return o.importExpr(Identifiers.restoreView).callFn([savedView]);\n}\n\nexport function resetView(returnValue: o.Expression): o.Expression {\n  return o.importExpr(Identifiers.resetView).callFn([returnValue]);\n}\n\nexport function text(\n  slot: number,\n  initialValue: string,\n  sourceSpan: ParseSourceSpan | null,\n): ir.CreateOp {\n  const args: o.Expression[] = [o.literal(slot, null)];\n  if (initialValue !== '') {\n    args.push(o.literal(initialValue));\n  }\n  return call(Identifiers.text, args, sourceSpan);\n}\n\nexport function defer(\n  selfSlot: number,\n  primarySlot: number,\n  dependencyResolverFn: o.Expression | null,\n  loadingSlot: number | null,\n  placeholderSlot: number | null,\n  errorSlot: number | null,\n  loadingConfig: o.Expression | null,\n  placeholderConfig: o.Expression | null,\n  enableTimerScheduling: boolean,\n  sourceSpan: ParseSourceSpan | null,\n  flags: ir.TDeferDetailsFlags | null,\n): ir.CreateOp {\n  const args: Array<o.Expression> = [\n    o.literal(selfSlot),\n    o.literal(primarySlot),\n    dependencyResolverFn ?? o.literal(null),\n    o.literal(loadingSlot),\n    o.literal(placeholderSlot),\n    o.literal(errorSlot),\n    loadingConfig ?? o.literal(null),\n    placeholderConfig ?? o.literal(null),\n    enableTimerScheduling ? o.importExpr(Identifiers.deferEnableTimerScheduling) : o.literal(null),\n    o.literal(flags),\n  ];\n\n  let expr: o.Expression;\n  while (\n    (expr = args[args.length - 1]) !== null &&\n    expr instanceof o.LiteralExpr &&\n    expr.value === null\n  ) {\n    args.pop();\n  }\n\n  return call(Identifiers.defer, args, sourceSpan);\n}\n\nconst deferTriggerToR3TriggerInstructionsMap = new Map([\n  [\n    ir.DeferTriggerKind.Idle,\n    {\n      [ir.DeferOpModifierKind.NONE]: Identifiers.deferOnIdle,\n      [ir.DeferOpModifierKind.PREFETCH]: Identifiers.deferPrefetchOnIdle,\n      [ir.DeferOpModifierKind.HYDRATE]: Identifiers.deferHydrateOnIdle,\n    },\n  ],\n  [\n    ir.DeferTriggerKind.Immediate,\n    {\n      [ir.DeferOpModifierKind.NONE]: Identifiers.deferOnImmediate,\n      [ir.DeferOpModifierKind.PREFETCH]: Identifiers.deferPrefetchOnImmediate,\n      [ir.DeferOpModifierKind.HYDRATE]: Identifiers.deferHydrateOnImmediate,\n    },\n  ],\n  [\n    ir.DeferTriggerKind.Timer,\n    {\n      [ir.DeferOpModifierKind.NONE]: Identifiers.deferOnTimer,\n      [ir.DeferOpModifierKind.PREFETCH]: Identifiers.deferPrefetchOnTimer,\n      [ir.DeferOpModifierKind.HYDRATE]: Identifiers.deferHydrateOnTimer,\n    },\n  ],\n  [\n    ir.DeferTriggerKind.Hover,\n    {\n      [ir.DeferOpModifierKind.NONE]: Identifiers.deferOnHover,\n      [ir.DeferOpModifierKind.PREFETCH]: Identifiers.deferPrefetchOnHover,\n      [ir.DeferOpModifierKind.HYDRATE]: Identifiers.deferHydrateOnHover,\n    },\n  ],\n  [\n    ir.DeferTriggerKind.Interaction,\n    {\n      [ir.DeferOpModifierKind.NONE]: Identifiers.deferOnInteraction,\n      [ir.DeferOpModifierKind.PREFETCH]: Identifiers.deferPrefetchOnInteraction,\n      [ir.DeferOpModifierKind.HYDRATE]: Identifiers.deferHydrateOnInteraction,\n    },\n  ],\n  [\n    ir.DeferTriggerKind.Viewport,\n    {\n      [ir.DeferOpModifierKind.NONE]: Identifiers.deferOnViewport,\n      [ir.DeferOpModifierKind.PREFETCH]: Identifiers.deferPrefetchOnViewport,\n      [ir.DeferOpModifierKind.HYDRATE]: Identifiers.deferHydrateOnViewport,\n    },\n  ],\n  [\n    ir.DeferTriggerKind.Never,\n    {\n      [ir.DeferOpModifierKind.NONE]: Identifiers.deferHydrateNever,\n      [ir.DeferOpModifierKind.PREFETCH]: Identifiers.deferHydrateNever,\n      [ir.DeferOpModifierKind.HYDRATE]: Identifiers.deferHydrateNever,\n    },\n  ],\n]);\n\nexport function deferOn(\n  trigger: ir.DeferTriggerKind,\n  args: (number | null)[],\n  modifier: ir.DeferOpModifierKind,\n  sourceSpan: ParseSourceSpan | null,\n): ir.CreateOp {\n  const instructionToCall = deferTriggerToR3TriggerInstructionsMap.get(trigger)?.[modifier];\n  if (instructionToCall === undefined) {\n    throw new Error(`Unable to determine instruction for trigger ${trigger}`);\n  }\n  return call(\n    instructionToCall,\n    args.map((a) => o.literal(a)),\n    sourceSpan,\n  );\n}\n\nexport function projectionDef(def: o.Expression | null): ir.CreateOp {\n  return call(Identifiers.projectionDef, def ? [def] : [], null);\n}\n\nexport function projection(\n  slot: number,\n  projectionSlotIndex: number,\n  attributes: o.LiteralArrayExpr | null,\n  fallbackFnName: string | null,\n  fallbackDecls: number | null,\n  fallbackVars: number | null,\n  sourceSpan: ParseSourceSpan,\n): ir.CreateOp {\n  const args: o.Expression[] = [o.literal(slot)];\n  if (projectionSlotIndex !== 0 || attributes !== null || fallbackFnName !== null) {\n    args.push(o.literal(projectionSlotIndex));\n    if (attributes !== null) {\n      args.push(attributes);\n    }\n    if (fallbackFnName !== null) {\n      if (attributes === null) {\n        args.push(o.literal(null));\n      }\n      args.push(o.variable(fallbackFnName), o.literal(fallbackDecls), o.literal(fallbackVars));\n    }\n  }\n  return call(Identifiers.projection, args, sourceSpan);\n}\n\nexport function i18nStart(\n  slot: number,\n  constIndex: number,\n  subTemplateIndex: number,\n  sourceSpan: ParseSourceSpan | null,\n): ir.CreateOp {\n  const args = [o.literal(slot), o.literal(constIndex)];\n  if (subTemplateIndex !== null) {\n    args.push(o.literal(subTemplateIndex));\n  }\n  return call(Identifiers.i18nStart, args, sourceSpan);\n}\n\nexport function conditionalCreate(\n  slot: number,\n  templateFnRef: o.Expression,\n  decls: number,\n  vars: number,\n  tag: string | null,\n  constIndex: number | null,\n  localRefs: number | null,\n  sourceSpan: ParseSourceSpan,\n): ir.CreateOp {\n  const args = [\n    o.literal(slot),\n    templateFnRef,\n    o.literal(decls),\n    o.literal(vars),\n    o.literal(tag),\n    o.literal(constIndex),\n  ];\n  if (localRefs !== null) {\n    args.push(o.literal(localRefs));\n    args.push(o.importExpr(Identifiers.templateRefExtractor));\n  }\n  while (args[args.length - 1].isEquivalent(o.NULL_EXPR)) {\n    args.pop();\n  }\n  return call(Identifiers.conditionalCreate, args, sourceSpan);\n}\n\nexport function conditionalBranchCreate(\n  slot: number,\n  templateFnRef: o.Expression,\n  decls: number,\n  vars: number,\n  tag: string | null,\n  constIndex: number | null,\n  localRefs: number | null,\n  sourceSpan: ParseSourceSpan,\n): ir.CreateOp {\n  const args = [\n    o.literal(slot),\n    templateFnRef,\n    o.literal(decls),\n    o.literal(vars),\n    o.literal(tag),\n    o.literal(constIndex),\n  ];\n  if (localRefs !== null) {\n    args.push(o.literal(localRefs));\n    args.push(o.importExpr(Identifiers.templateRefExtractor));\n  }\n  while (args[args.length - 1].isEquivalent(o.NULL_EXPR)) {\n    args.pop();\n  }\n  return call(Identifiers.conditionalBranchCreate, args, sourceSpan);\n}\n\nexport function repeaterCreate(\n  slot: number,\n  viewFnName: string,\n  decls: number,\n  vars: number,\n  tag: string | null,\n  constIndex: number | null,\n  trackByFn: o.Expression,\n  trackByUsesComponentInstance: boolean,\n  emptyViewFnName: string | null,\n  emptyDecls: number | null,\n  emptyVars: number | null,\n  emptyTag: string | null,\n  emptyConstIndex: number | null,\n  sourceSpan: ParseSourceSpan | null,\n): ir.CreateOp {\n  const args = [\n    o.literal(slot),\n    o.variable(viewFnName),\n    o.literal(decls),\n    o.literal(vars),\n    o.literal(tag),\n    o.literal(constIndex),\n    trackByFn,\n  ];\n  if (trackByUsesComponentInstance || emptyViewFnName !== null) {\n    args.push(o.literal(trackByUsesComponentInstance));\n    if (emptyViewFnName !== null) {\n      args.push(o.variable(emptyViewFnName), o.literal(emptyDecls), o.literal(emptyVars));\n      if (emptyTag !== null || emptyConstIndex !== null) {\n        args.push(o.literal(emptyTag));\n      }\n      if (emptyConstIndex !== null) {\n        args.push(o.literal(emptyConstIndex));\n      }\n    }\n  }\n  return call(Identifiers.repeaterCreate, args, sourceSpan);\n}\n\nexport function repeater(\n  collection: o.Expression,\n  sourceSpan: ParseSourceSpan | null,\n): ir.UpdateOp {\n  return call(Identifiers.repeater, [collection], sourceSpan);\n}\n\nexport function deferWhen(\n  modifier: ir.DeferOpModifierKind,\n  expr: o.Expression,\n  sourceSpan: ParseSourceSpan | null,\n): ir.UpdateOp {\n  if (modifier === ir.DeferOpModifierKind.PREFETCH) {\n    return call(Identifiers.deferPrefetchWhen, [expr], sourceSpan);\n  } else if (modifier === ir.DeferOpModifierKind.HYDRATE) {\n    return call(Identifiers.deferHydrateWhen, [expr], sourceSpan);\n  }\n  return call(Identifiers.deferWhen, [expr], sourceSpan);\n}\n\nexport function declareLet(slot: number, sourceSpan: ParseSourceSpan): ir.CreateOp {\n  return call(Identifiers.declareLet, [o.literal(slot)], sourceSpan);\n}\n\nexport function storeLet(value: o.Expression, sourceSpan: ParseSourceSpan): o.Expression {\n  return o.importExpr(Identifiers.storeLet).callFn([value], sourceSpan);\n}\n\nexport function readContextLet(slot: number): o.Expression {\n  return o.importExpr(Identifiers.readContextLet).callFn([o.literal(slot)]);\n}\n\nexport function i18n(\n  slot: number,\n  constIndex: number,\n  subTemplateIndex: number,\n  sourceSpan: ParseSourceSpan | null,\n): ir.CreateOp {\n  const args = [o.literal(slot), o.literal(constIndex)];\n  if (subTemplateIndex) {\n    args.push(o.literal(subTemplateIndex));\n  }\n  return call(Identifiers.i18n, args, sourceSpan);\n}\n\nexport function i18nEnd(endSourceSpan: ParseSourceSpan | null): ir.CreateOp {\n  return call(Identifiers.i18nEnd, [], endSourceSpan);\n}\n\nexport function i18nAttributes(slot: number, i18nAttributesConfig: number): ir.CreateOp {\n  const args = [o.literal(slot), o.literal(i18nAttributesConfig)];\n  return call(Identifiers.i18nAttributes, args, null);\n}\n\nexport function ariaProperty(\n  name: string,\n  expression: o.Expression | ir.Interpolation,\n  sourceSpan: ParseSourceSpan,\n): ir.UpdateOp {\n  return propertyBase(Identifiers.ariaProperty, name, expression, null, sourceSpan);\n}\n\nexport function property(\n  name: string,\n  expression: o.Expression | ir.Interpolation,\n  sanitizer: o.Expression | null,\n  sourceSpan: ParseSourceSpan,\n): ir.UpdateOp {\n  return propertyBase(Identifiers.property, name, expression, sanitizer, sourceSpan);\n}\n\nexport function twoWayProperty(\n  name: string,\n  expression: o.Expression,\n  sanitizer: o.Expression | null,\n  sourceSpan: ParseSourceSpan,\n): ir.UpdateOp {\n  const args = [o.literal(name), expression];\n  if (sanitizer !== null) {\n    args.push(sanitizer);\n  }\n  return call(Identifiers.twoWayProperty, args, sourceSpan);\n}\n\nexport function attribute(\n  name: string,\n  expression: o.Expression | ir.Interpolation,\n  sanitizer: o.Expression | null,\n  namespace: string | null,\n  sourceSpan: ParseSourceSpan,\n): ir.UpdateOp {\n  const args: o.Expression[] = [o.literal(name)];\n\n  if (expression instanceof ir.Interpolation) {\n    args.push(interpolationToExpression(expression, sourceSpan));\n  } else {\n    args.push(expression);\n  }\n  if (sanitizer !== null || namespace !== null) {\n    args.push(sanitizer ?? o.literal(null));\n  }\n  if (namespace !== null) {\n    args.push(o.literal(namespace));\n  }\n  return call(Identifiers.attribute, args, null);\n}\n\nexport function styleProp(\n  name: string,\n  expression: o.Expression | ir.Interpolation,\n  unit: string | null,\n  sourceSpan: ParseSourceSpan,\n): ir.UpdateOp {\n  const args: o.Expression[] = [o.literal(name)];\n\n  if (expression instanceof ir.Interpolation) {\n    args.push(interpolationToExpression(expression, sourceSpan));\n  } else {\n    args.push(expression);\n  }\n\n  if (unit !== null) {\n    args.push(o.literal(unit));\n  }\n  return call(Identifiers.styleProp, args, sourceSpan);\n}\n\nexport function classProp(\n  name: string,\n  expression: o.Expression,\n  sourceSpan: ParseSourceSpan,\n): ir.UpdateOp {\n  return call(Identifiers.classProp, [o.literal(name), expression], sourceSpan);\n}\n\nexport function styleMap(\n  expression: o.Expression | ir.Interpolation,\n  sourceSpan: ParseSourceSpan,\n): ir.UpdateOp {\n  const value =\n    expression instanceof ir.Interpolation\n      ? interpolationToExpression(expression, sourceSpan)\n      : expression;\n  return call(Identifiers.styleMap, [value], sourceSpan);\n}\n\nexport function classMap(\n  expression: o.Expression | ir.Interpolation,\n  sourceSpan: ParseSourceSpan,\n): ir.UpdateOp {\n  const value =\n    expression instanceof ir.Interpolation\n      ? interpolationToExpression(expression, sourceSpan)\n      : expression;\n  return call(Identifiers.classMap, [value], sourceSpan);\n}\n\nexport function domElement(\n  slot: number,\n  tag: string,\n  constIndex: number | null,\n  localRefIndex: number | null,\n  sourceSpan: ParseSourceSpan,\n): ir.CreateOp {\n  return elementOrContainerBase(\n    Identifiers.domElement,\n    slot,\n    tag,\n    constIndex,\n    localRefIndex,\n    sourceSpan,\n  );\n}\n\nexport function domElementStart(\n  slot: number,\n  tag: string,\n  constIndex: number | null,\n  localRefIndex: number | null,\n  sourceSpan: ParseSourceSpan,\n): ir.CreateOp {\n  return elementOrContainerBase(\n    Identifiers.domElementStart,\n    slot,\n    tag,\n    constIndex,\n    localRefIndex,\n    sourceSpan,\n  );\n}\n\nexport function domElementEnd(sourceSpan: ParseSourceSpan | null): ir.CreateOp {\n  return call(Identifiers.domElementEnd, [], sourceSpan);\n}\n\nexport function domElementContainerStart(\n  slot: number,\n  constIndex: number | null,\n  localRefIndex: number | null,\n  sourceSpan: ParseSourceSpan,\n): ir.CreateOp {\n  return elementOrContainerBase(\n    Identifiers.domElementContainerStart,\n    slot,\n    /* tag */ null,\n    constIndex,\n    localRefIndex,\n    sourceSpan,\n  );\n}\n\nexport function domElementContainer(\n  slot: number,\n  constIndex: number | null,\n  localRefIndex: number | null,\n  sourceSpan: ParseSourceSpan,\n): ir.CreateOp {\n  return elementOrContainerBase(\n    Identifiers.domElementContainer,\n    slot,\n    /* tag */ null,\n    constIndex,\n    localRefIndex,\n    sourceSpan,\n  );\n}\n\nexport function domElementContainerEnd(): ir.CreateOp {\n  return call(Identifiers.domElementContainerEnd, [], null);\n}\n\nexport function domListener(\n  name: string,\n  handlerFn: o.Expression,\n  eventTargetResolver: o.ExternalReference | null,\n  sourceSpan: ParseSourceSpan,\n): ir.CreateOp {\n  const args = [o.literal(name), handlerFn];\n  if (eventTargetResolver !== null) {\n    args.push(o.importExpr(eventTargetResolver));\n  }\n  return call(Identifiers.domListener, args, sourceSpan);\n}\n\nexport function domTemplate(\n  slot: number,\n  templateFnRef: o.Expression,\n  decls: number,\n  vars: number,\n  tag: string | null,\n  constIndex: number | null,\n  localRefs: number | null,\n  sourceSpan: ParseSourceSpan,\n): ir.CreateOp {\n  return templateBase(\n    Identifiers.domTemplate,\n    slot,\n    templateFnRef,\n    decls,\n    vars,\n    tag,\n    constIndex,\n    localRefs,\n    sourceSpan,\n  );\n}\n\nconst PIPE_BINDINGS: o.ExternalReference[] = [\n  Identifiers.pipeBind1,\n  Identifiers.pipeBind2,\n  Identifiers.pipeBind3,\n  Identifiers.pipeBind4,\n];\n\nexport function pipeBind(slot: number, varOffset: number, args: o.Expression[]): o.Expression {\n  if (args.length < 1 || args.length > PIPE_BINDINGS.length) {\n    throw new Error(`pipeBind() argument count out of bounds`);\n  }\n\n  const instruction = PIPE_BINDINGS[args.length - 1];\n  return o.importExpr(instruction).callFn([o.literal(slot), o.literal(varOffset), ...args]);\n}\n\nexport function pipeBindV(slot: number, varOffset: number, args: o.Expression): o.Expression {\n  return o.importExpr(Identifiers.pipeBindV).callFn([o.literal(slot), o.literal(varOffset), args]);\n}\n\nexport function textInterpolate(\n  strings: string[],\n  expressions: o.Expression[],\n  sourceSpan: ParseSourceSpan,\n): ir.UpdateOp {\n  const interpolationArgs = collateInterpolationArgs(strings, expressions);\n\n  return callVariadicInstruction(TEXT_INTERPOLATE_CONFIG, [], interpolationArgs, [], sourceSpan);\n}\n\nexport function i18nExp(expr: o.Expression, sourceSpan: ParseSourceSpan | null): ir.UpdateOp {\n  return call(Identifiers.i18nExp, [expr], sourceSpan);\n}\n\nexport function i18nApply(slot: number, sourceSpan: ParseSourceSpan | null): ir.UpdateOp {\n  return call(Identifiers.i18nApply, [o.literal(slot)], sourceSpan);\n}\n\nexport function domProperty(\n  name: string,\n  expression: o.Expression | ir.Interpolation,\n  sanitizer: o.Expression | null,\n  sourceSpan: ParseSourceSpan,\n): ir.UpdateOp {\n  return propertyBase(Identifiers.domProperty, name, expression, sanitizer, sourceSpan);\n}\n\nexport function animation(\n  animationKind: ir.AnimationKind,\n  handlerFn: o.Expression,\n  sanitizer: o.Expression | null,\n  sourceSpan: ParseSourceSpan,\n): ir.CreateOp {\n  const args = [handlerFn];\n  if (sanitizer !== null) {\n    args.push(sanitizer);\n  }\n  const identifier =\n    animationKind === ir.AnimationKind.ENTER\n      ? Identifiers.animationEnter\n      : Identifiers.animationLeave;\n  return call(identifier, args, sourceSpan);\n}\n\nexport function animationString(\n  animationKind: ir.AnimationKind,\n  expression: o.Expression | ir.Interpolation,\n  sanitizer: o.Expression | null,\n  sourceSpan: ParseSourceSpan,\n): ir.CreateOp {\n  const value =\n    expression instanceof ir.Interpolation\n      ? interpolationToExpression(expression, sourceSpan)\n      : expression;\n  const args = [value];\n  if (sanitizer !== null) {\n    args.push(sanitizer);\n  }\n  const identifier =\n    animationKind === ir.AnimationKind.ENTER\n      ? Identifiers.animationEnter\n      : Identifiers.animationLeave;\n  return call(identifier, args, sourceSpan);\n}\n\nexport function animationListener(\n  animationKind: ir.AnimationKind,\n  handlerFn: o.Expression,\n  eventTargetResolver: o.ExternalReference | null,\n  sourceSpan: ParseSourceSpan,\n): ir.CreateOp {\n  const args = [handlerFn];\n  if (eventTargetResolver !== null) {\n    args.push(o.importExpr(eventTargetResolver));\n  }\n  const identifier =\n    animationKind === ir.AnimationKind.ENTER\n      ? Identifiers.animationEnterListener\n      : Identifiers.animationLeaveListener;\n\n  return call(identifier, args, sourceSpan);\n}\n\nexport function syntheticHostProperty(\n  name: string,\n  expression: o.Expression,\n  sourceSpan: ParseSourceSpan | null,\n): ir.UpdateOp {\n  return call(Identifiers.syntheticHostProperty, [o.literal(name), expression], sourceSpan);\n}\n\nexport function pureFunction(\n  varOffset: number,\n  fn: o.Expression,\n  args: o.Expression[],\n): o.Expression {\n  return callVariadicInstructionExpr(\n    PURE_FUNCTION_CONFIG,\n    [o.literal(varOffset), fn],\n    args,\n    [],\n    null,\n  );\n}\n\nexport function attachSourceLocation(\n  templatePath: string,\n  locations: o.LiteralArrayExpr,\n): ir.CreateOp {\n  return call(Identifiers.attachSourceLocations, [o.literal(templatePath), locations], null);\n}\n\n/**\n * Collates the string an expression arguments for an interpolation instruction.\n */\nfunction collateInterpolationArgs(strings: string[], expressions: o.Expression[]): o.Expression[] {\n  if (strings.length < 1 || expressions.length !== strings.length - 1) {\n    throw new Error(\n      `AssertionError: expected specific shape of args for strings/expressions in interpolation`,\n    );\n  }\n  const interpolationArgs: o.Expression[] = [];\n\n  if (expressions.length === 1 && strings[0] === '' && strings[1] === '') {\n    interpolationArgs.push(expressions[0]);\n  } else {\n    let idx: number;\n    for (idx = 0; idx < expressions.length; idx++) {\n      interpolationArgs.push(o.literal(strings[idx]), expressions[idx]);\n    }\n\n    // idx points at the last string.\n    interpolationArgs.push(o.literal(strings[idx]));\n  }\n\n  return interpolationArgs;\n}\n\nfunction interpolationToExpression(\n  interpolation: ir.Interpolation,\n  sourceSpan: ParseSourceSpan,\n): o.Expression {\n  const interpolationArgs = collateInterpolationArgs(\n    interpolation.strings,\n    interpolation.expressions,\n  );\n  return callVariadicInstructionExpr(\n    VALUE_INTERPOLATE_CONFIG,\n    [],\n    interpolationArgs,\n    [],\n    sourceSpan,\n  );\n}\n\nfunction call<OpT extends ir.CreateOp | ir.UpdateOp>(\n  instruction: o.ExternalReference,\n  args: o.Expression[],\n  sourceSpan: ParseSourceSpan | null,\n): OpT {\n  const expr = o.importExpr(instruction).callFn(args, sourceSpan);\n  return ir.createStatementOp(new o.ExpressionStatement(expr, sourceSpan)) as OpT;\n}\n\nexport function conditional(\n  condition: o.Expression,\n  contextValue: o.Expression | null,\n  sourceSpan: ParseSourceSpan | null,\n): ir.UpdateOp {\n  const args = [condition];\n  if (contextValue !== null) {\n    args.push(contextValue);\n  }\n  return call(Identifiers.conditional, args, sourceSpan);\n}\n\n/**\n * Describes a specific flavor of instruction used to represent variadic instructions, which\n * have some number of variants for specific argument counts.\n */\ninterface VariadicInstructionConfig {\n  constant: o.ExternalReference[];\n  variable: o.ExternalReference | null;\n  mapping: (argCount: number) => number;\n}\n\n/**\n * `InterpolationConfig` for the `textInterpolate` instruction.\n */\nconst TEXT_INTERPOLATE_CONFIG: VariadicInstructionConfig = {\n  constant: [\n    Identifiers.textInterpolate,\n    Identifiers.textInterpolate1,\n    Identifiers.textInterpolate2,\n    Identifiers.textInterpolate3,\n    Identifiers.textInterpolate4,\n    Identifiers.textInterpolate5,\n    Identifiers.textInterpolate6,\n    Identifiers.textInterpolate7,\n    Identifiers.textInterpolate8,\n  ],\n  variable: Identifiers.textInterpolateV,\n  mapping: (n) => {\n    if (n % 2 === 0) {\n      throw new Error(`Expected odd number of arguments`);\n    }\n    return (n - 1) / 2;\n  },\n};\n\nconst VALUE_INTERPOLATE_CONFIG: VariadicInstructionConfig = {\n  constant: [\n    Identifiers.interpolate,\n    Identifiers.interpolate1,\n    Identifiers.interpolate2,\n    Identifiers.interpolate3,\n    Identifiers.interpolate4,\n    Identifiers.interpolate5,\n    Identifiers.interpolate6,\n    Identifiers.interpolate7,\n    Identifiers.interpolate8,\n  ],\n  variable: Identifiers.interpolateV,\n  mapping: (n) => {\n    if (n % 2 === 0) {\n      throw new Error(`Expected odd number of arguments`);\n    }\n    return (n - 1) / 2;\n  },\n};\n\nconst PURE_FUNCTION_CONFIG: VariadicInstructionConfig = {\n  constant: [\n    Identifiers.pureFunction0,\n    Identifiers.pureFunction1,\n    Identifiers.pureFunction2,\n    Identifiers.pureFunction3,\n    Identifiers.pureFunction4,\n    Identifiers.pureFunction5,\n    Identifiers.pureFunction6,\n    Identifiers.pureFunction7,\n    Identifiers.pureFunction8,\n  ],\n  variable: Identifiers.pureFunctionV,\n  mapping: (n) => n,\n};\n\nfunction callVariadicInstructionExpr(\n  config: VariadicInstructionConfig,\n  baseArgs: o.Expression[],\n  interpolationArgs: o.Expression[],\n  extraArgs: o.Expression[],\n  sourceSpan: ParseSourceSpan | null,\n): o.Expression {\n  // mapping need to be done before potentially dropping the last interpolation argument\n  const n = config.mapping(interpolationArgs.length);\n\n  // In the case the interpolation instruction ends with a empty string we drop it\n  // And the runtime will take care of it.\n  const lastInterpolationArg = interpolationArgs.at(-1);\n  if (\n    extraArgs.length === 0 &&\n    interpolationArgs.length > 1 &&\n    lastInterpolationArg instanceof o.LiteralExpr &&\n    lastInterpolationArg.value === ''\n  ) {\n    interpolationArgs.pop();\n  }\n\n  if (n < config.constant.length) {\n    // Constant calling pattern.\n    return o\n      .importExpr(config.constant[n])\n      .callFn([...baseArgs, ...interpolationArgs, ...extraArgs], sourceSpan);\n  } else if (config.variable !== null) {\n    // Variable calling pattern.\n    return o\n      .importExpr(config.variable)\n      .callFn([...baseArgs, o.literalArr(interpolationArgs), ...extraArgs], sourceSpan);\n  } else {\n    throw new Error(`AssertionError: unable to call variadic function`);\n  }\n}\n\nfunction callVariadicInstruction(\n  config: VariadicInstructionConfig,\n  baseArgs: o.Expression[],\n  interpolationArgs: o.Expression[],\n  extraArgs: o.Expression[],\n  sourceSpan: ParseSourceSpan | null,\n): ir.UpdateOp {\n  return ir.createStatementOp(\n    callVariadicInstructionExpr(\n      config,\n      baseArgs,\n      interpolationArgs,\n      extraArgs,\n      sourceSpan,\n    ).toStmt(),\n  );\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport {Identifiers} from '../../../../render3/r3_identifiers';\nimport * as ir from '../../ir';\nimport {\n  TemplateCompilationMode,\n  ViewCompilationUnit,\n  type CompilationJob,\n  type CompilationUnit,\n} from '../compilation';\nimport * as ng from '../instruction';\nimport {isAriaAttribute} from '../util/attributes';\n\n/**\n * Map of target resolvers for event listeners.\n */\nconst GLOBAL_TARGET_RESOLVERS = new Map<string, o.ExternalReference>([\n  ['window', Identifiers.resolveWindow],\n  ['document', Identifiers.resolveDocument],\n  ['body', Identifiers.resolveBody],\n]);\n\n/**\n * DOM properties that need to be remapped on the compiler side.\n * Note: this mapping has to be kept in sync with the equally named mapping in the runtime.\n */\nconst DOM_PROPERTY_REMAPPING = new Map([\n  ['class', 'className'],\n  ['for', 'htmlFor'],\n  ['formaction', 'formAction'],\n  ['innerHtml', 'innerHTML'],\n  ['readonly', 'readOnly'],\n  ['tabindex', 'tabIndex'],\n]);\n\n/**\n * Compiles semantic operations across all views and generates output `o.Statement`s with actual\n * runtime calls in their place.\n *\n * Reification replaces semantic operations with selected Ivy instructions and other generated code\n * structures. After reification, the create/update operation lists of all views should only contain\n * `ir.StatementOp`s (which wrap generated `o.Statement`s).\n */\nexport function reify(job: CompilationJob): void {\n  for (const unit of job.units) {\n    reifyCreateOperations(unit, unit.create);\n    reifyUpdateOperations(unit, unit.update);\n  }\n}\n\n/**\n * This function can be used a sanity check -- it walks every expression in the const pool, and\n * every expression reachable from an op, and makes sure that there are no IR expressions\n * left. This is nice to use for debugging mysterious failures where an IR expression cannot be\n * output from the output AST code.\n */\nfunction ensureNoIrForDebug(job: CompilationJob) {\n  for (const stmt of job.pool.statements) {\n    ir.transformExpressionsInStatement(\n      stmt,\n      (expr) => {\n        if (ir.isIrExpression(expr)) {\n          throw new Error(\n            `AssertionError: IR expression found during reify: ${ir.ExpressionKind[expr.kind]}`,\n          );\n        }\n        return expr;\n      },\n      ir.VisitorContextFlag.None,\n    );\n  }\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      ir.visitExpressionsInOp(op, (expr) => {\n        if (ir.isIrExpression(expr)) {\n          throw new Error(\n            `AssertionError: IR expression found during reify: ${ir.ExpressionKind[expr.kind]}`,\n          );\n        }\n      });\n    }\n  }\n}\n\nfunction reifyCreateOperations(unit: CompilationUnit, ops: ir.OpList<ir.CreateOp>): void {\n  for (const op of ops) {\n    ir.transformExpressionsInOp(op, reifyIrExpression, ir.VisitorContextFlag.None);\n\n    switch (op.kind) {\n      case ir.OpKind.Text:\n        ir.OpList.replace(op, ng.text(op.handle.slot!, op.initialValue, op.sourceSpan));\n        break;\n      case ir.OpKind.ElementStart:\n        ir.OpList.replace(\n          op,\n          unit.job.mode === TemplateCompilationMode.DomOnly\n            ? ng.domElementStart(\n                op.handle.slot!,\n                op.tag!,\n                op.attributes as number | null,\n                op.localRefs as number | null,\n                op.startSourceSpan,\n              )\n            : ng.elementStart(\n                op.handle.slot!,\n                op.tag!,\n                op.attributes as number | null,\n                op.localRefs as number | null,\n                op.startSourceSpan,\n              ),\n        );\n        break;\n      case ir.OpKind.Element:\n        ir.OpList.replace(\n          op,\n          unit.job.mode === TemplateCompilationMode.DomOnly\n            ? ng.domElement(\n                op.handle.slot!,\n                op.tag!,\n                op.attributes as number | null,\n                op.localRefs as number | null,\n                op.wholeSourceSpan,\n              )\n            : ng.element(\n                op.handle.slot!,\n                op.tag!,\n                op.attributes as number | null,\n                op.localRefs as number | null,\n                op.wholeSourceSpan,\n              ),\n        );\n        break;\n      case ir.OpKind.ElementEnd:\n        ir.OpList.replace(\n          op,\n          unit.job.mode === TemplateCompilationMode.DomOnly\n            ? ng.domElementEnd(op.sourceSpan)\n            : ng.elementEnd(op.sourceSpan),\n        );\n        break;\n      case ir.OpKind.ContainerStart:\n        ir.OpList.replace(\n          op,\n          unit.job.mode === TemplateCompilationMode.DomOnly\n            ? ng.domElementContainerStart(\n                op.handle.slot!,\n                op.attributes as number | null,\n                op.localRefs as number | null,\n                op.startSourceSpan,\n              )\n            : ng.elementContainerStart(\n                op.handle.slot!,\n                op.attributes as number | null,\n                op.localRefs as number | null,\n                op.startSourceSpan,\n              ),\n        );\n        break;\n      case ir.OpKind.Container:\n        ir.OpList.replace(\n          op,\n          unit.job.mode === TemplateCompilationMode.DomOnly\n            ? ng.domElementContainer(\n                op.handle.slot!,\n                op.attributes as number | null,\n                op.localRefs as number | null,\n                op.wholeSourceSpan,\n              )\n            : ng.elementContainer(\n                op.handle.slot!,\n                op.attributes as number | null,\n                op.localRefs as number | null,\n                op.wholeSourceSpan,\n              ),\n        );\n        break;\n      case ir.OpKind.ContainerEnd:\n        ir.OpList.replace(\n          op,\n          unit.job.mode === TemplateCompilationMode.DomOnly\n            ? ng.domElementContainerEnd()\n            : ng.elementContainerEnd(),\n        );\n        break;\n      case ir.OpKind.I18nStart:\n        ir.OpList.replace(\n          op,\n          ng.i18nStart(op.handle.slot!, op.messageIndex!, op.subTemplateIndex!, op.sourceSpan),\n        );\n        break;\n      case ir.OpKind.I18nEnd:\n        ir.OpList.replace(op, ng.i18nEnd(op.sourceSpan));\n        break;\n      case ir.OpKind.I18n:\n        ir.OpList.replace(\n          op,\n          ng.i18n(op.handle.slot!, op.messageIndex!, op.subTemplateIndex!, op.sourceSpan),\n        );\n        break;\n      case ir.OpKind.I18nAttributes:\n        if (op.i18nAttributesConfig === null) {\n          throw new Error(`AssertionError: i18nAttributesConfig was not set`);\n        }\n        ir.OpList.replace(op, ng.i18nAttributes(op.handle.slot!, op.i18nAttributesConfig));\n        break;\n      case ir.OpKind.Template:\n        if (!(unit instanceof ViewCompilationUnit)) {\n          throw new Error(`AssertionError: must be compiling a component`);\n        }\n        if (Array.isArray(op.localRefs)) {\n          throw new Error(\n            `AssertionError: local refs array should have been extracted into a constant`,\n          );\n        }\n        const childView = unit.job.views.get(op.xref)!;\n        ir.OpList.replace(\n          op,\n          // Block templates can't have directives so we can always generate them as DOM-only.\n          op.templateKind === ir.TemplateKind.Block ||\n            unit.job.mode === TemplateCompilationMode.DomOnly\n            ? ng.domTemplate(\n                op.handle.slot!,\n                o.variable(childView.fnName!),\n                childView.decls!,\n                childView.vars!,\n                op.tag,\n                op.attributes,\n                op.localRefs,\n                op.startSourceSpan,\n              )\n            : ng.template(\n                op.handle.slot!,\n                o.variable(childView.fnName!),\n                childView.decls!,\n                childView.vars!,\n                op.tag,\n                op.attributes,\n                op.localRefs,\n                op.startSourceSpan,\n              ),\n        );\n        break;\n      case ir.OpKind.DisableBindings:\n        ir.OpList.replace(op, ng.disableBindings());\n        break;\n      case ir.OpKind.EnableBindings:\n        ir.OpList.replace(op, ng.enableBindings());\n        break;\n      case ir.OpKind.Pipe:\n        ir.OpList.replace(op, ng.pipe(op.handle.slot!, op.name));\n        break;\n      case ir.OpKind.DeclareLet:\n        ir.OpList.replace(op, ng.declareLet(op.handle.slot!, op.sourceSpan));\n        break;\n      case ir.OpKind.AnimationString:\n        ir.OpList.replace(\n          op,\n          ng.animationString(op.animationKind, op.expression, op.sanitizer, op.sourceSpan),\n        );\n        break;\n      case ir.OpKind.Animation:\n        const animationCallbackFn = reifyListenerHandler(\n          unit,\n          op.handlerFnName!,\n          op.handlerOps,\n          /* consumesDollarEvent */ false,\n        );\n        ir.OpList.replace(\n          op,\n          ng.animation(op.animationKind, animationCallbackFn, op.sanitizer, op.sourceSpan),\n        );\n        break;\n      case ir.OpKind.AnimationListener:\n        const animationListenerFn = reifyListenerHandler(\n          unit,\n          op.handlerFnName!,\n          op.handlerOps,\n          op.consumesDollarEvent,\n        );\n\n        ir.OpList.replace(\n          op,\n          ng.animationListener(op.animationKind, animationListenerFn, null, op.sourceSpan),\n        );\n        break;\n      case ir.OpKind.Listener:\n        const listenerFn = reifyListenerHandler(\n          unit,\n          op.handlerFnName!,\n          op.handlerOps,\n          op.consumesDollarEvent,\n        );\n        const eventTargetResolver = op.eventTarget\n          ? GLOBAL_TARGET_RESOLVERS.get(op.eventTarget)\n          : null;\n        if (eventTargetResolver === undefined) {\n          throw new Error(\n            `Unexpected global target '${op.eventTarget}' defined for '${op.name}' event. Supported list of global targets: window,document,body.`,\n          );\n        }\n        ir.OpList.replace(\n          op,\n          unit.job.mode === TemplateCompilationMode.DomOnly &&\n            !op.hostListener &&\n            !op.isLegacyAnimationListener\n            ? ng.domListener(op.name, listenerFn, eventTargetResolver, op.sourceSpan)\n            : ng.listener(\n                op.name,\n                listenerFn,\n                eventTargetResolver,\n                op.hostListener && op.isLegacyAnimationListener,\n                op.sourceSpan,\n              ),\n        );\n        break;\n      case ir.OpKind.TwoWayListener:\n        ir.OpList.replace(\n          op,\n          ng.twoWayListener(\n            op.name,\n            reifyListenerHandler(unit, op.handlerFnName!, op.handlerOps, true),\n            op.sourceSpan,\n          ),\n        );\n        break;\n      case ir.OpKind.Variable:\n        if (op.variable.name === null) {\n          throw new Error(`AssertionError: unnamed variable ${op.xref}`);\n        }\n        ir.OpList.replace<ir.CreateOp>(\n          op,\n          ir.createStatementOp(\n            new o.DeclareVarStmt(op.variable.name, op.initializer, undefined, o.StmtModifier.Final),\n          ),\n        );\n        break;\n      case ir.OpKind.Namespace:\n        switch (op.active) {\n          case ir.Namespace.HTML:\n            ir.OpList.replace<ir.CreateOp>(op, ng.namespaceHTML());\n            break;\n          case ir.Namespace.SVG:\n            ir.OpList.replace<ir.CreateOp>(op, ng.namespaceSVG());\n            break;\n          case ir.Namespace.Math:\n            ir.OpList.replace<ir.CreateOp>(op, ng.namespaceMath());\n            break;\n        }\n        break;\n      case ir.OpKind.Defer:\n        const timerScheduling =\n          !!op.loadingMinimumTime || !!op.loadingAfterTime || !!op.placeholderMinimumTime;\n        ir.OpList.replace(\n          op,\n          ng.defer(\n            op.handle.slot!,\n            op.mainSlot.slot!,\n            op.resolverFn,\n            op.loadingSlot?.slot ?? null,\n            op.placeholderSlot?.slot! ?? null,\n            op.errorSlot?.slot ?? null,\n            op.loadingConfig,\n            op.placeholderConfig,\n            timerScheduling,\n            op.sourceSpan,\n            op.flags,\n          ),\n        );\n        break;\n      case ir.OpKind.DeferOn:\n        let args: (number | null)[] = [];\n        switch (op.trigger.kind) {\n          case ir.DeferTriggerKind.Never:\n          case ir.DeferTriggerKind.Idle:\n          case ir.DeferTriggerKind.Immediate:\n            break;\n          case ir.DeferTriggerKind.Timer:\n            args = [op.trigger.delay];\n            break;\n          case ir.DeferTriggerKind.Interaction:\n          case ir.DeferTriggerKind.Hover:\n          case ir.DeferTriggerKind.Viewport:\n            // `hydrate` triggers don't support targets.\n            if (op.modifier === ir.DeferOpModifierKind.HYDRATE) {\n              args = [];\n            } else {\n              // The slots not being defined at this point is invalid, however we\n              // catch it during type checking. Pass in null in such cases.\n              args = [op.trigger.targetSlot?.slot ?? null];\n              if (op.trigger.targetSlotViewSteps !== 0) {\n                args.push(op.trigger.targetSlotViewSteps);\n              }\n            }\n            break;\n          default:\n            throw new Error(\n              `AssertionError: Unsupported reification of defer trigger kind ${\n                (op.trigger as any).kind\n              }`,\n            );\n        }\n        ir.OpList.replace(op, ng.deferOn(op.trigger.kind, args, op.modifier, op.sourceSpan));\n        break;\n      case ir.OpKind.ProjectionDef:\n        ir.OpList.replace<ir.CreateOp>(op, ng.projectionDef(op.def));\n        break;\n      case ir.OpKind.Projection:\n        if (op.handle.slot === null) {\n          throw new Error('No slot was assigned for project instruction');\n        }\n        let fallbackViewFnName: string | null = null;\n        let fallbackDecls: number | null = null;\n        let fallbackVars: number | null = null;\n        if (op.fallbackView !== null) {\n          if (!(unit instanceof ViewCompilationUnit)) {\n            throw new Error(`AssertionError: must be compiling a component`);\n          }\n          const fallbackView = unit.job.views.get(op.fallbackView);\n          if (fallbackView === undefined) {\n            throw new Error(\n              'AssertionError: projection had fallback view xref, but fallback view was not found',\n            );\n          }\n          if (\n            fallbackView.fnName === null ||\n            fallbackView.decls === null ||\n            fallbackView.vars === null\n          ) {\n            throw new Error(\n              `AssertionError: expected projection fallback view to have been named and counted`,\n            );\n          }\n          fallbackViewFnName = fallbackView.fnName;\n          fallbackDecls = fallbackView.decls;\n          fallbackVars = fallbackView.vars;\n        }\n        ir.OpList.replace<ir.CreateOp>(\n          op,\n          ng.projection(\n            op.handle.slot!,\n            op.projectionSlotIndex,\n            op.attributes,\n            fallbackViewFnName,\n            fallbackDecls,\n            fallbackVars,\n            op.sourceSpan,\n          ),\n        );\n        break;\n      case ir.OpKind.ConditionalCreate:\n        if (!(unit instanceof ViewCompilationUnit)) {\n          throw new Error(`AssertionError: must be compiling a component`);\n        }\n        if (Array.isArray(op.localRefs)) {\n          throw new Error(\n            `AssertionError: local refs array should have been extracted into a constant`,\n          );\n        }\n        const conditionalCreateChildView = unit.job.views.get(op.xref)!;\n        ir.OpList.replace(\n          op,\n          ng.conditionalCreate(\n            op.handle.slot!,\n            o.variable(conditionalCreateChildView.fnName!),\n            conditionalCreateChildView.decls!,\n            conditionalCreateChildView.vars!,\n            op.tag,\n            op.attributes,\n            op.localRefs,\n            op.startSourceSpan,\n          ),\n        );\n        break;\n      case ir.OpKind.ConditionalBranchCreate:\n        if (!(unit instanceof ViewCompilationUnit)) {\n          throw new Error(`AssertionError: must be compiling a component`);\n        }\n        if (Array.isArray(op.localRefs)) {\n          throw new Error(\n            `AssertionError: local refs array should have been extracted into a constant`,\n          );\n        }\n        const conditionalBranchCreateChildView = unit.job.views.get(op.xref)!;\n        ir.OpList.replace(\n          op,\n          ng.conditionalBranchCreate(\n            op.handle.slot!,\n            o.variable(conditionalBranchCreateChildView.fnName!),\n            conditionalBranchCreateChildView.decls!,\n            conditionalBranchCreateChildView.vars!,\n            op.tag,\n            op.attributes,\n            op.localRefs,\n            op.startSourceSpan,\n          ),\n        );\n        break;\n      case ir.OpKind.RepeaterCreate:\n        if (op.handle.slot === null) {\n          throw new Error('No slot was assigned for repeater instruction');\n        }\n        if (!(unit instanceof ViewCompilationUnit)) {\n          throw new Error(`AssertionError: must be compiling a component`);\n        }\n        const repeaterView = unit.job.views.get(op.xref)!;\n        if (repeaterView.fnName === null) {\n          throw new Error(`AssertionError: expected repeater primary view to have been named`);\n        }\n\n        let emptyViewFnName: string | null = null;\n        let emptyDecls: number | null = null;\n        let emptyVars: number | null = null;\n        if (op.emptyView !== null) {\n          const emptyView = unit.job.views.get(op.emptyView);\n          if (emptyView === undefined) {\n            throw new Error(\n              'AssertionError: repeater had empty view xref, but empty view was not found',\n            );\n          }\n          if (emptyView.fnName === null || emptyView.decls === null || emptyView.vars === null) {\n            throw new Error(\n              `AssertionError: expected repeater empty view to have been named and counted`,\n            );\n          }\n          emptyViewFnName = emptyView.fnName;\n          emptyDecls = emptyView.decls;\n          emptyVars = emptyView.vars;\n        }\n\n        ir.OpList.replace(\n          op,\n          ng.repeaterCreate(\n            op.handle.slot,\n            repeaterView.fnName,\n            op.decls!,\n            op.vars!,\n            op.tag,\n            op.attributes,\n            reifyTrackBy(unit, op),\n            op.usesComponentInstance,\n            emptyViewFnName,\n            emptyDecls,\n            emptyVars,\n            op.emptyTag,\n            op.emptyAttributes,\n            op.wholeSourceSpan,\n          ),\n        );\n        break;\n      case ir.OpKind.SourceLocation:\n        const locationsLiteral = o.literalArr(\n          op.locations.map(({targetSlot, offset, line, column}) => {\n            if (targetSlot.slot === null) {\n              throw new Error('No slot was assigned for source location');\n            }\n            return o.literalArr([\n              o.literal(targetSlot.slot),\n              o.literal(offset),\n              o.literal(line),\n              o.literal(column),\n            ]);\n          }),\n        );\n\n        ir.OpList.replace(op, ng.attachSourceLocation(op.templatePath, locationsLiteral));\n        break;\n      case ir.OpKind.Statement:\n        // Pass statement operations directly through.\n        break;\n      default:\n        throw new Error(\n          `AssertionError: Unsupported reification of create op ${ir.OpKind[op.kind]}`,\n        );\n    }\n  }\n}\n\nfunction reifyUpdateOperations(unit: CompilationUnit, ops: ir.OpList<ir.UpdateOp>): void {\n  for (const op of ops) {\n    ir.transformExpressionsInOp(op, reifyIrExpression, ir.VisitorContextFlag.None);\n\n    switch (op.kind) {\n      case ir.OpKind.Advance:\n        ir.OpList.replace(op, ng.advance(op.delta, op.sourceSpan));\n        break;\n      case ir.OpKind.Property:\n        ir.OpList.replace(\n          op,\n          unit.job.mode === TemplateCompilationMode.DomOnly &&\n            op.bindingKind !== ir.BindingKind.LegacyAnimation &&\n            op.bindingKind !== ir.BindingKind.Animation\n            ? reifyDomProperty(op)\n            : reifyProperty(op),\n        );\n        break;\n      case ir.OpKind.TwoWayProperty:\n        ir.OpList.replace(\n          op,\n          ng.twoWayProperty(op.name, op.expression, op.sanitizer, op.sourceSpan),\n        );\n        break;\n      case ir.OpKind.StyleProp:\n        ir.OpList.replace(op, ng.styleProp(op.name, op.expression, op.unit, op.sourceSpan));\n        break;\n      case ir.OpKind.ClassProp:\n        ir.OpList.replace(op, ng.classProp(op.name, op.expression, op.sourceSpan));\n        break;\n      case ir.OpKind.StyleMap:\n        ir.OpList.replace(op, ng.styleMap(op.expression, op.sourceSpan));\n        break;\n      case ir.OpKind.ClassMap:\n        ir.OpList.replace(op, ng.classMap(op.expression, op.sourceSpan));\n        break;\n      case ir.OpKind.I18nExpression:\n        ir.OpList.replace(op, ng.i18nExp(op.expression, op.sourceSpan));\n        break;\n      case ir.OpKind.I18nApply:\n        ir.OpList.replace(op, ng.i18nApply(op.handle.slot!, op.sourceSpan));\n        break;\n      case ir.OpKind.InterpolateText:\n        ir.OpList.replace(\n          op,\n          ng.textInterpolate(op.interpolation.strings, op.interpolation.expressions, op.sourceSpan),\n        );\n        break;\n      case ir.OpKind.Attribute:\n        ir.OpList.replace(\n          op,\n          ng.attribute(op.name, op.expression, op.sanitizer, op.namespace, op.sourceSpan),\n        );\n        break;\n      case ir.OpKind.DomProperty:\n        if (op.expression instanceof ir.Interpolation) {\n          throw new Error('not yet handled');\n        } else {\n          if (\n            op.bindingKind === ir.BindingKind.LegacyAnimation ||\n            op.bindingKind === ir.BindingKind.Animation\n          ) {\n            ir.OpList.replace(op, ng.syntheticHostProperty(op.name, op.expression, op.sourceSpan));\n          } else {\n            ir.OpList.replace(op, reifyDomProperty(op));\n          }\n        }\n        break;\n      case ir.OpKind.Variable:\n        if (op.variable.name === null) {\n          throw new Error(`AssertionError: unnamed variable ${op.xref}`);\n        }\n        ir.OpList.replace<ir.UpdateOp>(\n          op,\n          ir.createStatementOp(\n            new o.DeclareVarStmt(op.variable.name, op.initializer, undefined, o.StmtModifier.Final),\n          ),\n        );\n        break;\n      case ir.OpKind.Conditional:\n        if (op.processed === null) {\n          throw new Error(`Conditional test was not set.`);\n        }\n        ir.OpList.replace(op, ng.conditional(op.processed, op.contextValue, op.sourceSpan));\n        break;\n      case ir.OpKind.Repeater:\n        ir.OpList.replace(op, ng.repeater(op.collection, op.sourceSpan));\n        break;\n      case ir.OpKind.DeferWhen:\n        ir.OpList.replace(op, ng.deferWhen(op.modifier, op.expr, op.sourceSpan));\n        break;\n      case ir.OpKind.StoreLet:\n        throw new Error(`AssertionError: unexpected storeLet ${op.declaredName}`);\n      case ir.OpKind.Statement:\n        // Pass statement operations directly through.\n        break;\n      default:\n        throw new Error(\n          `AssertionError: Unsupported reification of update op ${ir.OpKind[op.kind]}`,\n        );\n    }\n  }\n}\n\n/**\n * Reifies a DOM property binding operation.\n *\n * This is an optimized version of {@link reifyProperty} that avoids unnecessarily trying to bind\n * to directive inputs at runtime for views that don't import any directives.\n *\n * @param op A property binding operation.\n * @returns A statement to update the property at runtime.\n */\nfunction reifyDomProperty(op: ir.DomPropertyOp | ir.PropertyOp): ir.UpdateOp {\n  return ng.domProperty(\n    DOM_PROPERTY_REMAPPING.get(op.name) ?? op.name,\n    op.expression,\n    op.sanitizer,\n    op.sourceSpan,\n  );\n}\n\n/**\n * Reifies a property binding operation.\n *\n * The returned statement attempts to bind to directive inputs before falling back to a DOM\n * property.\n *\n * @param op A property binding operation.\n * @returns A statement to update the property at runtime.\n */\nfunction reifyProperty(op: ir.PropertyOp): ir.UpdateOp {\n  return isAriaAttribute(op.name)\n    ? ng.ariaProperty(op.name, op.expression, op.sourceSpan)\n    : ng.property(op.name, op.expression, op.sanitizer, op.sourceSpan);\n}\n\nfunction reifyIrExpression(expr: o.Expression): o.Expression {\n  if (!ir.isIrExpression(expr)) {\n    return expr;\n  }\n\n  switch (expr.kind) {\n    case ir.ExpressionKind.NextContext:\n      return ng.nextContext(expr.steps);\n    case ir.ExpressionKind.Reference:\n      return ng.reference(expr.targetSlot.slot! + 1 + expr.offset);\n    case ir.ExpressionKind.LexicalRead:\n      throw new Error(`AssertionError: unresolved LexicalRead of ${expr.name}`);\n    case ir.ExpressionKind.TwoWayBindingSet:\n      throw new Error(`AssertionError: unresolved TwoWayBindingSet`);\n    case ir.ExpressionKind.RestoreView:\n      if (typeof expr.view === 'number') {\n        throw new Error(`AssertionError: unresolved RestoreView`);\n      }\n      return ng.restoreView(expr.view);\n    case ir.ExpressionKind.ResetView:\n      return ng.resetView(expr.expr);\n    case ir.ExpressionKind.GetCurrentView:\n      return ng.getCurrentView();\n    case ir.ExpressionKind.ReadVariable:\n      if (expr.name === null) {\n        throw new Error(`Read of unnamed variable ${expr.xref}`);\n      }\n      return o.variable(expr.name);\n    case ir.ExpressionKind.ReadTemporaryExpr:\n      if (expr.name === null) {\n        throw new Error(`Read of unnamed temporary ${expr.xref}`);\n      }\n      return o.variable(expr.name);\n    case ir.ExpressionKind.AssignTemporaryExpr:\n      if (expr.name === null) {\n        throw new Error(`Assign of unnamed temporary ${expr.xref}`);\n      }\n      return o.variable(expr.name).set(expr.expr);\n    case ir.ExpressionKind.PureFunctionExpr:\n      if (expr.fn === null) {\n        throw new Error(`AssertionError: expected PureFunctions to have been extracted`);\n      }\n      return ng.pureFunction(expr.varOffset!, expr.fn, expr.args);\n    case ir.ExpressionKind.PureFunctionParameterExpr:\n      throw new Error(`AssertionError: expected PureFunctionParameterExpr to have been extracted`);\n    case ir.ExpressionKind.PipeBinding:\n      return ng.pipeBind(expr.targetSlot.slot!, expr.varOffset!, expr.args);\n    case ir.ExpressionKind.PipeBindingVariadic:\n      return ng.pipeBindV(expr.targetSlot.slot!, expr.varOffset!, expr.args);\n    case ir.ExpressionKind.SlotLiteralExpr:\n      return o.literal(expr.slot.slot!);\n    case ir.ExpressionKind.ContextLetReference:\n      return ng.readContextLet(expr.targetSlot.slot!);\n    case ir.ExpressionKind.StoreLet:\n      return ng.storeLet(expr.value, expr.sourceSpan);\n    case ir.ExpressionKind.TrackContext:\n      return o.variable('this');\n    default:\n      throw new Error(\n        `AssertionError: Unsupported reification of ir.Expression kind: ${\n          ir.ExpressionKind[(expr as ir.Expression).kind]\n        }`,\n      );\n  }\n}\n\n/**\n * Listeners get turned into a function expression, which may or may not have the `$event`\n * parameter defined.\n */\nfunction reifyListenerHandler(\n  unit: CompilationUnit,\n  name: string,\n  handlerOps: ir.OpList<ir.UpdateOp>,\n  consumesDollarEvent: boolean,\n): o.FunctionExpr {\n  // First, reify all instruction calls within `handlerOps`.\n  reifyUpdateOperations(unit, handlerOps);\n\n  // Next, extract all the `o.Statement`s from the reified operations. We can expect that at this\n  // point, all operations have been converted to statements.\n  const handlerStmts: o.Statement[] = [];\n  for (const op of handlerOps) {\n    if (op.kind !== ir.OpKind.Statement) {\n      throw new Error(\n        `AssertionError: expected reified statements, but found op ${ir.OpKind[op.kind]}`,\n      );\n    }\n    handlerStmts.push(op.statement);\n  }\n\n  // If `$event` is referenced, we need to generate it as a parameter.\n  const params: o.FnParam[] = [];\n  if (consumesDollarEvent) {\n    // We need the `$event` parameter.\n    params.push(new o.FnParam('$event'));\n  }\n\n  return o.fn(params, handlerStmts, undefined, undefined, name);\n}\n\n/** Reifies the tracking expression of a `RepeaterCreateOp`. */\nfunction reifyTrackBy(unit: CompilationUnit, op: ir.RepeaterCreateOp): o.Expression {\n  // If the tracking function was created already, there's nothing left to do.\n  if (op.trackByFn !== null) {\n    return op.trackByFn;\n  }\n\n  const params: o.FnParam[] = [new o.FnParam('$index'), new o.FnParam('$item')];\n  let fn: o.FunctionExpr | o.ArrowFunctionExpr;\n\n  if (op.trackByOps === null) {\n    // If there are no additional ops related to the tracking function, we just need\n    // to turn it into a function that returns the result of the expression.\n    fn = op.usesComponentInstance\n      ? o.fn(params, [new o.ReturnStatement(op.track)])\n      : o.arrowFn(params, op.track);\n  } else {\n    // Otherwise first we need to reify the track-related ops.\n    reifyUpdateOperations(unit, op.trackByOps);\n\n    const statements: o.Statement[] = [];\n    for (const trackOp of op.trackByOps) {\n      if (trackOp.kind !== ir.OpKind.Statement) {\n        throw new Error(\n          `AssertionError: expected reified statements, but found op ${ir.OpKind[trackOp.kind]}`,\n        );\n      }\n      statements.push(trackOp.statement);\n    }\n\n    // Afterwards we can create the function from those ops.\n    fn =\n      op.usesComponentInstance ||\n      statements.length !== 1 ||\n      !(statements[0] instanceof o.ReturnStatement)\n        ? o.fn(params, statements)\n        : o.arrowFn(params, statements[0].value);\n  }\n\n  op.trackByFn = unit.job.pool.getSharedFunctionReference(fn, '_forTrack');\n  return op.trackByFn;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as ir from '../../ir';\nimport type {CompilationJob} from '../compilation';\n\n/**\n * Binding with no content can be safely deleted.\n */\nexport function removeEmptyBindings(job: CompilationJob): void {\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      switch (op.kind) {\n        case ir.OpKind.Attribute:\n        case ir.OpKind.Binding:\n        case ir.OpKind.ClassProp:\n        case ir.OpKind.ClassMap:\n        case ir.OpKind.Property:\n        case ir.OpKind.StyleProp:\n        case ir.OpKind.StyleMap:\n          if (op.expression instanceof ir.EmptyExpr) {\n            ir.OpList.remove<ir.UpdateOp>(op);\n          }\n          break;\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as ir from '../../ir';\nimport {CompilationJob} from '../compilation';\n\n/**\n * Remove the i18n context ops after they are no longer needed, and null out references to them to\n * be safe.\n */\nexport function removeI18nContexts(job: CompilationJob) {\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case ir.OpKind.I18nContext:\n          ir.OpList.remove<ir.CreateOp>(op);\n          break;\n        case ir.OpKind.I18nStart:\n          op.context = null;\n          break;\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\nimport {CompilationJob} from '../compilation';\n\n/**\n * It's not allowed to access a `@let` declaration before it has been defined. This is enforced\n * already via template type checking, however it can trip some of the assertions in the pipeline.\n * E.g. the naming phase can fail because we resolved the variable here, but the variable doesn't\n * exist anymore because the optimization phase removed it since it's invalid. To avoid surfacing\n * confusing errors to users in the case where template type checking isn't running (e.g. in JIT\n * mode) this phase detects illegal forward references and replaces them with `undefined`.\n * Eventually users will see the proper error from the template type checker.\n */\nexport function removeIllegalLetReferences(job: CompilationJob): void {\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      if (\n        op.kind !== ir.OpKind.Variable ||\n        op.variable.kind !== ir.SemanticVariableKind.Identifier ||\n        !(op.initializer instanceof ir.StoreLetExpr)\n      ) {\n        continue;\n      }\n\n      const name = op.variable.identifier;\n      let current: ir.UpdateOp | null = op;\n      while (current && current.kind !== ir.OpKind.ListEnd) {\n        ir.transformExpressionsInOp(\n          current,\n          (expr) =>\n            expr instanceof ir.LexicalReadExpr && expr.name === name ? o.literal(undefined) : expr,\n          ir.VisitorContextFlag.None,\n        );\n        current = current.prev;\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as ir from '../../ir';\nimport {CompilationJob} from '../compilation';\n\n/**\n * i18nAttributes ops will be generated for each i18n attribute. However, not all i18n attribues\n * will contain dynamic content, and so some of these i18nAttributes ops may be unnecessary.\n */\nexport function removeUnusedI18nAttributesOps(job: CompilationJob) {\n  for (const unit of job.units) {\n    const ownersWithI18nExpressions = new Set<ir.XrefId>();\n\n    for (const op of unit.update) {\n      switch (op.kind) {\n        case ir.OpKind.I18nExpression:\n          ownersWithI18nExpressions.add(op.i18nOwner);\n      }\n    }\n\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case ir.OpKind.I18nAttributes:\n          if (ownersWithI18nExpressions.has(op.xref)) {\n            continue;\n          }\n          ir.OpList.remove<ir.CreateOp>(op);\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\nimport {CompilationJob, CompilationUnit} from '../compilation';\n\n/**\n * Resolves `ir.ContextExpr` expressions (which represent embedded view or component contexts) to\n * either the `ctx` parameter to component functions (for the current view context) or to variables\n * that store those contexts (for contexts accessed via the `nextContext()` instruction).\n */\nexport function resolveContexts(job: CompilationJob): void {\n  for (const unit of job.units) {\n    processLexicalScope(unit, unit.create);\n    processLexicalScope(unit, unit.update);\n  }\n}\n\nfunction processLexicalScope(\n  view: CompilationUnit,\n  ops: ir.OpList<ir.CreateOp | ir.UpdateOp>,\n): void {\n  // Track the expressions used to access all available contexts within the current view, by the\n  // view `ir.XrefId`.\n  const scope = new Map<ir.XrefId, o.Expression>();\n\n  // The current view's context is accessible via the `ctx` parameter.\n  scope.set(view.xref, o.variable('ctx'));\n\n  for (const op of ops) {\n    switch (op.kind) {\n      case ir.OpKind.Variable:\n        switch (op.variable.kind) {\n          case ir.SemanticVariableKind.Context:\n            scope.set(op.variable.view, new ir.ReadVariableExpr(op.xref));\n            break;\n        }\n        break;\n      case ir.OpKind.Animation:\n      case ir.OpKind.AnimationListener:\n      case ir.OpKind.Listener:\n      case ir.OpKind.TwoWayListener:\n        processLexicalScope(view, op.handlerOps);\n        break;\n      case ir.OpKind.RepeaterCreate:\n        if (op.trackByOps !== null) {\n          processLexicalScope(view, op.trackByOps);\n        }\n        break;\n    }\n  }\n\n  if (view === view.job.root) {\n    // Prefer `ctx` of the root view to any variables which happen to contain the root context.\n    scope.set(view.xref, o.variable('ctx'));\n  }\n\n  for (const op of ops) {\n    ir.transformExpressionsInOp(\n      op,\n      (expr) => {\n        if (expr instanceof ir.ContextExpr) {\n          if (!scope.has(expr.view)) {\n            throw new Error(\n              `No context found for reference to view ${expr.view} from view ${view.xref}`,\n            );\n          }\n          return scope.get(expr.view)!;\n        } else {\n          return expr;\n        }\n      },\n      ir.VisitorContextFlag.None,\n    );\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as ir from '../../ir';\nimport {ComponentCompilationJob} from '../compilation';\n\n/**\n * Resolve the dependency function of a deferred block.\n */\nexport function resolveDeferDepsFns(job: ComponentCompilationJob): void {\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === ir.OpKind.Defer) {\n        if (op.resolverFn !== null) {\n          continue;\n        }\n\n        if (op.ownResolverFn !== null) {\n          if (op.handle.slot === null) {\n            throw new Error(\n              'AssertionError: slot must be assigned before extracting defer deps functions',\n            );\n          }\n          const fullPathName = unit.fnName?.replace('_Template', '');\n          op.resolverFn = job.pool.getSharedFunctionReference(\n            op.ownResolverFn,\n            `${fullPathName}_Defer_${op.handle.slot}_DepsFn`,\n            /* Don't use unique names for TDB compatibility */ false,\n          );\n        }\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\nimport type {CompilationJob} from '../compilation';\n\n/**\n * Any variable inside a listener with the name `$event` will be transformed into a output lexical\n * read immediately, and does not participate in any of the normal logic for handling variables.\n */\nexport function resolveDollarEvent(job: CompilationJob): void {\n  for (const unit of job.units) {\n    transformDollarEvent(unit.create);\n    transformDollarEvent(unit.update);\n  }\n}\n\nfunction transformDollarEvent(ops: ir.OpList<ir.CreateOp> | ir.OpList<ir.UpdateOp>): void {\n  for (const op of ops) {\n    if (\n      op.kind === ir.OpKind.Listener ||\n      op.kind === ir.OpKind.TwoWayListener ||\n      op.kind === ir.OpKind.AnimationListener\n    ) {\n      ir.transformExpressionsInOp(\n        op,\n        (expr) => {\n          if (expr instanceof ir.LexicalReadExpr && expr.name === '$event') {\n            // Two-way listeners always consume `$event` so they omit this field.\n            if (op.kind === ir.OpKind.Listener || op.kind === ir.OpKind.AnimationListener) {\n              op.consumesDollarEvent = true;\n            }\n            return new o.ReadVarExpr(expr.name);\n          }\n          return expr;\n        },\n        ir.VisitorContextFlag.InChildOperation,\n      );\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as i18n from '../../../../i18n/i18n_ast';\nimport * as ir from '../../ir';\nimport {ComponentCompilationJob, ViewCompilationUnit} from '../compilation';\n\n/**\n * Resolve the element placeholders in i18n messages.\n */\nexport function resolveI18nElementPlaceholders(job: ComponentCompilationJob) {\n  // Record all of the element and i18n context ops for use later.\n  const i18nContexts = new Map<ir.XrefId, ir.I18nContextOp>();\n  const elements = new Map<ir.XrefId, ir.ElementStartOp>();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case ir.OpKind.I18nContext:\n          i18nContexts.set(op.xref, op);\n          break;\n        case ir.OpKind.ElementStart:\n          elements.set(op.xref, op);\n          break;\n      }\n    }\n  }\n\n  resolvePlaceholdersForView(job, job.root, i18nContexts, elements);\n}\n\n/**\n * Recursively resolves element and template tag placeholders in the given view.\n */\nfunction resolvePlaceholdersForView(\n  job: ComponentCompilationJob,\n  unit: ViewCompilationUnit,\n  i18nContexts: Map<ir.XrefId, ir.I18nContextOp>,\n  elements: Map<ir.XrefId, ir.ElementStartOp>,\n  pendingStructuralDirective?:\n    | ir.TemplateOp\n    | ir.ConditionalCreateOp\n    | ir.ConditionalBranchCreateOp,\n) {\n  // Track the current i18n op and corresponding i18n context op as we step through the creation\n  // IR.\n  let currentOps: {i18nBlock: ir.I18nStartOp; i18nContext: ir.I18nContextOp} | null = null;\n  let pendingStructuralDirectiveCloses = new Map<\n    ir.XrefId,\n    ir.TemplateOp | ir.ConditionalCreateOp | ir.ConditionalBranchCreateOp\n  >();\n  for (const op of unit.create) {\n    switch (op.kind) {\n      case ir.OpKind.I18nStart:\n        if (!op.context) {\n          throw Error('Could not find i18n context for i18n op');\n        }\n        currentOps = {i18nBlock: op, i18nContext: i18nContexts.get(op.context)!};\n        break;\n      case ir.OpKind.I18nEnd:\n        currentOps = null;\n        break;\n      case ir.OpKind.ElementStart:\n        // For elements with i18n placeholders, record its slot value in the params map under the\n        // corresponding tag start placeholder.\n        if (op.i18nPlaceholder !== undefined) {\n          if (currentOps === null) {\n            throw Error('i18n tag placeholder should only occur inside an i18n block');\n          }\n          recordElementStart(\n            op,\n            currentOps.i18nContext,\n            currentOps.i18nBlock,\n            pendingStructuralDirective,\n          );\n          // If there is a separate close tag placeholder for this element, save the pending\n          // structural directive so we can pass it to the closing tag as well.\n          if (pendingStructuralDirective && op.i18nPlaceholder.closeName) {\n            pendingStructuralDirectiveCloses.set(op.xref, pendingStructuralDirective);\n          }\n          // Clear out the pending structural directive now that its been accounted for.\n          pendingStructuralDirective = undefined;\n        }\n        break;\n      case ir.OpKind.ElementEnd:\n        // For elements with i18n placeholders, record its slot value in the params map under the\n        // corresponding tag close placeholder.\n        const startOp = elements.get(op.xref);\n        if (startOp && startOp.i18nPlaceholder !== undefined) {\n          if (currentOps === null) {\n            throw Error(\n              'AssertionError: i18n tag placeholder should only occur inside an i18n block',\n            );\n          }\n          recordElementClose(\n            startOp,\n            currentOps.i18nContext,\n            currentOps.i18nBlock,\n            pendingStructuralDirectiveCloses.get(op.xref),\n          );\n          // Clear out the pending structural directive close that was accounted for.\n          pendingStructuralDirectiveCloses.delete(op.xref);\n        }\n        break;\n      case ir.OpKind.Projection:\n        // For content projections with i18n placeholders, record its slot value in the params map\n        // under the corresponding tag start and close placeholders.\n        if (op.i18nPlaceholder !== undefined) {\n          if (currentOps === null) {\n            throw Error('i18n tag placeholder should only occur inside an i18n block');\n          }\n          recordElementStart(\n            op,\n            currentOps.i18nContext,\n            currentOps.i18nBlock,\n            pendingStructuralDirective,\n          );\n          recordElementClose(\n            op,\n            currentOps.i18nContext,\n            currentOps.i18nBlock,\n            pendingStructuralDirective,\n          );\n          // Clear out the pending structural directive now that its been accounted for.\n          pendingStructuralDirective = undefined;\n        }\n\n        if (op.fallbackView !== null) {\n          const view = job.views.get(op.fallbackView)!;\n          if (op.fallbackViewI18nPlaceholder === undefined) {\n            resolvePlaceholdersForView(job, view, i18nContexts, elements);\n          } else {\n            if (currentOps === null) {\n              throw Error('i18n tag placeholder should only occur inside an i18n block');\n            }\n            recordTemplateStart(\n              job,\n              view,\n              op.handle.slot!,\n              op.fallbackViewI18nPlaceholder,\n              currentOps.i18nContext,\n              currentOps.i18nBlock,\n              pendingStructuralDirective,\n            );\n            resolvePlaceholdersForView(job, view, i18nContexts, elements);\n            recordTemplateClose(\n              job,\n              view,\n              op.handle.slot!,\n              op.fallbackViewI18nPlaceholder,\n              currentOps.i18nContext,\n              currentOps.i18nBlock,\n              pendingStructuralDirective,\n            );\n            pendingStructuralDirective = undefined;\n          }\n        }\n\n        break;\n      case ir.OpKind.ConditionalCreate:\n      case ir.OpKind.ConditionalBranchCreate:\n      case ir.OpKind.Template:\n        const view = job.views.get(op.xref)!;\n        if (op.i18nPlaceholder === undefined) {\n          // If there is no i18n placeholder, just recurse into the view in case it contains i18n\n          // blocks.\n          resolvePlaceholdersForView(job, view, i18nContexts, elements);\n        } else {\n          if (currentOps === null) {\n            throw Error('i18n tag placeholder should only occur inside an i18n block');\n          }\n          if (op.templateKind === ir.TemplateKind.Structural) {\n            // If this is a structural directive template, don't record anything yet. Instead pass\n            // the current template as a pending structural directive to be recorded when we find\n            // the element, content, or template it belongs to. This allows us to create combined\n            // values that represent, e.g. the start of a template and element at the same time.\n            resolvePlaceholdersForView(job, view, i18nContexts, elements, op);\n          } else {\n            // If this is some other kind of template, we can record its start, recurse into its\n            // view, and then record its end.\n            recordTemplateStart(\n              job,\n              view,\n              op.handle.slot!,\n              op.i18nPlaceholder,\n              currentOps.i18nContext,\n              currentOps.i18nBlock,\n              pendingStructuralDirective,\n            );\n            resolvePlaceholdersForView(job, view, i18nContexts, elements);\n            recordTemplateClose(\n              job,\n              view,\n              op.handle.slot!,\n              op.i18nPlaceholder,\n              currentOps!.i18nContext,\n              currentOps!.i18nBlock,\n              pendingStructuralDirective,\n            );\n            pendingStructuralDirective = undefined;\n          }\n        }\n        break;\n      case ir.OpKind.RepeaterCreate:\n        if (pendingStructuralDirective !== undefined) {\n          throw Error('AssertionError: Unexpected structural directive associated with @for block');\n        }\n        // RepeaterCreate has 3 slots: the first is for the op itself, the second is for the @for\n        // template and the (optional) third is for the @empty template.\n        const forSlot = op.handle.slot! + 1;\n        const forView = job.views.get(op.xref)!;\n        // First record all of the placeholders for the @for template.\n        if (op.i18nPlaceholder === undefined) {\n          // If there is no i18n placeholder, just recurse into the view in case it contains i18n\n          // blocks.\n          resolvePlaceholdersForView(job, forView, i18nContexts, elements);\n        } else {\n          if (currentOps === null) {\n            throw Error('i18n tag placeholder should only occur inside an i18n block');\n          }\n          recordTemplateStart(\n            job,\n            forView,\n            forSlot,\n            op.i18nPlaceholder,\n            currentOps.i18nContext,\n            currentOps.i18nBlock,\n            pendingStructuralDirective,\n          );\n          resolvePlaceholdersForView(job, forView, i18nContexts, elements);\n          recordTemplateClose(\n            job,\n            forView,\n            forSlot,\n            op.i18nPlaceholder,\n            currentOps!.i18nContext,\n            currentOps!.i18nBlock,\n            pendingStructuralDirective,\n          );\n          pendingStructuralDirective = undefined;\n        }\n        // Then if there's an @empty template, add its placeholders as well.\n        if (op.emptyView !== null) {\n          // RepeaterCreate has 3 slots: the first is for the op itself, the second is for the @for\n          // template and the (optional) third is for the @empty template.\n          const emptySlot = op.handle.slot! + 2;\n          const emptyView = job.views.get(op.emptyView!)!;\n          if (op.emptyI18nPlaceholder === undefined) {\n            // If there is no i18n placeholder, just recurse into the view in case it contains i18n\n            // blocks.\n            resolvePlaceholdersForView(job, emptyView, i18nContexts, elements);\n          } else {\n            if (currentOps === null) {\n              throw Error('i18n tag placeholder should only occur inside an i18n block');\n            }\n            recordTemplateStart(\n              job,\n              emptyView,\n              emptySlot,\n              op.emptyI18nPlaceholder,\n              currentOps.i18nContext,\n              currentOps.i18nBlock,\n              pendingStructuralDirective,\n            );\n            resolvePlaceholdersForView(job, emptyView, i18nContexts, elements);\n            recordTemplateClose(\n              job,\n              emptyView,\n              emptySlot,\n              op.emptyI18nPlaceholder,\n              currentOps!.i18nContext,\n              currentOps!.i18nBlock,\n              pendingStructuralDirective,\n            );\n            pendingStructuralDirective = undefined;\n          }\n        }\n        break;\n    }\n  }\n}\n\n/**\n * Records an i18n param value for the start of an element.\n */\nfunction recordElementStart(\n  op: ir.ElementStartOp | ir.ProjectionOp,\n  i18nContext: ir.I18nContextOp,\n  i18nBlock: ir.I18nStartOp,\n  structuralDirective?: ir.TemplateOp | ir.ConditionalCreateOp | ir.ConditionalBranchCreateOp,\n) {\n  const {startName, closeName} = op.i18nPlaceholder!;\n  let flags = ir.I18nParamValueFlags.ElementTag | ir.I18nParamValueFlags.OpenTag;\n  let value: ir.I18nParamValue['value'] = op.handle.slot!;\n  // If the element is associated with a structural directive, start it as well.\n  if (structuralDirective !== undefined) {\n    flags |= ir.I18nParamValueFlags.TemplateTag;\n    value = {element: value, template: structuralDirective.handle.slot!};\n  }\n  // For self-closing tags, there is no close tag placeholder. Instead, the start tag\n  // placeholder accounts for the start and close of the element.\n  if (!closeName) {\n    flags |= ir.I18nParamValueFlags.CloseTag;\n  }\n  addParam(i18nContext.params, startName, value, i18nBlock.subTemplateIndex, flags);\n}\n\n/**\n * Records an i18n param value for the closing of an element.\n */\nfunction recordElementClose(\n  op: ir.ElementStartOp | ir.ProjectionOp,\n  i18nContext: ir.I18nContextOp,\n  i18nBlock: ir.I18nStartOp,\n  structuralDirective?: ir.TemplateOp | ir.ConditionalCreateOp | ir.ConditionalBranchCreateOp,\n) {\n  const {closeName} = op.i18nPlaceholder!;\n  // Self-closing tags don't have a closing tag placeholder, instead the element closing is\n  // recorded via an additional flag on the element start value.\n  if (closeName) {\n    let flags = ir.I18nParamValueFlags.ElementTag | ir.I18nParamValueFlags.CloseTag;\n    let value: ir.I18nParamValue['value'] = op.handle.slot!;\n    // If the element is associated with a structural directive, close it as well.\n    if (structuralDirective !== undefined) {\n      flags |= ir.I18nParamValueFlags.TemplateTag;\n      value = {element: value, template: structuralDirective.handle.slot!};\n    }\n    addParam(i18nContext.params, closeName, value, i18nBlock.subTemplateIndex, flags);\n  }\n}\n\n/**\n * Records an i18n param value for the start of a template.\n */\nfunction recordTemplateStart(\n  job: ComponentCompilationJob,\n  view: ViewCompilationUnit,\n  slot: number,\n  i18nPlaceholder: i18n.TagPlaceholder | i18n.BlockPlaceholder,\n  i18nContext: ir.I18nContextOp,\n  i18nBlock: ir.I18nStartOp,\n  structuralDirective?: ir.TemplateOp | ir.ConditionalCreateOp | ir.ConditionalBranchCreateOp,\n) {\n  let {startName, closeName} = i18nPlaceholder;\n  let flags = ir.I18nParamValueFlags.TemplateTag | ir.I18nParamValueFlags.OpenTag;\n  // For self-closing tags, there is no close tag placeholder. Instead, the start tag\n  // placeholder accounts for the start and close of the element.\n  if (!closeName) {\n    flags |= ir.I18nParamValueFlags.CloseTag;\n  }\n  // If the template is associated with a structural directive, record the structural directive's\n  // start first. Since this template must be in the structural directive's view, we can just\n  // directly use the current i18n block's sub-template index.\n  if (structuralDirective !== undefined) {\n    addParam(\n      i18nContext.params,\n      startName,\n      structuralDirective.handle.slot!,\n      i18nBlock.subTemplateIndex,\n      flags,\n    );\n  }\n  // Record the start of the template. For the sub-template index, pass the index for the template's\n  // view, rather than the current i18n block's index.\n  addParam(\n    i18nContext.params,\n    startName,\n    slot,\n    getSubTemplateIndexForTemplateTag(job, i18nBlock, view),\n    flags,\n  );\n}\n\n/**\n * Records an i18n param value for the closing of a template.\n */\nfunction recordTemplateClose(\n  job: ComponentCompilationJob,\n  view: ViewCompilationUnit,\n  slot: number,\n  i18nPlaceholder: i18n.TagPlaceholder | i18n.BlockPlaceholder,\n  i18nContext: ir.I18nContextOp,\n  i18nBlock: ir.I18nStartOp,\n  structuralDirective?: ir.TemplateOp | ir.ConditionalCreateOp | ir.ConditionalBranchCreateOp,\n) {\n  const {closeName} = i18nPlaceholder;\n  const flags = ir.I18nParamValueFlags.TemplateTag | ir.I18nParamValueFlags.CloseTag;\n  // Self-closing tags don't have a closing tag placeholder, instead the template's closing is\n  // recorded via an additional flag on the template start value.\n  if (closeName) {\n    // Record the closing of the template. For the sub-template index, pass the index for the\n    // template's view, rather than the current i18n block's index.\n    addParam(\n      i18nContext.params,\n      closeName,\n      slot,\n      getSubTemplateIndexForTemplateTag(job, i18nBlock, view),\n      flags,\n    );\n    // If the template is associated with a structural directive, record the structural directive's\n    // closing after. Since this template must be in the structural directive's view, we can just\n    // directly use the current i18n block's sub-template index.\n    if (structuralDirective !== undefined) {\n      addParam(\n        i18nContext.params,\n        closeName,\n        structuralDirective.handle.slot!,\n        i18nBlock.subTemplateIndex,\n        flags,\n      );\n    }\n  }\n}\n\n/**\n * Get the subTemplateIndex for the given template op. For template ops, use the subTemplateIndex of\n * the child i18n block inside the template.\n */\nfunction getSubTemplateIndexForTemplateTag(\n  job: ComponentCompilationJob,\n  i18nOp: ir.I18nStartOp,\n  view: ViewCompilationUnit,\n): number | null {\n  for (const childOp of view.create) {\n    if (childOp.kind === ir.OpKind.I18nStart) {\n      return childOp.subTemplateIndex;\n    }\n  }\n  return i18nOp.subTemplateIndex;\n}\n\n/**\n * Add a param value to the given params map.\n */\nfunction addParam(\n  params: Map<string, ir.I18nParamValue[]>,\n  placeholder: string,\n  value: string | number | {element: number; template: number},\n  subTemplateIndex: number | null,\n  flags: ir.I18nParamValueFlags,\n) {\n  const values = params.get(placeholder) ?? [];\n  values.push({value, subTemplateIndex, flags});\n  params.set(placeholder, values);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as ir from '../../ir';\nimport {ComponentCompilationJob} from '../compilation';\n\n/**\n * Resolve the i18n expression placeholders in i18n messages.\n */\nexport function resolveI18nExpressionPlaceholders(job: ComponentCompilationJob) {\n  // Record all of the i18n context ops, and the sub-template index for each i18n op.\n  const subTemplateIndices = new Map<ir.XrefId, number | null>();\n  const i18nContexts = new Map<ir.XrefId, ir.I18nContextOp>();\n  const icuPlaceholders = new Map<ir.XrefId, ir.IcuPlaceholderOp>();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case ir.OpKind.I18nStart:\n          subTemplateIndices.set(op.xref, op.subTemplateIndex);\n          break;\n        case ir.OpKind.I18nContext:\n          i18nContexts.set(op.xref, op);\n          break;\n        case ir.OpKind.IcuPlaceholder:\n          icuPlaceholders.set(op.xref, op);\n          break;\n      }\n    }\n  }\n\n  // Keep track of the next available expression index for each i18n message.\n  const expressionIndices = new Map<ir.XrefId, number>();\n\n  // Keep track of a reference index for each expression.\n  // We use different references for normal i18n expressio and attribute i18n expressions. This is\n  // because child i18n blocks in templates don't get their own context, since they're rolled into\n  // the translated message of the parent, but they may target a different slot.\n  const referenceIndex = (op: ir.I18nExpressionOp): ir.XrefId =>\n    op.usage === ir.I18nExpressionFor.I18nText ? op.i18nOwner : op.context;\n\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      if (op.kind === ir.OpKind.I18nExpression) {\n        const index = expressionIndices.get(referenceIndex(op)) || 0;\n        const subTemplateIndex = subTemplateIndices.get(op.i18nOwner) ?? null;\n        const value: ir.I18nParamValue = {\n          value: index,\n          subTemplateIndex: subTemplateIndex,\n          flags: ir.I18nParamValueFlags.ExpressionIndex,\n        };\n        updatePlaceholder(op, value, i18nContexts, icuPlaceholders);\n        expressionIndices.set(referenceIndex(op), index + 1);\n      }\n    }\n  }\n}\n\nfunction updatePlaceholder(\n  op: ir.I18nExpressionOp,\n  value: ir.I18nParamValue,\n  i18nContexts: Map<ir.XrefId, ir.I18nContextOp>,\n  icuPlaceholders: Map<ir.XrefId, ir.IcuPlaceholderOp>,\n) {\n  if (op.i18nPlaceholder !== null) {\n    const i18nContext = i18nContexts.get(op.context)!;\n    const params =\n      op.resolutionTime === ir.I18nParamResolutionTime.Creation\n        ? i18nContext.params\n        : i18nContext.postprocessingParams;\n    const values = params.get(op.i18nPlaceholder) || [];\n    values.push(value);\n    params.set(op.i18nPlaceholder, values);\n  }\n  if (op.icuPlaceholder !== null) {\n    const icuPlaceholderOp = icuPlaceholders.get(op.icuPlaceholder);\n    icuPlaceholderOp?.expressionPlaceholders.push(value);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\nimport {CompilationJob, CompilationUnit} from '../compilation';\n\n/**\n * Resolves lexical references in views (`ir.LexicalReadExpr`) to either a target variable or to\n * property reads on the top-level component context.\n *\n * Also matches `ir.RestoreViewExpr` expressions with the variables of their corresponding saved\n * views.\n */\nexport function resolveNames(job: CompilationJob): void {\n  for (const unit of job.units) {\n    processLexicalScope(unit, unit.create, null);\n    processLexicalScope(unit, unit.update, null);\n  }\n}\n\nfunction processLexicalScope(\n  unit: CompilationUnit,\n  ops: ir.OpList<ir.CreateOp> | ir.OpList<ir.UpdateOp>,\n  savedView: SavedView | null,\n): void {\n  // Maps names defined in the lexical scope of this template to the `ir.XrefId`s of the variable\n  // declarations which represent those values.\n  //\n  // Since variables are generated in each view for the entire lexical scope (including any\n  // identifiers from parent templates) only local variables need be considered here.\n  const scope = new Map<string, ir.XrefId>();\n\n  // Symbols defined within the current scope. They take precedence over ones defined outside.\n  const localDefinitions = new Map<string, ir.XrefId>();\n\n  // First, step through the operations list and:\n  // 1) build up the `scope` mapping\n  // 2) recurse into any listener functions\n  for (const op of ops) {\n    switch (op.kind) {\n      case ir.OpKind.Variable:\n        switch (op.variable.kind) {\n          case ir.SemanticVariableKind.Identifier:\n            if (op.variable.local) {\n              if (localDefinitions.has(op.variable.identifier)) {\n                continue;\n              }\n              localDefinitions.set(op.variable.identifier, op.xref);\n            } else if (scope.has(op.variable.identifier)) {\n              continue;\n            }\n            scope.set(op.variable.identifier, op.xref);\n            break;\n          case ir.SemanticVariableKind.Alias:\n            // This variable represents some kind of identifier which can be used in the template.\n            if (scope.has(op.variable.identifier)) {\n              continue;\n            }\n            scope.set(op.variable.identifier, op.xref);\n            break;\n          case ir.SemanticVariableKind.SavedView:\n            // This variable represents a snapshot of the current view context, and can be used to\n            // restore that context within listener functions.\n            savedView = {\n              view: op.variable.view,\n              variable: op.xref,\n            };\n            break;\n        }\n        break;\n      case ir.OpKind.Animation:\n      case ir.OpKind.AnimationListener:\n      case ir.OpKind.Listener:\n      case ir.OpKind.TwoWayListener:\n        // Listener functions have separate variable declarations, so process them as a separate\n        // lexical scope.\n        processLexicalScope(unit, op.handlerOps, savedView);\n        break;\n      case ir.OpKind.RepeaterCreate:\n        if (op.trackByOps !== null) {\n          processLexicalScope(unit, op.trackByOps, savedView);\n        }\n        break;\n    }\n  }\n\n  // Next, use the `scope` mapping to match `ir.LexicalReadExpr` with defined names in the lexical\n  // scope. Also, look for `ir.RestoreViewExpr`s and match them with the snapshotted view context\n  // variable.\n  for (const op of ops) {\n    if (\n      op.kind == ir.OpKind.Listener ||\n      op.kind === ir.OpKind.TwoWayListener ||\n      op.kind === ir.OpKind.Animation ||\n      op.kind === ir.OpKind.AnimationListener\n    ) {\n      // Listeners were already processed above with their own scopes.\n      continue;\n    }\n    ir.transformExpressionsInOp(\n      op,\n      (expr) => {\n        if (expr instanceof ir.LexicalReadExpr) {\n          // `expr` is a read of a name within the lexical scope of this view.\n          // Either that name is defined within the current view, or it represents a property from the\n          // main component context.\n          if (localDefinitions.has(expr.name)) {\n            return new ir.ReadVariableExpr(localDefinitions.get(expr.name)!);\n          } else if (scope.has(expr.name)) {\n            // This was a defined variable in the current scope.\n            return new ir.ReadVariableExpr(scope.get(expr.name)!);\n          } else {\n            // Reading from the component context.\n            return new o.ReadPropExpr(new ir.ContextExpr(unit.job.root.xref), expr.name);\n          }\n        } else if (expr instanceof ir.RestoreViewExpr && typeof expr.view === 'number') {\n          // `ir.RestoreViewExpr` happens in listener functions and restores a saved view from the\n          // parent creation list. We expect to find that we captured the `savedView` previously, and\n          // that it matches the expected view to be restored.\n          if (savedView === null || savedView.view !== expr.view) {\n            throw new Error(`AssertionError: no saved view ${expr.view} from view ${unit.xref}`);\n          }\n          expr.view = new ir.ReadVariableExpr(savedView.variable);\n          return expr;\n        } else {\n          return expr;\n        }\n      },\n      ir.VisitorContextFlag.None,\n    );\n  }\n\n  for (const op of ops) {\n    ir.visitExpressionsInOp(op, (expr) => {\n      if (expr instanceof ir.LexicalReadExpr) {\n        throw new Error(\n          `AssertionError: no lexical reads should remain, but found read of ${expr.name}`,\n        );\n      }\n    });\n  }\n}\n\n/**\n * Information about a `SavedView` variable.\n */\ninterface SavedView {\n  /**\n   * The view `ir.XrefId` which was saved into this variable.\n   */\n  view: ir.XrefId;\n\n  /**\n   * The `ir.XrefId` of the variable into which the view was saved.\n   */\n  variable: ir.XrefId;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {SecurityContext} from '../../../../core';\nimport * as o from '../../../../output/output_ast';\nimport {Identifiers} from '../../../../render3/r3_identifiers';\nimport {isIframeSecuritySensitiveAttr} from '../../../../schema/dom_security_schema';\nimport * as ir from '../../ir';\nimport {CompilationJob, CompilationJobKind} from '../compilation';\nimport {createOpXrefMap} from '../util/elements';\n\n/**\n * Map of security contexts to their sanitizer function.\n */\nconst sanitizerFns = new Map<SecurityContext, o.ExternalReference>([\n  [SecurityContext.HTML, Identifiers.sanitizeHtml],\n  [SecurityContext.RESOURCE_URL, Identifiers.sanitizeResourceUrl],\n  [SecurityContext.SCRIPT, Identifiers.sanitizeScript],\n  [SecurityContext.STYLE, Identifiers.sanitizeStyle],\n  [SecurityContext.URL, Identifiers.sanitizeUrl],\n]);\n\n/**\n * Map of security contexts to their trusted value function.\n */\nconst trustedValueFns = new Map<SecurityContext, o.ExternalReference>([\n  [SecurityContext.HTML, Identifiers.trustConstantHtml],\n  [SecurityContext.RESOURCE_URL, Identifiers.trustConstantResourceUrl],\n]);\n\n/**\n * Resolves sanitization functions for ops that need them.\n */\nexport function resolveSanitizers(job: CompilationJob): void {\n  for (const unit of job.units) {\n    const elements = createOpXrefMap(unit);\n\n    // For normal element bindings we create trusted values for security sensitive constant\n    // attributes. However, for host bindings we skip this step (this matches what\n    // TemplateDefinitionBuilder does).\n    // TODO: Is the TDB behavior correct here?\n    if (job.kind !== CompilationJobKind.Host) {\n      for (const op of unit.create) {\n        if (op.kind === ir.OpKind.ExtractedAttribute) {\n          const trustedValueFn =\n            trustedValueFns.get(getOnlySecurityContext(op.securityContext)) ?? null;\n          op.trustedValueFn = trustedValueFn !== null ? o.importExpr(trustedValueFn) : null;\n        }\n      }\n    }\n\n    for (const op of unit.update) {\n      switch (op.kind) {\n        case ir.OpKind.Property:\n        case ir.OpKind.Attribute:\n        case ir.OpKind.DomProperty:\n          let sanitizerFn: o.ExternalReference | null = null;\n          if (\n            Array.isArray(op.securityContext) &&\n            op.securityContext.length === 2 &&\n            op.securityContext.indexOf(SecurityContext.URL) > -1 &&\n            op.securityContext.indexOf(SecurityContext.RESOURCE_URL) > -1\n          ) {\n            // When the host element isn't known, some URL attributes (such as \"src\" and \"href\") may\n            // be part of multiple different security contexts. In this case we use special\n            // sanitization function and select the actual sanitizer at runtime based on a tag name\n            // that is provided while invoking sanitization function.\n            sanitizerFn = Identifiers.sanitizeUrlOrResourceUrl;\n          } else {\n            sanitizerFn = sanitizerFns.get(getOnlySecurityContext(op.securityContext)) ?? null;\n          }\n          op.sanitizer = sanitizerFn !== null ? o.importExpr(sanitizerFn) : null;\n\n          // If there was no sanitization function found based on the security context of an\n          // attribute/property, check whether this attribute/property is one of the\n          // security-sensitive <iframe> attributes (and that the current element is actually an\n          // <iframe>).\n          if (op.sanitizer === null) {\n            let isIframe = false;\n            if (job.kind === CompilationJobKind.Host || op.kind === ir.OpKind.DomProperty) {\n              // Note: for host bindings defined on a directive, we do not try to find all\n              // possible places where it can be matched, so we can not determine whether\n              // the host element is an <iframe>. In this case, we just assume it is and append a\n              // validation function, which is invoked at runtime and would have access to the\n              // underlying DOM element to check if it's an <iframe> and if so - run extra checks.\n              isIframe = true;\n            } else {\n              // For a normal binding we can just check if the element its on is an iframe.\n              const ownerOp = elements.get(op.target);\n              if (ownerOp === undefined || !ir.isElementOrContainerOp(ownerOp)) {\n                throw Error('Property should have an element-like owner');\n              }\n              isIframe = isIframeElement(ownerOp);\n            }\n            if (isIframe && isIframeSecuritySensitiveAttr(op.name)) {\n              op.sanitizer = o.importExpr(Identifiers.validateIframeAttribute);\n            }\n          }\n          break;\n      }\n    }\n  }\n}\n\n/**\n * Checks whether the given op represents an iframe element.\n */\nfunction isIframeElement(op: ir.ElementOrContainerOps): boolean {\n  return op.kind === ir.OpKind.ElementStart && op.tag?.toLowerCase() === 'iframe';\n}\n\n/**\n * Asserts that there is only a single security context and returns it.\n */\nfunction getOnlySecurityContext(\n  securityContext: SecurityContext | SecurityContext[],\n): SecurityContext {\n  if (Array.isArray(securityContext)) {\n    if (securityContext.length > 1) {\n      // TODO: What should we do here? TDB just took the first one, but this feels like something we\n      // would want to know about and create a special case for like we did for Url/ResourceUrl. My\n      // guess is that, outside of the Url/ResourceUrl case, this never actually happens. If there\n      // do turn out to be other cases, throwing an error until we can address it feels safer.\n      throw Error(`AssertionError: Ambiguous security context`);\n    }\n    return securityContext[0] || SecurityContext.NONE;\n  }\n  return securityContext;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\nimport type {ComponentCompilationJob, ViewCompilationUnit} from '../compilation';\n\n/**\n * When inside of a listener, we may need access to one or more enclosing views. Therefore, each\n * view should save the current view, and each listener must have the ability to restore the\n * appropriate view. We eagerly generate all save view variables; they will be optimized away later.\n */\nexport function saveAndRestoreView(job: ComponentCompilationJob): void {\n  for (const unit of job.units) {\n    unit.create.prepend([\n      ir.createVariableOp<ir.CreateOp>(\n        unit.job.allocateXrefId(),\n        {\n          kind: ir.SemanticVariableKind.SavedView,\n          name: null,\n          view: unit.xref,\n        },\n        new ir.GetCurrentViewExpr(),\n        ir.VariableFlags.None,\n      ),\n    ]);\n\n    for (const op of unit.create) {\n      if (\n        op.kind !== ir.OpKind.Listener &&\n        op.kind !== ir.OpKind.TwoWayListener &&\n        op.kind !== ir.OpKind.Animation &&\n        op.kind !== ir.OpKind.AnimationListener\n      ) {\n        continue;\n      }\n\n      // Embedded views always need the save/restore view operation.\n      let needsRestoreView = unit !== job.root;\n\n      if (!needsRestoreView) {\n        for (const handlerOp of op.handlerOps) {\n          ir.visitExpressionsInOp(handlerOp, (expr) => {\n            if (expr instanceof ir.ReferenceExpr || expr instanceof ir.ContextLetReferenceExpr) {\n              // Listeners that reference() a local ref need the save/restore view operation.\n              needsRestoreView = true;\n            }\n          });\n        }\n      }\n\n      if (needsRestoreView) {\n        addSaveRestoreViewOperationToListener(unit, op);\n      }\n    }\n  }\n}\n\nfunction addSaveRestoreViewOperationToListener(\n  unit: ViewCompilationUnit,\n  op: ir.ListenerOp | ir.TwoWayListenerOp | ir.AnimationOp | ir.AnimationListenerOp,\n) {\n  op.handlerOps.prepend([\n    ir.createVariableOp<ir.UpdateOp>(\n      unit.job.allocateXrefId(),\n      {\n        kind: ir.SemanticVariableKind.Context,\n        name: null,\n        view: unit.xref,\n      },\n      new ir.RestoreViewExpr(unit.xref),\n      ir.VariableFlags.None,\n    ),\n  ]);\n\n  // The \"restore view\" operation in listeners requires a call to `resetView` to reset the\n  // context prior to returning from the listener operation. Find any `return` statements in\n  // the listener body and wrap them in a call to reset the view.\n  for (const handlerOp of op.handlerOps) {\n    if (\n      handlerOp.kind === ir.OpKind.Statement &&\n      handlerOp.statement instanceof o.ReturnStatement\n    ) {\n      handlerOp.statement.value = new ir.ResetViewExpr(handlerOp.statement.value);\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as ir from '../../ir';\nimport type {ComponentCompilationJob} from '../compilation';\n\n/**\n * Assign data slots for all operations which implement `ConsumesSlotOpTrait`, and propagate the\n * assigned data slots of those operations to any expressions which reference them via\n * `UsesSlotIndexTrait`.\n *\n * This phase is also responsible for counting the number of slots used for each view (its `decls`)\n * and propagating that number into the `Template` operations which declare embedded views.\n */\nexport function allocateSlots(job: ComponentCompilationJob): void {\n  // Map of all declarations in all views within the component which require an assigned slot index.\n  // This map needs to be global (across all views within the component) since it's possible to\n  // reference a slot from one view from an expression within another (e.g. local references work\n  // this way).\n  const slotMap = new Map<ir.XrefId, number>();\n\n  // Process all views in the component and assign slot indexes.\n  for (const unit of job.units) {\n    // Slot indices start at 0 for each view (and are not unique between views).\n    let slotCount = 0;\n\n    for (const op of unit.create) {\n      // Only consider declarations which consume data slots.\n      if (!ir.hasConsumesSlotTrait(op)) {\n        continue;\n      }\n\n      // Assign slots to this declaration starting at the current `slotCount`.\n      op.handle.slot = slotCount;\n\n      // And track its assigned slot in the `slotMap`.\n      slotMap.set(op.xref, op.handle.slot);\n\n      // Each declaration may use more than 1 slot, so increment `slotCount` to reserve the number\n      // of slots required.\n      slotCount += op.numSlotsUsed;\n    }\n\n    // Record the total number of slots used on the view itself. This will later be propagated into\n    // `ir.TemplateOp`s which declare those views (except for the root view).\n    unit.decls = slotCount;\n  }\n\n  // After slot assignment, `slotMap` now contains slot assignments for every declaration in the\n  // whole template, across all views. Next, look for expressions which implement\n  // `UsesSlotIndexExprTrait` and propagate the assigned slot indexes into them.\n  // Additionally, this second scan allows us to find `ir.TemplateOp`s which declare views and\n  // propagate the number of slots used for each view into the operation which declares it.\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      if (\n        op.kind === ir.OpKind.Template ||\n        op.kind === ir.OpKind.ConditionalCreate ||\n        op.kind === ir.OpKind.ConditionalBranchCreate ||\n        op.kind === ir.OpKind.RepeaterCreate\n      ) {\n        // Record the number of slots used by the view this `ir.TemplateOp` declares in the\n        // operation itself, so it can be emitted later.\n        const childView = job.views.get(op.xref)!;\n        op.decls = childView.decls;\n\n        // TODO: currently we handle the decls for the RepeaterCreate empty template in the reify\n        // phase. We should handle that here instead.\n      }\n    }\n  }\n}\n","/*!\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as ir from '../../ir';\nimport {CompilationJob} from '../compilation';\n\n/**\n * Removes any `storeLet` calls that aren't referenced outside of the current view.\n */\nexport function optimizeStoreLet(job: CompilationJob): void {\n  const letUsedExternally = new Set<ir.XrefId>();\n  const declareLetOps = new Map<ir.XrefId, ir.DeclareLetOp>();\n\n  // Since `@let` declarations can be referenced in child views, both in\n  // the creation block (via listeners) and in the update block, we have\n  // to look through all the ops to find the references.\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      // Take advantage that we're already looking through all the ops and track some more info.\n      if (op.kind === ir.OpKind.DeclareLet) {\n        declareLetOps.set(op.xref, op);\n      }\n\n      ir.visitExpressionsInOp(op, (expr) => {\n        if (expr instanceof ir.ContextLetReferenceExpr) {\n          letUsedExternally.add(expr.target);\n        }\n      });\n    }\n  }\n\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      ir.transformExpressionsInOp(\n        op,\n        (expr) => {\n          // If a @let isn't used in other views, we don't have to store its value.\n          if (expr instanceof ir.StoreLetExpr && !letUsedExternally.has(expr.target)) {\n            // Furthermore, if the @let isn't using pipes, we can also drop its declareLet op.\n            // We need to keep the declareLet if there are pipes, because they can use DI which\n            // requires the TNode created by declareLet.\n            if (!hasPipe(expr)) {\n              ir.OpList.remove<ir.CreateOp>(declareLetOps.get(expr.target)!);\n            }\n            return expr.value;\n          }\n          return expr;\n        },\n        ir.VisitorContextFlag.None,\n      );\n    }\n  }\n}\n\n/** Determines if a `storeLet` expression contains a pipe. */\nfunction hasPipe(root: ir.StoreLetExpr): boolean {\n  let result = false;\n\n  ir.transformExpressionsInExpression(\n    root,\n    (expr) => {\n      if (expr instanceof ir.PipeBindingExpr || expr instanceof ir.PipeBindingVariadicExpr) {\n        result = true;\n      }\n      return expr;\n    },\n    ir.VisitorContextFlag.None,\n  );\n\n  return result;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\nimport type {CompilationJob} from '../compilation';\n\n/**\n * In most cases we can drop user added parentheses from expressions. However, in some cases\n * parentheses are needed for the expression to be considered valid JavaScript or for Typescript to\n * generate the correct output. This phases strips all parentheses except in the following\n * siturations where they are required:\n *\n * 1. Unary operators in the base of an exponentiation expression. For example, `-2 ** 3` is not\n *    valid JavaScript, but `(-2) ** 3` is.\n *\n * 2. When mixing nullish coalescing (`??`) and logical and/or operators (`&&`, `||`), we need\n *    parentheses. For example, `a ?? b && c` is not valid JavaScript, but `a ?? (b && c)` is.\n *    Note: Because of the outcome of https://github.com/microsoft/TypeScript/issues/62307\n *    We need (for now) to keep parentheses around the `??` operator when it is used with and/or operators.\n *    For example, `a ?? b && c` is not valid JavaScript, but `(a ?? b) && c` is.\n *\n * 3. Ternary expression used as an operand for nullish coalescing. Typescript generates incorrect\n *    code if the parentheses are missing. For example when `(a ? b : c) ?? d` is translated to\n *    typescript AST, the parentheses node is removed, and then the remaining AST is printed, it\n *    incorrectly prints `a ? b : c ?? d`. This is different from how it handles the same situation\n *    with `||` and `&&` where it prints the parentheses even if they are not present in the AST.\n *    Note: We may be able to remove this case if Typescript resolves the following issue:\n *    https://github.com/microsoft/TypeScript/issues/61369\n */\nexport function stripNonrequiredParentheses(job: CompilationJob): void {\n  // Check which parentheses are required.\n  const requiredParens = new Set<o.ParenthesizedExpr>();\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      ir.visitExpressionsInOp(op, (expr) => {\n        if (expr instanceof o.BinaryOperatorExpr) {\n          switch (expr.operator) {\n            case o.BinaryOperator.Exponentiation:\n              checkExponentiationParens(expr, requiredParens);\n              break;\n            case o.BinaryOperator.NullishCoalesce:\n              checkNullishCoalescingParens(expr, requiredParens);\n              break;\n            // these 2 cases can be dropped if the regression introduced in 5.9.2 is fixed\n            // see https://github.com/microsoft/TypeScript/issues/62307\n            case o.BinaryOperator.And:\n            case o.BinaryOperator.Or:\n              checkAndOrParens(expr, requiredParens);\n          }\n        }\n      });\n    }\n  }\n\n  // Remove any non-required parentheses.\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      ir.transformExpressionsInOp(\n        op,\n        (expr) => {\n          if (expr instanceof o.ParenthesizedExpr) {\n            return requiredParens.has(expr) ? expr : expr.expr;\n          }\n          return expr;\n        },\n        ir.VisitorContextFlag.None,\n      );\n    }\n  }\n}\n\nfunction checkExponentiationParens(\n  expr: o.BinaryOperatorExpr,\n  requiredParens: Set<o.ParenthesizedExpr>,\n) {\n  if (expr.lhs instanceof o.ParenthesizedExpr && expr.lhs.expr instanceof o.UnaryOperatorExpr) {\n    requiredParens.add(expr.lhs);\n  }\n}\n\nfunction checkNullishCoalescingParens(\n  expr: o.BinaryOperatorExpr,\n  requiredParens: Set<o.ParenthesizedExpr>,\n) {\n  if (\n    expr.lhs instanceof o.ParenthesizedExpr &&\n    (isLogicalAndOr(expr.lhs.expr) || expr.lhs.expr instanceof o.ConditionalExpr)\n  ) {\n    requiredParens.add(expr.lhs);\n  }\n  if (\n    expr.rhs instanceof o.ParenthesizedExpr &&\n    (isLogicalAndOr(expr.rhs.expr) || expr.rhs.expr instanceof o.ConditionalExpr)\n  ) {\n    requiredParens.add(expr.rhs);\n  }\n}\n\nfunction checkAndOrParens(expr: o.BinaryOperatorExpr, requiredParens: Set<o.ParenthesizedExpr>) {\n  if (\n    expr.lhs instanceof o.ParenthesizedExpr &&\n    expr.lhs.expr instanceof o.BinaryOperatorExpr &&\n    expr.lhs.expr.operator === o.BinaryOperator.NullishCoalesce\n  ) {\n    requiredParens.add(expr.lhs);\n  }\n}\n\nfunction isLogicalAndOr(expr: o.Expression) {\n  return (\n    expr instanceof o.BinaryOperatorExpr &&\n    (expr.operator === o.BinaryOperator.And || expr.operator === o.BinaryOperator.Or)\n  );\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as ir from '../../ir';\nimport type {CompilationJob} from '../compilation';\n\n/**\n * Transforms special-case bindings with 'style' or 'class' in their names. Must run before the\n * main binding specialization pass.\n */\nexport function specializeStyleBindings(job: CompilationJob): void {\n  for (const unit of job.units) {\n    for (const op of unit.update) {\n      if (op.kind !== ir.OpKind.Binding) {\n        continue;\n      }\n\n      switch (op.bindingKind) {\n        case ir.BindingKind.ClassName:\n          if (op.expression instanceof ir.Interpolation) {\n            throw new Error(`Unexpected interpolation in ClassName binding`);\n          }\n          ir.OpList.replace<ir.UpdateOp>(\n            op,\n            ir.createClassPropOp(op.target, op.name, op.expression, op.sourceSpan),\n          );\n          break;\n        case ir.BindingKind.StyleProperty:\n          ir.OpList.replace<ir.UpdateOp>(\n            op,\n            ir.createStylePropOp(op.target, op.name, op.expression, op.unit, op.sourceSpan),\n          );\n          break;\n        case ir.BindingKind.Property:\n        case ir.BindingKind.Template:\n          if (op.name === 'style') {\n            ir.OpList.replace<ir.UpdateOp>(\n              op,\n              ir.createStyleMapOp(op.target, op.expression, op.sourceSpan),\n            );\n          } else if (op.name === 'class') {\n            ir.OpList.replace<ir.UpdateOp>(\n              op,\n              ir.createClassMapOp(op.target, op.expression, op.sourceSpan),\n            );\n          }\n          break;\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\nimport type {CompilationJob} from '../compilation';\n\n/**\n * Find all assignments and usages of temporary variables, which are linked to each other with cross\n * references. Generate names for each cross-reference, and add a `DeclareVarStmt` to initialize\n * them at the beginning of the update block.\n *\n * TODO: Sometimes, it will be possible to reuse names across different subexpressions. For example,\n * in the double keyed read `a?.[f()]?.[f()]`, the two function calls have non-overlapping scopes.\n * Implement an algorithm for reuse.\n */\nexport function generateTemporaryVariables(job: CompilationJob): void {\n  for (const unit of job.units) {\n    unit.create.prepend(generateTemporaries(unit.create) as Array<ir.StatementOp<ir.CreateOp>>);\n    unit.update.prepend(generateTemporaries(unit.update) as Array<ir.StatementOp<ir.UpdateOp>>);\n  }\n}\n\nfunction generateTemporaries(\n  ops: ir.OpList<ir.CreateOp | ir.UpdateOp>,\n): Array<ir.StatementOp<ir.CreateOp | ir.UpdateOp>> {\n  let opCount = 0;\n  let generatedStatements: Array<ir.StatementOp<ir.UpdateOp>> = [];\n\n  // For each op, search for any variables that are assigned or read. For each variable, generate a\n  // name and produce a `DeclareVarStmt` to the beginning of the block.\n  for (const op of ops) {\n    // Identify the final time each temp var is read.\n    const finalReads = new Map<ir.XrefId, ir.ReadTemporaryExpr>();\n    ir.visitExpressionsInOp(op, (expr, flag) => {\n      if (flag & ir.VisitorContextFlag.InChildOperation) {\n        return;\n      }\n      if (expr instanceof ir.ReadTemporaryExpr) {\n        finalReads.set(expr.xref, expr);\n      }\n    });\n\n    // Name the temp vars, accounting for the fact that a name can be reused after it has been\n    // read for the final time.\n    let count = 0;\n    const assigned = new Set<ir.XrefId>();\n    const released = new Set<ir.XrefId>();\n    const defs = new Map<ir.XrefId, string>();\n    ir.visitExpressionsInOp(op, (expr, flag) => {\n      if (flag & ir.VisitorContextFlag.InChildOperation) {\n        return;\n      }\n      if (expr instanceof ir.AssignTemporaryExpr) {\n        if (!assigned.has(expr.xref)) {\n          assigned.add(expr.xref);\n          // TODO: Exactly replicate the naming scheme used by `TemplateDefinitionBuilder`.\n          // It seems to rely on an expression index instead of an op index.\n          defs.set(expr.xref, `tmp_${opCount}_${count++}`);\n        }\n        assignName(defs, expr);\n      } else if (expr instanceof ir.ReadTemporaryExpr) {\n        if (finalReads.get(expr.xref) === expr) {\n          released.add(expr.xref);\n          count--;\n        }\n        assignName(defs, expr);\n      }\n    });\n\n    // Add declarations for the temp vars.\n    generatedStatements.push(\n      ...Array.from(new Set(defs.values())).map((name) =>\n        ir.createStatementOp<ir.UpdateOp>(new o.DeclareVarStmt(name)),\n      ),\n    );\n    opCount++;\n\n    if (\n      op.kind === ir.OpKind.Listener ||\n      op.kind === ir.OpKind.Animation ||\n      op.kind === ir.OpKind.AnimationListener ||\n      op.kind === ir.OpKind.TwoWayListener\n    ) {\n      op.handlerOps.prepend(generateTemporaries(op.handlerOps) as ir.UpdateOp[]);\n    } else if (op.kind === ir.OpKind.RepeaterCreate && op.trackByOps !== null) {\n      op.trackByOps.prepend(generateTemporaries(op.trackByOps) as ir.UpdateOp[]);\n    }\n  }\n\n  return generatedStatements;\n}\n\n/**\n * Assigns a name to the temporary variable in the given temporary variable expression.\n */\nfunction assignName(\n  names: Map<ir.XrefId, string>,\n  expr: ir.AssignTemporaryExpr | ir.ReadTemporaryExpr,\n) {\n  const name = names.get(expr.xref);\n  if (name === undefined) {\n    throw new Error(`Found xref with unassigned name: ${expr.xref}`);\n  }\n  expr.name = name;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport {Identifiers} from '../../../../render3/r3_identifiers';\nimport * as ir from '../../ir';\n\nimport type {CompilationJob} from '../compilation';\n\n/**\n * `track` functions in `for` repeaters can sometimes be \"optimized,\" i.e. transformed into inline\n * expressions, in lieu of an external function call. For example, tracking by `$index` can be be\n * optimized into an inline `trackByIndex` reference. This phase checks track expressions for\n * optimizable cases.\n */\nexport function optimizeTrackFns(job: CompilationJob): void {\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind !== ir.OpKind.RepeaterCreate) {\n        continue;\n      }\n      if (op.track instanceof o.ReadVarExpr && op.track.name === '$index') {\n        // Top-level access of `$index` uses the built in `repeaterTrackByIndex`.\n        op.trackByFn = o.importExpr(Identifiers.repeaterTrackByIndex);\n      } else if (op.track instanceof o.ReadVarExpr && op.track.name === '$item') {\n        // Top-level access of the item uses the built in `repeaterTrackByIdentity`.\n        op.trackByFn = o.importExpr(Identifiers.repeaterTrackByIdentity);\n      } else if (isTrackByFunctionCall(job.root.xref, op.track)) {\n        // Mark the function as using the component instance to play it safe\n        // since the method might be using `this` internally (see #53628).\n        op.usesComponentInstance = true;\n\n        // Top-level method calls in the form of `fn($index, item)` can be passed in directly.\n        if (op.track.receiver.receiver.view === unit.xref) {\n          // TODO: this may be wrong\n          op.trackByFn = op.track.receiver;\n        } else {\n          // This is a plain method call, but not in the component's root view.\n          // We need to get the component instance, and then call the method on it.\n          op.trackByFn = o\n            .importExpr(Identifiers.componentInstance)\n            .callFn([])\n            .prop(op.track.receiver.name);\n          // Because the context is not avaiable (without a special function), we don't want to\n          // try to resolve it later. Let's get rid of it by overwriting the original track\n          // expression (which won't be used anyway).\n          op.track = op.trackByFn;\n        }\n      } else {\n        // The track function could not be optimized.\n        // Replace context reads with a special IR expression, since context reads in a track\n        // function are emitted specially.\n        op.track = ir.transformExpressionsInExpression(\n          op.track,\n          (expr) => {\n            if (expr instanceof ir.PipeBindingExpr || expr instanceof ir.PipeBindingVariadicExpr) {\n              throw new Error(`Illegal State: Pipes are not allowed in this context`);\n            } else if (expr instanceof ir.ContextExpr) {\n              op.usesComponentInstance = true;\n              return new ir.TrackContextExpr(expr.view);\n            }\n            return expr;\n          },\n          ir.VisitorContextFlag.None,\n        );\n\n        // Also create an OpList for the tracking expression since it may need\n        // additional ops when generating the final code (e.g. temporary variables).\n        const trackOpList = new ir.OpList<ir.UpdateOp>();\n        trackOpList.push(\n          ir.createStatementOp(new o.ReturnStatement(op.track, op.track.sourceSpan)),\n        );\n        op.trackByOps = trackOpList;\n      }\n    }\n  }\n}\n\nfunction isTrackByFunctionCall(\n  rootView: ir.XrefId,\n  expr: o.Expression,\n): expr is o.InvokeFunctionExpr & {\n  receiver: o.ReadPropExpr & {\n    receiver: ir.ContextExpr;\n  };\n} {\n  if (!(expr instanceof o.InvokeFunctionExpr) || expr.args.length === 0 || expr.args.length > 2) {\n    return false;\n  }\n\n  if (\n    !(\n      expr.receiver instanceof o.ReadPropExpr && expr.receiver.receiver instanceof ir.ContextExpr\n    ) ||\n    expr.receiver.receiver.view !== rootView\n  ) {\n    return false;\n  }\n\n  const [arg0, arg1] = expr.args;\n  if (!(arg0 instanceof o.ReadVarExpr) || arg0.name !== '$index') {\n    return false;\n  } else if (expr.args.length === 1) {\n    return true;\n  }\n  if (!(arg1 instanceof o.ReadVarExpr) || arg1.name !== '$item') {\n    return false;\n  }\n  return true;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\n\nimport type {CompilationJob} from '../compilation';\n\n/**\n * Inside the `track` expression on a `for` repeater, the `$index` and `$item` variables are\n * ambiently available. In this phase, we find those variable usages, and replace them with the\n * appropriate output read.\n */\nexport function generateTrackVariables(job: CompilationJob): void {\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind !== ir.OpKind.RepeaterCreate) {\n        continue;\n      }\n\n      op.track = ir.transformExpressionsInExpression(\n        op.track,\n        (expr) => {\n          if (expr instanceof ir.LexicalReadExpr) {\n            if (op.varNames.$index.has(expr.name)) {\n              return o.variable('$index');\n            } else if (expr.name === op.varNames.$implicit) {\n              return o.variable('$item');\n            }\n\n            // TODO: handle prohibited context variables (emit as globals?)\n          }\n          return expr;\n        },\n        ir.VisitorContextFlag.None,\n      );\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\nimport * as ng from '../instruction';\nimport type {CompilationJob} from '../compilation';\n\n/**\n * Transforms a `TwoWayBindingSet` expression into an expression that either\n * sets a value through the `twoWayBindingSet` instruction or falls back to setting\n * the value directly. E.g. the expression `TwoWayBindingSet(target, value)` becomes:\n * `ng.twoWayBindingSet(target, value) || (target = value)`.\n */\nexport function transformTwoWayBindingSet(job: CompilationJob): void {\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (op.kind === ir.OpKind.TwoWayListener) {\n        ir.transformExpressionsInOp(\n          op,\n          (expr) => {\n            if (!(expr instanceof ir.TwoWayBindingSetExpr)) {\n              return expr;\n            }\n\n            const {target, value} = expr;\n\n            if (target instanceof o.ReadPropExpr || target instanceof o.ReadKeyExpr) {\n              return ng.twoWayBindingSet(target, value).or(target.set(value));\n            }\n\n            // ASSUMPTION: here we're assuming that `ReadVariableExpr` will be a reference\n            // to a local template variable. This appears to be the case at the time of writing.\n            // If the expression is targeting a variable read, we only emit the `twoWayBindingSet`\n            // since the fallback would be attempting to write into a constant. Invalid usages will be\n            // flagged during template type checking.\n            if (target instanceof ir.ReadVariableExpr) {\n              return ng.twoWayBindingSet(target, value);\n            }\n\n            throw new Error(`Unsupported expression in two-way action binding.`);\n          },\n          ir.VisitorContextFlag.InChildOperation,\n        );\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as ir from '../../ir';\nimport {CompilationJob, ComponentCompilationJob} from '../compilation';\n\n/**\n * Counts the number of variable slots used within each view, and stores that on the view itself, as\n * well as propagates it to the `ir.TemplateOp` for embedded views.\n */\nexport function countVariables(job: CompilationJob): void {\n  // First, count the vars used in each view, and update the view-level counter.\n  for (const unit of job.units) {\n    let varCount = 0;\n\n    // Count variables on top-level ops first. Don't explore nested expressions just yet.\n    for (const op of unit.ops()) {\n      if (ir.hasConsumesVarsTrait(op)) {\n        varCount += varsUsedByOp(op);\n      }\n    }\n\n    // Count variables on expressions inside ops. We do this later because some of these expressions\n    // might be conditional (e.g. `pipeBinding` inside of a ternary), and we don't want to interfere\n    // with indices for top-level binding slots (e.g. `property`).\n    for (const op of unit.ops()) {\n      ir.visitExpressionsInOp(op, (expr) => {\n        if (!ir.isIrExpression(expr)) {\n          return;\n        }\n\n        // TemplateDefinitionBuilder assigns variable offsets for everything but pure functions\n        // first, and then assigns offsets to pure functions lazily. We emulate that behavior by\n        // assigning offsets in two passes instead of one, only in compatibility mode.\n        if (\n          job.compatibility === ir.CompatibilityMode.TemplateDefinitionBuilder &&\n          expr instanceof ir.PureFunctionExpr\n        ) {\n          return;\n        }\n\n        // Some expressions require knowledge of the number of variable slots consumed.\n        if (ir.hasUsesVarOffsetTrait(expr)) {\n          expr.varOffset = varCount;\n        }\n\n        if (ir.hasConsumesVarsTrait(expr)) {\n          varCount += varsUsedByIrExpression(expr);\n        }\n      });\n    }\n\n    // Compatibility mode pass for pure function offsets (as explained above).\n    if (job.compatibility === ir.CompatibilityMode.TemplateDefinitionBuilder) {\n      for (const op of unit.ops()) {\n        ir.visitExpressionsInOp(op, (expr) => {\n          if (!ir.isIrExpression(expr) || !(expr instanceof ir.PureFunctionExpr)) {\n            return;\n          }\n\n          // Some expressions require knowledge of the number of variable slots consumed.\n          if (ir.hasUsesVarOffsetTrait(expr)) {\n            expr.varOffset = varCount;\n          }\n\n          if (ir.hasConsumesVarsTrait(expr)) {\n            varCount += varsUsedByIrExpression(expr);\n          }\n        });\n      }\n    }\n\n    unit.vars = varCount;\n  }\n\n  if (job instanceof ComponentCompilationJob) {\n    // Add var counts for each view to the `ir.TemplateOp` which declares that view (if the view is\n    // an embedded view).\n    for (const unit of job.units) {\n      for (const op of unit.create) {\n        if (\n          op.kind !== ir.OpKind.Template &&\n          op.kind !== ir.OpKind.RepeaterCreate &&\n          op.kind !== ir.OpKind.ConditionalCreate &&\n          op.kind !== ir.OpKind.ConditionalBranchCreate\n        ) {\n          continue;\n        }\n\n        const childView = job.views.get(op.xref)!;\n        op.vars = childView.vars;\n\n        // TODO: currently we handle the vars for the RepeaterCreate empty template in the reify\n        // phase. We should handle that here instead.\n      }\n    }\n  }\n}\n\n/**\n * Different operations that implement `ir.UsesVarsTrait` use different numbers of variables, so\n * count the variables used by any particular `op`.\n */\nfunction varsUsedByOp(op: (ir.CreateOp | ir.UpdateOp) & ir.ConsumesVarsTrait): number {\n  let slots: number;\n  switch (op.kind) {\n    case ir.OpKind.Attribute:\n      // All of these bindings use 1 variable slot, plus 1 slot for every interpolated expression,\n      // if any.\n      slots = 1;\n      if (op.expression instanceof ir.Interpolation && !isSingletonInterpolation(op.expression)) {\n        slots += op.expression.expressions.length;\n      }\n      return slots;\n    case ir.OpKind.Property:\n    case ir.OpKind.DomProperty:\n      slots = 1;\n\n      // We need to assign a slot even for singleton interpolations, because the\n      // runtime needs to store both the raw value and the stringified one.\n      if (op.expression instanceof ir.Interpolation) {\n        slots += op.expression.expressions.length;\n      }\n      return slots;\n    case ir.OpKind.TwoWayProperty:\n      // Two-way properties can only have expressions so they only need one variable slot.\n      return 1;\n    case ir.OpKind.StyleProp:\n    case ir.OpKind.ClassProp:\n    case ir.OpKind.StyleMap:\n    case ir.OpKind.ClassMap:\n      // Style & class bindings use 2 variable slots, plus 1 slot for every interpolated expression,\n      // if any.\n      slots = 2;\n      if (op.expression instanceof ir.Interpolation) {\n        slots += op.expression.expressions.length;\n      }\n      return slots;\n    case ir.OpKind.InterpolateText:\n      // `ir.InterpolateTextOp`s use a variable slot for each dynamic expression.\n      return op.interpolation.expressions.length;\n    case ir.OpKind.I18nExpression:\n    case ir.OpKind.Conditional:\n    case ir.OpKind.DeferWhen:\n    case ir.OpKind.StoreLet:\n      return 1;\n    case ir.OpKind.RepeaterCreate:\n      // Repeaters may require an extra variable binding slot, if they have an empty view, for the\n      // empty block tracking.\n      // TODO: It's a bit odd to have a create mode instruction consume variable slots. Maybe we can\n      // find a way to use the Repeater update op instead.\n      return op.emptyView ? 1 : 0;\n    default:\n      throw new Error(`Unhandled op: ${ir.OpKind[op.kind]}`);\n  }\n}\n\nexport function varsUsedByIrExpression(expr: ir.Expression & ir.ConsumesVarsTrait): number {\n  switch (expr.kind) {\n    case ir.ExpressionKind.PureFunctionExpr:\n      return 1 + expr.args.length;\n    case ir.ExpressionKind.PipeBinding:\n      return 1 + expr.args.length;\n    case ir.ExpressionKind.PipeBindingVariadic:\n      return 1 + expr.numArgs;\n    case ir.ExpressionKind.StoreLet:\n      return 1;\n    default:\n      throw new Error(\n        `AssertionError: unhandled ConsumesVarsTrait expression ${expr.constructor.name}`,\n      );\n  }\n}\n\nfunction isSingletonInterpolation(expr: ir.Interpolation): boolean {\n  if (expr.expressions.length !== 1 || expr.strings.length !== 2) {\n    return false;\n  }\n  if (expr.strings[0] !== '' || expr.strings[1] !== '') {\n    return false;\n  }\n  return true;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\nimport {CompilationJob} from '../compilation';\n\n/**\n * Optimize variables declared and used in the IR.\n *\n * Variables are eagerly generated by pipeline stages for all possible values that could be\n * referenced. This stage processes the list of declared variables and all variable usages,\n * and optimizes where possible. It performs 3 main optimizations:\n *\n *   * It transforms variable declarations to side effectful expressions when the\n *     variable is not used, but its initializer has global effects which other\n *     operations rely upon.\n *   * It removes variable declarations if those variables are not referenced and\n *     either they do not have global effects, or nothing relies on them.\n *   * It inlines variable declarations when those variables are only used once\n *     and the inlining is semantically safe.\n *\n * To guarantee correctness, analysis of \"fences\" in the instruction lists is used to determine\n * which optimizations are safe to perform.\n */\nexport function optimizeVariables(job: CompilationJob): void {\n  for (const unit of job.units) {\n    inlineAlwaysInlineVariables(unit.create);\n    inlineAlwaysInlineVariables(unit.update);\n\n    for (const op of unit.create) {\n      if (\n        op.kind === ir.OpKind.Listener ||\n        op.kind === ir.OpKind.Animation ||\n        op.kind === ir.OpKind.AnimationListener ||\n        op.kind === ir.OpKind.TwoWayListener\n      ) {\n        inlineAlwaysInlineVariables(op.handlerOps);\n      } else if (op.kind === ir.OpKind.RepeaterCreate && op.trackByOps !== null) {\n        inlineAlwaysInlineVariables(op.trackByOps);\n      }\n    }\n\n    optimizeVariablesInOpList(unit.create, job.compatibility);\n    optimizeVariablesInOpList(unit.update, job.compatibility);\n\n    for (const op of unit.create) {\n      if (\n        op.kind === ir.OpKind.Listener ||\n        op.kind === ir.OpKind.Animation ||\n        op.kind === ir.OpKind.AnimationListener ||\n        op.kind === ir.OpKind.TwoWayListener\n      ) {\n        optimizeVariablesInOpList(op.handlerOps, job.compatibility);\n      } else if (op.kind === ir.OpKind.RepeaterCreate && op.trackByOps !== null) {\n        optimizeVariablesInOpList(op.trackByOps, job.compatibility);\n      }\n    }\n  }\n}\n\n/**\n * A [fence](https://en.wikipedia.org/wiki/Memory_barrier) flag for an expression which indicates\n * how that expression can be optimized in relation to other expressions or instructions.\n *\n * `Fence`s are a bitfield, so multiple flags may be set on a single expression.\n */\nenum Fence {\n  /**\n   * Empty flag (no fence exists).\n   */\n  None = 0b000,\n\n  /**\n   * A context read fence, meaning that the expression in question reads from the \"current view\"\n   * context of the runtime.\n   */\n  ViewContextRead = 0b001,\n\n  /**\n   * A context write fence, meaning that the expression in question writes to the \"current view\"\n   * context of the runtime.\n   *\n   * Note that all `ContextWrite` fences are implicitly `ContextRead` fences as operations which\n   * change the view context do so based on the current one.\n   */\n  ViewContextWrite = 0b010,\n\n  /**\n   * Indicates that a call is required for its side-effects, even if nothing reads its result.\n   *\n   * This is also true of `ViewContextWrite` operations **if** they are followed by a\n   * `ViewContextRead`.\n   */\n  SideEffectful = 0b100,\n}\n\n/**\n * Summary data collected for each `Op` in a list.\n *\n * Tracking this data per operation allows the optimizer to process operations at a higher level\n * than always scanning expressions.\n */\ninterface OpInfo {\n  /**\n   * A `Set` of variables referenced by expressions in this operation.\n   */\n  variablesUsed: Set<ir.XrefId>;\n\n  /**\n   * Flags indicating any `Fence`s present for this operation.\n   */\n  fences: Fence;\n}\n\nfunction inlineAlwaysInlineVariables(ops: ir.OpList<ir.CreateOp | ir.UpdateOp>): void {\n  const vars = new Map<ir.XrefId, ir.VariableOp<ir.CreateOp | ir.UpdateOp>>();\n  for (const op of ops) {\n    if (op.kind === ir.OpKind.Variable && op.flags & ir.VariableFlags.AlwaysInline) {\n      ir.visitExpressionsInOp(op, (expr) => {\n        if (ir.isIrExpression(expr) && fencesForIrExpression(expr) !== Fence.None) {\n          throw new Error(`AssertionError: A context-sensitive variable was marked AlwaysInline`);\n        }\n      });\n      vars.set(op.xref, op);\n    }\n\n    ir.transformExpressionsInOp(\n      op,\n      (expr) => {\n        if (expr instanceof ir.ReadVariableExpr && vars.has(expr.xref)) {\n          const varOp = vars.get(expr.xref)!;\n          // Inline by cloning, because we might inline into multiple places.\n          return varOp.initializer.clone();\n        }\n        return expr;\n      },\n      ir.VisitorContextFlag.None,\n    );\n  }\n\n  for (const op of vars.values()) {\n    ir.OpList.remove(op as ir.CreateOp | ir.UpdateOp);\n  }\n}\n\n/**\n * Process a list of operations and optimize variables within that list.\n */\nfunction optimizeVariablesInOpList(\n  ops: ir.OpList<ir.CreateOp | ir.UpdateOp>,\n  compatibility: ir.CompatibilityMode,\n): void {\n  const varDecls = new Map<ir.XrefId, ir.VariableOp<ir.CreateOp | ir.UpdateOp>>();\n  const varUsages = new Map<ir.XrefId, number>();\n\n  // Track variables that are used outside of the immediate operation list. For example, within\n  // `ListenerOp` handler operations of listeners in the current operation list.\n  const varRemoteUsages = new Set<ir.XrefId>();\n  const opMap = new Map<ir.CreateOp | ir.UpdateOp, OpInfo>();\n\n  // First, extract information about variables declared or used within the whole list.\n  for (const op of ops) {\n    if (op.kind === ir.OpKind.Variable) {\n      if (varDecls.has(op.xref) || varUsages.has(op.xref)) {\n        throw new Error(`Should not see two declarations of the same variable: ${op.xref}`);\n      }\n      varDecls.set(op.xref, op);\n      varUsages.set(op.xref, 0);\n    }\n\n    opMap.set(op, collectOpInfo(op));\n    countVariableUsages(op, varUsages, varRemoteUsages);\n  }\n\n  // The next step is to remove any variable declarations for variables that aren't used. The\n  // variable initializer expressions may be side-effectful, so they may need to be retained as\n  // expression statements.\n\n  // Track whether we've seen an operation which reads from the view context yet. This is used to\n  // determine whether a write to the view context in a variable initializer can be observed.\n  let contextIsUsed = false;\n\n  // Note that iteration through the list happens in reverse, which guarantees that we'll process\n  // all reads of a variable prior to processing its declaration.\n  for (const op of ops.reversed()) {\n    const opInfo = opMap.get(op)!;\n\n    if (op.kind === ir.OpKind.Variable && varUsages.get(op.xref)! === 0) {\n      // This variable is unused and can be removed. We might need to keep the initializer around,\n      // though, if something depends on it running.\n      if (\n        (contextIsUsed && opInfo.fences & Fence.ViewContextWrite) ||\n        opInfo.fences & Fence.SideEffectful\n      ) {\n        // This variable initializer has a side effect which must be retained. Either:\n        //  * it writes to the view context, and we know there is a future operation which depends\n        //    on that write, or\n        //  * it's an operation which is inherently side-effectful.\n        // We can't remove the initializer, but we can remove the variable declaration itself and\n        // replace it with a side-effectful statement.\n        const stmtOp = ir.createStatementOp(op.initializer.toStmt()) as ir.UpdateOp;\n        opMap.set(stmtOp, opInfo);\n        ir.OpList.replace(op as ir.UpdateOp, stmtOp);\n      } else {\n        // It's safe to delete this entire variable declaration as nothing depends on it, even\n        // side-effectfully. Note that doing this might make other variables unused. Since we're\n        // iterating in reverse order, we should always be processing usages before declarations\n        // and therefore by the time we get to a declaration, all removable usages will have been\n        // removed.\n        uncountVariableUsages(op, varUsages);\n        ir.OpList.remove(op as ir.UpdateOp);\n      }\n\n      opMap.delete(op);\n      varDecls.delete(op.xref);\n      varUsages.delete(op.xref);\n      continue;\n    }\n\n    // Does this operation depend on the view context?\n    if (opInfo.fences & Fence.ViewContextRead) {\n      contextIsUsed = true;\n    }\n  }\n\n  // Next, inline any remaining variables with exactly one usage.\n  const toInline: ir.XrefId[] = [];\n  for (const [id, count] of varUsages) {\n    const decl = varDecls.get(id)!;\n    // We can inline variables that:\n    //  - are used exactly once, and\n    //  - are not used remotely\n    // OR\n    //  - are marked for always inlining\n    const isAlwaysInline = !!(decl.flags & ir.VariableFlags.AlwaysInline);\n    if (count !== 1 || isAlwaysInline) {\n      // We can't inline this variable as it's used more than once.\n      continue;\n    }\n\n    if (varRemoteUsages.has(id)) {\n      // This variable is used once, but across an operation boundary, so it can't be inlined.\n      continue;\n    }\n\n    toInline.push(id);\n  }\n\n  let candidate: ir.XrefId | undefined;\n  while ((candidate = toInline.pop())) {\n    // We will attempt to inline this variable. If inlining fails (due to fences for example),\n    // no future operation will make inlining legal.\n    const decl = varDecls.get(candidate)!;\n    const varInfo = opMap.get(decl as ir.CreateOp | ir.UpdateOp)!;\n    const isAlwaysInline = !!(decl.flags & ir.VariableFlags.AlwaysInline);\n\n    if (isAlwaysInline) {\n      throw new Error(\n        `AssertionError: Found an 'AlwaysInline' variable after the always inlining pass.`,\n      );\n    }\n\n    // Scan operations following the variable declaration and look for the point where that variable\n    // is used. There should only be one usage given the precondition above.\n    for (\n      let targetOp = decl.next!;\n      targetOp.kind !== ir.OpKind.ListEnd;\n      targetOp = targetOp.next!\n    ) {\n      const opInfo = opMap.get(targetOp)!;\n\n      // Is the variable used in this operation?\n      if (opInfo.variablesUsed.has(candidate)) {\n        if (\n          compatibility === ir.CompatibilityMode.TemplateDefinitionBuilder &&\n          !allowConservativeInlining(decl, targetOp)\n        ) {\n          // We're in conservative mode, and this variable is not eligible for inlining into the\n          // target operation in this mode.\n          break;\n        }\n\n        // Yes, try to inline it. Inlining may not be successful if fences in this operation before\n        // the variable's usage cannot be safely crossed.\n        if (tryInlineVariableInitializer(candidate, decl.initializer, targetOp, varInfo.fences)) {\n          // Inlining was successful! Update the tracking structures to reflect the inlined\n          // variable.\n          opInfo.variablesUsed.delete(candidate);\n\n          // Add all variables used in the variable's initializer to its new usage site.\n          for (const id of varInfo.variablesUsed) {\n            opInfo.variablesUsed.add(id);\n          }\n\n          // Merge fences in the variable's initializer into its new usage site.\n          opInfo.fences |= varInfo.fences;\n\n          // Delete tracking info related to the declaration.\n          varDecls.delete(candidate);\n          varUsages.delete(candidate);\n          opMap.delete(decl as ir.CreateOp | ir.UpdateOp);\n\n          // And finally, delete the original declaration from the operation list.\n          ir.OpList.remove(decl as ir.UpdateOp);\n        }\n\n        // Whether inlining succeeded or failed, we're done processing this variable.\n        break;\n      }\n\n      // If the variable is not used in this operation, then we'd need to inline across it. Check if\n      // that's safe to do.\n      if (!safeToInlinePastFences(opInfo.fences, varInfo.fences)) {\n        // We can't safely inline this variable beyond this operation, so don't proceed with\n        // inlining this variable.\n        break;\n      }\n    }\n  }\n}\n\n/**\n * Given an `ir.Expression`, returns the `Fence` flags for that expression type.\n */\nfunction fencesForIrExpression(expr: ir.Expression): Fence {\n  switch (expr.kind) {\n    case ir.ExpressionKind.NextContext:\n      return Fence.ViewContextRead | Fence.ViewContextWrite;\n    case ir.ExpressionKind.RestoreView:\n      return Fence.ViewContextRead | Fence.ViewContextWrite | Fence.SideEffectful;\n    case ir.ExpressionKind.StoreLet:\n      return Fence.SideEffectful;\n    case ir.ExpressionKind.Reference:\n    case ir.ExpressionKind.ContextLetReference:\n      return Fence.ViewContextRead;\n    default:\n      return Fence.None;\n  }\n}\n\n/**\n * Build the `OpInfo` structure for the given `op`. This performs two operations:\n *\n *  * It tracks which variables are used in the operation's expressions.\n *  * It rolls up fence flags for expressions within the operation.\n */\nfunction collectOpInfo(op: ir.CreateOp | ir.UpdateOp): OpInfo {\n  let fences = Fence.None;\n  const variablesUsed = new Set<ir.XrefId>();\n  ir.visitExpressionsInOp(op, (expr) => {\n    if (!ir.isIrExpression(expr)) {\n      return;\n    }\n\n    switch (expr.kind) {\n      case ir.ExpressionKind.ReadVariable:\n        variablesUsed.add(expr.xref);\n        break;\n      default:\n        fences |= fencesForIrExpression(expr);\n    }\n  });\n  return {fences, variablesUsed};\n}\n\n/**\n * Count the number of usages of each variable, being careful to track whether those usages are\n * local or remote.\n */\nfunction countVariableUsages(\n  op: ir.CreateOp | ir.UpdateOp,\n  varUsages: Map<ir.XrefId, number>,\n  varRemoteUsage: Set<ir.XrefId>,\n): void {\n  ir.visitExpressionsInOp(op, (expr, flags) => {\n    if (!ir.isIrExpression(expr)) {\n      return;\n    }\n\n    if (expr.kind !== ir.ExpressionKind.ReadVariable) {\n      return;\n    }\n\n    const count = varUsages.get(expr.xref);\n    if (count === undefined) {\n      // This variable is declared outside the current scope of optimization.\n      return;\n    }\n    varUsages.set(expr.xref, count + 1);\n\n    if (flags & ir.VisitorContextFlag.InChildOperation) {\n      varRemoteUsage.add(expr.xref);\n    }\n  });\n}\n\n/**\n * Remove usages of a variable in `op` from the `varUsages` tracking.\n */\nfunction uncountVariableUsages(\n  op: ir.CreateOp | ir.UpdateOp,\n  varUsages: Map<ir.XrefId, number>,\n): void {\n  ir.visitExpressionsInOp(op, (expr) => {\n    if (!ir.isIrExpression(expr)) {\n      return;\n    }\n\n    if (expr.kind !== ir.ExpressionKind.ReadVariable) {\n      return;\n    }\n\n    const count = varUsages.get(expr.xref);\n    if (count === undefined) {\n      // This variable is declared outside the current scope of optimization.\n      return;\n    } else if (count === 0) {\n      throw new Error(\n        `Inaccurate variable count: ${expr.xref} - found another read but count is already 0`,\n      );\n    }\n    varUsages.set(expr.xref, count - 1);\n  });\n}\n\n/**\n * Checks whether it's safe to inline a variable across a particular operation.\n *\n * @param fences the fences of the operation which the inlining will cross\n * @param declFences the fences of the variable being inlined.\n */\nfunction safeToInlinePastFences(fences: Fence, declFences: Fence): boolean {\n  if (fences & Fence.ViewContextWrite) {\n    // It's not safe to inline context reads across context writes.\n    if (declFences & Fence.ViewContextRead) {\n      return false;\n    }\n  } else if (fences & Fence.ViewContextRead) {\n    // It's not safe to inline context writes across context reads.\n    if (declFences & Fence.ViewContextWrite) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Attempt to inline the initializer of a variable into a target operation's expressions.\n *\n * This may or may not be safe to do. For example, the variable could be read following the\n * execution of an expression with fences that don't permit the variable to be inlined across them.\n */\nfunction tryInlineVariableInitializer(\n  id: ir.XrefId,\n  initializer: o.Expression,\n  target: ir.CreateOp | ir.UpdateOp,\n  declFences: Fence,\n): boolean {\n  // We use `ir.transformExpressionsInOp` to walk the expressions and inline the variable if\n  // possible. Since this operation is callback-based, once inlining succeeds or fails we can't\n  // \"stop\" the expression processing, and have to keep track of whether inlining has succeeded or\n  // is no longer allowed.\n  let inlined = false;\n  let inliningAllowed = true;\n\n  ir.transformExpressionsInOp(\n    target,\n    (expr, flags) => {\n      if (!ir.isIrExpression(expr)) {\n        return expr;\n      }\n\n      if (inlined || !inliningAllowed) {\n        // Either the inlining has already succeeded, or we've passed a fence that disallows inlining\n        // at this point, so don't try.\n        return expr;\n      } else if (\n        flags & ir.VisitorContextFlag.InChildOperation &&\n        declFences & Fence.ViewContextRead\n      ) {\n        // We cannot inline variables that are sensitive to the current context across operation\n        // boundaries.\n        return expr;\n      }\n\n      switch (expr.kind) {\n        case ir.ExpressionKind.ReadVariable:\n          if (expr.xref === id) {\n            // This is the usage site of the variable. Since nothing has disallowed inlining, it's\n            // safe to inline the initializer here.\n            inlined = true;\n            return initializer;\n          }\n          break;\n        default:\n          // For other types of `ir.Expression`s, whether inlining is allowed depends on their fences.\n          const exprFences = fencesForIrExpression(expr);\n          inliningAllowed = inliningAllowed && safeToInlinePastFences(exprFences, declFences);\n          break;\n      }\n      return expr;\n    },\n    ir.VisitorContextFlag.None,\n  );\n  return inlined;\n}\n\n/**\n * Determines whether inlining of `decl` should be allowed in \"conservative\" mode.\n *\n * In conservative mode, inlining behavior is limited to those operations which the\n * `TemplateDefinitionBuilder` supported, with the goal of producing equivalent output.\n */\nfunction allowConservativeInlining(\n  decl: ir.VariableOp<ir.CreateOp | ir.UpdateOp>,\n  target: ir.Op<ir.CreateOp | ir.UpdateOp>,\n): boolean {\n  // TODO(alxhub): understand exactly how TemplateDefinitionBuilder approaches inlining, and record\n  // that behavior here.\n  switch (decl.variable.kind) {\n    case ir.SemanticVariableKind.Identifier:\n      if (decl.initializer instanceof o.ReadVarExpr && decl.initializer.name === 'ctx') {\n        // Although TemplateDefinitionBuilder is cautious about inlining, we still want to do so\n        // when the variable is the context, to imitate its behavior with aliases in control flow\n        // blocks. This quirky behavior will become dead code once compatibility mode is no longer\n        // supported.\n        return true;\n      }\n      return false;\n    case ir.SemanticVariableKind.Context:\n      // Context can only be inlined into other variables.\n      return target.kind === ir.OpKind.Variable;\n    default:\n      return true;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as ir from '../../ir';\nimport {CompilationJob} from '../compilation';\n\n/**\n * Wraps ICUs that do not already belong to an i18n block in a new i18n block.\n */\nexport function wrapI18nIcus(job: CompilationJob): void {\n  for (const unit of job.units) {\n    let currentI18nOp: ir.I18nStartOp | null = null;\n    let addedI18nId: ir.XrefId | null = null;\n    for (const op of unit.create) {\n      switch (op.kind) {\n        case ir.OpKind.I18nStart:\n          currentI18nOp = op;\n          break;\n        case ir.OpKind.I18nEnd:\n          currentI18nOp = null;\n          break;\n        case ir.OpKind.IcuStart:\n          if (currentI18nOp === null) {\n            addedI18nId = job.allocateXrefId();\n            // ICU i18n start/end ops should not receive source spans.\n            ir.OpList.insertBefore<ir.CreateOp>(\n              ir.createI18nStartOp(addedI18nId, op.message, undefined, null),\n              op,\n            );\n          }\n          break;\n        case ir.OpKind.IcuEnd:\n          if (addedI18nId !== null) {\n            ir.OpList.insertAfter<ir.CreateOp>(ir.createI18nEndOp(addedI18nId, null), op);\n            addedI18nId = null;\n          }\n          break;\n      }\n    }\n  }\n}\n","/**\n *\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../../../../src/output/output_ast';\nimport {ConstantPool} from '../../../constant_pool';\nimport * as ir from '../ir';\n\nimport {\n  CompilationJob,\n  CompilationJobKind as Kind,\n  type ComponentCompilationJob,\n  type HostBindingCompilationJob,\n  type ViewCompilationUnit,\n} from './compilation';\n\nimport {deleteAnyCasts} from './phases/any_cast';\nimport {applyI18nExpressions} from './phases/apply_i18n_expressions';\nimport {assignI18nSlotDependencies} from './phases/assign_i18n_slot_dependencies';\nimport {attachSourceLocations} from './phases/attach_source_locations';\nimport {extractAttributes} from './phases/attribute_extraction';\nimport {specializeBindings} from './phases/binding_specialization';\nimport {chain} from './phases/chaining';\nimport {collapseSingletonInterpolations} from './phases/collapse_singleton_interpolations';\nimport {generateConditionalExpressions} from './phases/conditionals';\nimport {collectElementConsts} from './phases/const_collection';\nimport {convertAnimations} from './phases/convert_animations';\nimport {convertI18nBindings} from './phases/convert_i18n_bindings';\nimport {createI18nContexts} from './phases/create_i18n_contexts';\nimport {deduplicateTextBindings} from './phases/deduplicate_text_bindings';\nimport {configureDeferInstructions} from './phases/defer_configs';\nimport {resolveDeferTargetNames} from './phases/defer_resolve_targets';\nimport {collapseEmptyInstructions} from './phases/empty_elements';\nimport {expandSafeReads} from './phases/expand_safe_reads';\nimport {extractI18nMessages} from './phases/extract_i18n_messages';\nimport {generateAdvance} from './phases/generate_advance';\nimport {generateLocalLetReferences} from './phases/generate_local_let_references';\nimport {generateProjectionDefs} from './phases/generate_projection_def';\nimport {generateVariables} from './phases/generate_variables';\nimport {collectConstExpressions} from './phases/has_const_expression_collection';\nimport {parseHostStyleProperties} from './phases/host_style_property_parsing';\nimport {collectI18nConsts} from './phases/i18n_const_collection';\nimport {convertI18nText} from './phases/i18n_text_extraction';\nimport {liftLocalRefs} from './phases/local_refs';\nimport {emitNamespaceChanges} from './phases/namespace';\nimport {nameFunctionsAndVariables} from './phases/naming';\nimport {mergeNextContextExpressions} from './phases/next_context_merging';\nimport {generateNgContainerOps} from './phases/ng_container';\nimport {disableBindings} from './phases/nonbindable';\nimport {orderOps} from './phases/ordering';\nimport {parseExtractedStyles} from './phases/parse_extracted_styles';\nimport {removeContentSelectors} from './phases/phase_remove_content_selectors';\nimport {createPipes} from './phases/pipe_creation';\nimport {createVariadicPipes} from './phases/pipe_variadic';\nimport {propagateI18nBlocks} from './phases/propagate_i18n_blocks';\nimport {extractPureFunctions} from './phases/pure_function_extraction';\nimport {generatePureLiteralStructures} from './phases/pure_literal_structures';\nimport {reify} from './phases/reify';\nimport {removeEmptyBindings} from './phases/remove_empty_bindings';\nimport {removeI18nContexts} from './phases/remove_i18n_contexts';\nimport {removeIllegalLetReferences} from './phases/remove_illegal_let_references';\nimport {removeUnusedI18nAttributesOps} from './phases/remove_unused_i18n_attrs';\nimport {resolveContexts} from './phases/resolve_contexts';\nimport {resolveDeferDepsFns} from './phases/resolve_defer_deps_fns';\nimport {resolveDollarEvent} from './phases/resolve_dollar_event';\nimport {resolveI18nElementPlaceholders} from './phases/resolve_i18n_element_placeholders';\nimport {resolveI18nExpressionPlaceholders} from './phases/resolve_i18n_expression_placeholders';\nimport {resolveNames} from './phases/resolve_names';\nimport {resolveSanitizers} from './phases/resolve_sanitizers';\nimport {saveAndRestoreView} from './phases/save_restore_view';\nimport {allocateSlots} from './phases/slot_allocation';\nimport {optimizeStoreLet} from './phases/store_let_optimization';\nimport {stripNonrequiredParentheses} from './phases/strip_nonrequired_parentheses';\nimport {specializeStyleBindings} from './phases/style_binding_specialization';\nimport {generateTemporaryVariables} from './phases/temporary_variables';\nimport {optimizeTrackFns} from './phases/track_fn_optimization';\nimport {generateTrackVariables} from './phases/track_variables';\nimport {transformTwoWayBindingSet} from './phases/transform_two_way_binding_set';\nimport {countVariables} from './phases/var_counting';\nimport {optimizeVariables} from './phases/variable_optimization';\nimport {wrapI18nIcus} from './phases/wrap_icus';\n\ntype Phase =\n  | {\n      fn: (job: CompilationJob) => void;\n      kind: Kind.Both | Kind.Host | Kind.Tmpl;\n    }\n  | {\n      fn: (job: ComponentCompilationJob) => void;\n      kind: Kind.Tmpl;\n    }\n  | {\n      fn: (job: HostBindingCompilationJob) => void;\n      kind: Kind.Host;\n    };\n\nconst phases: Phase[] = [\n  {kind: Kind.Tmpl, fn: removeContentSelectors},\n  {kind: Kind.Host, fn: parseHostStyleProperties},\n  {kind: Kind.Tmpl, fn: emitNamespaceChanges},\n  {kind: Kind.Tmpl, fn: propagateI18nBlocks},\n  {kind: Kind.Tmpl, fn: wrapI18nIcus},\n  {kind: Kind.Both, fn: deduplicateTextBindings},\n  {kind: Kind.Both, fn: specializeStyleBindings},\n  {kind: Kind.Both, fn: specializeBindings},\n  {kind: Kind.Both, fn: convertAnimations},\n  {kind: Kind.Both, fn: extractAttributes},\n  {kind: Kind.Tmpl, fn: createI18nContexts},\n  {kind: Kind.Both, fn: parseExtractedStyles},\n  {kind: Kind.Tmpl, fn: removeEmptyBindings},\n  {kind: Kind.Both, fn: collapseSingletonInterpolations},\n  {kind: Kind.Both, fn: orderOps},\n  {kind: Kind.Tmpl, fn: generateConditionalExpressions},\n  {kind: Kind.Tmpl, fn: createPipes},\n  {kind: Kind.Tmpl, fn: configureDeferInstructions},\n  {kind: Kind.Tmpl, fn: createVariadicPipes},\n  {kind: Kind.Both, fn: generatePureLiteralStructures},\n  {kind: Kind.Tmpl, fn: generateProjectionDefs},\n  {kind: Kind.Tmpl, fn: generateLocalLetReferences},\n  {kind: Kind.Tmpl, fn: generateVariables},\n  {kind: Kind.Tmpl, fn: saveAndRestoreView},\n  {kind: Kind.Both, fn: deleteAnyCasts},\n  {kind: Kind.Both, fn: resolveDollarEvent},\n  {kind: Kind.Tmpl, fn: generateTrackVariables},\n  {kind: Kind.Tmpl, fn: removeIllegalLetReferences},\n  {kind: Kind.Both, fn: resolveNames},\n  {kind: Kind.Tmpl, fn: resolveDeferTargetNames},\n  {kind: Kind.Tmpl, fn: transformTwoWayBindingSet},\n  {kind: Kind.Tmpl, fn: optimizeTrackFns},\n  {kind: Kind.Both, fn: resolveContexts},\n  {kind: Kind.Both, fn: resolveSanitizers},\n  {kind: Kind.Tmpl, fn: liftLocalRefs},\n  {kind: Kind.Both, fn: expandSafeReads},\n  {kind: Kind.Both, fn: stripNonrequiredParentheses},\n  {kind: Kind.Both, fn: generateTemporaryVariables},\n  {kind: Kind.Both, fn: optimizeVariables},\n  {kind: Kind.Both, fn: optimizeStoreLet},\n  {kind: Kind.Tmpl, fn: convertI18nText},\n  {kind: Kind.Tmpl, fn: convertI18nBindings},\n  {kind: Kind.Tmpl, fn: removeUnusedI18nAttributesOps},\n  {kind: Kind.Tmpl, fn: assignI18nSlotDependencies},\n  {kind: Kind.Tmpl, fn: applyI18nExpressions},\n  {kind: Kind.Tmpl, fn: allocateSlots},\n  {kind: Kind.Tmpl, fn: resolveI18nElementPlaceholders},\n  {kind: Kind.Tmpl, fn: resolveI18nExpressionPlaceholders},\n  {kind: Kind.Tmpl, fn: extractI18nMessages},\n  {kind: Kind.Tmpl, fn: collectI18nConsts},\n  {kind: Kind.Tmpl, fn: collectConstExpressions},\n  {kind: Kind.Both, fn: collectElementConsts},\n  {kind: Kind.Tmpl, fn: removeI18nContexts},\n  {kind: Kind.Both, fn: countVariables},\n  {kind: Kind.Tmpl, fn: generateAdvance},\n  {kind: Kind.Both, fn: nameFunctionsAndVariables},\n  {kind: Kind.Tmpl, fn: resolveDeferDepsFns},\n  {kind: Kind.Tmpl, fn: mergeNextContextExpressions},\n  {kind: Kind.Tmpl, fn: generateNgContainerOps},\n  {kind: Kind.Tmpl, fn: collapseEmptyInstructions},\n  {kind: Kind.Tmpl, fn: attachSourceLocations},\n  {kind: Kind.Tmpl, fn: disableBindings},\n  {kind: Kind.Both, fn: extractPureFunctions},\n  {kind: Kind.Both, fn: reify},\n  {kind: Kind.Both, fn: chain},\n];\n\n/**\n * Run all transformation phases in the correct order against a compilation job. After this\n * processing, the compilation should be in a state where it can be emitted.\n */\nexport function transform(job: CompilationJob, kind: Kind): void {\n  for (const phase of phases) {\n    if (phase.kind === kind || phase.kind === Kind.Both) {\n      // The type of `Phase` above ensures it is impossible to call a phase that doesn't support the\n      // job kind.\n      phase.fn(job as CompilationJob & ComponentCompilationJob & HostBindingCompilationJob);\n    }\n  }\n}\n\n/**\n * Compile all views in the given `ComponentCompilation` into the final template function, which may\n * reference constants defined in a `ConstantPool`.\n */\nexport function emitTemplateFn(tpl: ComponentCompilationJob, pool: ConstantPool): o.FunctionExpr {\n  const rootFn = emitView(tpl.root);\n  emitChildViews(tpl.root, pool);\n  return rootFn;\n}\n\nfunction emitChildViews(parent: ViewCompilationUnit, pool: ConstantPool): void {\n  for (const unit of parent.job.units) {\n    if (unit.parent !== parent.xref) {\n      continue;\n    }\n\n    // Child views are emitted depth-first.\n    emitChildViews(unit, pool);\n\n    const viewFn = emitView(unit);\n    pool.statements.push(viewFn.toDeclStmt(viewFn.name!));\n  }\n}\n\n/**\n * Emit a template function for an individual `ViewCompilation` (which may be either the root view\n * or an embedded view).\n */\nfunction emitView(view: ViewCompilationUnit): o.FunctionExpr {\n  if (view.fnName === null) {\n    throw new Error(`AssertionError: view ${view.xref} is unnamed`);\n  }\n\n  const createStatements: o.Statement[] = [];\n  for (const op of view.create) {\n    if (op.kind !== ir.OpKind.Statement) {\n      throw new Error(\n        `AssertionError: expected all create ops to have been compiled, but got ${\n          ir.OpKind[op.kind]\n        }`,\n      );\n    }\n    createStatements.push(op.statement);\n  }\n  const updateStatements: o.Statement[] = [];\n  for (const op of view.update) {\n    if (op.kind !== ir.OpKind.Statement) {\n      throw new Error(\n        `AssertionError: expected all update ops to have been compiled, but got ${\n          ir.OpKind[op.kind]\n        }`,\n      );\n    }\n    updateStatements.push(op.statement);\n  }\n\n  const createCond = maybeGenerateRfBlock(1, createStatements);\n  const updateCond = maybeGenerateRfBlock(2, updateStatements);\n  return o.fn(\n    [new o.FnParam('rf'), new o.FnParam('ctx')],\n    [...createCond, ...updateCond],\n    /* type */ undefined,\n    /* sourceSpan */ undefined,\n    view.fnName,\n  );\n}\n\nfunction maybeGenerateRfBlock(flag: number, statements: o.Statement[]): o.Statement[] {\n  if (statements.length === 0) {\n    return [];\n  }\n\n  return [\n    o.ifStmt(\n      new o.BinaryOperatorExpr(o.BinaryOperator.BitwiseAnd, o.variable('rf'), o.literal(flag)),\n      statements,\n    ),\n  ];\n}\n\nexport function emitHostBindingFunction(job: HostBindingCompilationJob): o.FunctionExpr | null {\n  if (job.root.fnName === null) {\n    throw new Error(`AssertionError: host binding function is unnamed`);\n  }\n\n  const createStatements: o.Statement[] = [];\n  for (const op of job.root.create) {\n    if (op.kind !== ir.OpKind.Statement) {\n      throw new Error(\n        `AssertionError: expected all create ops to have been compiled, but got ${\n          ir.OpKind[op.kind]\n        }`,\n      );\n    }\n    createStatements.push(op.statement);\n  }\n  const updateStatements: o.Statement[] = [];\n  for (const op of job.root.update) {\n    if (op.kind !== ir.OpKind.Statement) {\n      throw new Error(\n        `AssertionError: expected all update ops to have been compiled, but got ${\n          ir.OpKind[op.kind]\n        }`,\n      );\n    }\n    updateStatements.push(op.statement);\n  }\n\n  if (createStatements.length === 0 && updateStatements.length === 0) {\n    return null;\n  }\n\n  const createCond = maybeGenerateRfBlock(1, createStatements);\n  const updateCond = maybeGenerateRfBlock(2, updateStatements);\n  return o.fn(\n    [new o.FnParam('rf'), new o.FnParam('ctx')],\n    [...createCond, ...updateCond],\n    /* type */ undefined,\n    /* sourceSpan */ undefined,\n    job.root.fnName,\n  );\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ConstantPool} from '../../../constant_pool';\nimport {SecurityContext} from '../../../core';\nimport * as e from '../../../expression_parser/ast';\nimport * as i18n from '../../../i18n/i18n_ast';\nimport {splitNsName} from '../../../ml_parser/tags';\nimport * as o from '../../../output/output_ast';\nimport {ParseSourceSpan} from '../../../parse_util';\nimport * as t from '../../../render3/r3_ast';\nimport {DeferBlockDepsEmitMode, R3ComponentDeferMetadata} from '../../../render3/view/api';\nimport {icuFromI18nMessage} from '../../../render3/view/i18n/util';\nimport {DomElementSchemaRegistry} from '../../../schema/dom_element_schema_registry';\nimport {BindingParser} from '../../../template_parser/binding_parser';\nimport * as ir from '../ir';\n\nimport {\n  TemplateCompilationMode,\n  CompilationUnit,\n  ComponentCompilationJob,\n  HostBindingCompilationJob,\n  type CompilationJob,\n  type ViewCompilationUnit,\n} from './compilation';\nimport {BINARY_OPERATORS, namespaceForKey, prefixWithNamespace} from './conversion';\n\nconst compatibilityMode = ir.CompatibilityMode.TemplateDefinitionBuilder;\n\n// Schema containing DOM elements and their properties.\nconst domSchema = new DomElementSchemaRegistry();\n\n// Tag name of the `ng-template` element.\nconst NG_TEMPLATE_TAG_NAME = 'ng-template';\n\n// prefix for any animation binding\nconst ANIMATE_PREFIX = 'animate.';\n\nexport function isI18nRootNode(meta?: i18n.I18nMeta): meta is i18n.Message {\n  return meta instanceof i18n.Message;\n}\n\nexport function isSingleI18nIcu(meta?: i18n.I18nMeta): meta is i18n.I18nMeta & {nodes: [i18n.Icu]} {\n  return isI18nRootNode(meta) && meta.nodes.length === 1 && meta.nodes[0] instanceof i18n.Icu;\n}\n\n/**\n * Process a template AST and convert it into a `ComponentCompilation` in the intermediate\n * representation.\n * TODO: Refactor more of the ingestion code into phases.\n */\nexport function ingestComponent(\n  componentName: string,\n  template: t.Node[],\n  constantPool: ConstantPool,\n  compilationMode: TemplateCompilationMode,\n  relativeContextFilePath: string,\n  i18nUseExternalIds: boolean,\n  deferMeta: R3ComponentDeferMetadata,\n  allDeferrableDepsFn: o.ReadVarExpr | null,\n  relativeTemplatePath: string | null,\n  enableDebugLocations: boolean,\n): ComponentCompilationJob {\n  const job = new ComponentCompilationJob(\n    componentName,\n    constantPool,\n    compatibilityMode,\n    compilationMode,\n    relativeContextFilePath,\n    i18nUseExternalIds,\n    deferMeta,\n    allDeferrableDepsFn,\n    relativeTemplatePath,\n    enableDebugLocations,\n  );\n  ingestNodes(job.root, template);\n  return job;\n}\n\nexport interface HostBindingInput {\n  componentName: string;\n  componentSelector: string;\n  properties: e.ParsedProperty[] | null;\n  attributes: {[key: string]: o.Expression};\n  events: e.ParsedEvent[] | null;\n}\n\n/**\n * Process a host binding AST and convert it into a `HostBindingCompilationJob` in the intermediate\n * representation.\n */\nexport function ingestHostBinding(\n  input: HostBindingInput,\n  bindingParser: BindingParser,\n  constantPool: ConstantPool,\n): HostBindingCompilationJob {\n  const job = new HostBindingCompilationJob(\n    input.componentName,\n    constantPool,\n    compatibilityMode,\n    TemplateCompilationMode.DomOnly,\n  );\n  for (const property of input.properties ?? []) {\n    let bindingKind = ir.BindingKind.Property;\n    // TODO: this should really be handled in the parser.\n    if (property.name.startsWith('attr.')) {\n      property.name = property.name.substring('attr.'.length);\n      bindingKind = ir.BindingKind.Attribute;\n    }\n    if (property.isLegacyAnimation) {\n      bindingKind = ir.BindingKind.LegacyAnimation;\n    }\n    if (property.isAnimation) {\n      bindingKind = ir.BindingKind.Animation;\n    }\n    const securityContexts = bindingParser\n      .calcPossibleSecurityContexts(\n        input.componentSelector,\n        property.name,\n        bindingKind === ir.BindingKind.Attribute,\n      )\n      .filter((context) => context !== SecurityContext.NONE);\n    ingestDomProperty(job, property, bindingKind, securityContexts);\n  }\n  for (const [name, expr] of Object.entries(input.attributes) ?? []) {\n    const securityContexts = bindingParser\n      .calcPossibleSecurityContexts(input.componentSelector, name, true)\n      .filter((context) => context !== SecurityContext.NONE);\n    ingestHostAttribute(job, name, expr, securityContexts);\n  }\n  for (const event of input.events ?? []) {\n    ingestHostEvent(job, event);\n  }\n  return job;\n}\n\n// TODO: We should refactor the parser to use the same types and structures for host bindings as\n// with ordinary components. This would allow us to share a lot more ingestion code.\nexport function ingestDomProperty(\n  job: HostBindingCompilationJob,\n  property: e.ParsedProperty,\n  bindingKind: ir.BindingKind,\n  securityContexts: SecurityContext[],\n): void {\n  let expression: o.Expression | ir.Interpolation;\n  const ast = property.expression.ast;\n  if (ast instanceof e.Interpolation) {\n    expression = new ir.Interpolation(\n      ast.strings,\n      ast.expressions.map((expr) => convertAst(expr, job, property.sourceSpan)),\n      [],\n    );\n  } else {\n    expression = convertAst(ast, job, property.sourceSpan);\n  }\n  job.root.update.push(\n    ir.createBindingOp(\n      job.root.xref,\n      bindingKind,\n      property.name,\n      expression,\n      null,\n      securityContexts,\n      false,\n      false,\n      null,\n      /* TODO: How do Host bindings handle i18n attrs? */ null,\n      property.sourceSpan,\n    ),\n  );\n}\n\nexport function ingestHostAttribute(\n  job: HostBindingCompilationJob,\n  name: string,\n  value: o.Expression,\n  securityContexts: SecurityContext[],\n): void {\n  const attrBinding = ir.createBindingOp(\n    job.root.xref,\n    ir.BindingKind.Attribute,\n    name,\n    value,\n    null,\n    securityContexts,\n    /* Host attributes should always be extracted to const hostAttrs, even if they are not\n     *strictly* text literals */\n    true,\n    false,\n    null,\n    /* TODO */ null,\n    /** TODO: May be null? */ value.sourceSpan!,\n  );\n  job.root.update.push(attrBinding);\n}\n\nexport function ingestHostEvent(job: HostBindingCompilationJob, event: e.ParsedEvent) {\n  let eventBinding: ir.CreateOp;\n  if (event.type === e.ParsedEventType.Animation) {\n    eventBinding = ir.createAnimationListenerOp(\n      job.root.xref,\n      new ir.SlotHandle(),\n      event.name,\n      null,\n      makeListenerHandlerOps(job.root, event.handler, event.handlerSpan),\n      event.name.endsWith('enter') ? ir.AnimationKind.ENTER : ir.AnimationKind.LEAVE,\n      event.targetOrPhase,\n      true,\n      event.sourceSpan,\n    );\n  } else {\n    const [phase, target] =\n      event.type !== e.ParsedEventType.LegacyAnimation\n        ? [null, event.targetOrPhase]\n        : [event.targetOrPhase, null];\n\n    eventBinding = ir.createListenerOp(\n      job.root.xref,\n      new ir.SlotHandle(),\n      event.name,\n      null,\n      makeListenerHandlerOps(job.root, event.handler, event.handlerSpan),\n      phase,\n      target,\n      true,\n      event.sourceSpan,\n    );\n  }\n  job.root.create.push(eventBinding);\n}\n\n/**\n * Ingest the nodes of a template AST into the given `ViewCompilation`.\n */\nfunction ingestNodes(unit: ViewCompilationUnit, template: t.Node[]): void {\n  for (const node of template) {\n    if (node instanceof t.Element) {\n      ingestElement(unit, node);\n    } else if (node instanceof t.Template) {\n      ingestTemplate(unit, node);\n    } else if (node instanceof t.Content) {\n      ingestContent(unit, node);\n    } else if (node instanceof t.Text) {\n      ingestText(unit, node, null);\n    } else if (node instanceof t.BoundText) {\n      ingestBoundText(unit, node, null);\n    } else if (node instanceof t.IfBlock) {\n      ingestIfBlock(unit, node);\n    } else if (node instanceof t.SwitchBlock) {\n      ingestSwitchBlock(unit, node);\n    } else if (node instanceof t.DeferredBlock) {\n      ingestDeferBlock(unit, node);\n    } else if (node instanceof t.Icu) {\n      ingestIcu(unit, node);\n    } else if (node instanceof t.ForLoopBlock) {\n      ingestForBlock(unit, node);\n    } else if (node instanceof t.LetDeclaration) {\n      ingestLetDeclaration(unit, node);\n    } else if (node instanceof t.Component) {\n      // TODO(crisbeto): account for selectorless nodes.\n    } else {\n      throw new Error(`Unsupported template node: ${node.constructor.name}`);\n    }\n  }\n}\n\n/**\n * Ingest an element AST from the template into the given `ViewCompilation`.\n */\nfunction ingestElement(unit: ViewCompilationUnit, element: t.Element): void {\n  if (\n    element.i18n !== undefined &&\n    !(element.i18n instanceof i18n.Message || element.i18n instanceof i18n.TagPlaceholder)\n  ) {\n    throw Error(`Unhandled i18n metadata type for element: ${element.i18n.constructor.name}`);\n  }\n\n  const id = unit.job.allocateXrefId();\n\n  const [namespaceKey, elementName] = splitNsName(element.name);\n\n  const startOp = ir.createElementStartOp(\n    elementName,\n    id,\n    namespaceForKey(namespaceKey),\n    element.i18n instanceof i18n.TagPlaceholder ? element.i18n : undefined,\n    element.startSourceSpan,\n    element.sourceSpan,\n  );\n  unit.create.push(startOp);\n\n  ingestElementBindings(unit, startOp, element);\n  ingestReferences(startOp, element);\n\n  // Start i18n, if needed, goes after the element create and bindings, but before the nodes\n  let i18nBlockId: ir.XrefId | null = null;\n  if (element.i18n instanceof i18n.Message) {\n    i18nBlockId = unit.job.allocateXrefId();\n    unit.create.push(\n      ir.createI18nStartOp(i18nBlockId, element.i18n, undefined, element.startSourceSpan),\n    );\n  }\n\n  ingestNodes(unit, element.children);\n\n  // The source span for the end op is typically the element closing tag. However, if no closing tag\n  // exists, such as in `<input>`, we use the start source span instead. Usually the start and end\n  // instructions will be collapsed into one `element` instruction, negating the purpose of this\n  // fallback, but in cases when it is not collapsed (such as an input with a binding), we still\n  // want to map the end instruction to the main element.\n  const endOp = ir.createElementEndOp(id, element.endSourceSpan ?? element.startSourceSpan);\n  unit.create.push(endOp);\n\n  // If there is an i18n message associated with this element, insert i18n start and end ops.\n  if (i18nBlockId !== null) {\n    ir.OpList.insertBefore<ir.CreateOp>(\n      ir.createI18nEndOp(i18nBlockId, element.endSourceSpan ?? element.startSourceSpan),\n      endOp,\n    );\n  }\n}\n\n/**\n * Ingest an `ng-template` node from the AST into the given `ViewCompilation`.\n */\nfunction ingestTemplate(unit: ViewCompilationUnit, tmpl: t.Template): void {\n  if (\n    tmpl.i18n !== undefined &&\n    !(tmpl.i18n instanceof i18n.Message || tmpl.i18n instanceof i18n.TagPlaceholder)\n  ) {\n    throw Error(`Unhandled i18n metadata type for template: ${tmpl.i18n.constructor.name}`);\n  }\n\n  const childView = unit.job.allocateView(unit.xref);\n\n  let tagNameWithoutNamespace = tmpl.tagName;\n  let namespacePrefix: string | null = '';\n  if (tmpl.tagName) {\n    [namespacePrefix, tagNameWithoutNamespace] = splitNsName(tmpl.tagName);\n  }\n\n  const i18nPlaceholder = tmpl.i18n instanceof i18n.TagPlaceholder ? tmpl.i18n : undefined;\n  const namespace = namespaceForKey(namespacePrefix);\n  const functionNameSuffix =\n    tagNameWithoutNamespace === null ? '' : prefixWithNamespace(tagNameWithoutNamespace, namespace);\n  const templateKind = isPlainTemplate(tmpl)\n    ? ir.TemplateKind.NgTemplate\n    : ir.TemplateKind.Structural;\n  const templateOp = ir.createTemplateOp(\n    childView.xref,\n    templateKind,\n    tagNameWithoutNamespace,\n    functionNameSuffix,\n    namespace,\n    i18nPlaceholder,\n    tmpl.startSourceSpan,\n    tmpl.sourceSpan,\n  );\n  unit.create.push(templateOp);\n\n  ingestTemplateBindings(unit, templateOp, tmpl, templateKind);\n  ingestReferences(templateOp, tmpl);\n  ingestNodes(childView, tmpl.children);\n\n  for (const {name, value} of tmpl.variables) {\n    childView.contextVariables.set(name, value !== '' ? value : '$implicit');\n  }\n\n  // If this is a plain template and there is an i18n message associated with it, insert i18n start\n  // and end ops. For structural directive templates, the i18n ops will be added when ingesting the\n  // element/template the directive is placed on.\n  if (templateKind === ir.TemplateKind.NgTemplate && tmpl.i18n instanceof i18n.Message) {\n    const id = unit.job.allocateXrefId();\n    ir.OpList.insertAfter(\n      ir.createI18nStartOp(id, tmpl.i18n, undefined, tmpl.startSourceSpan),\n      childView.create.head,\n    );\n    ir.OpList.insertBefore(\n      ir.createI18nEndOp(id, tmpl.endSourceSpan ?? tmpl.startSourceSpan),\n      childView.create.tail,\n    );\n  }\n}\n\n/**\n * Ingest a content node from the AST into the given `ViewCompilation`.\n */\nfunction ingestContent(unit: ViewCompilationUnit, content: t.Content): void {\n  if (content.i18n !== undefined && !(content.i18n instanceof i18n.TagPlaceholder)) {\n    throw Error(`Unhandled i18n metadata type for element: ${content.i18n.constructor.name}`);\n  }\n\n  let fallbackView: ViewCompilationUnit | null = null;\n\n  // Don't capture default content that's only made up of empty text nodes and comments.\n  // Note that we process the default content before the projection in order to match the\n  // insertion order at runtime.\n  if (\n    content.children.some(\n      (child) =>\n        !(child instanceof t.Comment) &&\n        (!(child instanceof t.Text) || child.value.trim().length > 0),\n    )\n  ) {\n    fallbackView = unit.job.allocateView(unit.xref);\n    ingestNodes(fallbackView, content.children);\n  }\n\n  const id = unit.job.allocateXrefId();\n  const op = ir.createProjectionOp(\n    id,\n    content.selector,\n    content.i18n,\n    fallbackView?.xref ?? null,\n    content.sourceSpan,\n  );\n  for (const attr of content.attributes) {\n    const securityContext = domSchema.securityContext(content.name, attr.name, true);\n    unit.update.push(\n      ir.createBindingOp(\n        op.xref,\n        ir.BindingKind.Attribute,\n        attr.name,\n        o.literal(attr.value),\n        null,\n        securityContext,\n        true,\n        false,\n        null,\n        asMessage(attr.i18n),\n        attr.sourceSpan,\n      ),\n    );\n  }\n  unit.create.push(op);\n}\n\n/**\n * Ingest a literal text node from the AST into the given `ViewCompilation`.\n */\nfunction ingestText(unit: ViewCompilationUnit, text: t.Text, icuPlaceholder: string | null): void {\n  unit.create.push(\n    ir.createTextOp(unit.job.allocateXrefId(), text.value, icuPlaceholder, text.sourceSpan),\n  );\n}\n\n/**\n * Ingest an interpolated text node from the AST into the given `ViewCompilation`.\n */\nfunction ingestBoundText(\n  unit: ViewCompilationUnit,\n  text: t.BoundText,\n  icuPlaceholder: string | null,\n): void {\n  let value = text.value;\n  if (value instanceof e.ASTWithSource) {\n    value = value.ast;\n  }\n  if (!(value instanceof e.Interpolation)) {\n    throw new Error(\n      `AssertionError: expected Interpolation for BoundText node, got ${value.constructor.name}`,\n    );\n  }\n  if (text.i18n !== undefined && !(text.i18n instanceof i18n.Container)) {\n    throw Error(\n      `Unhandled i18n metadata type for text interpolation: ${text.i18n?.constructor.name}`,\n    );\n  }\n\n  const i18nPlaceholders =\n    text.i18n instanceof i18n.Container\n      ? text.i18n.children\n          .filter((node): node is i18n.Placeholder => node instanceof i18n.Placeholder)\n          .map((placeholder) => placeholder.name)\n      : [];\n  if (i18nPlaceholders.length > 0 && i18nPlaceholders.length !== value.expressions.length) {\n    throw Error(\n      `Unexpected number of i18n placeholders (${value.expressions.length}) for BoundText with ${value.expressions.length} expressions`,\n    );\n  }\n\n  const textXref = unit.job.allocateXrefId();\n  unit.create.push(ir.createTextOp(textXref, '', icuPlaceholder, text.sourceSpan));\n  // TemplateDefinitionBuilder does not generate source maps for sub-expressions inside an\n  // interpolation. We copy that behavior in compatibility mode.\n  // TODO: is it actually correct to generate these extra maps in modern mode?\n  const baseSourceSpan = unit.job.compatibility ? null : text.sourceSpan;\n  unit.update.push(\n    ir.createInterpolateTextOp(\n      textXref,\n      new ir.Interpolation(\n        value.strings,\n        value.expressions.map((expr) => convertAst(expr, unit.job, baseSourceSpan)),\n        i18nPlaceholders,\n      ),\n      text.sourceSpan,\n    ),\n  );\n}\n\n/**\n * Ingest an `@if` block into the given `ViewCompilation`.\n */\nfunction ingestIfBlock(unit: ViewCompilationUnit, ifBlock: t.IfBlock): void {\n  let firstXref: ir.XrefId | null = null;\n  let conditions: Array<ir.ConditionalCaseExpr> = [];\n  for (let i = 0; i < ifBlock.branches.length; i++) {\n    const ifCase = ifBlock.branches[i];\n    const cView = unit.job.allocateView(unit.xref);\n    const tagName = ingestControlFlowInsertionPoint(unit, cView.xref, ifCase);\n\n    if (ifCase.expressionAlias !== null) {\n      cView.contextVariables.set(ifCase.expressionAlias.name, ir.CTX_REF);\n    }\n\n    let ifCaseI18nMeta: i18n.BlockPlaceholder | undefined = undefined;\n    if (ifCase.i18n !== undefined) {\n      if (!(ifCase.i18n instanceof i18n.BlockPlaceholder)) {\n        throw Error(`Unhandled i18n metadata type for if block: ${ifCase.i18n?.constructor.name}`);\n      }\n      ifCaseI18nMeta = ifCase.i18n;\n    }\n\n    const createOp = i === 0 ? ir.createConditionalCreateOp : ir.createConditionalBranchCreateOp;\n\n    const conditionalCreateOp = createOp(\n      cView.xref,\n      ir.TemplateKind.Block,\n      tagName,\n      'Conditional',\n      ir.Namespace.HTML,\n      ifCaseI18nMeta,\n      ifCase.startSourceSpan,\n      ifCase.sourceSpan,\n    );\n    unit.create.push(conditionalCreateOp);\n\n    if (firstXref === null) {\n      firstXref = cView.xref;\n    }\n\n    const caseExpr = ifCase.expression ? convertAst(ifCase.expression, unit.job, null) : null;\n    const conditionalCaseExpr = new ir.ConditionalCaseExpr(\n      caseExpr,\n      conditionalCreateOp.xref,\n      conditionalCreateOp.handle,\n      ifCase.expressionAlias,\n    );\n    conditions.push(conditionalCaseExpr);\n    ingestNodes(cView, ifCase.children);\n  }\n  unit.update.push(ir.createConditionalOp(firstXref!, null, conditions, ifBlock.sourceSpan));\n}\n\n/**\n * Ingest an `@switch` block into the given `ViewCompilation`.\n */\nfunction ingestSwitchBlock(unit: ViewCompilationUnit, switchBlock: t.SwitchBlock): void {\n  // Don't ingest empty switches since they won't render anything.\n  if (switchBlock.cases.length === 0) {\n    return;\n  }\n\n  let firstXref: ir.XrefId | null = null;\n  let conditions: Array<ir.ConditionalCaseExpr> = [];\n  for (let i = 0; i < switchBlock.cases.length; i++) {\n    const switchCase = switchBlock.cases[i];\n    const cView = unit.job.allocateView(unit.xref);\n    const tagName = ingestControlFlowInsertionPoint(unit, cView.xref, switchCase);\n    let switchCaseI18nMeta: i18n.BlockPlaceholder | undefined = undefined;\n    if (switchCase.i18n !== undefined) {\n      if (!(switchCase.i18n instanceof i18n.BlockPlaceholder)) {\n        throw Error(\n          `Unhandled i18n metadata type for switch block: ${switchCase.i18n?.constructor.name}`,\n        );\n      }\n      switchCaseI18nMeta = switchCase.i18n;\n    }\n\n    const createOp = i === 0 ? ir.createConditionalCreateOp : ir.createConditionalBranchCreateOp;\n\n    const conditionalCreateOp = createOp(\n      cView.xref,\n      ir.TemplateKind.Block,\n      tagName,\n      'Case',\n      ir.Namespace.HTML,\n      switchCaseI18nMeta,\n      switchCase.startSourceSpan,\n      switchCase.sourceSpan,\n    );\n    unit.create.push(conditionalCreateOp);\n\n    if (firstXref === null) {\n      firstXref = cView.xref;\n    }\n    const caseExpr = switchCase.expression\n      ? convertAst(switchCase.expression, unit.job, switchBlock.startSourceSpan)\n      : null;\n    const conditionalCaseExpr = new ir.ConditionalCaseExpr(\n      caseExpr,\n      conditionalCreateOp.xref,\n      conditionalCreateOp.handle,\n    );\n    conditions.push(conditionalCaseExpr);\n    ingestNodes(cView, switchCase.children);\n  }\n  unit.update.push(\n    ir.createConditionalOp(\n      firstXref!,\n      convertAst(switchBlock.expression, unit.job, null),\n      conditions,\n      switchBlock.sourceSpan,\n    ),\n  );\n}\n\nfunction ingestDeferView(\n  unit: ViewCompilationUnit,\n  suffix: string,\n  i18nMeta: i18n.I18nMeta | undefined,\n  children?: t.Node[],\n  sourceSpan?: ParseSourceSpan,\n): ir.TemplateOp | null {\n  if (i18nMeta !== undefined && !(i18nMeta instanceof i18n.BlockPlaceholder)) {\n    throw Error('Unhandled i18n metadata type for defer block');\n  }\n  if (children === undefined) {\n    return null;\n  }\n  const secondaryView = unit.job.allocateView(unit.xref);\n  ingestNodes(secondaryView, children);\n  const templateOp = ir.createTemplateOp(\n    secondaryView.xref,\n    ir.TemplateKind.Block,\n    null,\n    `Defer${suffix}`,\n    ir.Namespace.HTML,\n    i18nMeta,\n    sourceSpan!,\n    sourceSpan!,\n  );\n  unit.create.push(templateOp);\n  return templateOp;\n}\n\nfunction ingestDeferBlock(unit: ViewCompilationUnit, deferBlock: t.DeferredBlock): void {\n  let ownResolverFn: o.Expression | null = null;\n\n  if (unit.job.deferMeta.mode === DeferBlockDepsEmitMode.PerBlock) {\n    if (!unit.job.deferMeta.blocks.has(deferBlock)) {\n      throw new Error(\n        `AssertionError: unable to find a dependency function for this deferred block`,\n      );\n    }\n    ownResolverFn = unit.job.deferMeta.blocks.get(deferBlock) ?? null;\n  }\n\n  // Generate the defer main view and all secondary views.\n  const main = ingestDeferView(\n    unit,\n    '',\n    deferBlock.i18n,\n    deferBlock.children,\n    deferBlock.sourceSpan,\n  )!;\n  const loading = ingestDeferView(\n    unit,\n    'Loading',\n    deferBlock.loading?.i18n,\n    deferBlock.loading?.children,\n    deferBlock.loading?.sourceSpan,\n  );\n  const placeholder = ingestDeferView(\n    unit,\n    'Placeholder',\n    deferBlock.placeholder?.i18n,\n    deferBlock.placeholder?.children,\n    deferBlock.placeholder?.sourceSpan,\n  );\n  const error = ingestDeferView(\n    unit,\n    'Error',\n    deferBlock.error?.i18n,\n    deferBlock.error?.children,\n    deferBlock.error?.sourceSpan,\n  );\n\n  // Create the main defer op, and ops for all secondary views.\n  const deferXref = unit.job.allocateXrefId();\n  const deferOp = ir.createDeferOp(\n    deferXref,\n    main.xref,\n    main.handle,\n    ownResolverFn,\n    unit.job.allDeferrableDepsFn,\n    deferBlock.sourceSpan,\n  );\n  deferOp.placeholderView = placeholder?.xref ?? null;\n  deferOp.placeholderSlot = placeholder?.handle ?? null;\n  deferOp.loadingSlot = loading?.handle ?? null;\n  deferOp.errorSlot = error?.handle ?? null;\n  deferOp.placeholderMinimumTime = deferBlock.placeholder?.minimumTime ?? null;\n  deferOp.loadingMinimumTime = deferBlock.loading?.minimumTime ?? null;\n  deferOp.loadingAfterTime = deferBlock.loading?.afterTime ?? null;\n  deferOp.flags = calcDeferBlockFlags(deferBlock);\n  unit.create.push(deferOp);\n\n  // Configure all defer `on` conditions.\n  // TODO: refactor prefetch triggers to use a separate op type, with a shared superclass. This will\n  // make it easier to refactor prefetch behavior in the future.\n  const deferOnOps: ir.DeferOnOp[] = [];\n  const deferWhenOps: ir.DeferWhenOp[] = [];\n\n  // Ingest the hydrate triggers first since they set up all the other triggers during SSR.\n  ingestDeferTriggers(\n    ir.DeferOpModifierKind.HYDRATE,\n    deferBlock.hydrateTriggers,\n    deferOnOps,\n    deferWhenOps,\n    unit,\n    deferXref,\n  );\n\n  ingestDeferTriggers(\n    ir.DeferOpModifierKind.NONE,\n    deferBlock.triggers,\n    deferOnOps,\n    deferWhenOps,\n    unit,\n    deferXref,\n  );\n\n  ingestDeferTriggers(\n    ir.DeferOpModifierKind.PREFETCH,\n    deferBlock.prefetchTriggers,\n    deferOnOps,\n    deferWhenOps,\n    unit,\n    deferXref,\n  );\n\n  // If no (non-prefetching or hydrating) defer triggers were provided, default to `idle`.\n  const hasConcreteTrigger =\n    deferOnOps.some((op) => op.modifier === ir.DeferOpModifierKind.NONE) ||\n    deferWhenOps.some((op) => op.modifier === ir.DeferOpModifierKind.NONE);\n\n  if (!hasConcreteTrigger) {\n    deferOnOps.push(\n      ir.createDeferOnOp(\n        deferXref,\n        {kind: ir.DeferTriggerKind.Idle},\n        ir.DeferOpModifierKind.NONE,\n        null!,\n      ),\n    );\n  }\n\n  unit.create.push(deferOnOps);\n  unit.update.push(deferWhenOps);\n}\n\nfunction calcDeferBlockFlags(deferBlockDetails: t.DeferredBlock): ir.TDeferDetailsFlags | null {\n  if (Object.keys(deferBlockDetails.hydrateTriggers).length > 0) {\n    return ir.TDeferDetailsFlags.HasHydrateTriggers;\n  }\n  return null;\n}\n\nfunction ingestDeferTriggers(\n  modifier: ir.DeferOpModifierKind,\n  triggers: Readonly<t.DeferredBlockTriggers>,\n  onOps: ir.DeferOnOp[],\n  whenOps: ir.DeferWhenOp[],\n  unit: ViewCompilationUnit,\n  deferXref: ir.XrefId,\n) {\n  if (triggers.idle !== undefined) {\n    const deferOnOp = ir.createDeferOnOp(\n      deferXref,\n      {kind: ir.DeferTriggerKind.Idle},\n      modifier,\n      triggers.idle.sourceSpan,\n    );\n    onOps.push(deferOnOp);\n  }\n  if (triggers.immediate !== undefined) {\n    const deferOnOp = ir.createDeferOnOp(\n      deferXref,\n      {kind: ir.DeferTriggerKind.Immediate},\n      modifier,\n      triggers.immediate.sourceSpan,\n    );\n    onOps.push(deferOnOp);\n  }\n  if (triggers.timer !== undefined) {\n    const deferOnOp = ir.createDeferOnOp(\n      deferXref,\n      {kind: ir.DeferTriggerKind.Timer, delay: triggers.timer.delay},\n      modifier,\n      triggers.timer.sourceSpan,\n    );\n    onOps.push(deferOnOp);\n  }\n  if (triggers.hover !== undefined) {\n    const deferOnOp = ir.createDeferOnOp(\n      deferXref,\n      {\n        kind: ir.DeferTriggerKind.Hover,\n        targetName: triggers.hover.reference,\n        targetXref: null,\n        targetSlot: null,\n        targetView: null,\n        targetSlotViewSteps: null,\n      },\n      modifier,\n      triggers.hover.sourceSpan,\n    );\n    onOps.push(deferOnOp);\n  }\n  if (triggers.interaction !== undefined) {\n    const deferOnOp = ir.createDeferOnOp(\n      deferXref,\n      {\n        kind: ir.DeferTriggerKind.Interaction,\n        targetName: triggers.interaction.reference,\n        targetXref: null,\n        targetSlot: null,\n        targetView: null,\n        targetSlotViewSteps: null,\n      },\n      modifier,\n      triggers.interaction.sourceSpan,\n    );\n    onOps.push(deferOnOp);\n  }\n  if (triggers.viewport !== undefined) {\n    const deferOnOp = ir.createDeferOnOp(\n      deferXref,\n      {\n        kind: ir.DeferTriggerKind.Viewport,\n        targetName: triggers.viewport.reference,\n        targetXref: null,\n        targetSlot: null,\n        targetView: null,\n        targetSlotViewSteps: null,\n      },\n      modifier,\n      triggers.viewport.sourceSpan,\n    );\n    onOps.push(deferOnOp);\n  }\n  if (triggers.never !== undefined) {\n    const deferOnOp = ir.createDeferOnOp(\n      deferXref,\n      {kind: ir.DeferTriggerKind.Never},\n      modifier,\n      triggers.never.sourceSpan,\n    );\n    onOps.push(deferOnOp);\n  }\n  if (triggers.when !== undefined) {\n    if (triggers.when.value instanceof e.Interpolation) {\n      // TemplateDefinitionBuilder supports this case, but it's very strange to me. What would it\n      // even mean?\n      throw new Error(`Unexpected interpolation in defer block when trigger`);\n    }\n    const deferOnOp = ir.createDeferWhenOp(\n      deferXref,\n      convertAst(triggers.when.value, unit.job, triggers.when.sourceSpan),\n      modifier,\n      triggers.when.sourceSpan,\n    );\n    whenOps.push(deferOnOp);\n  }\n}\n\nfunction ingestIcu(unit: ViewCompilationUnit, icu: t.Icu) {\n  if (icu.i18n instanceof i18n.Message && isSingleI18nIcu(icu.i18n)) {\n    const xref = unit.job.allocateXrefId();\n    unit.create.push(ir.createIcuStartOp(xref, icu.i18n, icuFromI18nMessage(icu.i18n).name, null!));\n    for (const [placeholder, text] of Object.entries({...icu.vars, ...icu.placeholders})) {\n      if (text instanceof t.BoundText) {\n        ingestBoundText(unit, text, placeholder);\n      } else {\n        ingestText(unit, text, placeholder);\n      }\n    }\n    unit.create.push(ir.createIcuEndOp(xref));\n  } else {\n    throw Error(`Unhandled i18n metadata type for ICU: ${icu.i18n?.constructor.name}`);\n  }\n}\n\n/**\n * Ingest an `@for` block into the given `ViewCompilation`.\n */\nfunction ingestForBlock(unit: ViewCompilationUnit, forBlock: t.ForLoopBlock): void {\n  const repeaterView = unit.job.allocateView(unit.xref);\n\n  // We copy TemplateDefinitionBuilder's scheme of creating names for `$count` and `$index`\n  // that are suffixed with special information, to disambiguate which level of nested loop\n  // the below aliases refer to.\n  // TODO: We should refactor Template Pipeline's variable phases to gracefully handle\n  // shadowing, and arbitrarily many levels of variables depending on each other.\n  const indexName = `ɵ$index_${repeaterView.xref}`;\n  const countName = `ɵ$count_${repeaterView.xref}`;\n  const indexVarNames = new Set<string>();\n\n  // Set all the context variables and aliases available in the repeater.\n  repeaterView.contextVariables.set(forBlock.item.name, forBlock.item.value);\n\n  for (const variable of forBlock.contextVariables) {\n    if (variable.value === '$index') {\n      indexVarNames.add(variable.name);\n    }\n    if (variable.name === '$index') {\n      repeaterView.contextVariables.set('$index', variable.value).set(indexName, variable.value);\n    } else if (variable.name === '$count') {\n      repeaterView.contextVariables.set('$count', variable.value).set(countName, variable.value);\n    } else {\n      repeaterView.aliases.add({\n        kind: ir.SemanticVariableKind.Alias,\n        name: null,\n        identifier: variable.name,\n        expression: getComputedForLoopVariableExpression(variable, indexName, countName),\n      });\n    }\n  }\n\n  const sourceSpan = convertSourceSpan(forBlock.trackBy.span, forBlock.sourceSpan);\n  const track = convertAst(forBlock.trackBy, unit.job, sourceSpan);\n\n  ingestNodes(repeaterView, forBlock.children);\n\n  let emptyView: ViewCompilationUnit | null = null;\n  let emptyTagName: string | null = null;\n  if (forBlock.empty !== null) {\n    emptyView = unit.job.allocateView(unit.xref);\n    ingestNodes(emptyView, forBlock.empty.children);\n    emptyTagName = ingestControlFlowInsertionPoint(unit, emptyView.xref, forBlock.empty);\n  }\n\n  const varNames: ir.RepeaterVarNames = {\n    $index: indexVarNames,\n    $implicit: forBlock.item.name,\n  };\n\n  if (forBlock.i18n !== undefined && !(forBlock.i18n instanceof i18n.BlockPlaceholder)) {\n    throw Error('AssertionError: Unhandled i18n metadata type or @for');\n  }\n  if (\n    forBlock.empty?.i18n !== undefined &&\n    !(forBlock.empty.i18n instanceof i18n.BlockPlaceholder)\n  ) {\n    throw Error('AssertionError: Unhandled i18n metadata type or @empty');\n  }\n  const i18nPlaceholder = forBlock.i18n;\n  const emptyI18nPlaceholder = forBlock.empty?.i18n;\n\n  const tagName = ingestControlFlowInsertionPoint(unit, repeaterView.xref, forBlock);\n  const repeaterCreate = ir.createRepeaterCreateOp(\n    repeaterView.xref,\n    emptyView?.xref ?? null,\n    tagName,\n    track,\n    varNames,\n    emptyTagName,\n    i18nPlaceholder,\n    emptyI18nPlaceholder,\n    forBlock.startSourceSpan,\n    forBlock.sourceSpan,\n  );\n  unit.create.push(repeaterCreate);\n\n  const expression = convertAst(\n    forBlock.expression,\n    unit.job,\n    convertSourceSpan(forBlock.expression.span, forBlock.sourceSpan),\n  );\n  const repeater = ir.createRepeaterOp(\n    repeaterCreate.xref,\n    repeaterCreate.handle,\n    expression,\n    forBlock.sourceSpan,\n  );\n  unit.update.push(repeater);\n}\n\n/**\n * Gets an expression that represents a variable in an `@for` loop.\n * @param variable AST representing the variable.\n * @param indexName Loop-specific name for `$index`.\n * @param countName Loop-specific name for `$count`.\n */\nfunction getComputedForLoopVariableExpression(\n  variable: t.Variable,\n  indexName: string,\n  countName: string,\n): o.Expression {\n  switch (variable.value) {\n    case '$index':\n      return new ir.LexicalReadExpr(indexName);\n\n    case '$count':\n      return new ir.LexicalReadExpr(countName);\n\n    case '$first':\n      return new ir.LexicalReadExpr(indexName).identical(o.literal(0));\n\n    case '$last':\n      return new ir.LexicalReadExpr(indexName).identical(\n        new ir.LexicalReadExpr(countName).minus(o.literal(1)),\n      );\n\n    case '$even':\n      return new ir.LexicalReadExpr(indexName).modulo(o.literal(2)).identical(o.literal(0));\n\n    case '$odd':\n      return new ir.LexicalReadExpr(indexName).modulo(o.literal(2)).notIdentical(o.literal(0));\n\n    default:\n      throw new Error(`AssertionError: unknown @for loop variable ${variable.value}`);\n  }\n}\n\nfunction ingestLetDeclaration(unit: ViewCompilationUnit, node: t.LetDeclaration) {\n  const target = unit.job.allocateXrefId();\n\n  unit.create.push(ir.createDeclareLetOp(target, node.name, node.sourceSpan));\n  unit.update.push(\n    ir.createStoreLetOp(\n      target,\n      node.name,\n      convertAst(node.value, unit.job, node.valueSpan),\n      node.sourceSpan,\n    ),\n  );\n}\n\n/**\n * Convert a template AST expression into an output AST expression.\n */\nfunction convertAst(\n  ast: e.AST,\n  job: CompilationJob,\n  baseSourceSpan: ParseSourceSpan | null,\n): o.Expression {\n  if (ast instanceof e.ASTWithSource) {\n    return convertAst(ast.ast, job, baseSourceSpan);\n  } else if (ast instanceof e.PropertyRead) {\n    // Whether this is an implicit receiver, *excluding* explicit reads of `this`.\n    const isImplicitReceiver =\n      ast.receiver instanceof e.ImplicitReceiver && !(ast.receiver instanceof e.ThisReceiver);\n    if (isImplicitReceiver) {\n      return new ir.LexicalReadExpr(ast.name);\n    } else {\n      return new o.ReadPropExpr(\n        convertAst(ast.receiver, job, baseSourceSpan),\n        ast.name,\n        null,\n        convertSourceSpan(ast.span, baseSourceSpan),\n      );\n    }\n  } else if (ast instanceof e.Call) {\n    if (ast.receiver instanceof e.ImplicitReceiver) {\n      throw new Error(`Unexpected ImplicitReceiver`);\n    } else {\n      return new o.InvokeFunctionExpr(\n        convertAst(ast.receiver, job, baseSourceSpan),\n        ast.args.map((arg) => convertAst(arg, job, baseSourceSpan)),\n        undefined,\n        convertSourceSpan(ast.span, baseSourceSpan),\n      );\n    }\n  } else if (ast instanceof e.LiteralPrimitive) {\n    return o.literal(ast.value, undefined, convertSourceSpan(ast.span, baseSourceSpan));\n  } else if (ast instanceof e.Unary) {\n    switch (ast.operator) {\n      case '+':\n        return new o.UnaryOperatorExpr(\n          o.UnaryOperator.Plus,\n          convertAst(ast.expr, job, baseSourceSpan),\n          undefined,\n          convertSourceSpan(ast.span, baseSourceSpan),\n        );\n      case '-':\n        return new o.UnaryOperatorExpr(\n          o.UnaryOperator.Minus,\n          convertAst(ast.expr, job, baseSourceSpan),\n          undefined,\n          convertSourceSpan(ast.span, baseSourceSpan),\n        );\n      default:\n        throw new Error(`AssertionError: unknown unary operator ${ast.operator}`);\n    }\n  } else if (ast instanceof e.Binary) {\n    const operator = BINARY_OPERATORS.get(ast.operation);\n    if (operator === undefined) {\n      throw new Error(`AssertionError: unknown binary operator ${ast.operation}`);\n    }\n    return new o.BinaryOperatorExpr(\n      operator,\n      convertAst(ast.left, job, baseSourceSpan),\n      convertAst(ast.right, job, baseSourceSpan),\n      undefined,\n      convertSourceSpan(ast.span, baseSourceSpan),\n    );\n  } else if (ast instanceof e.ThisReceiver) {\n    // TODO: should context expressions have source maps?\n    return new ir.ContextExpr(job.root.xref);\n  } else if (ast instanceof e.KeyedRead) {\n    return new o.ReadKeyExpr(\n      convertAst(ast.receiver, job, baseSourceSpan),\n      convertAst(ast.key, job, baseSourceSpan),\n      undefined,\n      convertSourceSpan(ast.span, baseSourceSpan),\n    );\n  } else if (ast instanceof e.Chain) {\n    throw new Error(`AssertionError: Chain in unknown context`);\n  } else if (ast instanceof e.LiteralMap) {\n    const entries = ast.keys.map((key, idx) => {\n      const value = ast.values[idx];\n      // TODO: should literals have source maps, or do we just map the whole surrounding\n      // expression?\n      return new o.LiteralMapEntry(key.key, convertAst(value, job, baseSourceSpan), key.quoted);\n    });\n    return new o.LiteralMapExpr(entries, undefined, convertSourceSpan(ast.span, baseSourceSpan));\n  } else if (ast instanceof e.LiteralArray) {\n    // TODO: should literals have source maps, or do we just map the whole surrounding expression?\n    return new o.LiteralArrayExpr(\n      ast.expressions.map((expr) => convertAst(expr, job, baseSourceSpan)),\n    );\n  } else if (ast instanceof e.Conditional) {\n    return new o.ConditionalExpr(\n      convertAst(ast.condition, job, baseSourceSpan),\n      convertAst(ast.trueExp, job, baseSourceSpan),\n      convertAst(ast.falseExp, job, baseSourceSpan),\n      undefined,\n      convertSourceSpan(ast.span, baseSourceSpan),\n    );\n  } else if (ast instanceof e.NonNullAssert) {\n    // A non-null assertion shouldn't impact generated instructions, so we can just drop it.\n    return convertAst(ast.expression, job, baseSourceSpan);\n  } else if (ast instanceof e.BindingPipe) {\n    // TODO: pipes should probably have source maps; figure out details.\n    return new ir.PipeBindingExpr(job.allocateXrefId(), new ir.SlotHandle(), ast.name, [\n      convertAst(ast.exp, job, baseSourceSpan),\n      ...ast.args.map((arg) => convertAst(arg, job, baseSourceSpan)),\n    ]);\n  } else if (ast instanceof e.SafeKeyedRead) {\n    return new ir.SafeKeyedReadExpr(\n      convertAst(ast.receiver, job, baseSourceSpan),\n      convertAst(ast.key, job, baseSourceSpan),\n      convertSourceSpan(ast.span, baseSourceSpan),\n    );\n  } else if (ast instanceof e.SafePropertyRead) {\n    // TODO: source span\n    return new ir.SafePropertyReadExpr(convertAst(ast.receiver, job, baseSourceSpan), ast.name);\n  } else if (ast instanceof e.SafeCall) {\n    // TODO: source span\n    return new ir.SafeInvokeFunctionExpr(\n      convertAst(ast.receiver, job, baseSourceSpan),\n      ast.args.map((a) => convertAst(a, job, baseSourceSpan)),\n    );\n  } else if (ast instanceof e.EmptyExpr) {\n    return new ir.EmptyExpr(convertSourceSpan(ast.span, baseSourceSpan));\n  } else if (ast instanceof e.PrefixNot) {\n    return o.not(\n      convertAst(ast.expression, job, baseSourceSpan),\n      convertSourceSpan(ast.span, baseSourceSpan),\n    );\n  } else if (ast instanceof e.TypeofExpression) {\n    return o.typeofExpr(convertAst(ast.expression, job, baseSourceSpan));\n  } else if (ast instanceof e.VoidExpression) {\n    return new o.VoidExpr(\n      convertAst(ast.expression, job, baseSourceSpan),\n      undefined,\n      convertSourceSpan(ast.span, baseSourceSpan),\n    );\n  } else if (ast instanceof e.TemplateLiteral) {\n    return convertTemplateLiteral(ast, job, baseSourceSpan);\n  } else if (ast instanceof e.TaggedTemplateLiteral) {\n    return new o.TaggedTemplateLiteralExpr(\n      convertAst(ast.tag, job, baseSourceSpan),\n      convertTemplateLiteral(ast.template, job, baseSourceSpan),\n      undefined,\n      convertSourceSpan(ast.span, baseSourceSpan),\n    );\n  } else if (ast instanceof e.ParenthesizedExpression) {\n    return new o.ParenthesizedExpr(\n      convertAst(ast.expression, job, baseSourceSpan),\n      undefined,\n      convertSourceSpan(ast.span, baseSourceSpan),\n    );\n  } else {\n    throw new Error(\n      `Unhandled expression type \"${ast.constructor.name}\" in file \"${baseSourceSpan?.start.file.url}\"`,\n    );\n  }\n}\n\nfunction convertTemplateLiteral(\n  ast: e.TemplateLiteral,\n  job: CompilationJob,\n  baseSourceSpan: ParseSourceSpan | null,\n) {\n  return new o.TemplateLiteralExpr(\n    ast.elements.map((el) => {\n      return new o.TemplateLiteralElementExpr(el.text, convertSourceSpan(el.span, baseSourceSpan));\n    }),\n    ast.expressions.map((expr) => convertAst(expr, job, baseSourceSpan)),\n    convertSourceSpan(ast.span, baseSourceSpan),\n  );\n}\n\nfunction convertAstWithInterpolation(\n  job: CompilationJob,\n  value: e.AST | string,\n  i18nMeta: i18n.I18nMeta | null | undefined,\n  sourceSpan?: ParseSourceSpan,\n): o.Expression | ir.Interpolation {\n  let expression: o.Expression | ir.Interpolation;\n  if (value instanceof e.Interpolation) {\n    expression = new ir.Interpolation(\n      value.strings,\n      value.expressions.map((e) => convertAst(e, job, sourceSpan ?? null)),\n      Object.keys(asMessage(i18nMeta)?.placeholders ?? {}),\n    );\n  } else if (value instanceof e.AST) {\n    expression = convertAst(value, job, sourceSpan ?? null);\n  } else {\n    expression = o.literal(value);\n  }\n  return expression;\n}\n\n// TODO: Can we populate Template binding kinds in ingest?\nconst BINDING_KINDS = new Map<e.BindingType, ir.BindingKind>([\n  [e.BindingType.Property, ir.BindingKind.Property],\n  [e.BindingType.TwoWay, ir.BindingKind.TwoWayProperty],\n  [e.BindingType.Attribute, ir.BindingKind.Attribute],\n  [e.BindingType.Class, ir.BindingKind.ClassName],\n  [e.BindingType.Style, ir.BindingKind.StyleProperty],\n  [e.BindingType.LegacyAnimation, ir.BindingKind.LegacyAnimation],\n  [e.BindingType.Animation, ir.BindingKind.Animation],\n]);\n\n/**\n * Checks whether the given template is a plain ng-template (as opposed to another kind of template\n * such as a structural directive template or control flow template). This is checked based on the\n * tagName. We can expect that only plain ng-templates will come through with a tagName of\n * 'ng-template'.\n *\n * Here are some of the cases we expect:\n *\n * | Angular HTML                       | Template tagName   |\n * | ---------------------------------- | ------------------ |\n * | `<ng-template>`                    | 'ng-template'      |\n * | `<div *ngIf=\"true\">`               | 'div'              |\n * | `<svg><ng-template>`               | 'svg:ng-template'  |\n * | `@if (true) {`                     | 'Conditional'      |\n * | `<ng-template *ngIf>` (plain)      | 'ng-template'      |\n * | `<ng-template *ngIf>` (structural) | null               |\n */\nfunction isPlainTemplate(tmpl: t.Template) {\n  return splitNsName(tmpl.tagName ?? '')[1] === NG_TEMPLATE_TAG_NAME;\n}\n\n/**\n * Ensures that the i18nMeta, if provided, is an i18n.Message.\n */\nfunction asMessage(i18nMeta: i18n.I18nMeta | null | undefined): i18n.Message | null {\n  if (i18nMeta == null) {\n    return null;\n  }\n  if (!(i18nMeta instanceof i18n.Message)) {\n    throw Error(`Expected i18n meta to be a Message, but got: ${i18nMeta.constructor.name}`);\n  }\n  return i18nMeta;\n}\n\n/**\n * Process all of the bindings on an element in the template AST and convert them to their IR\n * representation.\n */\nfunction ingestElementBindings(\n  unit: ViewCompilationUnit,\n  op: ir.ElementOpBase,\n  element: t.Element,\n): void {\n  let bindings = new Array<ir.BindingOp | ir.ExtractedAttributeOp | null>();\n  let i18nAttributeBindingNames = new Set<string>();\n\n  for (const attr of element.attributes) {\n    // Attribute literal bindings, such as `attr.foo=\"bar\"`.\n    const securityContext = domSchema.securityContext(element.name, attr.name, true);\n    bindings.push(\n      ir.createBindingOp(\n        op.xref,\n        ir.BindingKind.Attribute,\n        attr.name,\n        convertAstWithInterpolation(unit.job, attr.value, attr.i18n),\n        null,\n        securityContext,\n        true,\n        false,\n        null,\n        asMessage(attr.i18n),\n        attr.sourceSpan,\n      ),\n    );\n    if (attr.i18n) {\n      i18nAttributeBindingNames.add(attr.name);\n    }\n  }\n\n  for (const input of element.inputs) {\n    if (i18nAttributeBindingNames.has(input.name)) {\n      console.error(\n        `On component ${unit.job.componentName}, the binding ${input.name} is both an i18n attribute and a property. You may want to remove the property binding. This will become a compilation error in future versions of Angular.`,\n      );\n    }\n    // All dynamic bindings (both attribute and property bindings).\n    bindings.push(\n      ir.createBindingOp(\n        op.xref,\n        BINDING_KINDS.get(input.type)!,\n        input.name,\n        convertAstWithInterpolation(unit.job, astOf(input.value), input.i18n),\n        input.unit,\n        input.securityContext,\n        false,\n        false,\n        null,\n        asMessage(input.i18n) ?? null,\n        input.sourceSpan,\n      ),\n    );\n  }\n\n  unit.create.push(\n    bindings.filter((b): b is ir.ExtractedAttributeOp => b?.kind === ir.OpKind.ExtractedAttribute),\n  );\n  unit.update.push(bindings.filter((b): b is ir.BindingOp => b?.kind === ir.OpKind.Binding));\n\n  for (const output of element.outputs) {\n    if (output.type === e.ParsedEventType.LegacyAnimation && output.phase === null) {\n      throw Error('Animation listener should have a phase');\n    }\n\n    if (output.type === e.ParsedEventType.TwoWay) {\n      unit.create.push(\n        ir.createTwoWayListenerOp(\n          op.xref,\n          op.handle,\n          output.name,\n          op.tag,\n          makeTwoWayListenerHandlerOps(unit, output.handler, output.handlerSpan),\n          output.sourceSpan,\n        ),\n      );\n    } else if (output.type === e.ParsedEventType.Animation) {\n      unit.create.push(\n        ir.createAnimationListenerOp(\n          op.xref,\n          op.handle,\n          output.name,\n          op.tag,\n          makeListenerHandlerOps(unit, output.handler, output.handlerSpan),\n          output.name.endsWith('enter') ? ir.AnimationKind.ENTER : ir.AnimationKind.LEAVE,\n          output.target,\n          false,\n          output.sourceSpan,\n        ),\n      );\n    } else {\n      unit.create.push(\n        ir.createListenerOp(\n          op.xref,\n          op.handle,\n          output.name,\n          op.tag,\n          makeListenerHandlerOps(unit, output.handler, output.handlerSpan),\n          output.phase,\n          output.target,\n          false,\n          output.sourceSpan,\n        ),\n      );\n    }\n  }\n\n  // If any of the bindings on this element have an i18n message, then an i18n attrs configuration\n  // op is also required.\n  if (bindings.some((b) => b?.i18nMessage) !== null) {\n    unit.create.push(\n      ir.createI18nAttributesOp(unit.job.allocateXrefId(), new ir.SlotHandle(), op.xref),\n    );\n  }\n}\n\n/**\n * Process all of the bindings on a template in the template AST and convert them to their IR\n * representation.\n */\nfunction ingestTemplateBindings(\n  unit: ViewCompilationUnit,\n  op: ir.ElementOpBase,\n  template: t.Template,\n  templateKind: ir.TemplateKind | null,\n): void {\n  let bindings = new Array<ir.BindingOp | ir.ExtractedAttributeOp | null>();\n  for (const attr of template.templateAttrs) {\n    if (attr instanceof t.TextAttribute) {\n      const securityContext = domSchema.securityContext(NG_TEMPLATE_TAG_NAME, attr.name, true);\n      bindings.push(\n        createTemplateBinding(\n          unit,\n          op.xref,\n          e.BindingType.Attribute,\n          attr.name,\n          attr.value,\n          null,\n          securityContext,\n          true,\n          templateKind,\n          asMessage(attr.i18n),\n          attr.sourceSpan,\n        ),\n      );\n    } else {\n      bindings.push(\n        createTemplateBinding(\n          unit,\n          op.xref,\n          attr.type,\n          attr.name,\n          astOf(attr.value),\n          attr.unit,\n          attr.securityContext,\n          true,\n          templateKind,\n          asMessage(attr.i18n),\n          attr.sourceSpan,\n        ),\n      );\n    }\n  }\n\n  for (const attr of template.attributes) {\n    // Attribute literal bindings, such as `attr.foo=\"bar\"`.\n    const securityContext = domSchema.securityContext(NG_TEMPLATE_TAG_NAME, attr.name, true);\n    bindings.push(\n      createTemplateBinding(\n        unit,\n        op.xref,\n        e.BindingType.Attribute,\n        attr.name,\n        attr.value,\n        null,\n        securityContext,\n        false,\n        templateKind,\n        asMessage(attr.i18n),\n        attr.sourceSpan,\n      ),\n    );\n  }\n\n  for (const input of template.inputs) {\n    // Dynamic bindings (both attribute and property bindings).\n    bindings.push(\n      createTemplateBinding(\n        unit,\n        op.xref,\n        input.type,\n        input.name,\n        astOf(input.value),\n        input.unit,\n        input.securityContext,\n        false,\n        templateKind,\n        asMessage(input.i18n),\n        input.sourceSpan,\n      ),\n    );\n  }\n\n  unit.create.push(\n    bindings.filter((b): b is ir.ExtractedAttributeOp => b?.kind === ir.OpKind.ExtractedAttribute),\n  );\n  unit.update.push(bindings.filter((b): b is ir.BindingOp => b?.kind === ir.OpKind.Binding));\n\n  for (const output of template.outputs) {\n    if (output.type === e.ParsedEventType.LegacyAnimation && output.phase === null) {\n      throw Error('Animation listener should have a phase');\n    }\n\n    if (templateKind === ir.TemplateKind.NgTemplate) {\n      if (output.type === e.ParsedEventType.TwoWay) {\n        unit.create.push(\n          ir.createTwoWayListenerOp(\n            op.xref,\n            op.handle,\n            output.name,\n            op.tag,\n            makeTwoWayListenerHandlerOps(unit, output.handler, output.handlerSpan),\n            output.sourceSpan,\n          ),\n        );\n      } else {\n        unit.create.push(\n          ir.createListenerOp(\n            op.xref,\n            op.handle,\n            output.name,\n            op.tag,\n            makeListenerHandlerOps(unit, output.handler, output.handlerSpan),\n            output.phase,\n            output.target,\n            false,\n            output.sourceSpan,\n          ),\n        );\n      }\n    }\n    if (\n      templateKind === ir.TemplateKind.Structural &&\n      output.type !== e.ParsedEventType.LegacyAnimation\n    ) {\n      // Animation bindings are excluded from the structural template's const array.\n      const securityContext = domSchema.securityContext(NG_TEMPLATE_TAG_NAME, output.name, false);\n      unit.create.push(\n        ir.createExtractedAttributeOp(\n          op.xref,\n          ir.BindingKind.Property,\n          null,\n          output.name,\n          null,\n          null,\n          null,\n          securityContext,\n        ),\n      );\n    }\n  }\n\n  // TODO: Perhaps we could do this in a phase? (It likely wouldn't change the slot indices.)\n  if (bindings.some((b) => b?.i18nMessage) !== null) {\n    unit.create.push(\n      ir.createI18nAttributesOp(unit.job.allocateXrefId(), new ir.SlotHandle(), op.xref),\n    );\n  }\n}\n\n/**\n * Helper to ingest an individual binding on a template, either an explicit `ng-template`, or an\n * implicit template created via structural directive.\n *\n * Bindings on templates are *extremely* tricky. I have tried to isolate all of the confusing edge\n * cases into this function, and to comment it well to document the behavior.\n *\n * Some of this behavior is intuitively incorrect, and we should consider changing it in the future.\n *\n * @param view The compilation unit for the view containing the template.\n * @param xref The xref of the template op.\n * @param type The binding type, according to the parser. This is fairly reasonable, e.g. both\n *     dynamic and static attributes have e.BindingType.Attribute.\n * @param name The binding's name.\n * @param value The bindings's value, which will either be an input AST expression, or a string\n *     literal. Note that the input AST expression may or may not be const -- it will only be a\n *     string literal if the parser considered it a text binding.\n * @param unit If the binding has a unit (e.g. `px` for style bindings), then this is the unit.\n * @param securityContext The security context of the binding.\n * @param isStructuralTemplateAttribute Whether this binding actually applies to the structural\n *     ng-template. For example, an `ngFor` would actually apply to the structural template. (Most\n *     bindings on structural elements target the inner element, not the template.)\n * @param templateKind Whether this is an explicit `ng-template` or an implicit template created by\n *     a structural directive. This should never be a block template.\n * @param i18nMessage The i18n metadata for the binding, if any.\n * @param sourceSpan The source span of the binding.\n * @returns An IR binding op, or null if the binding should be skipped.\n */\nfunction createTemplateBinding(\n  view: ViewCompilationUnit,\n  xref: ir.XrefId,\n  type: e.BindingType,\n  name: string,\n  value: e.AST | string,\n  unit: string | null,\n  securityContext: SecurityContext,\n  isStructuralTemplateAttribute: boolean,\n  templateKind: ir.TemplateKind | null,\n  i18nMessage: i18n.Message | null,\n  sourceSpan: ParseSourceSpan,\n): ir.BindingOp | ir.ExtractedAttributeOp | null {\n  const isTextBinding = typeof value === 'string';\n  // If this is a structural template, then several kinds of bindings should not result in an\n  // update instruction.\n  if (templateKind === ir.TemplateKind.Structural) {\n    if (!isStructuralTemplateAttribute) {\n      switch (type) {\n        case e.BindingType.Property:\n        case e.BindingType.Class:\n        case e.BindingType.Style:\n          // Because this binding doesn't really target the ng-template, it must be a binding on an\n          // inner node of a structural template. We can't skip it entirely, because we still need\n          // it on the ng-template's consts (e.g. for the purposes of directive matching). However,\n          // we should not generate an update instruction for it.\n          return ir.createExtractedAttributeOp(\n            xref,\n            ir.BindingKind.Property,\n            null,\n            name,\n            null,\n            null,\n            i18nMessage,\n            securityContext,\n          );\n        case e.BindingType.TwoWay:\n          return ir.createExtractedAttributeOp(\n            xref,\n            ir.BindingKind.TwoWayProperty,\n            null,\n            name,\n            null,\n            null,\n            i18nMessage,\n            securityContext,\n          );\n      }\n    }\n\n    if (\n      !isTextBinding &&\n      (type === e.BindingType.Attribute ||\n        type === e.BindingType.LegacyAnimation ||\n        type === e.BindingType.Animation)\n    ) {\n      // Again, this binding doesn't really target the ng-template; it actually targets the element\n      // inside the structural template. In the case of non-text attribute or animation bindings,\n      // the binding doesn't even show up on the ng-template const array, so we just skip it\n      // entirely.\n      return null;\n    }\n  }\n\n  let bindingType = BINDING_KINDS.get(type)!;\n\n  if (templateKind === ir.TemplateKind.NgTemplate) {\n    // We know we are dealing with bindings directly on an explicit ng-template.\n    // Static attribute bindings should be collected into the const array as k/v pairs. Property\n    // bindings should result in a `property` instruction, and `AttributeMarker.Bindings` const\n    // entries.\n    //\n    // The difficulty is with dynamic attribute, style, and class bindings. These don't really make\n    // sense on an `ng-template` and should probably be parser errors. However,\n    // TemplateDefinitionBuilder generates `property` instructions for them, and so we do that as\n    // well.\n    //\n    // Note that we do have a slight behavior difference with TemplateDefinitionBuilder: although\n    // TDB emits `property` instructions for dynamic attributes, styles, and classes, only styles\n    // and classes also get const collected into the `AttributeMarker.Bindings` field. Dynamic\n    // attribute bindings are missing from the consts entirely. We choose to emit them into the\n    // consts field anyway, to avoid creating special cases for something so arcane and nonsensical.\n    if (\n      type === e.BindingType.Class ||\n      type === e.BindingType.Style ||\n      (type === e.BindingType.Attribute && !isTextBinding)\n    ) {\n      // TODO: These cases should be parse errors.\n      bindingType = ir.BindingKind.Property;\n    }\n  }\n\n  return ir.createBindingOp(\n    xref,\n    bindingType,\n    name,\n    convertAstWithInterpolation(view.job, value, i18nMessage),\n    unit,\n    securityContext,\n    isTextBinding,\n    isStructuralTemplateAttribute,\n    templateKind,\n    i18nMessage,\n    sourceSpan,\n  );\n}\n\nfunction makeListenerHandlerOps(\n  unit: CompilationUnit,\n  handler: e.AST,\n  handlerSpan: ParseSourceSpan,\n): ir.UpdateOp[] {\n  handler = astOf(handler);\n  const handlerOps = new Array<ir.UpdateOp>();\n  let handlerExprs: e.AST[] = handler instanceof e.Chain ? handler.expressions : [handler];\n  if (handlerExprs.length === 0) {\n    throw new Error('Expected listener to have non-empty expression list.');\n  }\n  const expressions = handlerExprs.map((expr) => convertAst(expr, unit.job, handlerSpan));\n  const returnExpr = expressions.pop()!;\n  handlerOps.push(\n    ...expressions.map((e) =>\n      ir.createStatementOp<ir.UpdateOp>(new o.ExpressionStatement(e, e.sourceSpan)),\n    ),\n  );\n  handlerOps.push(ir.createStatementOp(new o.ReturnStatement(returnExpr, returnExpr.sourceSpan)));\n  return handlerOps;\n}\n\nfunction makeTwoWayListenerHandlerOps(\n  unit: CompilationUnit,\n  handler: e.AST,\n  handlerSpan: ParseSourceSpan,\n): ir.UpdateOp[] {\n  handler = astOf(handler);\n  const handlerOps = new Array<ir.UpdateOp>();\n\n  if (handler instanceof e.Chain) {\n    if (handler.expressions.length === 1) {\n      handler = handler.expressions[0];\n    } else {\n      // This is validated during parsing already, but we do it here just in case.\n      throw new Error('Expected two-way listener to have a single expression.');\n    }\n  }\n\n  const handlerExpr = convertAst(handler, unit.job, handlerSpan);\n  const eventReference = new ir.LexicalReadExpr('$event');\n  const twoWaySetExpr = new ir.TwoWayBindingSetExpr(handlerExpr, eventReference);\n\n  handlerOps.push(ir.createStatementOp<ir.UpdateOp>(new o.ExpressionStatement(twoWaySetExpr)));\n  handlerOps.push(ir.createStatementOp(new o.ReturnStatement(eventReference)));\n  return handlerOps;\n}\n\nfunction astOf(ast: e.AST | e.ASTWithSource): e.AST {\n  return ast instanceof e.ASTWithSource ? ast.ast : ast;\n}\n\n/**\n * Process all of the local references on an element-like structure in the template AST and\n * convert them to their IR representation.\n */\nfunction ingestReferences(op: ir.ElementOpBase, element: t.Element | t.Template): void {\n  assertIsArray<ir.LocalRef>(op.localRefs);\n  for (const {name, value} of element.references) {\n    op.localRefs.push({\n      name,\n      target: value,\n    });\n  }\n}\n\n/**\n * Assert that the given value is an array.\n */\nfunction assertIsArray<T>(value: any): asserts value is Array<T> {\n  if (!Array.isArray(value)) {\n    throw new Error(`AssertionError: expected an array`);\n  }\n}\n\n/**\n * Creates an absolute `ParseSourceSpan` from the relative `ParseSpan`.\n *\n * `ParseSpan` objects are relative to the start of the expression.\n * This method converts these to full `ParseSourceSpan` objects that\n * show where the span is within the overall source file.\n *\n * @param span the relative span to convert.\n * @param baseSourceSpan a span corresponding to the base of the expression tree.\n * @returns a `ParseSourceSpan` for the given span or null if no `baseSourceSpan` was provided.\n */\nfunction convertSourceSpan(\n  span: e.ParseSpan,\n  baseSourceSpan: ParseSourceSpan | null,\n): ParseSourceSpan | null {\n  if (baseSourceSpan === null) {\n    return null;\n  }\n  const start = baseSourceSpan.start.moveBy(span.start);\n  const end = baseSourceSpan.start.moveBy(span.end);\n  const fullStart = baseSourceSpan.fullStart.moveBy(span.start);\n  return new ParseSourceSpan(start, end, fullStart);\n}\n\n/**\n * With the directive-based control flow users were able to conditionally project content using\n * the `*` syntax. E.g. `<div *ngIf=\"expr\" projectMe></div>` will be projected into\n * `<ng-content select=\"[projectMe]\"/>`, because the attributes and tag name from the `div` are\n * copied to the template via the template creation instruction. With `@if` and `@for` that is\n * not the case, because the conditional is placed *around* elements, rather than *on* them.\n * The result is that content projection won't work in the same way if a user converts from\n * `*ngIf` to `@if`.\n *\n * This function aims to cover the most common case by doing the same copying when a control flow\n * node has *one and only one* root element or template node.\n *\n * This approach comes with some caveats:\n * 1. As soon as any other node is added to the root, the copying behavior won't work anymore.\n *    A diagnostic will be added to flag cases like this and to explain how to work around it.\n * 2. If `preserveWhitespaces` is enabled, it's very likely that indentation will break this\n *    workaround, because it'll include an additional text node as the first child. We can work\n *    around it here, but in a discussion it was decided not to, because the user explicitly opted\n *    into preserving the whitespace and we would have to drop it from the generated code.\n *    The diagnostic mentioned point in #1 will flag such cases to users.\n *\n * @returns Tag name to be used for the control flow template.\n */\nfunction ingestControlFlowInsertionPoint(\n  unit: ViewCompilationUnit,\n  xref: ir.XrefId,\n  node: t.IfBlockBranch | t.SwitchBlockCase | t.ForLoopBlock | t.ForLoopBlockEmpty,\n): string | null {\n  let root: t.Element | t.Template | null = null;\n\n  for (const child of node.children) {\n    // Skip over comment nodes and @let declarations since\n    // it doesn't matter where they end up in the DOM.\n    if (child instanceof t.Comment || child instanceof t.LetDeclaration) {\n      continue;\n    }\n\n    // We can only infer the tag name/attributes if there's a single root node.\n    if (root !== null) {\n      return null;\n    }\n\n    // Root nodes can only elements or templates with a tag name (e.g. `<div *foo></div>`).\n    if (child instanceof t.Element || (child instanceof t.Template && child.tagName !== null)) {\n      root = child;\n    } else {\n      return null;\n    }\n  }\n\n  // If we've found a single root node, its tag name and attributes can be\n  // copied to the surrounding template to be used for content projection.\n  if (root !== null) {\n    // Collect the static attributes for content projection purposes.\n    for (const attr of root.attributes) {\n      if (!attr.name.startsWith(ANIMATE_PREFIX)) {\n        const securityContext = domSchema.securityContext(NG_TEMPLATE_TAG_NAME, attr.name, true);\n        unit.update.push(\n          ir.createBindingOp(\n            xref,\n            ir.BindingKind.Attribute,\n            attr.name,\n            o.literal(attr.value),\n            null,\n            securityContext,\n            true,\n            false,\n            null,\n            asMessage(attr.i18n),\n            attr.sourceSpan,\n          ),\n        );\n      }\n    }\n\n    // Also collect the inputs since they participate in content projection as well.\n    // Note that TDB used to collect the outputs as well, but it wasn't passing them into\n    // the template instruction. Here we just don't collect them.\n    for (const attr of root.inputs) {\n      if (\n        attr.type !== e.BindingType.LegacyAnimation &&\n        attr.type !== e.BindingType.Animation &&\n        attr.type !== e.BindingType.Attribute\n      ) {\n        const securityContext = domSchema.securityContext(NG_TEMPLATE_TAG_NAME, attr.name, true);\n        unit.create.push(\n          ir.createExtractedAttributeOp(\n            xref,\n            ir.BindingKind.Property,\n            null,\n            attr.name,\n            null,\n            null,\n            null,\n            securityContext,\n          ),\n        );\n      }\n    }\n\n    const tagName = root instanceof t.Element ? root.name : root.tagName;\n\n    // Don't pass along `ng-template` tag name since it enables directive matching.\n    return tagName === NG_TEMPLATE_TAG_NAME ? null : tagName;\n  }\n\n  return null;\n}\n","/*!\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/**\n * Whether to produce instructions that will attach the source location to each DOM node.\n *\n * !!!Important!!! at the time of writing this flag isn't exposed externally, but internal debug\n * tools enable it via a local change. Any modifications to this flag need to update the\n * internal tooling as well.\n */\nlet ENABLE_TEMPLATE_SOURCE_LOCATIONS = false;\n\n/**\n * Utility function to enable source locations. Intended to be used **only** inside unit tests.\n */\nexport function setEnableTemplateSourceLocations(value: boolean): void {\n  ENABLE_TEMPLATE_SOURCE_LOCATIONS = value;\n}\n\n/** Gets whether template source locations are enabled. */\nexport function getTemplateSourceLocationsEnabled(): boolean {\n  return ENABLE_TEMPLATE_SOURCE_LOCATIONS;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ConstantPool} from '../../constant_pool';\nimport * as core from '../../core';\nimport * as o from '../../output/output_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {ForwardRefHandling} from '../util';\n\nimport {R3QueryMetadata} from './api';\nimport {CONTEXT_NAME, RENDER_FLAGS, TEMPORARY_NAME, temporaryAllocator} from './util';\n\n//  if (rf & flags) { .. }\nfunction renderFlagCheckIfStmt(flags: core.RenderFlags, statements: o.Statement[]): o.IfStmt {\n  return o.ifStmt(o.variable(RENDER_FLAGS).bitwiseAnd(o.literal(flags), null), statements);\n}\n\n/**\n * A set of flags to be used with Queries.\n *\n * NOTE: Ensure changes here are in sync with `packages/core/src/render3/interfaces/query.ts`\n */\nexport const enum QueryFlags {\n  /**\n   * No flags\n   */\n  none = 0b0000,\n\n  /**\n   * Whether or not the query should descend into children.\n   */\n  descendants = 0b0001,\n\n  /**\n   * The query can be computed statically and hence can be assigned eagerly.\n   *\n   * NOTE: Backwards compatibility with ViewEngine.\n   */\n  isStatic = 0b0010,\n\n  /**\n   * If the `QueryList` should fire change event only if actual change to query was computed (vs old\n   * behavior where the change was fired whenever the query was recomputed, even if the recomputed\n   * query resulted in the same list.)\n   */\n  emitDistinctChangesOnly = 0b0100,\n}\n\n/**\n * Translates query flags into `TQueryFlags` type in\n * packages/core/src/render3/interfaces/query.ts\n * @param query\n */\nfunction toQueryFlags(query: R3QueryMetadata): number {\n  return (\n    (query.descendants ? QueryFlags.descendants : QueryFlags.none) |\n    (query.static ? QueryFlags.isStatic : QueryFlags.none) |\n    (query.emitDistinctChangesOnly ? QueryFlags.emitDistinctChangesOnly : QueryFlags.none)\n  );\n}\n\nexport function getQueryPredicate(\n  query: R3QueryMetadata,\n  constantPool: ConstantPool,\n): o.Expression {\n  if (Array.isArray(query.predicate)) {\n    let predicate: o.Expression[] = [];\n    query.predicate.forEach((selector: string): void => {\n      // Each item in predicates array may contain strings with comma-separated refs\n      // (for ex. 'ref, ref1, ..., refN'), thus we extract individual refs and store them\n      // as separate array entities\n      const selectors = selector.split(',').map((token) => o.literal(token.trim()));\n      predicate.push(...selectors);\n    });\n    return constantPool.getConstLiteral(o.literalArr(predicate), true);\n  } else {\n    // The original predicate may have been wrapped in a `forwardRef()` call.\n    switch (query.predicate.forwardRef) {\n      case ForwardRefHandling.None:\n      case ForwardRefHandling.Unwrapped:\n        return query.predicate.expression;\n      case ForwardRefHandling.Wrapped:\n        return o.importExpr(R3.resolveForwardRef).callFn([query.predicate.expression]);\n    }\n  }\n}\n\nexport function createQueryCreateCall(\n  query: R3QueryMetadata,\n  constantPool: ConstantPool,\n  queryTypeFns: {signalBased: o.ExternalReference; nonSignal: o.ExternalReference},\n  prependParams?: o.Expression[],\n): o.InvokeFunctionExpr {\n  const parameters: o.Expression[] = [];\n  if (prependParams !== undefined) {\n    parameters.push(...prependParams);\n  }\n  if (query.isSignal) {\n    parameters.push(new o.ReadPropExpr(o.variable(CONTEXT_NAME), query.propertyName));\n  }\n  parameters.push(getQueryPredicate(query, constantPool), o.literal(toQueryFlags(query)));\n  if (query.read) {\n    parameters.push(query.read);\n  }\n\n  const queryCreateFn = query.isSignal ? queryTypeFns.signalBased : queryTypeFns.nonSignal;\n  return o.importExpr(queryCreateFn).callFn(parameters);\n}\n\nconst queryAdvancePlaceholder = Symbol('queryAdvancePlaceholder');\n\n/**\n * Collapses query advance placeholders in a list of statements.\n *\n * This allows for less generated code because multiple sibling query advance\n * statements can be collapsed into a single call with the count as argument.\n *\n * e.g.\n *\n * ```ts\n *   bla();\n *   queryAdvance();\n *   queryAdvance();\n *   bla();\n * ```\n *\n *   --> will turn into\n *\n * ```ts\n *   bla();\n *   queryAdvance(2);\n *   bla();\n * ```\n */\nfunction collapseAdvanceStatements(\n  statements: (o.Statement | typeof queryAdvancePlaceholder)[],\n): o.Statement[] {\n  const result: o.Statement[] = [];\n  let advanceCollapseCount = 0;\n  const flushAdvanceCount = () => {\n    if (advanceCollapseCount > 0) {\n      result.unshift(\n        o\n          .importExpr(R3.queryAdvance)\n          .callFn(advanceCollapseCount === 1 ? [] : [o.literal(advanceCollapseCount)])\n          .toStmt(),\n      );\n      advanceCollapseCount = 0;\n    }\n  };\n\n  // Iterate through statements in reverse and collapse advance placeholders.\n  for (let i = statements.length - 1; i >= 0; i--) {\n    const st = statements[i];\n    if (st === queryAdvancePlaceholder) {\n      advanceCollapseCount++;\n    } else {\n      flushAdvanceCount();\n      result.unshift(st);\n    }\n  }\n  flushAdvanceCount();\n  return result;\n}\n\n// Define and update any view queries\nexport function createViewQueriesFunction(\n  viewQueries: R3QueryMetadata[],\n  constantPool: ConstantPool,\n  name?: string,\n): o.Expression {\n  const createStatements: o.Statement[] = [];\n  const updateStatements: (o.Statement | typeof queryAdvancePlaceholder)[] = [];\n  const tempAllocator = temporaryAllocator((st) => updateStatements.push(st), TEMPORARY_NAME);\n\n  viewQueries.forEach((query: R3QueryMetadata) => {\n    // creation call, e.g. r3.viewQuery(somePredicate, true) or\n    //                r3.viewQuerySignal(ctx.prop, somePredicate, true);\n    const queryDefinitionCall = createQueryCreateCall(query, constantPool, {\n      signalBased: R3.viewQuerySignal,\n      nonSignal: R3.viewQuery,\n    });\n    createStatements.push(queryDefinitionCall.toStmt());\n\n    // Signal queries update lazily and we just advance the index.\n    if (query.isSignal) {\n      updateStatements.push(queryAdvancePlaceholder);\n      return;\n    }\n\n    // update, e.g. (r3.queryRefresh(tmp = r3.loadQuery()) && (ctx.someDir = tmp));\n    const temporary = tempAllocator();\n    const getQueryList = o.importExpr(R3.loadQuery).callFn([]);\n    const refresh = o.importExpr(R3.queryRefresh).callFn([temporary.set(getQueryList)]);\n    const updateDirective = o\n      .variable(CONTEXT_NAME)\n      .prop(query.propertyName)\n      .set(query.first ? temporary.prop('first') : temporary);\n    updateStatements.push(refresh.and(updateDirective).toStmt());\n  });\n\n  const viewQueryFnName = name ? `${name}_Query` : null;\n  return o.fn(\n    [new o.FnParam(RENDER_FLAGS, o.NUMBER_TYPE), new o.FnParam(CONTEXT_NAME, null)],\n    [\n      renderFlagCheckIfStmt(core.RenderFlags.Create, createStatements),\n      renderFlagCheckIfStmt(core.RenderFlags.Update, collapseAdvanceStatements(updateStatements)),\n    ],\n    o.INFERRED_TYPE,\n    null,\n    viewQueryFnName,\n  );\n}\n\n// Define and update any content queries\nexport function createContentQueriesFunction(\n  queries: R3QueryMetadata[],\n  constantPool: ConstantPool,\n  name?: string,\n): o.Expression {\n  const createStatements: o.Statement[] = [];\n  const updateStatements: (o.Statement | typeof queryAdvancePlaceholder)[] = [];\n  const tempAllocator = temporaryAllocator((st) => updateStatements.push(st), TEMPORARY_NAME);\n\n  for (const query of queries) {\n    // creation, e.g. r3.contentQuery(dirIndex, somePredicate, true, null) or\n    //                r3.contentQuerySignal(dirIndex, propName, somePredicate, <flags>, <read>).\n    createStatements.push(\n      createQueryCreateCall(\n        query,\n        constantPool,\n        {nonSignal: R3.contentQuery, signalBased: R3.contentQuerySignal},\n        /* prependParams */ [o.variable('dirIndex')],\n      ).toStmt(),\n    );\n\n    // Signal queries update lazily and we just advance the index.\n    if (query.isSignal) {\n      updateStatements.push(queryAdvancePlaceholder);\n      continue;\n    }\n\n    // update, e.g. (r3.queryRefresh(tmp = r3.loadQuery()) && (ctx.someDir = tmp));\n    const temporary = tempAllocator();\n    const getQueryList = o.importExpr(R3.loadQuery).callFn([]);\n    const refresh = o.importExpr(R3.queryRefresh).callFn([temporary.set(getQueryList)]);\n    const updateDirective = o\n      .variable(CONTEXT_NAME)\n      .prop(query.propertyName)\n      .set(query.first ? temporary.prop('first') : temporary);\n    updateStatements.push(refresh.and(updateDirective).toStmt());\n  }\n\n  const contentQueriesFnName = name ? `${name}_ContentQueries` : null;\n  return o.fn(\n    [\n      new o.FnParam(RENDER_FLAGS, o.NUMBER_TYPE),\n      new o.FnParam(CONTEXT_NAME, null),\n      new o.FnParam('dirIndex', null),\n    ],\n    [\n      renderFlagCheckIfStmt(core.RenderFlags.Create, createStatements),\n      renderFlagCheckIfStmt(core.RenderFlags.Update, collapseAdvanceStatements(updateStatements)),\n    ],\n    o.INFERRED_TYPE,\n    null,\n    contentQueriesFnName,\n  );\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {getHtmlTagDefinition} from './html_tags';\nimport {TokenizeOptions} from './lexer';\nimport {Parser, ParseTreeResult} from './parser';\n\nexport class HtmlParser extends Parser {\n  constructor() {\n    super(getHtmlTagDefinition);\n  }\n\n  override parse(source: string, url: string, options?: TokenizeOptions): ParseTreeResult {\n    return super.parse(source, url, options);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {SecurityContext} from '../core';\nimport {\n  AbsoluteSourceSpan,\n  AST,\n  ASTWithSource,\n  BindingType,\n  BoundElementProperty,\n  Call,\n  EmptyExpr,\n  ImplicitReceiver,\n  KeyedRead,\n  NonNullAssert,\n  ParenthesizedExpression,\n  ParsedEvent,\n  ParsedEventType,\n  ParsedProperty,\n  ParsedPropertyType,\n  ParsedVariable,\n  PropertyRead,\n  SafeKeyedRead,\n  SafePropertyRead,\n  TemplateBinding,\n  ThisReceiver,\n  VariableBinding,\n} from '../expression_parser/ast';\nimport {Parser} from '../expression_parser/parser';\nimport {InterpolationConfig} from '../ml_parser/defaults';\nimport {mergeNsAndName} from '../ml_parser/tags';\nimport {InterpolatedAttributeToken, InterpolatedTextToken} from '../ml_parser/tokens';\nimport {ParseError, ParseErrorLevel, ParseSourceSpan} from '../parse_util';\nimport {ElementSchemaRegistry} from '../schema/element_schema_registry';\nimport {CssSelector} from '../directive_matching';\nimport {splitAtColon, splitAtPeriod} from '../util';\n\nconst PROPERTY_PARTS_SEPARATOR = '.';\nconst ATTRIBUTE_PREFIX = 'attr';\nconst ANIMATE_PREFIX = 'animate';\nconst CLASS_PREFIX = 'class';\nconst STYLE_PREFIX = 'style';\nconst TEMPLATE_ATTR_PREFIX = '*';\nconst LEGACY_ANIMATE_PROP_PREFIX = 'animate-';\n\nexport interface HostProperties {\n  [key: string]: string;\n}\n\nexport interface HostListeners {\n  [key: string]: string;\n}\n\n/**\n * Parses bindings in templates and in the directive host area.\n */\nexport class BindingParser {\n  constructor(\n    private _exprParser: Parser,\n    private _interpolationConfig: InterpolationConfig,\n    private _schemaRegistry: ElementSchemaRegistry,\n    public errors: ParseError[],\n  ) {}\n\n  get interpolationConfig(): InterpolationConfig {\n    return this._interpolationConfig;\n  }\n\n  createBoundHostProperties(\n    properties: HostProperties,\n    sourceSpan: ParseSourceSpan,\n  ): ParsedProperty[] | null {\n    const boundProps: ParsedProperty[] = [];\n    for (const propName of Object.keys(properties)) {\n      const expression = properties[propName];\n      if (typeof expression === 'string') {\n        this.parsePropertyBinding(\n          propName,\n          expression,\n          true,\n          false,\n          sourceSpan,\n          sourceSpan.start.offset,\n          undefined,\n          [],\n          // Use the `sourceSpan` for  `keySpan`. This isn't really accurate, but neither is the\n          // sourceSpan, as it represents the sourceSpan of the host itself rather than the\n          // source of the host binding (which doesn't exist in the template). Regardless,\n          // neither of these values are used in Ivy but are only here to satisfy the function\n          // signature. This should likely be refactored in the future so that `sourceSpan`\n          // isn't being used inaccurately.\n          boundProps,\n          sourceSpan,\n        );\n      } else {\n        this._reportError(\n          `Value of the host property binding \"${propName}\" needs to be a string representing an expression but got \"${expression}\" (${typeof expression})`,\n          sourceSpan,\n        );\n      }\n    }\n    return boundProps;\n  }\n\n  createDirectiveHostEventAsts(\n    hostListeners: HostListeners,\n    sourceSpan: ParseSourceSpan,\n  ): ParsedEvent[] | null {\n    const targetEvents: ParsedEvent[] = [];\n    for (const propName of Object.keys(hostListeners)) {\n      const expression = hostListeners[propName];\n      if (typeof expression === 'string') {\n        // Use the `sourceSpan` for  `keySpan` and `handlerSpan`. This isn't really accurate, but\n        // neither is the `sourceSpan`, as it represents the `sourceSpan` of the host itself\n        // rather than the source of the host binding (which doesn't exist in the template).\n        // Regardless, neither of these values are used in Ivy but are only here to satisfy the\n        // function signature. This should likely be refactored in the future so that `sourceSpan`\n        // isn't being used inaccurately.\n        this.parseEvent(\n          propName,\n          expression,\n          /* isAssignmentEvent */ false,\n          sourceSpan,\n          sourceSpan,\n          [],\n          targetEvents,\n          sourceSpan,\n        );\n      } else {\n        this._reportError(\n          `Value of the host listener \"${propName}\" needs to be a string representing an expression but got \"${expression}\" (${typeof expression})`,\n          sourceSpan,\n        );\n      }\n    }\n    return targetEvents;\n  }\n\n  parseInterpolation(\n    value: string,\n    sourceSpan: ParseSourceSpan,\n    interpolatedTokens: InterpolatedAttributeToken[] | InterpolatedTextToken[] | null,\n  ): ASTWithSource {\n    const absoluteOffset = sourceSpan.fullStart.offset;\n\n    try {\n      const ast = this._exprParser.parseInterpolation(\n        value,\n        sourceSpan,\n        absoluteOffset,\n        interpolatedTokens,\n        this._interpolationConfig,\n      )!;\n      if (ast) {\n        this.errors.push(...ast.errors);\n      }\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceSpan, absoluteOffset);\n    }\n  }\n\n  /**\n   * Similar to `parseInterpolation`, but treats the provided string as a single expression\n   * element that would normally appear within the interpolation prefix and suffix (`{{` and `}}`).\n   * This is used for parsing the switch expression in ICUs.\n   */\n  parseInterpolationExpression(expression: string, sourceSpan: ParseSourceSpan): ASTWithSource {\n    const absoluteOffset = sourceSpan.start.offset;\n\n    try {\n      const ast = this._exprParser.parseInterpolationExpression(\n        expression,\n        sourceSpan,\n        absoluteOffset,\n      );\n      if (ast) {\n        this.errors.push(...ast.errors);\n      }\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceSpan, absoluteOffset);\n    }\n  }\n\n  /**\n   * Parses the bindings in a microsyntax expression, and converts them to\n   * `ParsedProperty` or `ParsedVariable`.\n   *\n   * @param tplKey template binding name\n   * @param tplValue template binding value\n   * @param sourceSpan span of template binding relative to entire the template\n   * @param absoluteValueOffset start of the tplValue relative to the entire template\n   * @param targetMatchableAttrs potential attributes to match in the template\n   * @param targetProps target property bindings in the template\n   * @param targetVars target variables in the template\n   */\n  parseInlineTemplateBinding(\n    tplKey: string,\n    tplValue: string,\n    sourceSpan: ParseSourceSpan,\n    absoluteValueOffset: number,\n    targetMatchableAttrs: string[][],\n    targetProps: ParsedProperty[],\n    targetVars: ParsedVariable[],\n    isIvyAst: boolean,\n  ) {\n    const absoluteKeyOffset = sourceSpan.start.offset + TEMPLATE_ATTR_PREFIX.length;\n    const bindings = this._parseTemplateBindings(\n      tplKey,\n      tplValue,\n      sourceSpan,\n      absoluteKeyOffset,\n      absoluteValueOffset,\n    );\n\n    for (const binding of bindings) {\n      // sourceSpan is for the entire HTML attribute. bindingSpan is for a particular\n      // binding within the microsyntax expression so it's more narrow than sourceSpan.\n      const bindingSpan = moveParseSourceSpan(sourceSpan, binding.sourceSpan);\n      const key = binding.key.source;\n      const keySpan = moveParseSourceSpan(sourceSpan, binding.key.span);\n      if (binding instanceof VariableBinding) {\n        const value = binding.value ? binding.value.source : '$implicit';\n        const valueSpan = binding.value\n          ? moveParseSourceSpan(sourceSpan, binding.value.span)\n          : undefined;\n        targetVars.push(new ParsedVariable(key, value, bindingSpan, keySpan, valueSpan));\n      } else if (binding.value) {\n        const srcSpan = isIvyAst ? bindingSpan : sourceSpan;\n        const valueSpan = moveParseSourceSpan(sourceSpan, binding.value.ast.sourceSpan);\n        this._parsePropertyAst(\n          key,\n          binding.value,\n          false,\n          srcSpan,\n          keySpan,\n          valueSpan,\n          targetMatchableAttrs,\n          targetProps,\n        );\n      } else {\n        targetMatchableAttrs.push([key, '' /* value */]);\n        // Since this is a literal attribute with no RHS, source span should be\n        // just the key span.\n        this.parseLiteralAttr(\n          key,\n          null /* value */,\n          keySpan,\n          absoluteValueOffset,\n          undefined /* valueSpan */,\n          targetMatchableAttrs,\n          targetProps,\n          keySpan,\n        );\n      }\n    }\n  }\n\n  /**\n   * Parses the bindings in a microsyntax expression, e.g.\n   * ```html\n   *    <tag *tplKey=\"let value1 = prop; let value2 = localVar\">\n   * ```\n   *\n   * @param tplKey template binding name\n   * @param tplValue template binding value\n   * @param sourceSpan span of template binding relative to entire the template\n   * @param absoluteKeyOffset start of the `tplKey`\n   * @param absoluteValueOffset start of the `tplValue`\n   */\n  private _parseTemplateBindings(\n    tplKey: string,\n    tplValue: string,\n    sourceSpan: ParseSourceSpan,\n    absoluteKeyOffset: number,\n    absoluteValueOffset: number,\n  ): TemplateBinding[] {\n    try {\n      const bindingsResult = this._exprParser.parseTemplateBindings(\n        tplKey,\n        tplValue,\n        sourceSpan,\n        absoluteKeyOffset,\n        absoluteValueOffset,\n      );\n      bindingsResult.errors.forEach((e) => this.errors.push(e));\n      bindingsResult.warnings.forEach((warning) => {\n        this._reportError(warning, sourceSpan, ParseErrorLevel.WARNING);\n      });\n      return bindingsResult.templateBindings;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return [];\n    }\n  }\n\n  parseLiteralAttr(\n    name: string,\n    value: string | null,\n    sourceSpan: ParseSourceSpan,\n    absoluteOffset: number,\n    valueSpan: ParseSourceSpan | undefined,\n    targetMatchableAttrs: string[][],\n    targetProps: ParsedProperty[],\n    keySpan: ParseSourceSpan,\n  ) {\n    if (isLegacyAnimationLabel(name)) {\n      name = name.substring(1);\n      if (keySpan !== undefined) {\n        keySpan = moveParseSourceSpan(\n          keySpan,\n          new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset),\n        );\n      }\n      if (value) {\n        this._reportError(\n          `Assigning animation triggers via @prop=\"exp\" attributes with an expression is invalid.` +\n            ` Use property bindings (e.g. [@prop]=\"exp\") or use an attribute without a value (e.g. @prop) instead.`,\n          sourceSpan,\n          ParseErrorLevel.ERROR,\n        );\n      }\n      this._parseLegacyAnimation(\n        name,\n        value,\n        sourceSpan,\n        absoluteOffset,\n        keySpan,\n        valueSpan,\n        targetMatchableAttrs,\n        targetProps,\n      );\n    } else {\n      targetProps.push(\n        new ParsedProperty(\n          name,\n          this._exprParser.wrapLiteralPrimitive(value, '', absoluteOffset),\n          ParsedPropertyType.LITERAL_ATTR,\n          sourceSpan,\n          keySpan,\n          valueSpan,\n        ),\n      );\n    }\n  }\n\n  parsePropertyBinding(\n    name: string,\n    expression: string,\n    isHost: boolean,\n    isPartOfAssignmentBinding: boolean,\n    sourceSpan: ParseSourceSpan,\n    absoluteOffset: number,\n    valueSpan: ParseSourceSpan | undefined,\n    targetMatchableAttrs: string[][],\n    targetProps: ParsedProperty[],\n    keySpan: ParseSourceSpan,\n  ) {\n    if (name.length === 0) {\n      this._reportError(`Property name is missing in binding`, sourceSpan);\n    }\n\n    let isLegacyAnimationProp = false;\n    if (name.startsWith(LEGACY_ANIMATE_PROP_PREFIX)) {\n      isLegacyAnimationProp = true;\n      name = name.substring(LEGACY_ANIMATE_PROP_PREFIX.length);\n      if (keySpan !== undefined) {\n        keySpan = moveParseSourceSpan(\n          keySpan,\n          new AbsoluteSourceSpan(\n            keySpan.start.offset + LEGACY_ANIMATE_PROP_PREFIX.length,\n            keySpan.end.offset,\n          ),\n        );\n      }\n    } else if (isLegacyAnimationLabel(name)) {\n      isLegacyAnimationProp = true;\n      name = name.substring(1);\n      if (keySpan !== undefined) {\n        keySpan = moveParseSourceSpan(\n          keySpan,\n          new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset),\n        );\n      }\n    }\n\n    if (isLegacyAnimationProp) {\n      this._parseLegacyAnimation(\n        name,\n        expression,\n        sourceSpan,\n        absoluteOffset,\n        keySpan,\n        valueSpan,\n        targetMatchableAttrs,\n        targetProps,\n      );\n    } else if (name.startsWith(`${ANIMATE_PREFIX}${PROPERTY_PARTS_SEPARATOR}`)) {\n      this._parseAnimation(\n        name,\n        this.parseBinding(expression, isHost, valueSpan || sourceSpan, absoluteOffset),\n        sourceSpan,\n        keySpan,\n        valueSpan,\n        targetMatchableAttrs,\n        targetProps,\n      );\n    } else {\n      this._parsePropertyAst(\n        name,\n        this.parseBinding(expression, isHost, valueSpan || sourceSpan, absoluteOffset),\n        isPartOfAssignmentBinding,\n        sourceSpan,\n        keySpan,\n        valueSpan,\n        targetMatchableAttrs,\n        targetProps,\n      );\n    }\n  }\n\n  parsePropertyInterpolation(\n    name: string,\n    value: string,\n    sourceSpan: ParseSourceSpan,\n    valueSpan: ParseSourceSpan | undefined,\n    targetMatchableAttrs: string[][],\n    targetProps: ParsedProperty[],\n    keySpan: ParseSourceSpan,\n    interpolatedTokens: InterpolatedAttributeToken[] | InterpolatedTextToken[] | null,\n  ): boolean {\n    const expr = this.parseInterpolation(value, valueSpan || sourceSpan, interpolatedTokens);\n    if (expr) {\n      this._parsePropertyAst(\n        name,\n        expr,\n        false,\n        sourceSpan,\n        keySpan,\n        valueSpan,\n        targetMatchableAttrs,\n        targetProps,\n      );\n      return true;\n    }\n    return false;\n  }\n\n  private _parsePropertyAst(\n    name: string,\n    ast: ASTWithSource,\n    isPartOfAssignmentBinding: boolean,\n    sourceSpan: ParseSourceSpan,\n    keySpan: ParseSourceSpan,\n    valueSpan: ParseSourceSpan | undefined,\n    targetMatchableAttrs: string[][],\n    targetProps: ParsedProperty[],\n  ) {\n    targetMatchableAttrs.push([name, ast.source!]);\n    targetProps.push(\n      new ParsedProperty(\n        name,\n        ast,\n        isPartOfAssignmentBinding ? ParsedPropertyType.TWO_WAY : ParsedPropertyType.DEFAULT,\n        sourceSpan,\n        keySpan,\n        valueSpan,\n      ),\n    );\n  }\n\n  private _parseAnimation(\n    name: string,\n    ast: ASTWithSource,\n    sourceSpan: ParseSourceSpan,\n    keySpan: ParseSourceSpan,\n    valueSpan: ParseSourceSpan | undefined,\n    targetMatchableAttrs: string[][],\n    targetProps: ParsedProperty[],\n  ) {\n    targetMatchableAttrs.push([name, ast.source!]);\n    targetProps.push(\n      new ParsedProperty(name, ast, ParsedPropertyType.ANIMATION, sourceSpan, keySpan, valueSpan),\n    );\n  }\n\n  private _parseLegacyAnimation(\n    name: string,\n    expression: string | null,\n    sourceSpan: ParseSourceSpan,\n    absoluteOffset: number,\n    keySpan: ParseSourceSpan,\n    valueSpan: ParseSourceSpan | undefined,\n    targetMatchableAttrs: string[][],\n    targetProps: ParsedProperty[],\n  ) {\n    if (name.length === 0) {\n      this._reportError('Animation trigger is missing', sourceSpan);\n    }\n\n    // This will occur when a @trigger is not paired with an expression.\n    // For animations it is valid to not have an expression since */void\n    // states will be applied by angular when the element is attached/detached\n    const ast = this.parseBinding(\n      expression || 'undefined',\n      false,\n      valueSpan || sourceSpan,\n      absoluteOffset,\n    );\n    targetMatchableAttrs.push([name, ast.source!]);\n    targetProps.push(\n      new ParsedProperty(\n        name,\n        ast,\n        ParsedPropertyType.LEGACY_ANIMATION,\n        sourceSpan,\n        keySpan,\n        valueSpan,\n      ),\n    );\n  }\n\n  parseBinding(\n    value: string,\n    isHostBinding: boolean,\n    sourceSpan: ParseSourceSpan,\n    absoluteOffset: number,\n  ): ASTWithSource {\n    try {\n      const ast = isHostBinding\n        ? this._exprParser.parseSimpleBinding(\n            value,\n            sourceSpan,\n            absoluteOffset,\n            this._interpolationConfig,\n          )\n        : this._exprParser.parseBinding(\n            value,\n            sourceSpan,\n            absoluteOffset,\n            this._interpolationConfig,\n          );\n      if (ast) {\n        this.errors.push(...ast.errors);\n      }\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceSpan, absoluteOffset);\n    }\n  }\n\n  createBoundElementProperty(\n    elementSelector: string | null,\n    boundProp: ParsedProperty,\n    skipValidation: boolean = false,\n    mapPropertyName: boolean = true,\n  ): BoundElementProperty {\n    if (boundProp.isLegacyAnimation) {\n      return new BoundElementProperty(\n        boundProp.name,\n        BindingType.LegacyAnimation,\n        SecurityContext.NONE,\n        boundProp.expression,\n        null,\n        boundProp.sourceSpan,\n        boundProp.keySpan,\n        boundProp.valueSpan,\n      );\n    }\n\n    let unit: string | null = null;\n    let bindingType: BindingType = undefined!;\n    let boundPropertyName: string | null = null;\n    const parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);\n    let securityContexts: SecurityContext[] = undefined!;\n\n    // Check for special cases (prefix style, attr, class)\n    if (parts.length > 1) {\n      if (parts[0] == ATTRIBUTE_PREFIX) {\n        boundPropertyName = parts.slice(1).join(PROPERTY_PARTS_SEPARATOR);\n        if (!skipValidation) {\n          this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);\n        }\n        securityContexts = calcPossibleSecurityContexts(\n          this._schemaRegistry,\n          elementSelector,\n          boundPropertyName,\n          true,\n        );\n\n        const nsSeparatorIdx = boundPropertyName.indexOf(':');\n        if (nsSeparatorIdx > -1) {\n          const ns = boundPropertyName.substring(0, nsSeparatorIdx);\n          const name = boundPropertyName.substring(nsSeparatorIdx + 1);\n          boundPropertyName = mergeNsAndName(ns, name);\n        }\n\n        bindingType = BindingType.Attribute;\n      } else if (parts[0] == CLASS_PREFIX) {\n        boundPropertyName = parts[1];\n        bindingType = BindingType.Class;\n        securityContexts = [SecurityContext.NONE];\n      } else if (parts[0] == STYLE_PREFIX) {\n        unit = parts.length > 2 ? parts[2] : null;\n        boundPropertyName = parts[1];\n        bindingType = BindingType.Style;\n        securityContexts = [SecurityContext.STYLE];\n      } else if (parts[0] == ANIMATE_PREFIX) {\n        boundPropertyName = boundProp.name;\n        bindingType = BindingType.Animation;\n        securityContexts = [SecurityContext.NONE];\n      }\n    }\n\n    // If not a special case, use the full property name\n    if (boundPropertyName === null) {\n      const mappedPropName = this._schemaRegistry.getMappedPropName(boundProp.name);\n      boundPropertyName = mapPropertyName ? mappedPropName : boundProp.name;\n      securityContexts = calcPossibleSecurityContexts(\n        this._schemaRegistry,\n        elementSelector,\n        mappedPropName,\n        false,\n      );\n      bindingType =\n        boundProp.type === ParsedPropertyType.TWO_WAY ? BindingType.TwoWay : BindingType.Property;\n      if (!skipValidation) {\n        this._validatePropertyOrAttributeName(mappedPropName, boundProp.sourceSpan, false);\n      }\n    }\n\n    return new BoundElementProperty(\n      boundPropertyName,\n      bindingType,\n      securityContexts[0],\n      boundProp.expression,\n      unit,\n      boundProp.sourceSpan,\n      boundProp.keySpan,\n      boundProp.valueSpan,\n    );\n  }\n\n  parseEvent(\n    name: string,\n    expression: string,\n    isAssignmentEvent: boolean,\n    sourceSpan: ParseSourceSpan,\n    handlerSpan: ParseSourceSpan,\n    targetMatchableAttrs: string[][],\n    targetEvents: ParsedEvent[],\n    keySpan: ParseSourceSpan,\n  ) {\n    if (name.length === 0) {\n      this._reportError(`Event name is missing in binding`, sourceSpan);\n    }\n\n    if (isLegacyAnimationLabel(name)) {\n      name = name.slice(1);\n      if (keySpan !== undefined) {\n        keySpan = moveParseSourceSpan(\n          keySpan,\n          new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset),\n        );\n      }\n      this._parseLegacyAnimationEvent(\n        name,\n        expression,\n        sourceSpan,\n        handlerSpan,\n        targetEvents,\n        keySpan,\n      );\n    } else {\n      this._parseRegularEvent(\n        name,\n        expression,\n        isAssignmentEvent,\n        sourceSpan,\n        handlerSpan,\n        targetMatchableAttrs,\n        targetEvents,\n        keySpan,\n      );\n    }\n  }\n\n  calcPossibleSecurityContexts(\n    selector: string,\n    propName: string,\n    isAttribute: boolean,\n  ): SecurityContext[] {\n    const prop = this._schemaRegistry.getMappedPropName(propName);\n    return calcPossibleSecurityContexts(this._schemaRegistry, selector, prop, isAttribute);\n  }\n\n  parseEventListenerName(rawName: string): {eventName: string; target: string | null} {\n    const [target, eventName] = splitAtColon(rawName, [null, rawName]);\n    return {eventName: eventName!, target};\n  }\n\n  parseLegacyAnimationEventName(rawName: string): {eventName: string; phase: string | null} {\n    const matches = splitAtPeriod(rawName, [rawName, null]);\n    return {eventName: matches[0]!, phase: matches[1] === null ? null : matches[1].toLowerCase()};\n  }\n\n  private _parseLegacyAnimationEvent(\n    name: string,\n    expression: string,\n    sourceSpan: ParseSourceSpan,\n    handlerSpan: ParseSourceSpan,\n    targetEvents: ParsedEvent[],\n    keySpan: ParseSourceSpan,\n  ) {\n    const {eventName, phase} = this.parseLegacyAnimationEventName(name);\n    const ast = this._parseAction(expression, handlerSpan);\n    targetEvents.push(\n      new ParsedEvent(\n        eventName,\n        phase,\n        ParsedEventType.LegacyAnimation,\n        ast,\n        sourceSpan,\n        handlerSpan,\n        keySpan,\n      ),\n    );\n\n    if (eventName.length === 0) {\n      this._reportError(`Animation event name is missing in binding`, sourceSpan);\n    }\n    if (phase) {\n      if (phase !== 'start' && phase !== 'done') {\n        this._reportError(\n          `The provided animation output phase value \"${phase}\" for \"@${eventName}\" is not supported (use start or done)`,\n          sourceSpan,\n        );\n      }\n    } else {\n      this._reportError(\n        `The animation trigger output event (@${eventName}) is missing its phase value name (start or done are currently supported)`,\n        sourceSpan,\n      );\n    }\n  }\n\n  private _parseRegularEvent(\n    name: string,\n    expression: string,\n    isAssignmentEvent: boolean,\n    sourceSpan: ParseSourceSpan,\n    handlerSpan: ParseSourceSpan,\n    targetMatchableAttrs: string[][],\n    targetEvents: ParsedEvent[],\n    keySpan: ParseSourceSpan,\n  ): void {\n    // long format: 'target: eventName'\n    const {eventName, target} = this.parseEventListenerName(name);\n    const prevErrorCount = this.errors.length;\n    const ast = this._parseAction(expression, handlerSpan);\n    const isValid = this.errors.length === prevErrorCount;\n    targetMatchableAttrs.push([name!, ast.source!]);\n\n    // Don't try to validate assignment events if there were other\n    // parsing errors to avoid adding more noise to the error logs.\n    if (isAssignmentEvent && isValid && !this._isAllowedAssignmentEvent(ast)) {\n      this._reportError('Unsupported expression in a two-way binding', sourceSpan);\n    }\n\n    let eventType = ParsedEventType.Regular;\n    if (isAssignmentEvent) {\n      eventType = ParsedEventType.TwoWay;\n    }\n    if (name.startsWith(`${ANIMATE_PREFIX}${PROPERTY_PARTS_SEPARATOR}`)) {\n      eventType = ParsedEventType.Animation;\n    }\n\n    targetEvents.push(\n      new ParsedEvent(eventName, target, eventType, ast, sourceSpan, handlerSpan, keySpan),\n    );\n    // Don't detect directives for event names for now,\n    // so don't add the event name to the matchableAttrs\n  }\n\n  private _parseAction(value: string, sourceSpan: ParseSourceSpan): ASTWithSource {\n    const absoluteOffset = sourceSpan && sourceSpan.start ? sourceSpan.start.offset : 0;\n\n    try {\n      const ast = this._exprParser.parseAction(\n        value,\n        sourceSpan,\n        absoluteOffset,\n        this._interpolationConfig,\n      );\n      if (ast) {\n        this.errors.push(...ast.errors);\n      }\n      if (!ast || ast.ast instanceof EmptyExpr) {\n        this._reportError(`Empty expressions are not allowed`, sourceSpan);\n        return this._exprParser.wrapLiteralPrimitive('ERROR', sourceSpan, absoluteOffset);\n      }\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceSpan, absoluteOffset);\n    }\n  }\n\n  private _reportError(\n    message: string,\n    sourceSpan: ParseSourceSpan,\n    level: ParseErrorLevel = ParseErrorLevel.ERROR,\n  ) {\n    this.errors.push(new ParseError(sourceSpan, message, level));\n  }\n\n  /**\n   * @param propName the name of the property / attribute\n   * @param sourceSpan\n   * @param isAttr true when binding to an attribute\n   */\n  private _validatePropertyOrAttributeName(\n    propName: string,\n    sourceSpan: ParseSourceSpan,\n    isAttr: boolean,\n  ): void {\n    const report = isAttr\n      ? this._schemaRegistry.validateAttribute(propName)\n      : this._schemaRegistry.validateProperty(propName);\n    if (report.error) {\n      this._reportError(report.msg!, sourceSpan, ParseErrorLevel.ERROR);\n    }\n  }\n\n  /**\n   * Returns whether a parsed AST is allowed to be used within the event side of a two-way binding.\n   * @param ast Parsed AST to be checked.\n   */\n  private _isAllowedAssignmentEvent(ast: AST): boolean {\n    if (ast instanceof ASTWithSource) {\n      return this._isAllowedAssignmentEvent(ast.ast);\n    }\n\n    if (ast instanceof NonNullAssert) {\n      return this._isAllowedAssignmentEvent(ast.expression);\n    }\n\n    if (\n      ast instanceof Call &&\n      ast.args.length === 1 &&\n      ast.receiver instanceof PropertyRead &&\n      ast.receiver.name === '$any' &&\n      ast.receiver.receiver instanceof ImplicitReceiver &&\n      !(ast.receiver.receiver instanceof ThisReceiver)\n    ) {\n      return this._isAllowedAssignmentEvent(ast.args[0]);\n    }\n\n    if (ast instanceof PropertyRead || ast instanceof KeyedRead) {\n      if (!hasRecursiveSafeReceiver(ast)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n}\n\nfunction hasRecursiveSafeReceiver(ast: AST): boolean {\n  if (ast instanceof SafePropertyRead || ast instanceof SafeKeyedRead) {\n    return true;\n  }\n\n  if (ast instanceof ParenthesizedExpression) {\n    return hasRecursiveSafeReceiver(ast.expression);\n  }\n\n  if (ast instanceof PropertyRead || ast instanceof KeyedRead || ast instanceof Call) {\n    return hasRecursiveSafeReceiver(ast.receiver);\n  }\n\n  return false;\n}\n\nfunction isLegacyAnimationLabel(name: string): boolean {\n  return name[0] == '@';\n}\n\nexport function calcPossibleSecurityContexts(\n  registry: ElementSchemaRegistry,\n  selector: string | null,\n  propName: string,\n  isAttribute: boolean,\n): SecurityContext[] {\n  let ctxs: SecurityContext[];\n  const nameToContext = (elName: string) => registry.securityContext(elName, propName, isAttribute);\n\n  if (selector === null) {\n    ctxs = registry.allKnownElementNames().map(nameToContext);\n  } else {\n    ctxs = [];\n    CssSelector.parse(selector).forEach((selector) => {\n      const elementNames = selector.element ? [selector.element] : registry.allKnownElementNames();\n      const notElementNames = new Set(\n        selector.notSelectors\n          .filter((selector) => selector.isElementSelector())\n          .map((selector) => selector.element),\n      );\n      const possibleElementNames = elementNames.filter((elName) => !notElementNames.has(elName));\n\n      ctxs.push(...possibleElementNames.map(nameToContext));\n    });\n  }\n  return ctxs.length === 0 ? [SecurityContext.NONE] : Array.from(new Set(ctxs)).sort();\n}\n\n/**\n * Compute a new ParseSourceSpan based off an original `sourceSpan` by using\n * absolute offsets from the specified `absoluteSpan`.\n *\n * @param sourceSpan original source span\n * @param absoluteSpan absolute source span to move to\n */\nfunction moveParseSourceSpan(\n  sourceSpan: ParseSourceSpan,\n  absoluteSpan: AbsoluteSourceSpan,\n): ParseSourceSpan {\n  // The difference of two absolute offsets provide the relative offset\n  const startDiff = absoluteSpan.start - sourceSpan.start.offset;\n  const endDiff = absoluteSpan.end - sourceSpan.end.offset;\n  return new ParseSourceSpan(\n    sourceSpan.start.moveBy(startDiff),\n    sourceSpan.end.moveBy(endDiff),\n    sourceSpan.fullStart.moveBy(startDiff),\n    sourceSpan.details,\n  );\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n// Some of the code comes from WebComponents.JS\n// https://github.com/webcomponents/webcomponentsjs/blob/master/src/HTMLImports/path.js\n\nexport function isStyleUrlResolvable(url: string | null): url is string {\n  if (url == null || url.length === 0 || url[0] == '/') return false;\n  const schemeMatch = url.match(URL_WITH_SCHEMA_REGEXP);\n  return schemeMatch === null || schemeMatch[1] == 'package' || schemeMatch[1] == 'asset';\n}\n\nconst URL_WITH_SCHEMA_REGEXP = /^([^:/?#]+):/;\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as html from '../ml_parser/ast';\nimport {isNgContent} from '../ml_parser/tags';\n\nconst NG_CONTENT_SELECT_ATTR = 'select';\nconst LINK_ELEMENT = 'link';\nconst LINK_STYLE_REL_ATTR = 'rel';\nconst LINK_STYLE_HREF_ATTR = 'href';\nconst LINK_STYLE_REL_VALUE = 'stylesheet';\nconst STYLE_ELEMENT = 'style';\nconst SCRIPT_ELEMENT = 'script';\nconst NG_NON_BINDABLE_ATTR = 'ngNonBindable';\nconst NG_PROJECT_AS = 'ngProjectAs';\n\nexport function preparseElement(ast: html.Element): PreparsedElement {\n  let selectAttr: string | null = null;\n  let hrefAttr: string | null = null;\n  let relAttr: string | null = null;\n  let nonBindable = false;\n  let projectAs = '';\n  ast.attrs.forEach((attr) => {\n    const lcAttrName = attr.name.toLowerCase();\n    if (lcAttrName == NG_CONTENT_SELECT_ATTR) {\n      selectAttr = attr.value;\n    } else if (lcAttrName == LINK_STYLE_HREF_ATTR) {\n      hrefAttr = attr.value;\n    } else if (lcAttrName == LINK_STYLE_REL_ATTR) {\n      relAttr = attr.value;\n    } else if (attr.name == NG_NON_BINDABLE_ATTR) {\n      nonBindable = true;\n    } else if (attr.name == NG_PROJECT_AS) {\n      if (attr.value.length > 0) {\n        projectAs = attr.value;\n      }\n    }\n  });\n  selectAttr = normalizeNgContentSelect(selectAttr);\n  const nodeName = ast.name.toLowerCase();\n  let type = PreparsedElementType.OTHER;\n  if (isNgContent(nodeName)) {\n    type = PreparsedElementType.NG_CONTENT;\n  } else if (nodeName == STYLE_ELEMENT) {\n    type = PreparsedElementType.STYLE;\n  } else if (nodeName == SCRIPT_ELEMENT) {\n    type = PreparsedElementType.SCRIPT;\n  } else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {\n    type = PreparsedElementType.STYLESHEET;\n  }\n  return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs);\n}\n\nexport enum PreparsedElementType {\n  NG_CONTENT,\n  STYLE,\n  STYLESHEET,\n  SCRIPT,\n  OTHER,\n}\n\nexport class PreparsedElement {\n  constructor(\n    public type: PreparsedElementType,\n    public selectAttr: string,\n    public hrefAttr: string | null,\n    public nonBindable: boolean,\n    public projectAs: string,\n  ) {}\n}\n\nfunction normalizeNgContentSelect(selectAttr: string | null): string {\n  if (selectAttr === null || selectAttr.length === 0) {\n    return '*';\n  }\n  return selectAttr;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  ASTWithSource,\n  EmptyExpr,\n  BindingPipe,\n  RecursiveAstVisitor,\n  AST,\n} from '../expression_parser/ast';\nimport * as html from '../ml_parser/ast';\nimport {ParseError, ParseSourceSpan} from '../parse_util';\nimport {BindingParser} from '../template_parser/binding_parser';\n\nimport * as t from './r3_ast';\n\n/** Pattern for the expression in a for loop block. */\nconst FOR_LOOP_EXPRESSION_PATTERN = /^\\s*([0-9A-Za-z_$]*)\\s+of\\s+([\\S\\s]*)/;\n\n/** Pattern for the tracking expression in a for loop block. */\nconst FOR_LOOP_TRACK_PATTERN = /^track\\s+([\\S\\s]*)/;\n\n/** Pattern for the `as` expression in a conditional block. */\nconst CONDITIONAL_ALIAS_PATTERN = /^(as\\s+)(.*)/;\n\n/** Pattern used to identify an `else if` block. */\nconst ELSE_IF_PATTERN = /^else[^\\S\\r\\n]+if/;\n\n/** Pattern used to identify a `let` parameter. */\nconst FOR_LOOP_LET_PATTERN = /^let\\s+([\\S\\s]*)/;\n\n/** Pattern used to validate a JavaScript identifier. */\nconst IDENTIFIER_PATTERN = /^[$A-Z_][0-9A-Z_$]*$/i;\n\n/**\n * Pattern to group a string into leading whitespace, non whitespace, and trailing whitespace.\n * Useful for getting the variable name span when a span can contain leading and trailing space.\n */\nconst CHARACTERS_IN_SURROUNDING_WHITESPACE_PATTERN = /(\\s*)(\\S+)(\\s*)/;\n\n/** Names of variables that are allowed to be used in the `let` expression of a `for` loop. */\nconst ALLOWED_FOR_LOOP_LET_VARIABLES = new Set([\n  '$index',\n  '$first',\n  '$last',\n  '$even',\n  '$odd',\n  '$count',\n]);\n\n/**\n * Predicate function that determines if a block with\n * a specific name cam be connected to a `for` block.\n */\nexport function isConnectedForLoopBlock(name: string): boolean {\n  return name === 'empty';\n}\n\n/**\n * Predicate function that determines if a block with\n * a specific name cam be connected to an `if` block.\n */\nexport function isConnectedIfLoopBlock(name: string): boolean {\n  return name === 'else' || ELSE_IF_PATTERN.test(name);\n}\n\n/** Creates an `if` loop block from an HTML AST node. */\nexport function createIfBlock(\n  ast: html.Block,\n  connectedBlocks: html.Block[],\n  visitor: html.Visitor,\n  bindingParser: BindingParser,\n): {node: t.IfBlock | null; errors: ParseError[]} {\n  const errors: ParseError[] = validateIfConnectedBlocks(connectedBlocks);\n  const branches: t.IfBlockBranch[] = [];\n  const mainBlockParams = parseConditionalBlockParameters(ast, errors, bindingParser);\n\n  if (mainBlockParams !== null) {\n    branches.push(\n      new t.IfBlockBranch(\n        mainBlockParams.expression,\n        html.visitAll(visitor, ast.children, ast.children),\n        mainBlockParams.expressionAlias,\n        ast.sourceSpan,\n        ast.startSourceSpan,\n        ast.endSourceSpan,\n        ast.nameSpan,\n        ast.i18n,\n      ),\n    );\n  }\n\n  for (const block of connectedBlocks) {\n    if (ELSE_IF_PATTERN.test(block.name)) {\n      const params = parseConditionalBlockParameters(block, errors, bindingParser);\n\n      if (params !== null) {\n        const children = html.visitAll(visitor, block.children, block.children);\n        branches.push(\n          new t.IfBlockBranch(\n            params.expression,\n            children,\n            params.expressionAlias,\n            block.sourceSpan,\n            block.startSourceSpan,\n            block.endSourceSpan,\n            block.nameSpan,\n            block.i18n,\n          ),\n        );\n      }\n    } else if (block.name === 'else') {\n      const children = html.visitAll(visitor, block.children, block.children);\n      branches.push(\n        new t.IfBlockBranch(\n          null,\n          children,\n          null,\n          block.sourceSpan,\n          block.startSourceSpan,\n          block.endSourceSpan,\n          block.nameSpan,\n          block.i18n,\n        ),\n      );\n    }\n  }\n\n  // The outer IfBlock should have a span that encapsulates all branches.\n  const ifBlockStartSourceSpan =\n    branches.length > 0 ? branches[0].startSourceSpan : ast.startSourceSpan;\n  const ifBlockEndSourceSpan =\n    branches.length > 0 ? branches[branches.length - 1].endSourceSpan : ast.endSourceSpan;\n\n  let wholeSourceSpan = ast.sourceSpan;\n  const lastBranch = branches[branches.length - 1];\n  if (lastBranch !== undefined) {\n    wholeSourceSpan = new ParseSourceSpan(ifBlockStartSourceSpan.start, lastBranch.sourceSpan.end);\n  }\n\n  return {\n    node: new t.IfBlock(\n      branches,\n      wholeSourceSpan,\n      ast.startSourceSpan,\n      ifBlockEndSourceSpan,\n      ast.nameSpan,\n    ),\n    errors,\n  };\n}\n\n/** Creates a `for` loop block from an HTML AST node. */\nexport function createForLoop(\n  ast: html.Block,\n  connectedBlocks: html.Block[],\n  visitor: html.Visitor,\n  bindingParser: BindingParser,\n): {node: t.ForLoopBlock | null; errors: ParseError[]} {\n  const errors: ParseError[] = [];\n  const params = parseForLoopParameters(ast, errors, bindingParser);\n  let node: t.ForLoopBlock | null = null;\n  let empty: t.ForLoopBlockEmpty | null = null;\n\n  for (const block of connectedBlocks) {\n    if (block.name === 'empty') {\n      if (empty !== null) {\n        errors.push(new ParseError(block.sourceSpan, '@for loop can only have one @empty block'));\n      } else if (block.parameters.length > 0) {\n        errors.push(new ParseError(block.sourceSpan, '@empty block cannot have parameters'));\n      } else {\n        empty = new t.ForLoopBlockEmpty(\n          html.visitAll(visitor, block.children, block.children),\n          block.sourceSpan,\n          block.startSourceSpan,\n          block.endSourceSpan,\n          block.nameSpan,\n          block.i18n,\n        );\n      }\n    } else {\n      errors.push(new ParseError(block.sourceSpan, `Unrecognized @for loop block \"${block.name}\"`));\n    }\n  }\n\n  if (params !== null) {\n    if (params.trackBy === null) {\n      // TODO: We should not fail here, and instead try to produce some AST for the language\n      // service.\n      errors.push(new ParseError(ast.startSourceSpan, '@for loop must have a \"track\" expression'));\n    } else {\n      // The `for` block has a main span that includes the `empty` branch. For only the span of the\n      // main `for` body, use `mainSourceSpan`.\n      const endSpan = empty?.endSourceSpan ?? ast.endSourceSpan;\n      const sourceSpan = new ParseSourceSpan(\n        ast.sourceSpan.start,\n        endSpan?.end ?? ast.sourceSpan.end,\n      );\n      validateTrackByExpression(params.trackBy.expression, params.trackBy.keywordSpan, errors);\n      node = new t.ForLoopBlock(\n        params.itemName,\n        params.expression,\n        params.trackBy.expression,\n        params.trackBy.keywordSpan,\n        params.context,\n        html.visitAll(visitor, ast.children, ast.children),\n        empty,\n        sourceSpan,\n        ast.sourceSpan,\n        ast.startSourceSpan,\n        endSpan,\n        ast.nameSpan,\n        ast.i18n,\n      );\n    }\n  }\n\n  return {node, errors};\n}\n\n/** Creates a switch block from an HTML AST node. */\nexport function createSwitchBlock(\n  ast: html.Block,\n  visitor: html.Visitor,\n  bindingParser: BindingParser,\n): {node: t.SwitchBlock | null; errors: ParseError[]} {\n  const errors = validateSwitchBlock(ast);\n  const primaryExpression =\n    ast.parameters.length > 0\n      ? parseBlockParameterToBinding(ast.parameters[0], bindingParser)\n      : bindingParser.parseBinding('', false, ast.sourceSpan, 0);\n  const cases: t.SwitchBlockCase[] = [];\n  const unknownBlocks: t.UnknownBlock[] = [];\n  let defaultCase: t.SwitchBlockCase | null = null;\n\n  // Here we assume that all the blocks are valid given that we validated them above.\n  for (const node of ast.children) {\n    if (!(node instanceof html.Block)) {\n      continue;\n    }\n\n    if ((node.name !== 'case' || node.parameters.length === 0) && node.name !== 'default') {\n      unknownBlocks.push(new t.UnknownBlock(node.name, node.sourceSpan, node.nameSpan));\n      continue;\n    }\n\n    const expression =\n      node.name === 'case' ? parseBlockParameterToBinding(node.parameters[0], bindingParser) : null;\n    const ast = new t.SwitchBlockCase(\n      expression,\n      html.visitAll(visitor, node.children, node.children),\n      node.sourceSpan,\n      node.startSourceSpan,\n      node.endSourceSpan,\n      node.nameSpan,\n      node.i18n,\n    );\n\n    if (expression === null) {\n      defaultCase = ast;\n    } else {\n      cases.push(ast);\n    }\n  }\n\n  // Ensure that the default case is last in the array.\n  if (defaultCase !== null) {\n    cases.push(defaultCase);\n  }\n\n  return {\n    node: new t.SwitchBlock(\n      primaryExpression,\n      cases,\n      unknownBlocks,\n      ast.sourceSpan,\n      ast.startSourceSpan,\n      ast.endSourceSpan,\n      ast.nameSpan,\n    ),\n    errors,\n  };\n}\n\n/** Parses the parameters of a `for` loop block. */\nfunction parseForLoopParameters(\n  block: html.Block,\n  errors: ParseError[],\n  bindingParser: BindingParser,\n) {\n  if (block.parameters.length === 0) {\n    errors.push(new ParseError(block.startSourceSpan, '@for loop does not have an expression'));\n    return null;\n  }\n\n  const [expressionParam, ...secondaryParams] = block.parameters;\n  const match = stripOptionalParentheses(expressionParam, errors)?.match(\n    FOR_LOOP_EXPRESSION_PATTERN,\n  );\n\n  if (!match || match[2].trim().length === 0) {\n    errors.push(\n      new ParseError(\n        expressionParam.sourceSpan,\n        'Cannot parse expression. @for loop expression must match the pattern \"<identifier> of <expression>\"',\n      ),\n    );\n    return null;\n  }\n\n  const [, itemName, rawExpression] = match;\n  if (ALLOWED_FOR_LOOP_LET_VARIABLES.has(itemName)) {\n    errors.push(\n      new ParseError(\n        expressionParam.sourceSpan,\n        `@for loop item name cannot be one of ${Array.from(ALLOWED_FOR_LOOP_LET_VARIABLES).join(\n          ', ',\n        )}.`,\n      ),\n    );\n  }\n\n  // `expressionParam.expression` contains the variable declaration and the expression of the\n  // for...of statement, i.e. 'user of users' The variable of a ForOfStatement is _only_ the \"const\n  // user\" part and does not include \"of x\".\n  const variableName = expressionParam.expression.split(' ')[0];\n  const variableSpan = new ParseSourceSpan(\n    expressionParam.sourceSpan.start,\n    expressionParam.sourceSpan.start.moveBy(variableName.length),\n  );\n  const result = {\n    itemName: new t.Variable(itemName, '$implicit', variableSpan, variableSpan),\n    trackBy: null as {expression: ASTWithSource; keywordSpan: ParseSourceSpan} | null,\n    expression: parseBlockParameterToBinding(expressionParam, bindingParser, rawExpression),\n    context: Array.from(ALLOWED_FOR_LOOP_LET_VARIABLES, (variableName) => {\n      // Give ambiently-available context variables empty spans at the end of\n      // the start of the `for` block, since they are not explicitly defined.\n      const emptySpanAfterForBlockStart = new ParseSourceSpan(\n        block.startSourceSpan.end,\n        block.startSourceSpan.end,\n      );\n      return new t.Variable(\n        variableName,\n        variableName,\n        emptySpanAfterForBlockStart,\n        emptySpanAfterForBlockStart,\n      );\n    }),\n  };\n\n  for (const param of secondaryParams) {\n    const letMatch = param.expression.match(FOR_LOOP_LET_PATTERN);\n\n    if (letMatch !== null) {\n      const variablesSpan = new ParseSourceSpan(\n        param.sourceSpan.start.moveBy(letMatch[0].length - letMatch[1].length),\n        param.sourceSpan.end,\n      );\n      parseLetParameter(\n        param.sourceSpan,\n        letMatch[1],\n        variablesSpan,\n        itemName,\n        result.context,\n        errors,\n      );\n      continue;\n    }\n\n    const trackMatch = param.expression.match(FOR_LOOP_TRACK_PATTERN);\n\n    if (trackMatch !== null) {\n      if (result.trackBy !== null) {\n        errors.push(\n          new ParseError(param.sourceSpan, '@for loop can only have one \"track\" expression'),\n        );\n      } else {\n        const expression = parseBlockParameterToBinding(param, bindingParser, trackMatch[1]);\n        if (expression.ast instanceof EmptyExpr) {\n          errors.push(\n            new ParseError(block.startSourceSpan, '@for loop must have a \"track\" expression'),\n          );\n        }\n        const keywordSpan = new ParseSourceSpan(\n          param.sourceSpan.start,\n          param.sourceSpan.start.moveBy('track'.length),\n        );\n        result.trackBy = {expression, keywordSpan};\n      }\n      continue;\n    }\n\n    errors.push(\n      new ParseError(param.sourceSpan, `Unrecognized @for loop parameter \"${param.expression}\"`),\n    );\n  }\n\n  return result;\n}\n\nfunction validateTrackByExpression(\n  expression: ASTWithSource<AST>,\n  parseSourceSpan: ParseSourceSpan,\n  errors: ParseError[],\n): void {\n  const visitor = new PipeVisitor();\n  expression.ast.visit(visitor);\n  if (visitor.hasPipe) {\n    errors.push(new ParseError(parseSourceSpan, 'Cannot use pipes in track expressions'));\n  }\n}\n\n/** Parses the `let` parameter of a `for` loop block. */\nfunction parseLetParameter(\n  sourceSpan: ParseSourceSpan,\n  expression: string,\n  span: ParseSourceSpan,\n  loopItemName: string,\n  context: t.Variable[],\n  errors: ParseError[],\n): void {\n  const parts = expression.split(',');\n  let startSpan = span.start;\n  for (const part of parts) {\n    const expressionParts = part.split('=');\n    const name = expressionParts.length === 2 ? expressionParts[0].trim() : '';\n    const variableName = expressionParts.length === 2 ? expressionParts[1].trim() : '';\n\n    if (name.length === 0 || variableName.length === 0) {\n      errors.push(\n        new ParseError(\n          sourceSpan,\n          `Invalid @for loop \"let\" parameter. Parameter should match the pattern \"<name> = <variable name>\"`,\n        ),\n      );\n    } else if (!ALLOWED_FOR_LOOP_LET_VARIABLES.has(variableName)) {\n      errors.push(\n        new ParseError(\n          sourceSpan,\n          `Unknown \"let\" parameter variable \"${variableName}\". The allowed variables are: ${Array.from(\n            ALLOWED_FOR_LOOP_LET_VARIABLES,\n          ).join(', ')}`,\n        ),\n      );\n    } else if (name === loopItemName) {\n      errors.push(\n        new ParseError(\n          sourceSpan,\n          `Invalid @for loop \"let\" parameter. Variable cannot be called \"${loopItemName}\"`,\n        ),\n      );\n    } else if (context.some((v) => v.name === name)) {\n      errors.push(\n        new ParseError(sourceSpan, `Duplicate \"let\" parameter variable \"${variableName}\"`),\n      );\n    } else {\n      const [, keyLeadingWhitespace, keyName] =\n        expressionParts[0].match(CHARACTERS_IN_SURROUNDING_WHITESPACE_PATTERN) ?? [];\n      const keySpan =\n        keyLeadingWhitespace !== undefined && expressionParts.length === 2\n          ? new ParseSourceSpan(\n              /* strip leading spaces */\n              startSpan.moveBy(keyLeadingWhitespace.length),\n              /* advance to end of the variable name */\n              startSpan.moveBy(keyLeadingWhitespace.length + keyName.length),\n            )\n          : span;\n\n      let valueSpan: ParseSourceSpan | undefined = undefined;\n      if (expressionParts.length === 2) {\n        const [, valueLeadingWhitespace, implicit] =\n          expressionParts[1].match(CHARACTERS_IN_SURROUNDING_WHITESPACE_PATTERN) ?? [];\n        valueSpan =\n          valueLeadingWhitespace !== undefined\n            ? new ParseSourceSpan(\n                startSpan.moveBy(expressionParts[0].length + 1 + valueLeadingWhitespace.length),\n                startSpan.moveBy(\n                  expressionParts[0].length + 1 + valueLeadingWhitespace.length + implicit.length,\n                ),\n              )\n            : undefined;\n      }\n      const sourceSpan = new ParseSourceSpan(keySpan.start, valueSpan?.end ?? keySpan.end);\n      context.push(new t.Variable(name, variableName, sourceSpan, keySpan, valueSpan));\n    }\n    startSpan = startSpan.moveBy(part.length + 1 /* add 1 to move past the comma */);\n  }\n}\n\n/**\n * Checks that the shape of the blocks connected to an\n * `@if` block is correct. Returns an array of errors.\n */\nfunction validateIfConnectedBlocks(connectedBlocks: html.Block[]): ParseError[] {\n  const errors: ParseError[] = [];\n  let hasElse = false;\n\n  for (let i = 0; i < connectedBlocks.length; i++) {\n    const block = connectedBlocks[i];\n\n    if (block.name === 'else') {\n      if (hasElse) {\n        errors.push(\n          new ParseError(block.startSourceSpan, 'Conditional can only have one @else block'),\n        );\n      } else if (connectedBlocks.length > 1 && i < connectedBlocks.length - 1) {\n        errors.push(\n          new ParseError(block.startSourceSpan, '@else block must be last inside the conditional'),\n        );\n      } else if (block.parameters.length > 0) {\n        errors.push(new ParseError(block.startSourceSpan, '@else block cannot have parameters'));\n      }\n      hasElse = true;\n    } else if (!ELSE_IF_PATTERN.test(block.name)) {\n      errors.push(\n        new ParseError(block.startSourceSpan, `Unrecognized conditional block @${block.name}`),\n      );\n    }\n  }\n\n  return errors;\n}\n\n/** Checks that the shape of a `switch` block is valid. Returns an array of errors. */\nfunction validateSwitchBlock(ast: html.Block): ParseError[] {\n  const errors: ParseError[] = [];\n  let hasDefault = false;\n\n  if (ast.parameters.length !== 1) {\n    errors.push(\n      new ParseError(ast.startSourceSpan, '@switch block must have exactly one parameter'),\n    );\n    return errors;\n  }\n\n  for (const node of ast.children) {\n    // Skip over comments and empty text nodes inside the switch block.\n    // Empty text nodes can be used for formatting while comments don't affect the runtime.\n    if (\n      node instanceof html.Comment ||\n      (node instanceof html.Text && node.value.trim().length === 0)\n    ) {\n      continue;\n    }\n\n    if (!(node instanceof html.Block) || (node.name !== 'case' && node.name !== 'default')) {\n      errors.push(\n        new ParseError(node.sourceSpan, '@switch block can only contain @case and @default blocks'),\n      );\n      continue;\n    }\n\n    if (node.name === 'default') {\n      if (hasDefault) {\n        errors.push(\n          new ParseError(node.startSourceSpan, '@switch block can only have one @default block'),\n        );\n      } else if (node.parameters.length > 0) {\n        errors.push(new ParseError(node.startSourceSpan, '@default block cannot have parameters'));\n      }\n      hasDefault = true;\n    } else if (node.name === 'case' && node.parameters.length !== 1) {\n      errors.push(\n        new ParseError(node.startSourceSpan, '@case block must have exactly one parameter'),\n      );\n    }\n  }\n\n  return errors;\n}\n\n/**\n * Parses a block parameter into a binding AST.\n * @param ast Block parameter that should be parsed.\n * @param bindingParser Parser that the expression should be parsed with.\n * @param part Specific part of the expression that should be parsed.\n */\nfunction parseBlockParameterToBinding(\n  ast: html.BlockParameter,\n  bindingParser: BindingParser,\n  part?: string,\n): ASTWithSource {\n  let start: number;\n  let end: number;\n\n  if (typeof part === 'string') {\n    // Note: `lastIndexOf` here should be enough to know the start index of the expression,\n    // because we know that it'll be at the end of the param. Ideally we could use the `d`\n    // flag when matching via regex and get the index from `match.indices`, but it's unclear\n    // if we can use it yet since it's a relatively new feature. See:\n    // https://github.com/tc39/proposal-regexp-match-indices\n    start = Math.max(0, ast.expression.lastIndexOf(part));\n    end = start + part.length;\n  } else {\n    start = 0;\n    end = ast.expression.length;\n  }\n\n  return bindingParser.parseBinding(\n    ast.expression.slice(start, end),\n    false,\n    ast.sourceSpan,\n    ast.sourceSpan.start.offset + start,\n  );\n}\n\n/** Parses the parameter of a conditional block (`if` or `else if`). */\nfunction parseConditionalBlockParameters(\n  block: html.Block,\n  errors: ParseError[],\n  bindingParser: BindingParser,\n) {\n  if (block.parameters.length === 0) {\n    errors.push(\n      new ParseError(block.startSourceSpan, 'Conditional block does not have an expression'),\n    );\n    return null;\n  }\n\n  const expression = parseBlockParameterToBinding(block.parameters[0], bindingParser);\n  let expressionAlias: t.Variable | null = null;\n\n  // Start from 1 since we processed the first parameter already.\n  for (let i = 1; i < block.parameters.length; i++) {\n    const param = block.parameters[i];\n    const aliasMatch = param.expression.match(CONDITIONAL_ALIAS_PATTERN);\n\n    // For now conditionals can only have an `as` parameter.\n    // We may want to rework this later if we add more.\n    if (aliasMatch === null) {\n      errors.push(\n        new ParseError(\n          param.sourceSpan,\n          `Unrecognized conditional parameter \"${param.expression}\"`,\n        ),\n      );\n    } else if (block.name !== 'if' && !ELSE_IF_PATTERN.test(block.name)) {\n      errors.push(\n        new ParseError(\n          param.sourceSpan,\n          '\"as\" expression is only allowed on `@if` and `@else if` blocks',\n        ),\n      );\n    } else if (expressionAlias !== null) {\n      errors.push(\n        new ParseError(param.sourceSpan, 'Conditional can only have one \"as\" expression'),\n      );\n    } else {\n      const name = aliasMatch[2].trim();\n\n      if (IDENTIFIER_PATTERN.test(name)) {\n        const variableStart = param.sourceSpan.start.moveBy(aliasMatch[1].length);\n        const variableSpan = new ParseSourceSpan(variableStart, variableStart.moveBy(name.length));\n        expressionAlias = new t.Variable(name, name, variableSpan, variableSpan);\n      } else {\n        errors.push(\n          new ParseError(param.sourceSpan, '\"as\" expression must be a valid JavaScript identifier'),\n        );\n      }\n    }\n  }\n\n  return {expression, expressionAlias};\n}\n\n/** Strips optional parentheses around from a control from expression parameter. */\nfunction stripOptionalParentheses(param: html.BlockParameter, errors: ParseError[]): string | null {\n  const expression = param.expression;\n  const spaceRegex = /^\\s$/;\n  let openParens = 0;\n  let start = 0;\n  let end = expression.length - 1;\n\n  for (let i = 0; i < expression.length; i++) {\n    const char = expression[i];\n\n    if (char === '(') {\n      start = i + 1;\n      openParens++;\n    } else if (spaceRegex.test(char)) {\n      continue;\n    } else {\n      break;\n    }\n  }\n\n  if (openParens === 0) {\n    return expression;\n  }\n\n  for (let i = expression.length - 1; i > -1; i--) {\n    const char = expression[i];\n\n    if (char === ')') {\n      end = i;\n      openParens--;\n      if (openParens === 0) {\n        break;\n      }\n    } else if (spaceRegex.test(char)) {\n      continue;\n    } else {\n      break;\n    }\n  }\n\n  if (openParens !== 0) {\n    errors.push(new ParseError(param.sourceSpan, 'Unclosed parentheses in expression'));\n    return null;\n  }\n\n  return expression.slice(start, end);\n}\n\nclass PipeVisitor extends RecursiveAstVisitor {\n  hasPipe = false;\n  override visitPipe(): any {\n    this.hasPipe = true;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as chars from '../chars';\nimport {Lexer, Token, TokenType} from '../expression_parser/lexer';\nimport * as html from '../ml_parser/ast';\nimport {ParseError, ParseSourceSpan} from '../parse_util';\nimport {BindingParser} from '../template_parser/binding_parser';\n\nimport * as t from './r3_ast';\n\n/** Pattern for a timing value in a trigger. */\nconst TIME_PATTERN = /^\\d+\\.?\\d*(ms|s)?$/;\n\n/** Pattern for a separator between keywords in a trigger expression. */\nconst SEPARATOR_PATTERN = /^\\s$/;\n\n/** Pairs of characters that form syntax that is comma-delimited. */\nconst COMMA_DELIMITED_SYNTAX = new Map([\n  [chars.$LBRACE, chars.$RBRACE], // Object literals\n  [chars.$LBRACKET, chars.$RBRACKET], // Array literals\n  [chars.$LPAREN, chars.$RPAREN], // Function calls\n]);\n\n/** Possible types of `on` triggers. */\nenum OnTriggerType {\n  IDLE = 'idle',\n  TIMER = 'timer',\n  INTERACTION = 'interaction',\n  IMMEDIATE = 'immediate',\n  HOVER = 'hover',\n  VIEWPORT = 'viewport',\n  NEVER = 'never',\n}\n\n/** Function that validates the structure of a reference-based trigger. */\ntype ReferenceTriggerValidator = (type: OnTriggerType, parameters: string[]) => void;\n\n/** Parses a `when` deferred trigger. */\nexport function parseNeverTrigger(\n  {expression, sourceSpan}: html.BlockParameter,\n  triggers: t.DeferredBlockTriggers,\n  errors: ParseError[],\n): void {\n  const neverIndex = expression.indexOf('never');\n  const neverSourceSpan = new ParseSourceSpan(\n    sourceSpan.start.moveBy(neverIndex),\n    sourceSpan.start.moveBy(neverIndex + 'never'.length),\n  );\n  const prefetchSpan = getPrefetchSpan(expression, sourceSpan);\n  const hydrateSpan = getHydrateSpan(expression, sourceSpan);\n\n  // This is here just to be safe, we shouldn't enter this function\n  // in the first place if a block doesn't have the \"on\" keyword.\n  if (neverIndex === -1) {\n    errors.push(new ParseError(sourceSpan, `Could not find \"never\" keyword in expression`));\n  } else {\n    trackTrigger(\n      'never',\n      triggers,\n      errors,\n      new t.NeverDeferredTrigger(neverSourceSpan, sourceSpan, prefetchSpan, null, hydrateSpan),\n    );\n  }\n}\n\n/** Parses a `when` deferred trigger. */\nexport function parseWhenTrigger(\n  {expression, sourceSpan}: html.BlockParameter,\n  bindingParser: BindingParser,\n  triggers: t.DeferredBlockTriggers,\n  errors: ParseError[],\n): void {\n  const whenIndex = expression.indexOf('when');\n  const whenSourceSpan = new ParseSourceSpan(\n    sourceSpan.start.moveBy(whenIndex),\n    sourceSpan.start.moveBy(whenIndex + 'when'.length),\n  );\n  const prefetchSpan = getPrefetchSpan(expression, sourceSpan);\n  const hydrateSpan = getHydrateSpan(expression, sourceSpan);\n\n  // This is here just to be safe, we shouldn't enter this function\n  // in the first place if a block doesn't have the \"when\" keyword.\n  if (whenIndex === -1) {\n    errors.push(new ParseError(sourceSpan, `Could not find \"when\" keyword in expression`));\n  } else {\n    const start = getTriggerParametersStart(expression, whenIndex + 1);\n    const parsed = bindingParser.parseBinding(\n      expression.slice(start),\n      false,\n      sourceSpan,\n      sourceSpan.start.offset + start,\n    );\n    trackTrigger(\n      'when',\n      triggers,\n      errors,\n      new t.BoundDeferredTrigger(parsed, sourceSpan, prefetchSpan, whenSourceSpan, hydrateSpan),\n    );\n  }\n}\n\n/** Parses an `on` trigger */\nexport function parseOnTrigger(\n  {expression, sourceSpan}: html.BlockParameter,\n  triggers: t.DeferredBlockTriggers,\n  errors: ParseError[],\n  placeholder: t.DeferredBlockPlaceholder | null,\n): void {\n  const onIndex = expression.indexOf('on');\n  const onSourceSpan = new ParseSourceSpan(\n    sourceSpan.start.moveBy(onIndex),\n    sourceSpan.start.moveBy(onIndex + 'on'.length),\n  );\n  const prefetchSpan = getPrefetchSpan(expression, sourceSpan);\n  const hydrateSpan = getHydrateSpan(expression, sourceSpan);\n\n  // This is here just to be safe, we shouldn't enter this function\n  // in the first place if a block doesn't have the \"on\" keyword.\n  if (onIndex === -1) {\n    errors.push(new ParseError(sourceSpan, `Could not find \"on\" keyword in expression`));\n  } else {\n    const start = getTriggerParametersStart(expression, onIndex + 1);\n    const parser = new OnTriggerParser(\n      expression,\n      start,\n      sourceSpan,\n      triggers,\n      errors,\n      expression.startsWith('hydrate')\n        ? validateHydrateReferenceBasedTrigger\n        : validatePlainReferenceBasedTrigger,\n      placeholder,\n      prefetchSpan,\n      onSourceSpan,\n      hydrateSpan,\n    );\n    parser.parse();\n  }\n}\n\nfunction getPrefetchSpan(expression: string, sourceSpan: ParseSourceSpan) {\n  if (!expression.startsWith('prefetch')) {\n    return null;\n  }\n  return new ParseSourceSpan(sourceSpan.start, sourceSpan.start.moveBy('prefetch'.length));\n}\n\nfunction getHydrateSpan(expression: string, sourceSpan: ParseSourceSpan) {\n  if (!expression.startsWith('hydrate')) {\n    return null;\n  }\n  return new ParseSourceSpan(sourceSpan.start, sourceSpan.start.moveBy('hydrate'.length));\n}\n\nclass OnTriggerParser {\n  private index = 0;\n  private tokens: Token[];\n\n  constructor(\n    private expression: string,\n    private start: number,\n    private span: ParseSourceSpan,\n    private triggers: t.DeferredBlockTriggers,\n    private errors: ParseError[],\n    private validator: ReferenceTriggerValidator,\n    private placeholder: t.DeferredBlockPlaceholder | null,\n    private prefetchSpan: ParseSourceSpan | null,\n    private onSourceSpan: ParseSourceSpan,\n    private hydrateSpan: ParseSourceSpan | null,\n  ) {\n    this.tokens = new Lexer().tokenize(expression.slice(start));\n  }\n\n  parse(): void {\n    while (this.tokens.length > 0 && this.index < this.tokens.length) {\n      const token = this.token();\n\n      if (!token.isIdentifier()) {\n        this.unexpectedToken(token);\n        break;\n      }\n\n      // An identifier immediately followed by a comma or the end of\n      // the expression cannot have parameters so we can exit early.\n      if (this.isFollowedByOrLast(chars.$COMMA)) {\n        this.consumeTrigger(token, []);\n        this.advance();\n      } else if (this.isFollowedByOrLast(chars.$LPAREN)) {\n        this.advance(); // Advance to the opening paren.\n        const prevErrors = this.errors.length;\n        const parameters = this.consumeParameters();\n        if (this.errors.length !== prevErrors) {\n          break;\n        }\n        this.consumeTrigger(token, parameters);\n        this.advance(); // Advance past the closing paren.\n      } else if (this.index < this.tokens.length - 1) {\n        this.unexpectedToken(this.tokens[this.index + 1]);\n      }\n\n      this.advance();\n    }\n  }\n\n  private advance() {\n    this.index++;\n  }\n\n  private isFollowedByOrLast(char: number): boolean {\n    if (this.index === this.tokens.length - 1) {\n      return true;\n    }\n\n    return this.tokens[this.index + 1].isCharacter(char);\n  }\n\n  private token(): Token {\n    return this.tokens[Math.min(this.index, this.tokens.length - 1)];\n  }\n\n  private consumeTrigger(identifier: Token, parameters: string[]) {\n    const triggerNameStartSpan = this.span.start.moveBy(\n      this.start + identifier.index - this.tokens[0].index,\n    );\n    const nameSpan = new ParseSourceSpan(\n      triggerNameStartSpan,\n      triggerNameStartSpan.moveBy(identifier.strValue.length),\n    );\n    const endSpan = triggerNameStartSpan.moveBy(this.token().end - identifier.index);\n\n    // Put the prefetch and on spans with the first trigger\n    // This should maybe be refactored to have something like an outer OnGroup AST\n    // Since triggers can be grouped with commas \"on hover(x), interaction(y)\"\n    const isFirstTrigger = identifier.index === 0;\n    const onSourceSpan = isFirstTrigger ? this.onSourceSpan : null;\n    const prefetchSourceSpan = isFirstTrigger ? this.prefetchSpan : null;\n    const hydrateSourceSpan = isFirstTrigger ? this.hydrateSpan : null;\n    const sourceSpan = new ParseSourceSpan(\n      isFirstTrigger ? this.span.start : triggerNameStartSpan,\n      endSpan,\n    );\n\n    try {\n      switch (identifier.toString()) {\n        case OnTriggerType.IDLE:\n          this.trackTrigger(\n            'idle',\n            createIdleTrigger(\n              parameters,\n              nameSpan,\n              sourceSpan,\n              prefetchSourceSpan,\n              onSourceSpan,\n              hydrateSourceSpan,\n            ),\n          );\n          break;\n\n        case OnTriggerType.TIMER:\n          this.trackTrigger(\n            'timer',\n            createTimerTrigger(\n              parameters,\n              nameSpan,\n              sourceSpan,\n              this.prefetchSpan,\n              this.onSourceSpan,\n              this.hydrateSpan,\n            ),\n          );\n          break;\n\n        case OnTriggerType.INTERACTION:\n          this.trackTrigger(\n            'interaction',\n            createInteractionTrigger(\n              parameters,\n              nameSpan,\n              sourceSpan,\n              this.prefetchSpan,\n              this.onSourceSpan,\n              this.hydrateSpan,\n              this.validator,\n            ),\n          );\n          break;\n\n        case OnTriggerType.IMMEDIATE:\n          this.trackTrigger(\n            'immediate',\n            createImmediateTrigger(\n              parameters,\n              nameSpan,\n              sourceSpan,\n              this.prefetchSpan,\n              this.onSourceSpan,\n              this.hydrateSpan,\n            ),\n          );\n          break;\n\n        case OnTriggerType.HOVER:\n          this.trackTrigger(\n            'hover',\n            createHoverTrigger(\n              parameters,\n              nameSpan,\n              sourceSpan,\n              this.prefetchSpan,\n              this.onSourceSpan,\n              this.hydrateSpan,\n              this.placeholder,\n              this.validator,\n            ),\n          );\n          break;\n\n        case OnTriggerType.VIEWPORT:\n          this.trackTrigger(\n            'viewport',\n            createViewportTrigger(\n              parameters,\n              nameSpan,\n              sourceSpan,\n              this.prefetchSpan,\n              this.onSourceSpan,\n              this.hydrateSpan,\n              this.validator,\n            ),\n          );\n          break;\n\n        default:\n          throw new Error(`Unrecognized trigger type \"${identifier}\"`);\n      }\n    } catch (e) {\n      this.error(identifier, (e as Error).message);\n    }\n  }\n\n  private consumeParameters(): string[] {\n    const parameters: string[] = [];\n\n    if (!this.token().isCharacter(chars.$LPAREN)) {\n      this.unexpectedToken(this.token());\n      return parameters;\n    }\n\n    this.advance();\n\n    const commaDelimStack: number[] = [];\n    let current = '';\n\n    while (this.index < this.tokens.length) {\n      const token = this.token();\n\n      // Stop parsing if we've hit the end character and we're outside of a comma-delimited syntax.\n      // Note that we don't need to account for strings here since the lexer already parsed them\n      // into string tokens.\n      if (token.isCharacter(chars.$RPAREN) && commaDelimStack.length === 0) {\n        if (current.length) {\n          parameters.push(current);\n        }\n        break;\n      }\n\n      // In the `on` microsyntax \"top-level\" commas (e.g. ones outside of an parameters) separate\n      // the different triggers (e.g. `on idle,timer(500)`). This is problematic, because the\n      // function-like syntax also implies that multiple parameters can be passed into the\n      // individual trigger (e.g. `on foo(a, b)`). To avoid tripping up the parser with commas that\n      // are part of other sorts of syntax (object literals, arrays), we treat anything inside\n      // a comma-delimited syntax block as plain text.\n      if (token.type === TokenType.Character && COMMA_DELIMITED_SYNTAX.has(token.numValue)) {\n        commaDelimStack.push(COMMA_DELIMITED_SYNTAX.get(token.numValue)!);\n      }\n\n      if (\n        commaDelimStack.length > 0 &&\n        token.isCharacter(commaDelimStack[commaDelimStack.length - 1])\n      ) {\n        commaDelimStack.pop();\n      }\n\n      // If we hit a comma outside of a comma-delimited syntax, it means\n      // that we're at the top level and we're starting a new parameter.\n      if (commaDelimStack.length === 0 && token.isCharacter(chars.$COMMA) && current.length > 0) {\n        parameters.push(current);\n        current = '';\n        this.advance();\n        continue;\n      }\n\n      // Otherwise treat the token as a plain text character in the current parameter.\n      current += this.tokenText();\n      this.advance();\n    }\n\n    if (!this.token().isCharacter(chars.$RPAREN) || commaDelimStack.length > 0) {\n      this.error(this.token(), 'Unexpected end of expression');\n    }\n\n    if (\n      this.index < this.tokens.length - 1 &&\n      !this.tokens[this.index + 1].isCharacter(chars.$COMMA)\n    ) {\n      this.unexpectedToken(this.tokens[this.index + 1]);\n    }\n\n    return parameters;\n  }\n\n  private tokenText(): string {\n    // Tokens have a toString already which we could use, but for string tokens it omits the quotes.\n    // Eventually we could expose this information on the token directly.\n    return this.expression.slice(this.start + this.token().index, this.start + this.token().end);\n  }\n\n  private trackTrigger(name: keyof t.DeferredBlockTriggers, trigger: t.DeferredTrigger): void {\n    trackTrigger(name, this.triggers, this.errors, trigger);\n  }\n\n  private error(token: Token, message: string): void {\n    const newStart = this.span.start.moveBy(this.start + token.index);\n    const newEnd = newStart.moveBy(token.end - token.index);\n    this.errors.push(new ParseError(new ParseSourceSpan(newStart, newEnd), message));\n  }\n\n  private unexpectedToken(token: Token) {\n    this.error(token, `Unexpected token \"${token}\"`);\n  }\n}\n\n/** Adds a trigger to a map of triggers. */\nfunction trackTrigger(\n  name: keyof t.DeferredBlockTriggers,\n  allTriggers: t.DeferredBlockTriggers,\n  errors: ParseError[],\n  trigger: t.DeferredTrigger,\n) {\n  if (allTriggers[name]) {\n    errors.push(new ParseError(trigger.sourceSpan, `Duplicate \"${name}\" trigger is not allowed`));\n  } else {\n    allTriggers[name] = trigger as any;\n  }\n}\n\nfunction createIdleTrigger(\n  parameters: string[],\n  nameSpan: ParseSourceSpan,\n  sourceSpan: ParseSourceSpan,\n  prefetchSpan: ParseSourceSpan | null,\n  onSourceSpan: ParseSourceSpan | null,\n  hydrateSpan: ParseSourceSpan | null,\n): t.IdleDeferredTrigger {\n  if (parameters.length > 0) {\n    throw new Error(`\"${OnTriggerType.IDLE}\" trigger cannot have parameters`);\n  }\n\n  return new t.IdleDeferredTrigger(nameSpan, sourceSpan, prefetchSpan, onSourceSpan, hydrateSpan);\n}\n\nfunction createTimerTrigger(\n  parameters: string[],\n  nameSpan: ParseSourceSpan,\n  sourceSpan: ParseSourceSpan,\n  prefetchSpan: ParseSourceSpan | null,\n  onSourceSpan: ParseSourceSpan | null,\n  hydrateSpan: ParseSourceSpan | null,\n) {\n  if (parameters.length !== 1) {\n    throw new Error(`\"${OnTriggerType.TIMER}\" trigger must have exactly one parameter`);\n  }\n\n  const delay = parseDeferredTime(parameters[0]);\n\n  if (delay === null) {\n    throw new Error(`Could not parse time value of trigger \"${OnTriggerType.TIMER}\"`);\n  }\n\n  return new t.TimerDeferredTrigger(\n    delay,\n    nameSpan,\n    sourceSpan,\n    prefetchSpan,\n    onSourceSpan,\n    hydrateSpan,\n  );\n}\n\nfunction createImmediateTrigger(\n  parameters: string[],\n  nameSpan: ParseSourceSpan,\n  sourceSpan: ParseSourceSpan,\n  prefetchSpan: ParseSourceSpan | null,\n  onSourceSpan: ParseSourceSpan | null,\n  hydrateSpan: ParseSourceSpan | null,\n): t.ImmediateDeferredTrigger {\n  if (parameters.length > 0) {\n    throw new Error(`\"${OnTriggerType.IMMEDIATE}\" trigger cannot have parameters`);\n  }\n\n  return new t.ImmediateDeferredTrigger(\n    nameSpan,\n    sourceSpan,\n    prefetchSpan,\n    onSourceSpan,\n    hydrateSpan,\n  );\n}\n\nfunction createHoverTrigger(\n  parameters: string[],\n  nameSpan: ParseSourceSpan,\n  sourceSpan: ParseSourceSpan,\n  prefetchSpan: ParseSourceSpan | null,\n  onSourceSpan: ParseSourceSpan | null,\n  hydrateSpan: ParseSourceSpan | null,\n  placeholder: t.DeferredBlockPlaceholder | null,\n  validator: ReferenceTriggerValidator,\n): t.HoverDeferredTrigger {\n  validator(OnTriggerType.HOVER, parameters);\n  return new t.HoverDeferredTrigger(\n    parameters[0] ?? null,\n    nameSpan,\n    sourceSpan,\n    prefetchSpan,\n    onSourceSpan,\n    hydrateSpan,\n  );\n}\n\nfunction createInteractionTrigger(\n  parameters: string[],\n  nameSpan: ParseSourceSpan,\n  sourceSpan: ParseSourceSpan,\n  prefetchSpan: ParseSourceSpan | null,\n  onSourceSpan: ParseSourceSpan | null,\n  hydrateSpan: ParseSourceSpan | null,\n  validator: ReferenceTriggerValidator,\n): t.InteractionDeferredTrigger {\n  validator(OnTriggerType.INTERACTION, parameters);\n  return new t.InteractionDeferredTrigger(\n    parameters[0] ?? null,\n    nameSpan,\n    sourceSpan,\n    prefetchSpan,\n    onSourceSpan,\n    hydrateSpan,\n  );\n}\n\nfunction createViewportTrigger(\n  parameters: string[],\n  nameSpan: ParseSourceSpan,\n  sourceSpan: ParseSourceSpan,\n  prefetchSpan: ParseSourceSpan | null,\n  onSourceSpan: ParseSourceSpan | null,\n  hydrateSpan: ParseSourceSpan | null,\n  validator: ReferenceTriggerValidator,\n): t.ViewportDeferredTrigger {\n  validator(OnTriggerType.VIEWPORT, parameters);\n  return new t.ViewportDeferredTrigger(\n    parameters[0] ?? null,\n    nameSpan,\n    sourceSpan,\n    prefetchSpan,\n    onSourceSpan,\n    hydrateSpan,\n  );\n}\n\n/**\n * Checks whether the structure of a non-hydrate reference-based trigger is valid.\n * @param type Type of the trigger being validated.\n * @param parameters Parameters of the trigger.\n */\nfunction validatePlainReferenceBasedTrigger(type: OnTriggerType, parameters: string[]) {\n  if (parameters.length > 1) {\n    throw new Error(`\"${type}\" trigger can only have zero or one parameters`);\n  }\n}\n\n/**\n * Checks whether the structure of a hydrate trigger is valid.\n * @param type Type of the trigger being validated.\n * @param parameters Parameters of the trigger.\n */\nfunction validateHydrateReferenceBasedTrigger(type: OnTriggerType, parameters: string[]) {\n  if (parameters.length > 0) {\n    throw new Error(`Hydration trigger \"${type}\" cannot have parameters`);\n  }\n}\n\n/** Gets the index within an expression at which the trigger parameters start. */\nexport function getTriggerParametersStart(value: string, startPosition = 0): number {\n  let hasFoundSeparator = false;\n\n  for (let i = startPosition; i < value.length; i++) {\n    if (SEPARATOR_PATTERN.test(value[i])) {\n      hasFoundSeparator = true;\n    } else if (hasFoundSeparator) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\n/**\n * Parses a time expression from a deferred trigger to\n * milliseconds. Returns null if it cannot be parsed.\n */\nexport function parseDeferredTime(value: string): number | null {\n  const match = value.match(TIME_PATTERN);\n\n  if (!match) {\n    return null;\n  }\n\n  const [time, units] = match;\n  return parseFloat(time) * (units === 's' ? 1000 : 1);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as html from '../ml_parser/ast';\nimport {ParseError, ParseSourceSpan} from '../parse_util';\nimport {BindingParser} from '../template_parser/binding_parser';\n\nimport * as t from './r3_ast';\nimport {\n  getTriggerParametersStart,\n  parseDeferredTime,\n  parseNeverTrigger,\n  parseOnTrigger,\n  parseWhenTrigger,\n} from './r3_deferred_triggers';\n\n/** Pattern to identify a `prefetch when` trigger. */\nconst PREFETCH_WHEN_PATTERN = /^prefetch\\s+when\\s/;\n\n/** Pattern to identify a `prefetch on` trigger. */\nconst PREFETCH_ON_PATTERN = /^prefetch\\s+on\\s/;\n\n/** Pattern to identify a `hydrate when` trigger. */\nconst HYDRATE_WHEN_PATTERN = /^hydrate\\s+when\\s/;\n\n/** Pattern to identify a `hydrate on` trigger. */\nconst HYDRATE_ON_PATTERN = /^hydrate\\s+on\\s/;\n\n/** Pattern to identify a `hydrate never` trigger. */\nconst HYDRATE_NEVER_PATTERN = /^hydrate\\s+never(\\s*)$/;\n\n/** Pattern to identify a `minimum` parameter in a block. */\nconst MINIMUM_PARAMETER_PATTERN = /^minimum\\s/;\n\n/** Pattern to identify a `after` parameter in a block. */\nconst AFTER_PARAMETER_PATTERN = /^after\\s/;\n\n/** Pattern to identify a `when` parameter in a block. */\nconst WHEN_PARAMETER_PATTERN = /^when\\s/;\n\n/** Pattern to identify a `on` parameter in a block. */\nconst ON_PARAMETER_PATTERN = /^on\\s/;\n\n/**\n * Predicate function that determines if a block with\n * a specific name cam be connected to a `defer` block.\n */\nexport function isConnectedDeferLoopBlock(name: string): boolean {\n  return name === 'placeholder' || name === 'loading' || name === 'error';\n}\n\n/** Creates a deferred block from an HTML AST node. */\nexport function createDeferredBlock(\n  ast: html.Block,\n  connectedBlocks: html.Block[],\n  visitor: html.Visitor,\n  bindingParser: BindingParser,\n): {node: t.DeferredBlock; errors: ParseError[]} {\n  const errors: ParseError[] = [];\n  const {placeholder, loading, error} = parseConnectedBlocks(connectedBlocks, errors, visitor);\n  const {triggers, prefetchTriggers, hydrateTriggers} = parsePrimaryTriggers(\n    ast,\n    bindingParser,\n    errors,\n    placeholder,\n  );\n\n  // The `defer` block has a main span encompassing all of the connected branches as well.\n  let lastEndSourceSpan = ast.endSourceSpan;\n  let endOfLastSourceSpan = ast.sourceSpan.end;\n  if (connectedBlocks.length > 0) {\n    const lastConnectedBlock = connectedBlocks[connectedBlocks.length - 1];\n    lastEndSourceSpan = lastConnectedBlock.endSourceSpan;\n    endOfLastSourceSpan = lastConnectedBlock.sourceSpan.end;\n  }\n\n  const sourceSpanWithConnectedBlocks = new ParseSourceSpan(\n    ast.sourceSpan.start,\n    endOfLastSourceSpan,\n  );\n\n  const node = new t.DeferredBlock(\n    html.visitAll(visitor, ast.children, ast.children),\n    triggers,\n    prefetchTriggers,\n    hydrateTriggers,\n    placeholder,\n    loading,\n    error,\n    ast.nameSpan,\n    sourceSpanWithConnectedBlocks,\n    ast.sourceSpan,\n    ast.startSourceSpan,\n    lastEndSourceSpan,\n    ast.i18n,\n  );\n\n  return {node, errors};\n}\n\nfunction parseConnectedBlocks(\n  connectedBlocks: html.Block[],\n  errors: ParseError[],\n  visitor: html.Visitor,\n) {\n  let placeholder: t.DeferredBlockPlaceholder | null = null;\n  let loading: t.DeferredBlockLoading | null = null;\n  let error: t.DeferredBlockError | null = null;\n\n  for (const block of connectedBlocks) {\n    try {\n      if (!isConnectedDeferLoopBlock(block.name)) {\n        errors.push(new ParseError(block.startSourceSpan, `Unrecognized block \"@${block.name}\"`));\n        break;\n      }\n\n      switch (block.name) {\n        case 'placeholder':\n          if (placeholder !== null) {\n            errors.push(\n              new ParseError(\n                block.startSourceSpan,\n                `@defer block can only have one @placeholder block`,\n              ),\n            );\n          } else {\n            placeholder = parsePlaceholderBlock(block, visitor);\n          }\n          break;\n\n        case 'loading':\n          if (loading !== null) {\n            errors.push(\n              new ParseError(\n                block.startSourceSpan,\n                `@defer block can only have one @loading block`,\n              ),\n            );\n          } else {\n            loading = parseLoadingBlock(block, visitor);\n          }\n          break;\n\n        case 'error':\n          if (error !== null) {\n            errors.push(\n              new ParseError(block.startSourceSpan, `@defer block can only have one @error block`),\n            );\n          } else {\n            error = parseErrorBlock(block, visitor);\n          }\n          break;\n      }\n    } catch (e) {\n      errors.push(new ParseError(block.startSourceSpan, (e as Error).message));\n    }\n  }\n\n  return {placeholder, loading, error};\n}\n\nfunction parsePlaceholderBlock(ast: html.Block, visitor: html.Visitor): t.DeferredBlockPlaceholder {\n  let minimumTime: number | null = null;\n\n  for (const param of ast.parameters) {\n    if (MINIMUM_PARAMETER_PATTERN.test(param.expression)) {\n      if (minimumTime != null) {\n        throw new Error(`@placeholder block can only have one \"minimum\" parameter`);\n      }\n\n      const parsedTime = parseDeferredTime(\n        param.expression.slice(getTriggerParametersStart(param.expression)),\n      );\n\n      if (parsedTime === null) {\n        throw new Error(`Could not parse time value of parameter \"minimum\"`);\n      }\n\n      minimumTime = parsedTime;\n    } else {\n      throw new Error(`Unrecognized parameter in @placeholder block: \"${param.expression}\"`);\n    }\n  }\n\n  return new t.DeferredBlockPlaceholder(\n    html.visitAll(visitor, ast.children, ast.children),\n    minimumTime,\n    ast.nameSpan,\n    ast.sourceSpan,\n    ast.startSourceSpan,\n    ast.endSourceSpan,\n    ast.i18n,\n  );\n}\n\nfunction parseLoadingBlock(ast: html.Block, visitor: html.Visitor): t.DeferredBlockLoading {\n  let afterTime: number | null = null;\n  let minimumTime: number | null = null;\n\n  for (const param of ast.parameters) {\n    if (AFTER_PARAMETER_PATTERN.test(param.expression)) {\n      if (afterTime != null) {\n        throw new Error(`@loading block can only have one \"after\" parameter`);\n      }\n\n      const parsedTime = parseDeferredTime(\n        param.expression.slice(getTriggerParametersStart(param.expression)),\n      );\n\n      if (parsedTime === null) {\n        throw new Error(`Could not parse time value of parameter \"after\"`);\n      }\n\n      afterTime = parsedTime;\n    } else if (MINIMUM_PARAMETER_PATTERN.test(param.expression)) {\n      if (minimumTime != null) {\n        throw new Error(`@loading block can only have one \"minimum\" parameter`);\n      }\n\n      const parsedTime = parseDeferredTime(\n        param.expression.slice(getTriggerParametersStart(param.expression)),\n      );\n\n      if (parsedTime === null) {\n        throw new Error(`Could not parse time value of parameter \"minimum\"`);\n      }\n\n      minimumTime = parsedTime;\n    } else {\n      throw new Error(`Unrecognized parameter in @loading block: \"${param.expression}\"`);\n    }\n  }\n\n  return new t.DeferredBlockLoading(\n    html.visitAll(visitor, ast.children, ast.children),\n    afterTime,\n    minimumTime,\n    ast.nameSpan,\n    ast.sourceSpan,\n    ast.startSourceSpan,\n    ast.endSourceSpan,\n    ast.i18n,\n  );\n}\n\nfunction parseErrorBlock(ast: html.Block, visitor: html.Visitor): t.DeferredBlockError {\n  if (ast.parameters.length > 0) {\n    throw new Error(`@error block cannot have parameters`);\n  }\n\n  return new t.DeferredBlockError(\n    html.visitAll(visitor, ast.children, ast.children),\n    ast.nameSpan,\n    ast.sourceSpan,\n    ast.startSourceSpan,\n    ast.endSourceSpan,\n    ast.i18n,\n  );\n}\n\nfunction parsePrimaryTriggers(\n  ast: html.Block,\n  bindingParser: BindingParser,\n  errors: ParseError[],\n  placeholder: t.DeferredBlockPlaceholder | null,\n) {\n  const triggers: t.DeferredBlockTriggers = {};\n  const prefetchTriggers: t.DeferredBlockTriggers = {};\n  const hydrateTriggers: t.DeferredBlockTriggers = {};\n\n  for (const param of ast.parameters) {\n    // The lexer ignores the leading spaces so we can assume\n    // that the expression starts with a keyword.\n    if (WHEN_PARAMETER_PATTERN.test(param.expression)) {\n      parseWhenTrigger(param, bindingParser, triggers, errors);\n    } else if (ON_PARAMETER_PATTERN.test(param.expression)) {\n      parseOnTrigger(param, triggers, errors, placeholder);\n    } else if (PREFETCH_WHEN_PATTERN.test(param.expression)) {\n      parseWhenTrigger(param, bindingParser, prefetchTriggers, errors);\n    } else if (PREFETCH_ON_PATTERN.test(param.expression)) {\n      parseOnTrigger(param, prefetchTriggers, errors, placeholder);\n    } else if (HYDRATE_WHEN_PATTERN.test(param.expression)) {\n      parseWhenTrigger(param, bindingParser, hydrateTriggers, errors);\n    } else if (HYDRATE_ON_PATTERN.test(param.expression)) {\n      parseOnTrigger(param, hydrateTriggers, errors, placeholder);\n    } else if (HYDRATE_NEVER_PATTERN.test(param.expression)) {\n      parseNeverTrigger(param, hydrateTriggers, errors);\n    } else {\n      errors.push(new ParseError(param.sourceSpan, 'Unrecognized trigger'));\n    }\n  }\n\n  if (hydrateTriggers.never && Object.keys(hydrateTriggers).length > 1) {\n    errors.push(\n      new ParseError(\n        ast.startSourceSpan,\n        'Cannot specify additional `hydrate` triggers if `hydrate never` is present',\n      ),\n    );\n  }\n\n  return {triggers, prefetchTriggers, hydrateTriggers};\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  BindingType,\n  EmptyExpr,\n  ParsedEvent,\n  ParsedProperty,\n  ParsedVariable,\n} from '../expression_parser/ast';\nimport * as i18n from '../i18n/i18n_ast';\nimport * as html from '../ml_parser/ast';\nimport {replaceNgsp} from '../ml_parser/html_whitespaces';\nimport {isNgTemplate} from '../ml_parser/tags';\nimport {InterpolatedAttributeToken, InterpolatedTextToken} from '../ml_parser/tokens';\nimport {ParseError, ParseErrorLevel, ParseSourceSpan} from '../parse_util';\nimport {isStyleUrlResolvable} from '../style_url_resolver';\nimport {isI18nRootNode} from '../template/pipeline/src/ingest';\nimport {BindingParser} from '../template_parser/binding_parser';\nimport {PreparsedElementType, preparseElement} from '../template_parser/template_preparser';\n\nimport * as t from './r3_ast';\nimport {\n  createForLoop,\n  createIfBlock,\n  createSwitchBlock,\n  isConnectedForLoopBlock,\n  isConnectedIfLoopBlock,\n} from './r3_control_flow';\nimport {createDeferredBlock, isConnectedDeferLoopBlock} from './r3_deferred_blocks';\nimport {I18N_ICU_VAR_PREFIX} from './view/i18n/util';\n\nconst BIND_NAME_REGEXP = /^(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.*)$/;\n\n// Group 1 = \"bind-\"\nconst KW_BIND_IDX = 1;\n// Group 2 = \"let-\"\nconst KW_LET_IDX = 2;\n// Group 3 = \"ref-/#\"\nconst KW_REF_IDX = 3;\n// Group 4 = \"on-\"\nconst KW_ON_IDX = 4;\n// Group 5 = \"bindon-\"\nconst KW_BINDON_IDX = 5;\n// Group 6 = \"@\"\nconst KW_AT_IDX = 6;\n// Group 7 = the identifier after \"bind-\", \"let-\", \"ref-/#\", \"on-\", \"bindon-\" or \"@\"\nconst IDENT_KW_IDX = 7;\n\nconst BINDING_DELIMS = {\n  BANANA_BOX: {start: '[(', end: ')]'},\n  PROPERTY: {start: '[', end: ']'},\n  EVENT: {start: '(', end: ')'},\n};\n\nconst TEMPLATE_ATTR_PREFIX = '*';\n\n// TODO(crisbeto): any other tag names that shouldn't be allowed here?\nconst UNSUPPORTED_SELECTORLESS_TAGS = new Set([\n  'link',\n  'style',\n  'script',\n  'ng-template',\n  'ng-container',\n  'ng-content',\n]);\n\n// TODO(crisbeto): any other attributes that should not be allowed here?\nconst UNSUPPORTED_SELECTORLESS_DIRECTIVE_ATTRS = new Set(['ngProjectAs', 'ngNonBindable']);\n\n// Result of the html AST to Ivy AST transformation\nexport interface Render3ParseResult {\n  nodes: t.Node[];\n  errors: ParseError[];\n  styles: string[];\n  styleUrls: string[];\n  ngContentSelectors: string[];\n  // Will be defined if `Render3ParseOptions['collectCommentNodes']` is true\n  commentNodes?: t.Comment[];\n}\n\ninterface Render3ParseOptions {\n  collectCommentNodes: boolean;\n}\n\nexport function htmlAstToRender3Ast(\n  htmlNodes: html.Node[],\n  bindingParser: BindingParser,\n  options: Render3ParseOptions,\n): Render3ParseResult {\n  const transformer = new HtmlAstToIvyAst(bindingParser, options);\n  const ivyNodes = html.visitAll(transformer, htmlNodes, htmlNodes);\n\n  // Errors might originate in either the binding parser or the html to ivy transformer\n  const allErrors = bindingParser.errors.concat(transformer.errors);\n\n  const result: Render3ParseResult = {\n    nodes: ivyNodes,\n    errors: allErrors,\n    styleUrls: transformer.styleUrls,\n    styles: transformer.styles,\n    ngContentSelectors: transformer.ngContentSelectors,\n  };\n  if (options.collectCommentNodes) {\n    result.commentNodes = transformer.commentNodes;\n  }\n  return result;\n}\n\nclass HtmlAstToIvyAst implements html.Visitor {\n  errors: ParseError[] = [];\n  styles: string[] = [];\n  styleUrls: string[] = [];\n  ngContentSelectors: string[] = [];\n  // This array will be populated if `Render3ParseOptions['collectCommentNodes']` is true\n  commentNodes: t.Comment[] = [];\n  private inI18nBlock: boolean = false;\n\n  /**\n   * Keeps track of the nodes that have been processed already when previous nodes were visited.\n   * These are typically blocks connected to other blocks or text nodes between connected blocks.\n   */\n  private processedNodes = new Set<html.Block | html.Text>();\n\n  constructor(\n    private bindingParser: BindingParser,\n    private options: Render3ParseOptions,\n  ) {}\n\n  // HTML visitor\n  visitElement(element: html.Element): t.Node | null {\n    const isI18nRootElement = isI18nRootNode(element.i18n);\n    if (isI18nRootElement) {\n      if (this.inI18nBlock) {\n        this.reportError(\n          'Cannot mark an element as translatable inside of a translatable section. Please remove the nested i18n marker.',\n          element.sourceSpan,\n        );\n      }\n      this.inI18nBlock = true;\n    }\n    const preparsedElement = preparseElement(element);\n    if (preparsedElement.type === PreparsedElementType.SCRIPT) {\n      return null;\n    } else if (preparsedElement.type === PreparsedElementType.STYLE) {\n      const contents = textContents(element);\n      if (contents !== null) {\n        this.styles.push(contents);\n      }\n      return null;\n    } else if (\n      preparsedElement.type === PreparsedElementType.STYLESHEET &&\n      isStyleUrlResolvable(preparsedElement.hrefAttr)\n    ) {\n      this.styleUrls.push(preparsedElement.hrefAttr);\n      return null;\n    }\n\n    // Whether the element is a `<ng-template>`\n    const isTemplateElement = isNgTemplate(element.name);\n    const {\n      attributes,\n      boundEvents,\n      references,\n      variables,\n      templateVariables,\n      elementHasInlineTemplate,\n      parsedProperties,\n      templateParsedProperties,\n      i18nAttrsMeta,\n    } = this.prepareAttributes(element.attrs, isTemplateElement);\n\n    const directives = this.extractDirectives(element);\n    let children: t.Node[];\n\n    if (preparsedElement.nonBindable) {\n      // The `NonBindableVisitor` may need to return an array of nodes for blocks so we need\n      // to flatten the array here. Avoid doing this for the `HtmlAstToIvyAst` since `flat` creates\n      // a new array.\n      children = html.visitAll(NON_BINDABLE_VISITOR, element.children).flat(Infinity);\n    } else {\n      children = html.visitAll(this, element.children, element.children);\n    }\n\n    let parsedElement: t.Content | t.Template | t.Element | undefined;\n    if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {\n      const selector = preparsedElement.selectAttr;\n      const attrs: t.TextAttribute[] = element.attrs.map((attr) => this.visitAttribute(attr));\n      parsedElement = new t.Content(\n        selector,\n        attrs,\n        children,\n        element.isSelfClosing,\n        element.sourceSpan,\n        element.startSourceSpan,\n        element.endSourceSpan,\n        element.i18n,\n      );\n      this.ngContentSelectors.push(selector);\n    } else if (isTemplateElement) {\n      // `<ng-template>`\n      const attrs = this.categorizePropertyAttributes(\n        element.name,\n        parsedProperties,\n        i18nAttrsMeta,\n      );\n\n      parsedElement = new t.Template(\n        element.name,\n        attributes,\n        attrs.bound,\n        boundEvents,\n        directives,\n        [\n          /* no template attributes */\n        ],\n        children,\n        references,\n        variables,\n        element.isSelfClosing,\n        element.sourceSpan,\n        element.startSourceSpan,\n        element.endSourceSpan,\n        element.i18n,\n      );\n    } else {\n      const attrs = this.categorizePropertyAttributes(\n        element.name,\n        parsedProperties,\n        i18nAttrsMeta,\n      );\n\n      if (element.name === 'ng-container') {\n        for (const bound of attrs.bound) {\n          if (bound.type === BindingType.Attribute) {\n            this.reportError(\n              `Attribute bindings are not supported on ng-container. Use property bindings instead.`,\n              bound.sourceSpan,\n            );\n          }\n        }\n      }\n\n      parsedElement = new t.Element(\n        element.name,\n        attributes,\n        attrs.bound,\n        boundEvents,\n        directives,\n        children,\n        references,\n        element.isSelfClosing,\n        element.sourceSpan,\n        element.startSourceSpan,\n        element.endSourceSpan,\n        element.isVoid,\n        element.i18n,\n      );\n    }\n\n    if (elementHasInlineTemplate) {\n      // If this node is an inline-template (e.g. has *ngFor) then we need to create a template\n      // node that contains this node.\n      parsedElement = this.wrapInTemplate(\n        parsedElement,\n        templateParsedProperties,\n        templateVariables,\n        i18nAttrsMeta,\n        isTemplateElement,\n        isI18nRootElement,\n      );\n    }\n    if (isI18nRootElement) {\n      this.inI18nBlock = false;\n    }\n    return parsedElement;\n  }\n\n  visitAttribute(attribute: html.Attribute): t.TextAttribute {\n    return new t.TextAttribute(\n      attribute.name,\n      attribute.value,\n      attribute.sourceSpan,\n      attribute.keySpan,\n      attribute.valueSpan,\n      attribute.i18n,\n    );\n  }\n\n  visitText(text: html.Text): t.Node | null {\n    return this.processedNodes.has(text)\n      ? null\n      : this._visitTextWithInterpolation(text.value, text.sourceSpan, text.tokens, text.i18n);\n  }\n\n  visitExpansion(expansion: html.Expansion): t.Icu | null {\n    if (!expansion.i18n) {\n      // do not generate Icu in case it was created\n      // outside of i18n block in a template\n      return null;\n    }\n    if (!isI18nRootNode(expansion.i18n)) {\n      throw new Error(\n        `Invalid type \"${\n          expansion.i18n.constructor\n        }\" for \"i18n\" property of ${expansion.sourceSpan.toString()}. Expected a \"Message\"`,\n      );\n    }\n    const message = expansion.i18n;\n    const vars: {[name: string]: t.BoundText} = {};\n    const placeholders: {[name: string]: t.Text | t.BoundText} = {};\n    // extract VARs from ICUs - we process them separately while\n    // assembling resulting message via goog.getMsg function, since\n    // we need to pass them to top-level goog.getMsg call\n    Object.keys(message.placeholders).forEach((key) => {\n      const value = message.placeholders[key];\n      if (key.startsWith(I18N_ICU_VAR_PREFIX)) {\n        // Currently when the `plural` or `select` keywords in an ICU contain trailing spaces (e.g.\n        // `{count, select , ...}`), these spaces are also included into the key names in ICU vars\n        // (e.g. \"VAR_SELECT \"). These trailing spaces are not desirable, since they will later be\n        // converted into `_` symbols while normalizing placeholder names, which might lead to\n        // mismatches at runtime (i.e. placeholder will not be replaced with the correct value).\n        const formattedKey = key.trim();\n\n        const ast = this.bindingParser.parseInterpolationExpression(value.text, value.sourceSpan);\n\n        vars[formattedKey] = new t.BoundText(ast, value.sourceSpan);\n      } else {\n        placeholders[key] = this._visitTextWithInterpolation(value.text, value.sourceSpan, null);\n      }\n    });\n    return new t.Icu(vars, placeholders, expansion.sourceSpan, message);\n  }\n\n  visitExpansionCase(expansionCase: html.ExpansionCase): null {\n    return null;\n  }\n\n  visitComment(comment: html.Comment): null {\n    if (this.options.collectCommentNodes) {\n      this.commentNodes.push(new t.Comment(comment.value || '', comment.sourceSpan));\n    }\n    return null;\n  }\n\n  visitLetDeclaration(decl: html.LetDeclaration, context: any) {\n    const value = this.bindingParser.parseBinding(\n      decl.value,\n      false,\n      decl.valueSpan,\n      decl.valueSpan.start.offset,\n    );\n\n    if (value.errors.length === 0 && value.ast instanceof EmptyExpr) {\n      this.reportError('@let declaration value cannot be empty', decl.valueSpan);\n    }\n\n    return new t.LetDeclaration(decl.name, value, decl.sourceSpan, decl.nameSpan, decl.valueSpan);\n  }\n\n  visitComponent(component: html.Component) {\n    const isI18nRootElement = isI18nRootNode(component.i18n);\n    if (isI18nRootElement) {\n      if (this.inI18nBlock) {\n        this.reportError(\n          'Cannot mark a component as translatable inside of a translatable section. Please remove the nested i18n marker.',\n          component.sourceSpan,\n        );\n      }\n      this.inI18nBlock = true;\n    }\n\n    if (component.tagName !== null && UNSUPPORTED_SELECTORLESS_TAGS.has(component.tagName)) {\n      this.reportError(\n        `Tag name \"${component.tagName}\" cannot be used as a component tag`,\n        component.startSourceSpan,\n      );\n      return null;\n    }\n\n    const {\n      attributes,\n      boundEvents,\n      references,\n      templateVariables,\n      elementHasInlineTemplate,\n      parsedProperties,\n      templateParsedProperties,\n      i18nAttrsMeta,\n    } = this.prepareAttributes(component.attrs, false);\n\n    this.validateSelectorlessReferences(references);\n\n    const directives = this.extractDirectives(component);\n    let children: t.Node[];\n\n    if (component.attrs.find((attr) => attr.name === 'ngNonBindable')) {\n      // The `NonBindableVisitor` may need to return an array of nodes for blocks so we need\n      // to flatten the array here. Avoid doing this for the `HtmlAstToIvyAst` since `flat` creates\n      // a new array.\n      children = html.visitAll(NON_BINDABLE_VISITOR, component.children).flat(Infinity);\n    } else {\n      children = html.visitAll(this, component.children, component.children);\n    }\n\n    const attrs = this.categorizePropertyAttributes(\n      component.tagName,\n      parsedProperties,\n      i18nAttrsMeta,\n    );\n\n    let node: t.Component | t.Template = new t.Component(\n      component.componentName,\n      component.tagName,\n      component.fullName,\n      attributes,\n      attrs.bound,\n      boundEvents,\n      directives,\n      children,\n      references,\n      component.isSelfClosing,\n      component.sourceSpan,\n      component.startSourceSpan,\n      component.endSourceSpan,\n      component.i18n,\n    );\n\n    if (elementHasInlineTemplate) {\n      node = this.wrapInTemplate(\n        node,\n        templateParsedProperties,\n        templateVariables,\n        i18nAttrsMeta,\n        false,\n        isI18nRootElement,\n      );\n    }\n    if (isI18nRootElement) {\n      this.inI18nBlock = false;\n    }\n    return node;\n  }\n\n  visitDirective() {\n    return null;\n  }\n\n  visitBlockParameter() {\n    return null;\n  }\n\n  visitBlock(block: html.Block, context: html.Node[]) {\n    const index = Array.isArray(context) ? context.indexOf(block) : -1;\n\n    if (index === -1) {\n      throw new Error(\n        'Visitor invoked incorrectly. Expecting visitBlock to be invoked siblings array as its context',\n      );\n    }\n\n    // Connected blocks may have been processed as a part of the previous block.\n    if (this.processedNodes.has(block)) {\n      return null;\n    }\n\n    let result: {node: t.Node | null; errors: ParseError[]} | null = null;\n\n    switch (block.name) {\n      case 'defer':\n        result = createDeferredBlock(\n          block,\n          this.findConnectedBlocks(index, context, isConnectedDeferLoopBlock),\n          this,\n          this.bindingParser,\n        );\n        break;\n\n      case 'switch':\n        result = createSwitchBlock(block, this, this.bindingParser);\n        break;\n\n      case 'for':\n        result = createForLoop(\n          block,\n          this.findConnectedBlocks(index, context, isConnectedForLoopBlock),\n          this,\n          this.bindingParser,\n        );\n        break;\n\n      case 'if':\n        result = createIfBlock(\n          block,\n          this.findConnectedBlocks(index, context, isConnectedIfLoopBlock),\n          this,\n          this.bindingParser,\n        );\n        break;\n\n      default:\n        let errorMessage: string;\n\n        if (isConnectedDeferLoopBlock(block.name)) {\n          errorMessage = `@${block.name} block can only be used after an @defer block.`;\n          this.processedNodes.add(block);\n        } else if (isConnectedForLoopBlock(block.name)) {\n          errorMessage = `@${block.name} block can only be used after an @for block.`;\n          this.processedNodes.add(block);\n        } else if (isConnectedIfLoopBlock(block.name)) {\n          errorMessage = `@${block.name} block can only be used after an @if or @else if block.`;\n          this.processedNodes.add(block);\n        } else {\n          errorMessage = `Unrecognized block @${block.name}.`;\n        }\n\n        result = {\n          node: new t.UnknownBlock(block.name, block.sourceSpan, block.nameSpan),\n          errors: [new ParseError(block.sourceSpan, errorMessage)],\n        };\n        break;\n    }\n\n    this.errors.push(...result.errors);\n    return result.node;\n  }\n\n  private findConnectedBlocks(\n    primaryBlockIndex: number,\n    siblings: html.Node[],\n    predicate: (blockName: string) => boolean,\n  ): html.Block[] {\n    const relatedBlocks: html.Block[] = [];\n\n    for (let i = primaryBlockIndex + 1; i < siblings.length; i++) {\n      const node = siblings[i];\n\n      // Skip over comments.\n      if (node instanceof html.Comment) {\n        continue;\n      }\n\n      // Ignore empty text nodes between blocks.\n      if (node instanceof html.Text && node.value.trim().length === 0) {\n        // Add the text node to the processed nodes since we don't want\n        // it to be generated between the connected nodes.\n        this.processedNodes.add(node);\n        continue;\n      }\n\n      // Stop searching as soon as we hit a non-block node or a block that is unrelated.\n      if (!(node instanceof html.Block) || !predicate(node.name)) {\n        break;\n      }\n\n      relatedBlocks.push(node);\n      this.processedNodes.add(node);\n    }\n\n    return relatedBlocks;\n  }\n\n  /** Splits up the property attributes depending on whether they're static or bound. */\n  private categorizePropertyAttributes(\n    elementName: string | null,\n    properties: ParsedProperty[],\n    i18nPropsMeta: {[key: string]: i18n.I18nMeta},\n  ): {bound: t.BoundAttribute[]; literal: t.TextAttribute[]} {\n    const bound: t.BoundAttribute[] = [];\n    const literal: t.TextAttribute[] = [];\n\n    properties.forEach((prop) => {\n      const i18n = i18nPropsMeta[prop.name];\n      if (prop.isLiteral) {\n        literal.push(\n          new t.TextAttribute(\n            prop.name,\n            prop.expression.source || '',\n            prop.sourceSpan,\n            prop.keySpan,\n            prop.valueSpan,\n            i18n,\n          ),\n        );\n      } else {\n        // Note that validation is skipped and property mapping is disabled\n        // due to the fact that we need to make sure a given prop is not an\n        // input of a directive and directive matching happens at runtime.\n        const bep = this.bindingParser.createBoundElementProperty(\n          elementName,\n          prop,\n          /* skipValidation */ true,\n          /* mapPropertyName */ false,\n        );\n        bound.push(t.BoundAttribute.fromBoundElementProperty(bep, i18n));\n      }\n    });\n\n    return {bound, literal};\n  }\n\n  private prepareAttributes(attrs: html.Attribute[], isTemplateElement: boolean) {\n    const parsedProperties: ParsedProperty[] = [];\n    const boundEvents: t.BoundEvent[] = [];\n    const variables: t.Variable[] = [];\n    const references: t.Reference[] = [];\n    const attributes: t.TextAttribute[] = [];\n    const i18nAttrsMeta: Record<string, i18n.I18nMeta> = {};\n    const templateParsedProperties: ParsedProperty[] = [];\n    const templateVariables: t.Variable[] = [];\n\n    // Whether the element has any *-attribute\n    let elementHasInlineTemplate = false;\n\n    for (const attribute of attrs) {\n      let hasBinding = false;\n      const normalizedName = normalizeAttributeName(attribute.name);\n\n      // `*attr` defines template bindings\n      let isTemplateBinding = false;\n\n      if (attribute.i18n) {\n        i18nAttrsMeta[attribute.name] = attribute.i18n;\n      }\n\n      if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX)) {\n        // *-attributes\n        if (elementHasInlineTemplate) {\n          this.reportError(\n            `Can't have multiple template bindings on one element. Use only one attribute prefixed with *`,\n            attribute.sourceSpan,\n          );\n        }\n        isTemplateBinding = true;\n        elementHasInlineTemplate = true;\n        const templateValue = attribute.value;\n        const templateKey = normalizedName.substring(TEMPLATE_ATTR_PREFIX.length);\n\n        const parsedVariables: ParsedVariable[] = [];\n        const absoluteValueOffset = attribute.valueSpan\n          ? attribute.valueSpan.fullStart.offset\n          : // If there is no value span the attribute does not have a value, like `attr` in\n            //`<div attr></div>`. In this case, point to one character beyond the last character of\n            // the attribute name.\n            attribute.sourceSpan.fullStart.offset + attribute.name.length;\n\n        this.bindingParser.parseInlineTemplateBinding(\n          templateKey,\n          templateValue,\n          attribute.sourceSpan,\n          absoluteValueOffset,\n          [],\n          templateParsedProperties,\n          parsedVariables,\n          true /* isIvyAst */,\n        );\n        templateVariables.push(\n          ...parsedVariables.map(\n            (v) => new t.Variable(v.name, v.value, v.sourceSpan, v.keySpan, v.valueSpan),\n          ),\n        );\n      } else {\n        // Check for variables, events, property bindings, interpolation\n        hasBinding = this.parseAttribute(\n          isTemplateElement,\n          attribute,\n          [],\n          parsedProperties,\n          boundEvents,\n          variables,\n          references,\n        );\n      }\n\n      if (!hasBinding && !isTemplateBinding) {\n        // don't include the bindings as attributes as well in the AST\n        attributes.push(this.visitAttribute(attribute));\n      }\n    }\n\n    return {\n      attributes,\n      boundEvents,\n      references,\n      variables,\n      templateVariables,\n      elementHasInlineTemplate,\n      parsedProperties,\n      templateParsedProperties,\n      i18nAttrsMeta,\n    };\n  }\n\n  private parseAttribute(\n    isTemplateElement: boolean,\n    attribute: html.Attribute,\n    matchableAttributes: string[][],\n    parsedProperties: ParsedProperty[],\n    boundEvents: t.BoundEvent[],\n    variables: t.Variable[],\n    references: t.Reference[],\n  ) {\n    const name = normalizeAttributeName(attribute.name);\n    const value = attribute.value;\n    const srcSpan = attribute.sourceSpan;\n    const absoluteOffset = attribute.valueSpan\n      ? attribute.valueSpan.fullStart.offset\n      : srcSpan.fullStart.offset;\n\n    function createKeySpan(srcSpan: ParseSourceSpan, prefix: string, identifier: string) {\n      // We need to adjust the start location for the keySpan to account for the removed 'data-'\n      // prefix from `normalizeAttributeName`.\n      const normalizationAdjustment = attribute.name.length - name.length;\n      const keySpanStart = srcSpan.start.moveBy(prefix.length + normalizationAdjustment);\n      const keySpanEnd = keySpanStart.moveBy(identifier.length);\n      return new ParseSourceSpan(keySpanStart, keySpanEnd, keySpanStart, identifier);\n    }\n\n    const bindParts = name.match(BIND_NAME_REGEXP);\n\n    if (bindParts) {\n      if (bindParts[KW_BIND_IDX] != null) {\n        const identifier = bindParts[IDENT_KW_IDX];\n        const keySpan = createKeySpan(srcSpan, bindParts[KW_BIND_IDX], identifier);\n        this.bindingParser.parsePropertyBinding(\n          identifier,\n          value,\n          false,\n          false,\n          srcSpan,\n          absoluteOffset,\n          attribute.valueSpan,\n          matchableAttributes,\n          parsedProperties,\n          keySpan,\n        );\n      } else if (bindParts[KW_LET_IDX]) {\n        if (isTemplateElement) {\n          const identifier = bindParts[IDENT_KW_IDX];\n          const keySpan = createKeySpan(srcSpan, bindParts[KW_LET_IDX], identifier);\n          this.parseVariable(identifier, value, srcSpan, keySpan, attribute.valueSpan, variables);\n        } else {\n          this.reportError(`\"let-\" is only supported on ng-template elements.`, srcSpan);\n        }\n      } else if (bindParts[KW_REF_IDX]) {\n        const identifier = bindParts[IDENT_KW_IDX];\n        const keySpan = createKeySpan(srcSpan, bindParts[KW_REF_IDX], identifier);\n        this.parseReference(identifier, value, srcSpan, keySpan, attribute.valueSpan, references);\n      } else if (bindParts[KW_ON_IDX]) {\n        const events: ParsedEvent[] = [];\n        const identifier = bindParts[IDENT_KW_IDX];\n        const keySpan = createKeySpan(srcSpan, bindParts[KW_ON_IDX], identifier);\n        this.bindingParser.parseEvent(\n          identifier,\n          value,\n          /* isAssignmentEvent */ false,\n          srcSpan,\n          attribute.valueSpan || srcSpan,\n          matchableAttributes,\n          events,\n          keySpan,\n        );\n        addEvents(events, boundEvents);\n      } else if (bindParts[KW_BINDON_IDX]) {\n        const identifier = bindParts[IDENT_KW_IDX];\n        const keySpan = createKeySpan(srcSpan, bindParts[KW_BINDON_IDX], identifier);\n        this.bindingParser.parsePropertyBinding(\n          identifier,\n          value,\n          false,\n          true,\n          srcSpan,\n          absoluteOffset,\n          attribute.valueSpan,\n          matchableAttributes,\n          parsedProperties,\n          keySpan,\n        );\n        this.parseAssignmentEvent(\n          identifier,\n          value,\n          srcSpan,\n          attribute.valueSpan,\n          matchableAttributes,\n          boundEvents,\n          keySpan,\n          absoluteOffset,\n        );\n      } else if (bindParts[KW_AT_IDX]) {\n        const keySpan = createKeySpan(srcSpan, '', name);\n        this.bindingParser.parseLiteralAttr(\n          name,\n          value,\n          srcSpan,\n          absoluteOffset,\n          attribute.valueSpan,\n          matchableAttributes,\n          parsedProperties,\n          keySpan,\n        );\n      }\n      return true;\n    }\n\n    // We didn't see a kw-prefixed property binding, but we have not yet checked\n    // for the []/()/[()] syntax.\n    let delims: {start: string; end: string} | null = null;\n    if (name.startsWith(BINDING_DELIMS.BANANA_BOX.start)) {\n      delims = BINDING_DELIMS.BANANA_BOX;\n    } else if (name.startsWith(BINDING_DELIMS.PROPERTY.start)) {\n      delims = BINDING_DELIMS.PROPERTY;\n    } else if (name.startsWith(BINDING_DELIMS.EVENT.start)) {\n      delims = BINDING_DELIMS.EVENT;\n    }\n    if (\n      delims !== null &&\n      // NOTE: older versions of the parser would match a start/end delimited\n      // binding iff the property name was terminated by the ending delimiter\n      // and the identifier in the binding was non-empty.\n      // TODO(ayazhafiz): update this to handle malformed bindings.\n      name.endsWith(delims.end) &&\n      name.length > delims.start.length + delims.end.length\n    ) {\n      const identifier = name.substring(delims.start.length, name.length - delims.end.length);\n      const keySpan = createKeySpan(srcSpan, delims.start, identifier);\n      if (delims.start === BINDING_DELIMS.BANANA_BOX.start) {\n        this.bindingParser.parsePropertyBinding(\n          identifier,\n          value,\n          false,\n          true,\n          srcSpan,\n          absoluteOffset,\n          attribute.valueSpan,\n          matchableAttributes,\n          parsedProperties,\n          keySpan,\n        );\n        this.parseAssignmentEvent(\n          identifier,\n          value,\n          srcSpan,\n          attribute.valueSpan,\n          matchableAttributes,\n          boundEvents,\n          keySpan,\n          absoluteOffset,\n        );\n      } else if (delims.start === BINDING_DELIMS.PROPERTY.start) {\n        this.bindingParser.parsePropertyBinding(\n          identifier,\n          value,\n          false,\n          false,\n          srcSpan,\n          absoluteOffset,\n          attribute.valueSpan,\n          matchableAttributes,\n          parsedProperties,\n          keySpan,\n        );\n      } else {\n        const events: ParsedEvent[] = [];\n        this.bindingParser.parseEvent(\n          identifier,\n          value,\n          /* isAssignmentEvent */ false,\n          srcSpan,\n          attribute.valueSpan || srcSpan,\n          matchableAttributes,\n          events,\n          keySpan,\n        );\n        addEvents(events, boundEvents);\n      }\n\n      return true;\n    }\n\n    // No explicit binding found.\n    const keySpan = createKeySpan(srcSpan, '' /* prefix */, name);\n    const hasBinding = this.bindingParser.parsePropertyInterpolation(\n      name,\n      value,\n      srcSpan,\n      attribute.valueSpan,\n      matchableAttributes,\n      parsedProperties,\n      keySpan,\n      attribute.valueTokens ?? null,\n    );\n    return hasBinding;\n  }\n\n  private extractDirectives(node: html.Element | html.Component): t.Directive[] {\n    const elementName = node instanceof html.Component ? node.tagName : node.name;\n    const directives: t.Directive[] = [];\n    const seenDirectives = new Set<string>();\n\n    for (const directive of node.directives) {\n      let invalid = false;\n\n      for (const attr of directive.attrs) {\n        if (attr.name.startsWith(TEMPLATE_ATTR_PREFIX)) {\n          invalid = true;\n          this.reportError(\n            `Shorthand template syntax \"${attr.name}\" is not supported inside a directive context`,\n            attr.sourceSpan,\n          );\n        } else if (UNSUPPORTED_SELECTORLESS_DIRECTIVE_ATTRS.has(attr.name)) {\n          invalid = true;\n          this.reportError(\n            `Attribute \"${attr.name}\" is not supported in a directive context`,\n            attr.sourceSpan,\n          );\n        }\n      }\n\n      if (!invalid && seenDirectives.has(directive.name)) {\n        invalid = true;\n        this.reportError(\n          `Cannot apply directive \"${directive.name}\" multiple times on the same element`,\n          directive.sourceSpan,\n        );\n      }\n\n      if (invalid) {\n        continue;\n      }\n\n      const {attributes, parsedProperties, boundEvents, references, i18nAttrsMeta} =\n        this.prepareAttributes(directive.attrs, false);\n      this.validateSelectorlessReferences(references);\n\n      const {bound: inputs} = this.categorizePropertyAttributes(\n        elementName,\n        parsedProperties,\n        i18nAttrsMeta,\n      );\n\n      for (const input of inputs) {\n        if (input.type !== BindingType.Property && input.type !== BindingType.TwoWay) {\n          invalid = true;\n          this.reportError('Binding is not supported in a directive context', input.sourceSpan);\n        }\n      }\n\n      if (invalid) {\n        continue;\n      }\n\n      seenDirectives.add(directive.name);\n      directives.push(\n        new t.Directive(\n          directive.name,\n          attributes,\n          inputs,\n          boundEvents,\n          references,\n          directive.sourceSpan,\n          directive.startSourceSpan,\n          directive.endSourceSpan,\n          undefined,\n        ),\n      );\n    }\n\n    return directives;\n  }\n\n  private filterAnimationAttributes(attributes: t.TextAttribute[]): t.TextAttribute[] {\n    return attributes.filter((a) => !a.name.startsWith('animate.'));\n  }\n\n  private filterAnimationInputs(attributes: t.BoundAttribute[]): t.BoundAttribute[] {\n    return attributes.filter((a) => a.type !== BindingType.Animation);\n  }\n\n  private wrapInTemplate(\n    node: t.Element | t.Component | t.Content | t.Template,\n    templateProperties: ParsedProperty[],\n    templateVariables: t.Variable[],\n    i18nAttrsMeta: Record<string, i18n.I18nMeta>,\n    isTemplateElement: boolean,\n    isI18nRootElement: boolean,\n  ) {\n    // We need to hoist the attributes of the node to the template for content projection purposes.\n    const attrs = this.categorizePropertyAttributes(\n      'ng-template',\n      templateProperties,\n      i18nAttrsMeta,\n    );\n    const templateAttrs: (t.TextAttribute | t.BoundAttribute)[] = [];\n    attrs.literal.forEach((attr) => templateAttrs.push(attr));\n    attrs.bound.forEach((attr) => templateAttrs.push(attr));\n\n    const hoistedAttrs = {\n      attributes: [] as t.TextAttribute[],\n      inputs: [] as t.BoundAttribute[],\n      outputs: [] as t.BoundEvent[],\n    };\n\n    if (node instanceof t.Element || node instanceof t.Component) {\n      hoistedAttrs.attributes.push(...this.filterAnimationAttributes(node.attributes));\n      hoistedAttrs.inputs.push(...this.filterAnimationInputs(node.inputs));\n      hoistedAttrs.outputs.push(...node.outputs);\n    }\n\n    // For <ng-template>s with structural directives on them, avoid passing i18n information to\n    // the wrapping template to prevent unnecessary i18n instructions from being generated. The\n    // necessary i18n meta information will be extracted from child elements.\n    const i18n = isTemplateElement && isI18nRootElement ? undefined : node.i18n;\n    let name: string | null;\n\n    if (node instanceof t.Component) {\n      name = node.tagName;\n    } else if (node instanceof t.Template) {\n      name = null;\n    } else {\n      name = node.name;\n    }\n\n    return new t.Template(\n      name,\n      hoistedAttrs.attributes,\n      hoistedAttrs.inputs,\n      hoistedAttrs.outputs,\n      [\n        // Do not copy over the directives.\n      ],\n      templateAttrs,\n      [node],\n      [\n        // Do not copy over the references.\n      ],\n      templateVariables,\n      false,\n      node.sourceSpan,\n      node.startSourceSpan,\n      node.endSourceSpan,\n      i18n,\n    );\n  }\n\n  private _visitTextWithInterpolation(\n    value: string,\n    sourceSpan: ParseSourceSpan,\n    interpolatedTokens: InterpolatedAttributeToken[] | InterpolatedTextToken[] | null,\n    i18n?: i18n.I18nMeta,\n  ): t.Text | t.BoundText {\n    const valueNoNgsp = replaceNgsp(value);\n    const expr = this.bindingParser.parseInterpolation(valueNoNgsp, sourceSpan, interpolatedTokens);\n    return expr ? new t.BoundText(expr, sourceSpan, i18n) : new t.Text(valueNoNgsp, sourceSpan);\n  }\n\n  private parseVariable(\n    identifier: string,\n    value: string,\n    sourceSpan: ParseSourceSpan,\n    keySpan: ParseSourceSpan,\n    valueSpan: ParseSourceSpan | undefined,\n    variables: t.Variable[],\n  ) {\n    if (identifier.indexOf('-') > -1) {\n      this.reportError(`\"-\" is not allowed in variable names`, sourceSpan);\n    } else if (identifier.length === 0) {\n      this.reportError(`Variable does not have a name`, sourceSpan);\n    }\n\n    variables.push(new t.Variable(identifier, value, sourceSpan, keySpan, valueSpan));\n  }\n\n  private parseReference(\n    identifier: string,\n    value: string,\n    sourceSpan: ParseSourceSpan,\n    keySpan: ParseSourceSpan,\n    valueSpan: ParseSourceSpan | undefined,\n    references: t.Reference[],\n  ) {\n    if (identifier.indexOf('-') > -1) {\n      this.reportError(`\"-\" is not allowed in reference names`, sourceSpan);\n    } else if (identifier.length === 0) {\n      this.reportError(`Reference does not have a name`, sourceSpan);\n    } else if (references.some((reference) => reference.name === identifier)) {\n      this.reportError(`Reference \"#${identifier}\" is defined more than once`, sourceSpan);\n    }\n\n    references.push(new t.Reference(identifier, value, sourceSpan, keySpan, valueSpan));\n  }\n\n  private parseAssignmentEvent(\n    name: string,\n    expression: string,\n    sourceSpan: ParseSourceSpan,\n    valueSpan: ParseSourceSpan | undefined,\n    targetMatchableAttrs: string[][],\n    boundEvents: t.BoundEvent[],\n    keySpan: ParseSourceSpan,\n    absoluteOffset: number,\n  ) {\n    const events: ParsedEvent[] = [];\n    this.bindingParser.parseEvent(\n      `${name}Change`,\n      expression,\n      /* isAssignmentEvent */ true,\n      sourceSpan,\n      valueSpan || sourceSpan,\n      targetMatchableAttrs,\n      events,\n      keySpan,\n    );\n    addEvents(events, boundEvents);\n  }\n\n  private validateSelectorlessReferences(references: t.Reference[]): void {\n    if (references.length === 0) {\n      return;\n    }\n\n    const seenNames = new Set<string>();\n\n    for (const ref of references) {\n      if (ref.value.length > 0) {\n        this.reportError(\n          'Cannot specify a value for a local reference in this context',\n          ref.valueSpan || ref.sourceSpan,\n        );\n      } else if (seenNames.has(ref.name)) {\n        this.reportError('Duplicate reference names are not allowed', ref.sourceSpan);\n      } else {\n        seenNames.add(ref.name);\n      }\n    }\n  }\n\n  private reportError(\n    message: string,\n    sourceSpan: ParseSourceSpan,\n    level: ParseErrorLevel = ParseErrorLevel.ERROR,\n  ) {\n    this.errors.push(new ParseError(sourceSpan, message, level));\n  }\n}\n\nclass NonBindableVisitor implements html.Visitor {\n  visitElement(ast: html.Element): t.Element | null {\n    const preparsedElement = preparseElement(ast);\n    if (\n      preparsedElement.type === PreparsedElementType.SCRIPT ||\n      preparsedElement.type === PreparsedElementType.STYLE ||\n      preparsedElement.type === PreparsedElementType.STYLESHEET\n    ) {\n      // Skipping <script> for security reasons\n      // Skipping <style> and stylesheets as we already processed them\n      // in the StyleCompiler\n      return null;\n    }\n\n    const children: t.Node[] = html.visitAll(this, ast.children, null);\n    return new t.Element(\n      ast.name,\n      html.visitAll(this, ast.attrs) as t.TextAttribute[],\n      /* inputs */ [],\n      /* outputs */ [],\n      /* directives */ [],\n      children,\n      /* references */ [],\n      ast.isSelfClosing,\n      ast.sourceSpan,\n      ast.startSourceSpan,\n      ast.endSourceSpan,\n      ast.isVoid,\n    );\n  }\n\n  visitComment(comment: html.Comment): any {\n    return null;\n  }\n\n  visitAttribute(attribute: html.Attribute): t.TextAttribute {\n    return new t.TextAttribute(\n      attribute.name,\n      attribute.value,\n      attribute.sourceSpan,\n      attribute.keySpan,\n      attribute.valueSpan,\n      attribute.i18n,\n    );\n  }\n\n  visitText(text: html.Text): t.Text {\n    return new t.Text(text.value, text.sourceSpan);\n  }\n\n  visitExpansion(expansion: html.Expansion): any {\n    return null;\n  }\n\n  visitExpansionCase(expansionCase: html.ExpansionCase): any {\n    return null;\n  }\n\n  visitBlock(block: html.Block, context: any) {\n    const nodes = [\n      // In an ngNonBindable context we treat the opening/closing tags of block as plain text.\n      // This is the as if the `tokenizeBlocks` option was disabled.\n      new t.Text(block.startSourceSpan.toString(), block.startSourceSpan),\n      ...html.visitAll(this, block.children),\n    ];\n\n    if (block.endSourceSpan !== null) {\n      nodes.push(new t.Text(block.endSourceSpan.toString(), block.endSourceSpan));\n    }\n\n    return nodes;\n  }\n\n  visitBlockParameter(parameter: html.BlockParameter, context: any) {\n    return null;\n  }\n\n  visitLetDeclaration(decl: html.LetDeclaration, context: any) {\n    return new t.Text(`@let ${decl.name} = ${decl.value};`, decl.sourceSpan);\n  }\n\n  visitComponent(ast: html.Component, context: any) {\n    const children: t.Node[] = html.visitAll(this, ast.children, null);\n    return new t.Element(\n      ast.fullName,\n      html.visitAll(this, ast.attrs) as t.TextAttribute[],\n      /* inputs */ [],\n      /* outputs */ [],\n      /* directives */ [],\n      children,\n      /* references */ [],\n      ast.isSelfClosing,\n      ast.sourceSpan,\n      ast.startSourceSpan,\n      ast.endSourceSpan,\n      false,\n    );\n  }\n\n  visitDirective(directive: html.Directive, context: any) {\n    return null;\n  }\n}\n\nconst NON_BINDABLE_VISITOR = new NonBindableVisitor();\n\nfunction normalizeAttributeName(attrName: string): string {\n  return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;\n}\n\nfunction addEvents(events: ParsedEvent[], boundEvents: t.BoundEvent[]) {\n  boundEvents.push(...events.map((e) => t.BoundEvent.fromParsedEvent(e)));\n}\n\nfunction textContents(node: html.Element): string | null {\n  if (node.children.length !== 1 || !(node.children[0] instanceof html.Text)) {\n    return null;\n  } else {\n    return (node.children[0] as html.Text).value;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Lexer} from '../../expression_parser/lexer';\nimport {Parser} from '../../expression_parser/parser';\nimport * as html from '../../ml_parser/ast';\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from '../../ml_parser/defaults';\nimport {HtmlParser} from '../../ml_parser/html_parser';\nimport {WhitespaceVisitor} from '../../ml_parser/html_whitespaces';\nimport {LexerRange} from '../../ml_parser/lexer';\nimport {ParseError} from '../../parse_util';\nimport {DomElementSchemaRegistry} from '../../schema/dom_element_schema_registry';\nimport {BindingParser} from '../../template_parser/binding_parser';\nimport * as t from '../r3_ast';\nimport {htmlAstToRender3Ast} from '../r3_template_transform';\n\nimport {I18nMetaVisitor} from './i18n/meta';\n\nexport const LEADING_TRIVIA_CHARS = [' ', '\\n', '\\r', '\\t'];\n\n/**\n * Options that can be used to modify how a template is parsed by `parseTemplate()`.\n */\nexport interface ParseTemplateOptions {\n  /**\n   * Include whitespace nodes in the parsed output.\n   */\n  preserveWhitespaces?: boolean;\n  /**\n   * Preserve original line endings instead of normalizing '\\r\\n' endings to '\\n'.\n   */\n  preserveLineEndings?: boolean;\n  /**\n   * Preserve whitespace significant to rendering.\n   */\n  preserveSignificantWhitespace?: boolean;\n  /**\n   * How to parse interpolation markers.\n   */\n  interpolationConfig?: InterpolationConfig;\n  /**\n   * The start and end point of the text to parse within the `source` string.\n   * The entire `source` string is parsed if this is not provided.\n   * */\n  range?: LexerRange;\n  /**\n   * If this text is stored in a JavaScript string, then we have to deal with escape sequences.\n   *\n   * **Example 1:**\n   *\n   * ```\n   * \"abc\\\"def\\nghi\"\n   * ```\n   *\n   * - The `\\\"` must be converted to `\"`.\n   * - The `\\n` must be converted to a new line character in a token,\n   *   but it should not increment the current line for source mapping.\n   *\n   * **Example 2:**\n   *\n   * ```\n   * \"abc\\\n   *  def\"\n   * ```\n   *\n   * The line continuation (`\\` followed by a newline) should be removed from a token\n   * but the new line should increment the current line for source mapping.\n   */\n  escapedString?: boolean;\n  /**\n   * An array of characters that should be considered as leading trivia.\n   * Leading trivia are characters that are not important to the developer, and so should not be\n   * included in source-map segments.  A common example is whitespace.\n   */\n  leadingTriviaChars?: string[];\n\n  /**\n   * Render `$localize` message ids with additional legacy message ids.\n   *\n   * This option defaults to `true` but in the future the default will be flipped.\n   *\n   * For now set this option to false if you have migrated the translation files to use the new\n   * `$localize` message id format and you are not using compile time translation merging.\n   */\n  enableI18nLegacyMessageIdFormat?: boolean;\n\n  /**\n   * If this text is stored in an external template (e.g. via `templateUrl`) then we need to decide\n   * whether or not to normalize the line-endings (from `\\r\\n` to `\\n`) when processing ICU\n   * expressions.\n   *\n   * If `true` then we will normalize ICU expression line endings.\n   * The default is `false`, but this will be switched in a future major release.\n   */\n  i18nNormalizeLineEndingsInICUs?: boolean;\n\n  /**\n   * Whether to always attempt to convert the parsed HTML AST to an R3 AST, despite HTML or i18n\n   * Meta parse errors.\n   *\n   *\n   * This option is useful in the context of the language service, where we want to get as much\n   * information as possible, despite any errors in the HTML. As an example, a user may be adding\n   * a new tag and expecting autocomplete on that tag. In this scenario, the HTML is in an errored\n   * state, as there is an incomplete open tag. However, we're still able to convert the HTML AST\n   * nodes to R3 AST nodes in order to provide information for the language service.\n   *\n   * Note that even when `true` the HTML parse and i18n errors are still appended to the errors\n   * output, but this is done after converting the HTML AST to R3 AST.\n   */\n  alwaysAttemptHtmlToR3AstConversion?: boolean;\n\n  /**\n   * Include HTML Comment nodes in a top-level comments array on the returned R3 AST.\n   *\n   * This option is required by tooling that needs to know the location of comment nodes within the\n   * AST. A concrete example is @angular-eslint which requires this in order to enable\n   * \"eslint-disable\" comments within HTML templates, which then allows users to turn off specific\n   * rules on a case by case basis, instead of for their whole project within a configuration file.\n   */\n  collectCommentNodes?: boolean;\n\n  /** Whether the @ block syntax is enabled. */\n  enableBlockSyntax?: boolean;\n\n  /** Whether the `@let` syntax is enabled. */\n  enableLetSyntax?: boolean;\n\n  /** Whether the selectorless syntax is enabled. */\n  enableSelectorless?: boolean;\n}\n\n/**\n * Parse a template into render3 `Node`s and additional metadata, with no other dependencies.\n *\n * @param template text of the template to parse\n * @param templateUrl URL to use for source mapping of the parsed template\n * @param options options to modify how the template is parsed\n */\nexport function parseTemplate(\n  template: string,\n  templateUrl: string,\n  options: ParseTemplateOptions = {},\n): ParsedTemplate {\n  const {interpolationConfig, preserveWhitespaces, enableI18nLegacyMessageIdFormat} = options;\n  const selectorlessEnabled = options.enableSelectorless ?? false;\n  const bindingParser = makeBindingParser(interpolationConfig, selectorlessEnabled);\n  const htmlParser = new HtmlParser();\n  const parseResult = htmlParser.parse(template, templateUrl, {\n    leadingTriviaChars: LEADING_TRIVIA_CHARS,\n    ...options,\n    tokenizeExpansionForms: true,\n    tokenizeBlocks: options.enableBlockSyntax ?? true,\n    tokenizeLet: options.enableLetSyntax ?? true,\n    selectorlessEnabled,\n  });\n\n  if (\n    !options.alwaysAttemptHtmlToR3AstConversion &&\n    parseResult.errors &&\n    parseResult.errors.length > 0\n  ) {\n    const parsedTemplate: ParsedTemplate = {\n      interpolationConfig,\n      preserveWhitespaces,\n      errors: parseResult.errors,\n      nodes: [],\n      styleUrls: [],\n      styles: [],\n      ngContentSelectors: [],\n    };\n    if (options.collectCommentNodes) {\n      parsedTemplate.commentNodes = [];\n    }\n    return parsedTemplate;\n  }\n\n  let rootNodes: html.Node[] = parseResult.rootNodes;\n\n  // We need to use the same `retainEmptyTokens` value for both parses to avoid\n  // causing a mismatch when reusing source spans, even if the\n  // `preserveSignificantWhitespace` behavior is different between the two\n  // parses.\n  const retainEmptyTokens = !(options.preserveSignificantWhitespace ?? true);\n\n  // process i18n meta information (scan attributes, generate ids)\n  // before we run whitespace removal process, because existing i18n\n  // extraction process (ng extract-i18n) relies on a raw content to generate\n  // message ids\n  const i18nMetaVisitor = new I18nMetaVisitor(\n    interpolationConfig,\n    /* keepI18nAttrs */ !preserveWhitespaces,\n    enableI18nLegacyMessageIdFormat,\n    /* containerBlocks */ undefined,\n    options.preserveSignificantWhitespace,\n    retainEmptyTokens,\n  );\n  const i18nMetaResult = i18nMetaVisitor.visitAllWithErrors(rootNodes);\n\n  if (\n    !options.alwaysAttemptHtmlToR3AstConversion &&\n    i18nMetaResult.errors &&\n    i18nMetaResult.errors.length > 0\n  ) {\n    const parsedTemplate: ParsedTemplate = {\n      interpolationConfig,\n      preserveWhitespaces,\n      errors: i18nMetaResult.errors,\n      nodes: [],\n      styleUrls: [],\n      styles: [],\n      ngContentSelectors: [],\n    };\n    if (options.collectCommentNodes) {\n      parsedTemplate.commentNodes = [];\n    }\n    return parsedTemplate;\n  }\n\n  rootNodes = i18nMetaResult.rootNodes;\n\n  if (!preserveWhitespaces) {\n    // Always preserve significant whitespace here because this is used to generate the `goog.getMsg`\n    // and `$localize` calls which should retain significant whitespace in order to render the\n    // correct output. We let this diverge from the message IDs generated earlier which might not\n    // have preserved significant whitespace.\n    //\n    // This should use `visitAllWithSiblings` to set `WhitespaceVisitor` context correctly, however\n    // there is an existing bug where significant whitespace is not properly retained in the JS\n    // output of leading/trailing whitespace for ICU messages due to the existing lack of context\\\n    // in `WhitespaceVisitor`. Using `visitAllWithSiblings` here would fix that bug and retain the\n    // whitespace, however it would also change the runtime representation which we don't want to do\n    // right now.\n    rootNodes = html.visitAll(\n      new WhitespaceVisitor(\n        /* preserveSignificantWhitespace */ true,\n        /* originalNodeMap */ undefined,\n        /* requireContext */ false,\n      ),\n      rootNodes,\n    );\n\n    // run i18n meta visitor again in case whitespaces are removed (because that might affect\n    // generated i18n message content) and first pass indicated that i18n content is present in a\n    // template. During this pass i18n IDs generated at the first pass will be preserved, so we can\n    // mimic existing extraction process (ng extract-i18n)\n    if (i18nMetaVisitor.hasI18nMeta) {\n      rootNodes = html.visitAll(\n        new I18nMetaVisitor(\n          interpolationConfig,\n          /* keepI18nAttrs */ false,\n          /* enableI18nLegacyMessageIdFormat */ undefined,\n          /* containerBlocks */ undefined,\n          /* preserveSignificantWhitespace */ true,\n          retainEmptyTokens,\n        ),\n        rootNodes,\n      );\n    }\n  }\n\n  const {nodes, errors, styleUrls, styles, ngContentSelectors, commentNodes} = htmlAstToRender3Ast(\n    rootNodes,\n    bindingParser,\n    {collectCommentNodes: !!options.collectCommentNodes},\n  );\n  errors.push(...parseResult.errors, ...i18nMetaResult.errors);\n\n  const parsedTemplate: ParsedTemplate = {\n    interpolationConfig,\n    preserveWhitespaces,\n    errors: errors.length > 0 ? errors : null,\n    nodes,\n    styleUrls,\n    styles,\n    ngContentSelectors,\n  };\n\n  if (options.collectCommentNodes) {\n    parsedTemplate.commentNodes = commentNodes;\n  }\n  return parsedTemplate;\n}\n\nconst elementRegistry = new DomElementSchemaRegistry();\n\n/**\n * Construct a `BindingParser` with a default configuration.\n */\nexport function makeBindingParser(\n  interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG,\n  selectorlessEnabled = false,\n): BindingParser {\n  return new BindingParser(\n    new Parser(new Lexer(), selectorlessEnabled),\n    interpolationConfig,\n    elementRegistry,\n    [],\n  );\n}\n\n/**\n * Information about the template which was extracted during parsing.\n *\n * This contains the actual parsed template as well as any metadata collected during its parsing,\n * some of which might be useful for re-parsing the template with different options.\n */\nexport interface ParsedTemplate {\n  /**\n   * Include whitespace nodes in the parsed output.\n   */\n  preserveWhitespaces?: boolean;\n\n  /**\n   * How to parse interpolation markers.\n   */\n  interpolationConfig?: InterpolationConfig;\n  /**\n   * Any errors from parsing the template the first time.\n   *\n   * `null` if there are no errors. Otherwise, the array of errors is guaranteed to be non-empty.\n   */\n  errors: ParseError[] | null;\n\n  /**\n   * The template AST, parsed from the template.\n   */\n  nodes: t.Node[];\n\n  /**\n   * Any styleUrls extracted from the metadata.\n   */\n  styleUrls: string[];\n\n  /**\n   * Any inline styles extracted from the metadata.\n   */\n  styles: string[];\n\n  /**\n   * Any ng-content selectors extracted from the template.\n   */\n  ngContentSelectors: string[];\n\n  /**\n   * Any R3 Comment Nodes extracted from the template when the `collectCommentNodes` parse template\n   * option is enabled.\n   */\n  commentNodes?: t.Comment[];\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ConstantPool} from '../../constant_pool';\nimport * as core from '../../core';\nimport * as o from '../../output/output_ast';\nimport {ParseError, ParseSourceSpan} from '../../parse_util';\nimport {CssSelector} from '../../directive_matching';\nimport {ShadowCss} from '../../shadow_css';\nimport {CompilationJobKind, TemplateCompilationMode} from '../../template/pipeline/src/compilation';\nimport {emitHostBindingFunction, emitTemplateFn, transform} from '../../template/pipeline/src/emit';\nimport {ingestComponent, ingestHostBinding} from '../../template/pipeline/src/ingest';\nimport {BindingParser} from '../../template_parser/binding_parser';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {R3CompiledExpression, typeWithParameters} from '../util';\n\nimport {\n  DeclarationListEmitMode,\n  DeferBlockDepsEmitMode,\n  R3ComponentMetadata,\n  R3DeferResolverFunctionMetadata,\n  R3DirectiveMetadata,\n  R3HostMetadata,\n  R3TemplateDependency,\n} from './api';\nimport {getTemplateSourceLocationsEnabled} from './config';\nimport {createContentQueriesFunction, createViewQueriesFunction} from './query_generation';\nimport {makeBindingParser} from './template';\nimport {asLiteral, conditionallyCreateDirectiveBindingLiteral, DefinitionMap} from './util';\n\nconst COMPONENT_VARIABLE = '%COMP%';\nconst HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;\nconst CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;\nconst ANIMATE_LEAVE = `animate.leave`;\n\nfunction baseDirectiveFields(\n  meta: R3DirectiveMetadata,\n  constantPool: ConstantPool,\n  bindingParser: BindingParser,\n): DefinitionMap {\n  const definitionMap = new DefinitionMap();\n  const selectors = core.parseSelectorToR3Selector(meta.selector);\n\n  // e.g. `type: MyDirective`\n  definitionMap.set('type', meta.type.value);\n\n  // e.g. `selectors: [['', 'someDir', '']]`\n  if (selectors.length > 0) {\n    definitionMap.set('selectors', asLiteral(selectors));\n  }\n\n  if (meta.queries.length > 0) {\n    // e.g. `contentQueries: (rf, ctx, dirIndex) => { ... }\n    definitionMap.set(\n      'contentQueries',\n      createContentQueriesFunction(meta.queries, constantPool, meta.name),\n    );\n  }\n\n  if (meta.viewQueries.length) {\n    definitionMap.set(\n      'viewQuery',\n      createViewQueriesFunction(meta.viewQueries, constantPool, meta.name),\n    );\n  }\n\n  // e.g. `hostBindings: (rf, ctx) => { ... }\n  definitionMap.set(\n    'hostBindings',\n    createHostBindingsFunction(\n      meta.host,\n      meta.typeSourceSpan,\n      bindingParser,\n      constantPool,\n      meta.selector || '',\n      meta.name,\n      definitionMap,\n    ),\n  );\n\n  // e.g 'inputs: {a: 'a'}`\n  definitionMap.set('inputs', conditionallyCreateDirectiveBindingLiteral(meta.inputs, true));\n\n  // e.g 'outputs: {a: 'a'}`\n  definitionMap.set('outputs', conditionallyCreateDirectiveBindingLiteral(meta.outputs));\n\n  if (meta.exportAs !== null) {\n    definitionMap.set('exportAs', o.literalArr(meta.exportAs.map((e) => o.literal(e))));\n  }\n\n  if (meta.isStandalone === false) {\n    definitionMap.set('standalone', o.literal(false));\n  }\n  if (meta.isSignal) {\n    definitionMap.set('signals', o.literal(true));\n  }\n\n  return definitionMap;\n}\n\nfunction hasAnimationHostBinding(\n  meta: R3DirectiveMetadata | R3ComponentMetadata<R3TemplateDependency>,\n): boolean {\n  return (\n    meta.host.attributes[ANIMATE_LEAVE] !== undefined ||\n    meta.host.properties[ANIMATE_LEAVE] !== undefined ||\n    meta.host.listeners[ANIMATE_LEAVE] !== undefined\n  );\n}\n\n/**\n * Add features to the definition map.\n */\nfunction addFeatures(\n  definitionMap: DefinitionMap,\n  meta: R3DirectiveMetadata | R3ComponentMetadata<R3TemplateDependency>,\n) {\n  // e.g. `features: [NgOnChangesFeature]`\n  const features: o.Expression[] = [];\n\n  const providers = meta.providers;\n  const viewProviders = (meta as R3ComponentMetadata<R3TemplateDependency>).viewProviders;\n\n  if (providers || viewProviders) {\n    const args = [providers || new o.LiteralArrayExpr([])];\n    if (viewProviders) {\n      args.push(viewProviders);\n    }\n    features.push(o.importExpr(R3.ProvidersFeature).callFn(args));\n  }\n  // Note: host directives feature needs to be inserted before the\n  // inheritance feature to ensure the correct execution order.\n  if (meta.hostDirectives?.length) {\n    features.push(\n      o\n        .importExpr(R3.HostDirectivesFeature)\n        .callFn([createHostDirectivesFeatureArg(meta.hostDirectives)]),\n    );\n  }\n  if (meta.usesInheritance) {\n    features.push(o.importExpr(R3.InheritDefinitionFeature));\n  }\n  if (meta.fullInheritance) {\n    features.push(o.importExpr(R3.CopyDefinitionFeature));\n  }\n  if (meta.lifecycle.usesOnChanges) {\n    features.push(o.importExpr(R3.NgOnChangesFeature));\n  }\n  if ('externalStyles' in meta && meta.externalStyles?.length) {\n    const externalStyleNodes = meta.externalStyles.map((externalStyle) => o.literal(externalStyle));\n    features.push(\n      o.importExpr(R3.ExternalStylesFeature).callFn([o.literalArr(externalStyleNodes)]),\n    );\n  }\n\n  if (features.length) {\n    definitionMap.set('features', o.literalArr(features));\n  }\n}\n\n/**\n * Compile a directive for the render3 runtime as defined by the `R3DirectiveMetadata`.\n */\nexport function compileDirectiveFromMetadata(\n  meta: R3DirectiveMetadata,\n  constantPool: ConstantPool,\n  bindingParser: BindingParser,\n): R3CompiledExpression {\n  const definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);\n  addFeatures(definitionMap, meta);\n  const expression = o\n    .importExpr(R3.defineDirective)\n    .callFn([definitionMap.toLiteralMap()], undefined, true);\n  const type = createDirectiveType(meta);\n\n  return {expression, type, statements: []};\n}\n\n/**\n * Compile a component for the render3 runtime as defined by the `R3ComponentMetadata`.\n */\nexport function compileComponentFromMetadata(\n  meta: R3ComponentMetadata<R3TemplateDependency>,\n  constantPool: ConstantPool,\n  bindingParser: BindingParser,\n): R3CompiledExpression {\n  const definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);\n  addFeatures(definitionMap, meta);\n\n  const selector = meta.selector && CssSelector.parse(meta.selector);\n  const firstSelector = selector && selector[0];\n\n  // e.g. `attr: [\"class\", \".my.app\"]`\n  // This is optional an only included if the first selector of a component specifies attributes.\n  if (firstSelector) {\n    const selectorAttributes = firstSelector.getAttrs();\n    if (selectorAttributes.length) {\n      definitionMap.set(\n        'attrs',\n        constantPool.getConstLiteral(\n          o.literalArr(\n            selectorAttributes.map((value) =>\n              value != null ? o.literal(value) : o.literal(undefined),\n            ),\n          ),\n          /* forceShared */ true,\n        ),\n      );\n    }\n  }\n\n  // e.g. `template: function MyComponent_Template(_ctx, _cm) {...}`\n  const templateTypeName = meta.name;\n\n  let allDeferrableDepsFn: o.ReadVarExpr | null = null;\n  if (\n    meta.defer.mode === DeferBlockDepsEmitMode.PerComponent &&\n    meta.defer.dependenciesFn !== null\n  ) {\n    const fnName = `${templateTypeName}_DeferFn`;\n    constantPool.statements.push(\n      new o.DeclareVarStmt(fnName, meta.defer.dependenciesFn, undefined, o.StmtModifier.Final),\n    );\n    allDeferrableDepsFn = o.variable(fnName);\n  }\n\n  const compilationMode =\n    meta.isStandalone && !meta.hasDirectiveDependencies\n      ? TemplateCompilationMode.DomOnly\n      : TemplateCompilationMode.Full;\n\n  // First the template is ingested into IR:\n  const tpl = ingestComponent(\n    meta.name,\n    meta.template.nodes,\n    constantPool,\n    compilationMode,\n    meta.relativeContextFilePath,\n    meta.i18nUseExternalIds,\n    meta.defer,\n    allDeferrableDepsFn,\n    meta.relativeTemplatePath,\n    getTemplateSourceLocationsEnabled(),\n  );\n\n  // Then the IR is transformed to prepare it for cod egeneration.\n  transform(tpl, CompilationJobKind.Tmpl);\n\n  // Finally we emit the template function:\n  const templateFn = emitTemplateFn(tpl, constantPool);\n\n  if (tpl.contentSelectors !== null) {\n    definitionMap.set('ngContentSelectors', tpl.contentSelectors);\n  }\n\n  definitionMap.set('decls', o.literal(tpl.root.decls as number));\n  definitionMap.set('vars', o.literal(tpl.root.vars as number));\n  if (tpl.consts.length > 0) {\n    if (tpl.constsInitializers.length > 0) {\n      definitionMap.set(\n        'consts',\n        o.arrowFn([], [...tpl.constsInitializers, new o.ReturnStatement(o.literalArr(tpl.consts))]),\n      );\n    } else {\n      definitionMap.set('consts', o.literalArr(tpl.consts));\n    }\n  }\n  definitionMap.set('template', templateFn);\n\n  if (\n    meta.declarationListEmitMode !== DeclarationListEmitMode.RuntimeResolved &&\n    meta.declarations.length > 0\n  ) {\n    definitionMap.set(\n      'dependencies',\n      compileDeclarationList(\n        o.literalArr(meta.declarations.map((decl) => decl.type)),\n        meta.declarationListEmitMode,\n      ),\n    );\n  } else if (meta.declarationListEmitMode === DeclarationListEmitMode.RuntimeResolved) {\n    const args = [meta.type.value];\n    if (meta.rawImports) {\n      args.push(meta.rawImports);\n    }\n    definitionMap.set('dependencies', o.importExpr(R3.getComponentDepsFactory).callFn(args));\n  }\n\n  if (meta.encapsulation === null) {\n    meta.encapsulation = core.ViewEncapsulation.Emulated;\n  }\n\n  let hasStyles = !!meta.externalStyles?.length;\n  // e.g. `styles: [str1, str2]`\n  if (meta.styles && meta.styles.length) {\n    const styleValues =\n      meta.encapsulation == core.ViewEncapsulation.Emulated\n        ? compileStyles(meta.styles, CONTENT_ATTR, HOST_ATTR)\n        : meta.styles;\n    const styleNodes = styleValues.reduce((result, style) => {\n      if (style.trim().length > 0) {\n        result.push(constantPool.getConstLiteral(o.literal(style)));\n      }\n      return result;\n    }, [] as o.Expression[]);\n\n    if (styleNodes.length > 0) {\n      hasStyles = true;\n      definitionMap.set('styles', o.literalArr(styleNodes));\n    }\n  }\n\n  if (!hasStyles && meta.encapsulation === core.ViewEncapsulation.Emulated) {\n    // If there is no style, don't generate css selectors on elements\n    meta.encapsulation = core.ViewEncapsulation.None;\n  }\n\n  // Only set view encapsulation if it's not the default value\n  if (meta.encapsulation !== core.ViewEncapsulation.Emulated) {\n    definitionMap.set('encapsulation', o.literal(meta.encapsulation));\n  }\n\n  // e.g. `animation: [trigger('123', [])]`\n  if (meta.animations !== null) {\n    definitionMap.set(\n      'data',\n      o.literalMap([{key: 'animation', value: meta.animations, quoted: false}]),\n    );\n  }\n\n  // Setting change detection flag\n  if (meta.changeDetection !== null) {\n    if (\n      typeof meta.changeDetection === 'number' &&\n      meta.changeDetection !== core.ChangeDetectionStrategy.Default\n    ) {\n      // changeDetection is resolved during analysis. Only set it if not the default.\n      definitionMap.set('changeDetection', o.literal(meta.changeDetection));\n    } else if (typeof meta.changeDetection === 'object') {\n      // changeDetection is not resolved during analysis (e.g., we are in local compilation mode).\n      // So place it as is.\n      definitionMap.set('changeDetection', meta.changeDetection);\n    }\n  }\n\n  const expression = o\n    .importExpr(R3.defineComponent)\n    .callFn([definitionMap.toLiteralMap()], undefined, true);\n  const type = createComponentType(meta);\n\n  return {expression, type, statements: []};\n}\n\n/**\n * Creates the type specification from the component meta. This type is inserted into .d.ts files\n * to be consumed by upstream compilations.\n */\nexport function createComponentType(meta: R3ComponentMetadata<R3TemplateDependency>): o.Type {\n  const typeParams = createBaseDirectiveTypeParams(meta);\n  typeParams.push(stringArrayAsType(meta.template.ngContentSelectors));\n  typeParams.push(o.expressionType(o.literal(meta.isStandalone)));\n  typeParams.push(createHostDirectivesType(meta));\n  // TODO(signals): Always include this metadata starting with v17. Right\n  // now Angular v16.0.x does not support this field and library distributions\n  // would then be incompatible with v16.0.x framework users.\n  if (meta.isSignal) {\n    typeParams.push(o.expressionType(o.literal(meta.isSignal)));\n  }\n  return o.expressionType(o.importExpr(R3.ComponentDeclaration, typeParams));\n}\n\n/**\n * Compiles the array literal of declarations into an expression according to the provided emit\n * mode.\n */\nfunction compileDeclarationList(\n  list: o.LiteralArrayExpr,\n  mode: DeclarationListEmitMode,\n): o.Expression {\n  switch (mode) {\n    case DeclarationListEmitMode.Direct:\n      // directives: [MyDir],\n      return list;\n    case DeclarationListEmitMode.Closure:\n      // directives: function () { return [MyDir]; }\n      return o.arrowFn([], list);\n    case DeclarationListEmitMode.ClosureResolved:\n      // directives: function () { return [MyDir].map(ng.resolveForwardRef); }\n      const resolvedList = list.prop('map').callFn([o.importExpr(R3.resolveForwardRef)]);\n      return o.arrowFn([], resolvedList);\n    case DeclarationListEmitMode.RuntimeResolved:\n      throw new Error(`Unsupported with an array of pre-resolved dependencies`);\n  }\n}\n\nfunction stringAsType(str: string): o.Type {\n  return o.expressionType(o.literal(str));\n}\n\nfunction stringMapAsLiteralExpression(map: {[key: string]: string | string[]}): o.LiteralMapExpr {\n  const mapValues = Object.keys(map).map((key) => {\n    const value = Array.isArray(map[key]) ? map[key][0] : map[key];\n    return {\n      key,\n      value: o.literal(value),\n      quoted: true,\n    };\n  });\n\n  return o.literalMap(mapValues);\n}\n\nfunction stringArrayAsType(arr: ReadonlyArray<string | null>): o.Type {\n  return arr.length > 0\n    ? o.expressionType(o.literalArr(arr.map((value) => o.literal(value))))\n    : o.NONE_TYPE;\n}\n\nfunction createBaseDirectiveTypeParams(meta: R3DirectiveMetadata): o.Type[] {\n  // On the type side, remove newlines from the selector as it will need to fit into a TypeScript\n  // string literal, which must be on one line.\n  const selectorForType = meta.selector !== null ? meta.selector.replace(/\\n/g, '') : null;\n\n  return [\n    typeWithParameters(meta.type.type, meta.typeArgumentCount),\n    selectorForType !== null ? stringAsType(selectorForType) : o.NONE_TYPE,\n    meta.exportAs !== null ? stringArrayAsType(meta.exportAs) : o.NONE_TYPE,\n    o.expressionType(getInputsTypeExpression(meta)),\n    o.expressionType(stringMapAsLiteralExpression(meta.outputs)),\n    stringArrayAsType(meta.queries.map((q) => q.propertyName)),\n  ];\n}\n\nfunction getInputsTypeExpression(meta: R3DirectiveMetadata): o.Expression {\n  return o.literalMap(\n    Object.keys(meta.inputs).map((key) => {\n      const value = meta.inputs[key];\n      const values = [\n        {key: 'alias', value: o.literal(value.bindingPropertyName), quoted: true},\n        {key: 'required', value: o.literal(value.required), quoted: true},\n      ];\n\n      // TODO(legacy-partial-output-inputs): Consider always emitting this information,\n      // or leaving it as is.\n      if (value.isSignal) {\n        values.push({key: 'isSignal', value: o.literal(value.isSignal), quoted: true});\n      }\n\n      return {key, value: o.literalMap(values), quoted: true};\n    }),\n  );\n}\n\n/**\n * Creates the type specification from the directive meta. This type is inserted into .d.ts files\n * to be consumed by upstream compilations.\n */\nexport function createDirectiveType(meta: R3DirectiveMetadata): o.Type {\n  const typeParams = createBaseDirectiveTypeParams(meta);\n  // Directives have no NgContentSelectors slot, but instead express a `never` type\n  // so that future fields align.\n  typeParams.push(o.NONE_TYPE);\n  typeParams.push(o.expressionType(o.literal(meta.isStandalone)));\n  typeParams.push(createHostDirectivesType(meta));\n  // TODO(signals): Always include this metadata starting with v17. Right\n  // now Angular v16.0.x does not support this field and library distributions\n  // would then be incompatible with v16.0.x framework users.\n  if (meta.isSignal) {\n    typeParams.push(o.expressionType(o.literal(meta.isSignal)));\n  }\n  return o.expressionType(o.importExpr(R3.DirectiveDeclaration, typeParams));\n}\n\n// Return a host binding function or null if one is not necessary.\nfunction createHostBindingsFunction(\n  hostBindingsMetadata: R3HostMetadata,\n  typeSourceSpan: ParseSourceSpan,\n  bindingParser: BindingParser,\n  constantPool: ConstantPool,\n  selector: string,\n  name: string,\n  definitionMap: DefinitionMap,\n): o.Expression | null {\n  const bindings = bindingParser.createBoundHostProperties(\n    hostBindingsMetadata.properties,\n    typeSourceSpan,\n  );\n\n  // Calculate host event bindings\n  const eventBindings = bindingParser.createDirectiveHostEventAsts(\n    hostBindingsMetadata.listeners,\n    typeSourceSpan,\n  );\n\n  // The parser for host bindings treats class and style attributes specially -- they are\n  // extracted into these separate fields. This is not the case for templates, so the compiler can\n  // actually already handle these special attributes internally. Therefore, we just drop them\n  // into the attributes map.\n  if (hostBindingsMetadata.specialAttributes.styleAttr) {\n    hostBindingsMetadata.attributes['style'] = o.literal(\n      hostBindingsMetadata.specialAttributes.styleAttr,\n    );\n  }\n  if (hostBindingsMetadata.specialAttributes.classAttr) {\n    hostBindingsMetadata.attributes['class'] = o.literal(\n      hostBindingsMetadata.specialAttributes.classAttr,\n    );\n  }\n\n  const hostJob = ingestHostBinding(\n    {\n      componentName: name,\n      componentSelector: selector,\n      properties: bindings,\n      events: eventBindings,\n      attributes: hostBindingsMetadata.attributes,\n    },\n    bindingParser,\n    constantPool,\n  );\n  transform(hostJob, CompilationJobKind.Host);\n\n  definitionMap.set('hostAttrs', hostJob.root.attributes);\n\n  const varCount = hostJob.root.vars;\n  if (varCount !== null && varCount > 0) {\n    definitionMap.set('hostVars', o.literal(varCount));\n  }\n\n  return emitHostBindingFunction(hostJob);\n}\n\nconst HOST_REG_EXP = /^(?:\\[([^\\]]+)\\])|(?:\\(([^\\)]+)\\))$/;\n// Represents the groups in the above regex.\nconst enum HostBindingGroup {\n  // group 1: \"prop\" from \"[prop]\", or \"attr.role\" from \"[attr.role]\", or @anim from [@anim]\n  Binding = 1,\n\n  // group 2: \"event\" from \"(event)\"\n  Event = 2,\n}\n\n// Defines Host Bindings structure that contains attributes, listeners, and properties,\n// parsed from the `host` object defined for a Type.\nexport interface ParsedHostBindings {\n  attributes: {[key: string]: o.Expression};\n  listeners: {[key: string]: string};\n  properties: {[key: string]: string};\n  specialAttributes: {styleAttr?: string; classAttr?: string};\n}\n\nexport function parseHostBindings(host: {\n  [key: string]: string | o.Expression;\n}): ParsedHostBindings {\n  const attributes: {[key: string]: o.Expression} = {};\n  const listeners: {[key: string]: string} = {};\n  const properties: {[key: string]: string} = {};\n  const specialAttributes: {styleAttr?: string; classAttr?: string} = {};\n\n  for (const key of Object.keys(host)) {\n    const value = host[key];\n    const matches = key.match(HOST_REG_EXP);\n\n    if (matches === null) {\n      switch (key) {\n        case 'class':\n          if (typeof value !== 'string') {\n            // TODO(alxhub): make this a diagnostic.\n            throw new Error(`Class binding must be string`);\n          }\n          specialAttributes.classAttr = value;\n          break;\n        case 'style':\n          if (typeof value !== 'string') {\n            // TODO(alxhub): make this a diagnostic.\n            throw new Error(`Style binding must be string`);\n          }\n          specialAttributes.styleAttr = value;\n          break;\n        default:\n          if (typeof value === 'string') {\n            attributes[key] = o.literal(value);\n          } else {\n            attributes[key] = value;\n          }\n      }\n    } else if (matches[HostBindingGroup.Binding] != null) {\n      if (typeof value !== 'string') {\n        // TODO(alxhub): make this a diagnostic.\n        throw new Error(`Property binding must be string`);\n      }\n      // synthetic properties (the ones that have a `@` as a prefix)\n      // are still treated the same as regular properties. Therefore\n      // there is no point in storing them in a separate map.\n      properties[matches[HostBindingGroup.Binding]] = value;\n    } else if (matches[HostBindingGroup.Event] != null) {\n      if (typeof value !== 'string') {\n        // TODO(alxhub): make this a diagnostic.\n        throw new Error(`Event binding must be string`);\n      }\n      listeners[matches[HostBindingGroup.Event]] = value;\n    }\n  }\n\n  return {attributes, listeners, properties, specialAttributes};\n}\n\n/**\n * Verifies host bindings and returns the list of errors (if any). Empty array indicates that a\n * given set of host bindings has no errors.\n *\n * @param bindings set of host bindings to verify.\n * @param sourceSpan source span where host bindings were defined.\n * @returns array of errors associated with a given set of host bindings.\n */\nexport function verifyHostBindings(\n  bindings: ParsedHostBindings,\n  sourceSpan: ParseSourceSpan,\n): ParseError[] {\n  // TODO: abstract out host bindings verification logic and use it instead of\n  // creating events and properties ASTs to detect errors (FW-996)\n  const bindingParser = makeBindingParser();\n  bindingParser.createDirectiveHostEventAsts(bindings.listeners, sourceSpan);\n  bindingParser.createBoundHostProperties(bindings.properties, sourceSpan);\n  return bindingParser.errors;\n}\n\nfunction compileStyles(styles: string[], selector: string, hostSelector: string): string[] {\n  const shadowCss = new ShadowCss();\n  return styles.map((style) => {\n    return shadowCss!.shimCssText(style, selector, hostSelector);\n  });\n}\n\n/**\n * Encapsulates a CSS stylesheet with emulated view encapsulation.\n * This allows a stylesheet to be used with an Angular component that\n * is using the `ViewEncapsulation.Emulated` mode.\n *\n * @param style The content of a CSS stylesheet.\n * @param componentIdentifier The identifier to use within the CSS rules.\n * @returns The encapsulated content for the style.\n */\nexport function encapsulateStyle(style: string, componentIdentifier?: string): string {\n  const shadowCss = new ShadowCss();\n  const selector = componentIdentifier\n    ? CONTENT_ATTR.replace(COMPONENT_VARIABLE, componentIdentifier)\n    : CONTENT_ATTR;\n  const hostSelector = componentIdentifier\n    ? HOST_ATTR.replace(COMPONENT_VARIABLE, componentIdentifier)\n    : HOST_ATTR;\n  return shadowCss.shimCssText(style, selector, hostSelector);\n}\n\nfunction createHostDirectivesType(meta: R3DirectiveMetadata): o.Type {\n  if (!meta.hostDirectives?.length) {\n    return o.NONE_TYPE;\n  }\n\n  return o.expressionType(\n    o.literalArr(\n      meta.hostDirectives.map((hostMeta) =>\n        o.literalMap([\n          {key: 'directive', value: o.typeofExpr(hostMeta.directive.type), quoted: false},\n          {\n            key: 'inputs',\n            value: stringMapAsLiteralExpression(hostMeta.inputs || {}),\n            quoted: false,\n          },\n          {\n            key: 'outputs',\n            value: stringMapAsLiteralExpression(hostMeta.outputs || {}),\n            quoted: false,\n          },\n        ]),\n      ),\n    ),\n  );\n}\n\nfunction createHostDirectivesFeatureArg(\n  hostDirectives: NonNullable<R3DirectiveMetadata['hostDirectives']>,\n): o.Expression {\n  const expressions: o.Expression[] = [];\n  let hasForwardRef = false;\n\n  for (const current of hostDirectives) {\n    // Use a shorthand if there are no inputs or outputs.\n    if (!current.inputs && !current.outputs) {\n      expressions.push(current.directive.type);\n    } else {\n      const keys = [{key: 'directive', value: current.directive.type, quoted: false}];\n\n      if (current.inputs) {\n        const inputsLiteral = createHostDirectivesMappingArray(current.inputs);\n        if (inputsLiteral) {\n          keys.push({key: 'inputs', value: inputsLiteral, quoted: false});\n        }\n      }\n\n      if (current.outputs) {\n        const outputsLiteral = createHostDirectivesMappingArray(current.outputs);\n        if (outputsLiteral) {\n          keys.push({key: 'outputs', value: outputsLiteral, quoted: false});\n        }\n      }\n\n      expressions.push(o.literalMap(keys));\n    }\n\n    if (current.isForwardReference) {\n      hasForwardRef = true;\n    }\n  }\n\n  // If there's a forward reference, we generate a `function() { return [HostDir] }`,\n  // otherwise we can save some bytes by using a plain array, e.g. `[HostDir]`.\n  return hasForwardRef\n    ? new o.FunctionExpr([], [new o.ReturnStatement(o.literalArr(expressions))])\n    : o.literalArr(expressions);\n}\n\n/**\n * Converts an input/output mapping object literal into an array where the even keys are the\n * public name of the binding and the odd ones are the name it was aliased to. E.g.\n * `{inputOne: 'aliasOne', inputTwo: 'aliasTwo'}` will become\n * `['inputOne', 'aliasOne', 'inputTwo', 'aliasTwo']`.\n *\n * This conversion is necessary, because hosts bind to the public name of the host directive and\n * keeping the mapping in an object literal will break for apps using property renaming.\n */\nexport function createHostDirectivesMappingArray(\n  mapping: Record<string, string>,\n): o.LiteralArrayExpr | null {\n  const elements: o.LiteralExpr[] = [];\n\n  for (const publicName in mapping) {\n    if (mapping.hasOwnProperty(publicName)) {\n      elements.push(o.literal(publicName), o.literal(mapping[publicName]));\n    }\n  }\n\n  return elements.length > 0 ? o.literalArr(elements) : null;\n}\n\n/**\n * Compiles the dependency resolver function for a defer block.\n */\nexport function compileDeferResolverFunction(\n  meta: R3DeferResolverFunctionMetadata,\n): o.ArrowFunctionExpr {\n  const depExpressions: o.Expression[] = [];\n\n  if (meta.mode === DeferBlockDepsEmitMode.PerBlock) {\n    for (const dep of meta.dependencies) {\n      if (dep.isDeferrable) {\n        // Callback function, e.g. `m () => m.MyCmp;`.\n        const innerFn = o.arrowFn(\n          // Default imports are always accessed through the `default` property.\n          [new o.FnParam('m', o.DYNAMIC_TYPE)],\n          o.variable('m').prop(dep.isDefaultImport ? 'default' : dep.symbolName),\n        );\n\n        // Dynamic import, e.g. `import('./a').then(...)`.\n        const importExpr = new o.DynamicImportExpr(dep.importPath!).prop('then').callFn([innerFn]);\n        depExpressions.push(importExpr);\n      } else {\n        // Non-deferrable symbol, just use a reference to the type. Note that it's important to\n        // go through `typeReference`, rather than `symbolName` in order to preserve the\n        // original reference within the source file.\n        depExpressions.push(dep.typeReference);\n      }\n    }\n  } else {\n    for (const {symbolName, importPath, isDefaultImport} of meta.dependencies) {\n      // Callback function, e.g. `m () => m.MyCmp;`.\n      const innerFn = o.arrowFn(\n        [new o.FnParam('m', o.DYNAMIC_TYPE)],\n        o.variable('m').prop(isDefaultImport ? 'default' : symbolName),\n      );\n\n      // Dynamic import, e.g. `import('./a').then(...)`.\n      const importExpr = new o.DynamicImportExpr(importPath).prop('then').callFn([innerFn]);\n      depExpressions.push(importExpr);\n    }\n  }\n\n  return o.arrowFn([], o.literalArr(depExpressions));\n}\n","/*!\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {AST, ASTWithSource, RecursiveAstVisitor} from './expression_parser/ast';\nimport * as t from './render3/r3_ast';\n\n/**\n * Visitor that traverses all template and expression AST nodes in a template.\n * Useful for cases where every single node needs to be visited.\n */\nexport class CombinedRecursiveAstVisitor extends RecursiveAstVisitor implements t.RecursiveVisitor {\n  override visit(node: AST | t.Node): void {\n    if (node instanceof ASTWithSource) {\n      this.visit(node.ast);\n    } else {\n      node.visit(this);\n    }\n  }\n\n  visitElement(element: t.Element): void {\n    this.visitAllTemplateNodes(element.attributes);\n    this.visitAllTemplateNodes(element.inputs);\n    this.visitAllTemplateNodes(element.outputs);\n    this.visitAllTemplateNodes(element.directives);\n    this.visitAllTemplateNodes(element.references);\n    this.visitAllTemplateNodes(element.children);\n  }\n\n  visitTemplate(template: t.Template): void {\n    this.visitAllTemplateNodes(template.attributes);\n    this.visitAllTemplateNodes(template.inputs);\n    this.visitAllTemplateNodes(template.outputs);\n    this.visitAllTemplateNodes(template.directives);\n    this.visitAllTemplateNodes(template.templateAttrs);\n    this.visitAllTemplateNodes(template.variables);\n    this.visitAllTemplateNodes(template.references);\n    this.visitAllTemplateNodes(template.children);\n  }\n\n  visitContent(content: t.Content): void {\n    this.visitAllTemplateNodes(content.children);\n  }\n\n  visitBoundAttribute(attribute: t.BoundAttribute): void {\n    this.visit(attribute.value);\n  }\n\n  visitBoundEvent(attribute: t.BoundEvent): void {\n    this.visit(attribute.handler);\n  }\n\n  visitBoundText(text: t.BoundText): void {\n    this.visit(text.value);\n  }\n\n  visitIcu(icu: t.Icu): void {\n    Object.keys(icu.vars).forEach((key) => this.visit(icu.vars[key]));\n    Object.keys(icu.placeholders).forEach((key) => this.visit(icu.placeholders[key]));\n  }\n\n  visitDeferredBlock(deferred: t.DeferredBlock): void {\n    deferred.visitAll(this);\n  }\n\n  visitDeferredTrigger(trigger: t.DeferredTrigger): void {\n    if (trigger instanceof t.BoundDeferredTrigger) {\n      this.visit(trigger.value);\n    }\n  }\n\n  visitDeferredBlockPlaceholder(block: t.DeferredBlockPlaceholder): void {\n    this.visitAllTemplateNodes(block.children);\n  }\n\n  visitDeferredBlockError(block: t.DeferredBlockError): void {\n    this.visitAllTemplateNodes(block.children);\n  }\n\n  visitDeferredBlockLoading(block: t.DeferredBlockLoading): void {\n    this.visitAllTemplateNodes(block.children);\n  }\n\n  visitSwitchBlock(block: t.SwitchBlock): void {\n    this.visit(block.expression);\n    this.visitAllTemplateNodes(block.cases);\n  }\n\n  visitSwitchBlockCase(block: t.SwitchBlockCase): void {\n    block.expression && this.visit(block.expression);\n    this.visitAllTemplateNodes(block.children);\n  }\n\n  visitForLoopBlock(block: t.ForLoopBlock): void {\n    block.item.visit(this);\n    this.visitAllTemplateNodes(block.contextVariables);\n    this.visit(block.expression);\n    this.visitAllTemplateNodes(block.children);\n    block.empty?.visit(this);\n  }\n\n  visitForLoopBlockEmpty(block: t.ForLoopBlockEmpty): void {\n    this.visitAllTemplateNodes(block.children);\n  }\n\n  visitIfBlock(block: t.IfBlock): void {\n    this.visitAllTemplateNodes(block.branches);\n  }\n\n  visitIfBlockBranch(block: t.IfBlockBranch): void {\n    block.expression && this.visit(block.expression);\n    block.expressionAlias?.visit(this);\n    this.visitAllTemplateNodes(block.children);\n  }\n\n  visitLetDeclaration(decl: t.LetDeclaration): void {\n    this.visit(decl.value);\n  }\n\n  visitComponent(component: t.Component): void {\n    this.visitAllTemplateNodes(component.attributes);\n    this.visitAllTemplateNodes(component.inputs);\n    this.visitAllTemplateNodes(component.outputs);\n    this.visitAllTemplateNodes(component.directives);\n    this.visitAllTemplateNodes(component.references);\n    this.visitAllTemplateNodes(component.children);\n  }\n\n  visitDirective(directive: t.Directive): void {\n    this.visitAllTemplateNodes(directive.attributes);\n    this.visitAllTemplateNodes(directive.inputs);\n    this.visitAllTemplateNodes(directive.outputs);\n    this.visitAllTemplateNodes(directive.references);\n  }\n\n  visitVariable(variable: t.Variable): void {}\n  visitReference(reference: t.Reference): void {}\n  visitTextAttribute(attribute: t.TextAttribute): void {}\n  visitText(text: t.Text): void {}\n  visitUnknownBlock(block: t.UnknownBlock): void {}\n\n  protected visitAllTemplateNodes(nodes: t.Node[]): void {\n    for (const node of nodes) {\n      this.visit(node);\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  AST,\n  BindingPipe,\n  ImplicitReceiver,\n  PropertyRead,\n  SafePropertyRead,\n  ThisReceiver,\n} from '../../expression_parser/ast';\nimport {CssSelector, SelectorlessMatcher, SelectorMatcher} from '../../directive_matching';\nimport {\n  BoundAttribute,\n  BoundEvent,\n  BoundText,\n  Comment,\n  Component,\n  Content,\n  DeferredBlock,\n  DeferredBlockError,\n  DeferredBlockLoading,\n  DeferredBlockPlaceholder,\n  DeferredTrigger,\n  Directive,\n  Element,\n  ForLoopBlock,\n  ForLoopBlockEmpty,\n  HostElement,\n  HoverDeferredTrigger,\n  Icu,\n  IfBlock,\n  IfBlockBranch,\n  InteractionDeferredTrigger,\n  LetDeclaration,\n  Node,\n  Reference,\n  SwitchBlock,\n  SwitchBlockCase,\n  Template,\n  Text,\n  TextAttribute,\n  UnknownBlock,\n  Variable,\n  ViewportDeferredTrigger,\n  Visitor,\n} from '../r3_ast';\n\nimport {\n  BoundTarget,\n  DirectiveMeta,\n  DirectiveOwner,\n  ReferenceTarget,\n  ScopedNode,\n  Target,\n  TargetBinder,\n  TemplateEntity,\n} from './t2_api';\nimport {parseTemplate} from './template';\nimport {createCssSelectorFromNode} from './util';\nimport {CombinedRecursiveAstVisitor} from '../../combined_visitor';\n\n/**\n * Computes a difference between full list (first argument) and\n * list of items that should be excluded from the full list (second\n * argument).\n */\nfunction diff(fullList: string[], itemsToExclude: string[]): string[] {\n  const exclude = new Set(itemsToExclude);\n  return fullList.filter((item) => !exclude.has(item));\n}\n\n/** Shorthand for a map between a binding AST node and the entity it's targeting. */\ntype BindingsMap<DirectiveT> = Map<\n  BoundAttribute | BoundEvent | TextAttribute,\n  DirectiveT | Template | Element\n>;\n\n/** Shorthand for a map between a reference AST node and the entity it's targeting. */\ntype ReferenceMap<DirectiveT> = Map<\n  Reference,\n  Template | Element | {directive: DirectiveT; node: Exclude<DirectiveOwner, HostElement>}\n>;\n\n/** Mapping between AST nodes and the directives that have been matched on them. */\ntype MatchedDirectives<DirectiveT> = Map<DirectiveOwner, DirectiveT[]>;\n\n/**\n * Mapping between a scoped not and the template entities that exist in it.\n * `null` represents the root scope.\n */\ntype ScopedNodeEntities = Map<ScopedNode | null, Set<TemplateEntity>>;\n\n/** Shorthand tuple type where a defer block is paired with its corresponding scope. */\ntype DeferBlockScopes = [DeferredBlock, Scope][];\n\n/**\n * Given a template string and a set of available directive selectors,\n * computes a list of matching selectors and splits them into 2 buckets:\n * (1) eagerly used in a template and (2) directives used only in defer\n * blocks. Similarly, returns 2 lists of pipes (eager and deferrable).\n *\n * Note: deferrable directives selectors and pipes names used in `@defer`\n * blocks are **candidates** and API caller should make sure that:\n *\n *  * A Component where a given template is defined is standalone\n *  * Underlying dependency classes are also standalone\n *  * Dependency class symbols are not eagerly used in a TS file\n *    where a host component (that owns the template) is located\n */\nexport function findMatchingDirectivesAndPipes(template: string, directiveSelectors: string[]) {\n  const matcher = new SelectorMatcher<DirectiveMeta[]>();\n  for (const selector of directiveSelectors) {\n    // Create a fake directive instance to account for the logic inside\n    // of the `R3TargetBinder` class (which invokes the `hasBindingPropertyName`\n    // function internally).\n    const fakeDirective = {\n      selector,\n      exportAs: null,\n      inputs: {\n        hasBindingPropertyName() {\n          return false;\n        },\n      },\n      outputs: {\n        hasBindingPropertyName() {\n          return false;\n        },\n      },\n    } as unknown as DirectiveMeta;\n    matcher.addSelectables(CssSelector.parse(selector), [fakeDirective]);\n  }\n  const parsedTemplate = parseTemplate(template, '' /* templateUrl */);\n  const binder = new R3TargetBinder(matcher);\n  const bound = binder.bind({template: parsedTemplate.nodes});\n\n  const eagerDirectiveSelectors = bound.getEagerlyUsedDirectives().map((dir) => dir.selector!);\n  const allMatchedDirectiveSelectors = bound.getUsedDirectives().map((dir) => dir.selector!);\n  const eagerPipes = bound.getEagerlyUsedPipes();\n  return {\n    directives: {\n      regular: eagerDirectiveSelectors,\n      deferCandidates: diff(allMatchedDirectiveSelectors, eagerDirectiveSelectors),\n    },\n    pipes: {\n      regular: eagerPipes,\n      deferCandidates: diff(bound.getUsedPipes(), eagerPipes),\n    },\n  };\n}\n\n/** Object used to match template nodes to directives. */\nexport type DirectiveMatcher<DirectiveT extends DirectiveMeta> =\n  | SelectorMatcher<DirectiveT[]>\n  | SelectorlessMatcher<DirectiveT>;\n\n/**\n * Processes `Target`s with a given set of directives and performs a binding operation, which\n * returns an object similar to TypeScript's `ts.TypeChecker` that contains knowledge about the\n * target.\n */\nexport class R3TargetBinder<DirectiveT extends DirectiveMeta> implements TargetBinder<DirectiveT> {\n  constructor(private directiveMatcher: DirectiveMatcher<DirectiveT> | null) {}\n\n  /**\n   * Perform a binding operation on the given `Target` and return a `BoundTarget` which contains\n   * metadata about the types referenced in the template.\n   */\n  bind(target: Target<DirectiveT>): BoundTarget<DirectiveT> {\n    if (!target.template && !target.host) {\n      throw new Error('Empty bound targets are not supported');\n    }\n\n    const directives: MatchedDirectives<DirectiveT> = new Map();\n    const eagerDirectives: DirectiveT[] = [];\n    const missingDirectives = new Set<string>();\n    const bindings: BindingsMap<DirectiveT> = new Map();\n    const references: ReferenceMap<DirectiveT> = new Map();\n    const scopedNodeEntities: ScopedNodeEntities = new Map();\n    const expressions = new Map<AST, TemplateEntity>();\n    const symbols = new Map<TemplateEntity, Template>();\n    const nestingLevel = new Map<ScopedNode, number>();\n    const usedPipes = new Set<string>();\n    const eagerPipes = new Set<string>();\n    const deferBlocks: DeferBlockScopes = [];\n\n    if (target.template) {\n      // First, parse the template into a `Scope` structure. This operation captures the syntactic\n      // scopes in the template and makes them available for later use.\n      const scope = Scope.apply(target.template);\n\n      // Use the `Scope` to extract the entities present at every level of the template.\n      extractScopedNodeEntities(scope, scopedNodeEntities);\n\n      // Next, perform directive matching on the template using the `DirectiveBinder`. This returns:\n      //   - directives: Map of nodes (elements & ng-templates) to the directives on them.\n      //   - bindings: Map of inputs, outputs, and attributes to the directive/element that claims\n      //     them. TODO(alxhub): handle multiple directives claiming an input/output/etc.\n      //   - references: Map of #references to their targets.\n      DirectiveBinder.apply(\n        target.template,\n        this.directiveMatcher,\n        directives,\n        eagerDirectives,\n        missingDirectives,\n        bindings,\n        references,\n      );\n\n      // Finally, run the TemplateBinder to bind references, variables, and other entities within the\n      // template. This extracts all the metadata that doesn't depend on directive matching.\n      TemplateBinder.applyWithScope(\n        target.template,\n        scope,\n        expressions,\n        symbols,\n        nestingLevel,\n        usedPipes,\n        eagerPipes,\n        deferBlocks,\n      );\n    }\n\n    // Bind the host element in a separate scope. Note that it only uses the\n    // `TemplateBinder` since directives don't apply inside a host context.\n    if (target.host) {\n      directives.set(target.host.node, target.host.directives);\n      TemplateBinder.applyWithScope(\n        target.host.node,\n        Scope.apply(target.host.node),\n        expressions,\n        symbols,\n        nestingLevel,\n        usedPipes,\n        eagerPipes,\n        deferBlocks,\n      );\n    }\n\n    return new R3BoundTarget(\n      target,\n      directives,\n      eagerDirectives,\n      missingDirectives,\n      bindings,\n      references,\n      expressions,\n      symbols,\n      nestingLevel,\n      scopedNodeEntities,\n      usedPipes,\n      eagerPipes,\n      deferBlocks,\n    );\n  }\n}\n\n/**\n * Represents a binding scope within a template.\n *\n * Any variables, references, or other named entities declared within the template will\n * be captured and available by name in `namedEntities`. Additionally, child templates will\n * be analyzed and have their child `Scope`s available in `childScopes`.\n */\nclass Scope implements Visitor {\n  /**\n   * Named members of the `Scope`, such as `Reference`s or `Variable`s.\n   */\n  readonly namedEntities = new Map<string, TemplateEntity>();\n\n  /**\n   * Set of element-like nodes that belong to this scope.\n   */\n  readonly elementLikeInScope = new Set<Element | Component>();\n\n  /**\n   * Child `Scope`s for immediately nested `ScopedNode`s.\n   */\n  readonly childScopes = new Map<ScopedNode, Scope>();\n\n  /** Whether this scope is deferred or if any of its ancestors are deferred. */\n  readonly isDeferred: boolean;\n\n  private constructor(\n    readonly parentScope: Scope | null,\n    readonly rootNode: ScopedNode | null,\n  ) {\n    this.isDeferred =\n      parentScope !== null && parentScope.isDeferred ? true : rootNode instanceof DeferredBlock;\n  }\n\n  static newRootScope(): Scope {\n    return new Scope(null, null);\n  }\n\n  /**\n   * Process a template (either as a `Template` sub-template with variables, or a plain array of\n   * template `Node`s) and construct its `Scope`.\n   */\n  static apply(template: ScopedNode | Node[]): Scope {\n    const scope = Scope.newRootScope();\n    scope.ingest(template);\n    return scope;\n  }\n\n  /**\n   * Internal method to process the scoped node and populate the `Scope`.\n   */\n  private ingest(nodeOrNodes: ScopedNode | Node[]): void {\n    if (nodeOrNodes instanceof Template) {\n      // Variables on an <ng-template> are defined in the inner scope.\n      nodeOrNodes.variables.forEach((node) => this.visitVariable(node));\n\n      // Process the nodes of the template.\n      nodeOrNodes.children.forEach((node) => node.visit(this));\n    } else if (nodeOrNodes instanceof IfBlockBranch) {\n      if (nodeOrNodes.expressionAlias !== null) {\n        this.visitVariable(nodeOrNodes.expressionAlias);\n      }\n      nodeOrNodes.children.forEach((node) => node.visit(this));\n    } else if (nodeOrNodes instanceof ForLoopBlock) {\n      this.visitVariable(nodeOrNodes.item);\n      nodeOrNodes.contextVariables.forEach((v) => this.visitVariable(v));\n      nodeOrNodes.children.forEach((node) => node.visit(this));\n    } else if (\n      nodeOrNodes instanceof SwitchBlockCase ||\n      nodeOrNodes instanceof ForLoopBlockEmpty ||\n      nodeOrNodes instanceof DeferredBlock ||\n      nodeOrNodes instanceof DeferredBlockError ||\n      nodeOrNodes instanceof DeferredBlockPlaceholder ||\n      nodeOrNodes instanceof DeferredBlockLoading ||\n      nodeOrNodes instanceof Content\n    ) {\n      nodeOrNodes.children.forEach((node) => node.visit(this));\n    } else if (!(nodeOrNodes instanceof HostElement)) {\n      // No overarching `Template` instance, so process the nodes directly.\n      nodeOrNodes.forEach((node) => node.visit(this));\n    }\n  }\n\n  visitElement(element: Element) {\n    this.visitElementLike(element);\n  }\n\n  visitTemplate(template: Template) {\n    template.directives.forEach((node) => node.visit(this));\n\n    // References on a <ng-template> are defined in the outer scope, so capture them before\n    // processing the template's child scope.\n    template.references.forEach((node) => this.visitReference(node));\n\n    // Next, create an inner scope and process the template within it.\n    this.ingestScopedNode(template);\n  }\n\n  visitVariable(variable: Variable) {\n    // Declare the variable if it's not already.\n    this.maybeDeclare(variable);\n  }\n\n  visitReference(reference: Reference) {\n    // Declare the variable if it's not already.\n    this.maybeDeclare(reference);\n  }\n\n  visitDeferredBlock(deferred: DeferredBlock) {\n    this.ingestScopedNode(deferred);\n    deferred.placeholder?.visit(this);\n    deferred.loading?.visit(this);\n    deferred.error?.visit(this);\n  }\n\n  visitDeferredBlockPlaceholder(block: DeferredBlockPlaceholder) {\n    this.ingestScopedNode(block);\n  }\n\n  visitDeferredBlockError(block: DeferredBlockError) {\n    this.ingestScopedNode(block);\n  }\n\n  visitDeferredBlockLoading(block: DeferredBlockLoading) {\n    this.ingestScopedNode(block);\n  }\n\n  visitSwitchBlock(block: SwitchBlock) {\n    block.cases.forEach((node) => node.visit(this));\n  }\n\n  visitSwitchBlockCase(block: SwitchBlockCase) {\n    this.ingestScopedNode(block);\n  }\n\n  visitForLoopBlock(block: ForLoopBlock) {\n    this.ingestScopedNode(block);\n    block.empty?.visit(this);\n  }\n\n  visitForLoopBlockEmpty(block: ForLoopBlockEmpty) {\n    this.ingestScopedNode(block);\n  }\n\n  visitIfBlock(block: IfBlock) {\n    block.branches.forEach((node) => node.visit(this));\n  }\n\n  visitIfBlockBranch(block: IfBlockBranch) {\n    this.ingestScopedNode(block);\n  }\n\n  visitContent(content: Content) {\n    this.ingestScopedNode(content);\n  }\n\n  visitLetDeclaration(decl: LetDeclaration) {\n    this.maybeDeclare(decl);\n  }\n\n  visitComponent(component: Component) {\n    this.visitElementLike(component);\n  }\n\n  visitDirective(directive: Directive) {\n    directive.references.forEach((current) => this.visitReference(current));\n  }\n\n  // Unused visitors.\n  visitBoundAttribute(attr: BoundAttribute) {}\n  visitBoundEvent(event: BoundEvent) {}\n  visitBoundText(text: BoundText) {}\n  visitText(text: Text) {}\n  visitTextAttribute(attr: TextAttribute) {}\n  visitIcu(icu: Icu) {}\n  visitDeferredTrigger(trigger: DeferredTrigger) {}\n  visitUnknownBlock(block: UnknownBlock) {}\n\n  private visitElementLike(node: Element | Component) {\n    node.directives.forEach((current) => current.visit(this));\n    node.references.forEach((current) => this.visitReference(current));\n    node.children.forEach((current) => current.visit(this));\n    this.elementLikeInScope.add(node);\n  }\n\n  private maybeDeclare(thing: TemplateEntity) {\n    // Declare something with a name, as long as that name isn't taken.\n    if (!this.namedEntities.has(thing.name)) {\n      this.namedEntities.set(thing.name, thing);\n    }\n  }\n\n  /**\n   * Look up a variable within this `Scope`.\n   *\n   * This can recurse into a parent `Scope` if it's available.\n   */\n  lookup(name: string): TemplateEntity | null {\n    if (this.namedEntities.has(name)) {\n      // Found in the local scope.\n      return this.namedEntities.get(name)!;\n    } else if (this.parentScope !== null) {\n      // Not in the local scope, but there's a parent scope so check there.\n      return this.parentScope.lookup(name);\n    } else {\n      // At the top level and it wasn't found.\n      return null;\n    }\n  }\n\n  /**\n   * Get the child scope for a `ScopedNode`.\n   *\n   * This should always be defined.\n   */\n  getChildScope(node: ScopedNode): Scope {\n    const res = this.childScopes.get(node);\n    if (res === undefined) {\n      throw new Error(`Assertion error: child scope for ${node} not found`);\n    }\n    return res;\n  }\n\n  private ingestScopedNode(node: ScopedNode) {\n    const scope = new Scope(this, node);\n    scope.ingest(node);\n    this.childScopes.set(node, scope);\n  }\n}\n\n/**\n * Processes a template and matches directives on nodes (elements and templates).\n *\n * Usually used via the static `apply()` method.\n */\nclass DirectiveBinder<DirectiveT extends DirectiveMeta> implements Visitor {\n  // Indicates whether we are visiting elements within a `defer` block\n  private isInDeferBlock = false;\n\n  private constructor(\n    private directiveMatcher: DirectiveMatcher<DirectiveT> | null,\n    private directives: MatchedDirectives<DirectiveT>,\n    private eagerDirectives: DirectiveT[],\n    private missingDirectives: Set<string>,\n    private bindings: BindingsMap<DirectiveT>,\n    private references: ReferenceMap<DirectiveT>,\n  ) {}\n\n  /**\n   * Process a template (list of `Node`s) and perform directive matching against each node.\n   *\n   * @param template the list of template `Node`s to match (recursively).\n   * @param selectorMatcher a `SelectorMatcher` containing the directives that are in scope for\n   * this template.\n   * @returns three maps which contain information about directives in the template: the\n   * `directives` map which lists directives matched on each node, the `bindings` map which\n   * indicates which directives claimed which bindings (inputs, outputs, etc), and the `references`\n   * map which resolves #references (`Reference`s) within the template to the named directive or\n   * template node.\n   */\n  static apply<DirectiveT extends DirectiveMeta>(\n    template: Node[],\n    directiveMatcher: DirectiveMatcher<DirectiveT> | null,\n    directives: MatchedDirectives<DirectiveT>,\n    eagerDirectives: DirectiveT[],\n    missingDirectives: Set<string>,\n    bindings: BindingsMap<DirectiveT>,\n    references: ReferenceMap<DirectiveT>,\n  ): void {\n    const matcher = new DirectiveBinder(\n      directiveMatcher,\n      directives,\n      eagerDirectives,\n      missingDirectives,\n      bindings,\n      references,\n    );\n    matcher.ingest(template);\n  }\n\n  private ingest(template: Node[]): void {\n    template.forEach((node) => node.visit(this));\n  }\n\n  visitElement(element: Element): void {\n    this.visitElementOrTemplate(element);\n  }\n\n  visitTemplate(template: Template): void {\n    this.visitElementOrTemplate(template);\n  }\n\n  visitDeferredBlock(deferred: DeferredBlock): void {\n    const wasInDeferBlock = this.isInDeferBlock;\n    this.isInDeferBlock = true;\n    deferred.children.forEach((child) => child.visit(this));\n    this.isInDeferBlock = wasInDeferBlock;\n\n    deferred.placeholder?.visit(this);\n    deferred.loading?.visit(this);\n    deferred.error?.visit(this);\n  }\n\n  visitDeferredBlockPlaceholder(block: DeferredBlockPlaceholder): void {\n    block.children.forEach((child) => child.visit(this));\n  }\n\n  visitDeferredBlockError(block: DeferredBlockError): void {\n    block.children.forEach((child) => child.visit(this));\n  }\n\n  visitDeferredBlockLoading(block: DeferredBlockLoading): void {\n    block.children.forEach((child) => child.visit(this));\n  }\n\n  visitSwitchBlock(block: SwitchBlock) {\n    block.cases.forEach((node) => node.visit(this));\n  }\n\n  visitSwitchBlockCase(block: SwitchBlockCase) {\n    block.children.forEach((node) => node.visit(this));\n  }\n\n  visitForLoopBlock(block: ForLoopBlock) {\n    block.item.visit(this);\n    block.contextVariables.forEach((v) => v.visit(this));\n    block.children.forEach((node) => node.visit(this));\n    block.empty?.visit(this);\n  }\n\n  visitForLoopBlockEmpty(block: ForLoopBlockEmpty) {\n    block.children.forEach((node) => node.visit(this));\n  }\n\n  visitIfBlock(block: IfBlock) {\n    block.branches.forEach((node) => node.visit(this));\n  }\n\n  visitIfBlockBranch(block: IfBlockBranch) {\n    block.expressionAlias?.visit(this);\n    block.children.forEach((node) => node.visit(this));\n  }\n\n  visitContent(content: Content): void {\n    content.children.forEach((child) => child.visit(this));\n  }\n\n  visitComponent(node: Component): void {\n    if (this.directiveMatcher instanceof SelectorlessMatcher) {\n      const componentMatches = this.directiveMatcher.match(node.componentName);\n\n      if (componentMatches.length > 0) {\n        this.trackSelectorlessMatchesAndDirectives(node, componentMatches);\n      } else {\n        this.missingDirectives.add(node.componentName);\n      }\n    }\n\n    node.directives.forEach((directive) => directive.visit(this));\n    node.children.forEach((child) => child.visit(this));\n  }\n\n  visitDirective(node: Directive): void {\n    if (this.directiveMatcher instanceof SelectorlessMatcher) {\n      const directives = this.directiveMatcher.match(node.name);\n\n      if (directives.length > 0) {\n        this.trackSelectorlessMatchesAndDirectives(node, directives);\n      } else {\n        this.missingDirectives.add(node.name);\n      }\n    }\n  }\n\n  private visitElementOrTemplate(node: Element | Template): void {\n    if (this.directiveMatcher instanceof SelectorMatcher) {\n      const directives: DirectiveT[] = [];\n      const cssSelector = createCssSelectorFromNode(node);\n      this.directiveMatcher.match(cssSelector, (_, results) => directives.push(...results));\n      this.trackSelectorBasedBindingsAndDirectives(node, directives);\n    } else {\n      node.references.forEach((ref) => {\n        if (ref.value.trim() === '') {\n          this.references.set(ref, node);\n        }\n      });\n    }\n\n    node.directives.forEach((directive) => directive.visit(this));\n    node.children.forEach((child) => child.visit(this));\n  }\n\n  private trackMatchedDirectives(node: DirectiveOwner, directives: DirectiveT[]): void {\n    if (directives.length > 0) {\n      this.directives.set(node, directives);\n      if (!this.isInDeferBlock) {\n        this.eagerDirectives.push(...directives);\n      }\n    }\n  }\n\n  private trackSelectorlessMatchesAndDirectives(\n    node: Component | Directive,\n    directives: DirectiveT[],\n  ): void {\n    if (directives.length === 0) {\n      return;\n    }\n\n    this.trackMatchedDirectives(node, directives);\n\n    const setBinding = (\n      meta: DirectiveT,\n      attribute: BoundAttribute | BoundEvent | TextAttribute,\n      ioType: keyof Pick<DirectiveMeta, 'inputs' | 'outputs'>,\n    ) => {\n      if (meta[ioType].hasBindingPropertyName(attribute.name)) {\n        this.bindings.set(attribute, meta);\n      }\n    };\n\n    for (const directive of directives) {\n      node.inputs.forEach((input) => setBinding(directive, input, 'inputs'));\n      node.attributes.forEach((attr) => setBinding(directive, attr, 'inputs'));\n      node.outputs.forEach((output) => setBinding(directive, output, 'outputs'));\n    }\n\n    // TODO(crisbeto): currently it's unclear how references should behave under selectorless,\n    // given that there's one named class which can bring in multiple host directives.\n    // For the time being only register the first directive as the reference target.\n    node.references.forEach((ref) =>\n      this.references.set(ref, {directive: directives[0], node: node}),\n    );\n  }\n\n  private trackSelectorBasedBindingsAndDirectives(\n    node: Element | Template,\n    directives: DirectiveT[],\n  ): void {\n    this.trackMatchedDirectives(node, directives);\n\n    // Resolve any references that are created on this node.\n    node.references.forEach((ref) => {\n      let dirTarget: DirectiveT | null = null;\n\n      // If the reference expression is empty, then it matches the \"primary\" directive on the node\n      // (if there is one). Otherwise it matches the host node itself (either an element or\n      // <ng-template> node).\n      if (ref.value.trim() === '') {\n        // This could be a reference to a component if there is one.\n        dirTarget = directives.find((dir) => dir.isComponent) || null;\n      } else {\n        // This should be a reference to a directive exported via exportAs.\n        dirTarget =\n          directives.find(\n            (dir) => dir.exportAs !== null && dir.exportAs.some((value) => value === ref.value),\n          ) || null;\n        // Check if a matching directive was found.\n        if (dirTarget === null) {\n          // No matching directive was found - this reference points to an unknown target. Leave it\n          // unmapped.\n          return;\n        }\n      }\n\n      if (dirTarget !== null) {\n        // This reference points to a directive.\n        this.references.set(ref, {directive: dirTarget, node});\n      } else {\n        // This reference points to the node itself.\n        this.references.set(ref, node);\n      }\n    });\n\n    // Associate attributes/bindings on the node with directives or with the node itself.\n    const setAttributeBinding = (\n      attribute: BoundAttribute | BoundEvent | TextAttribute,\n      ioType: keyof Pick<DirectiveMeta, 'inputs' | 'outputs'>,\n    ) => {\n      const dir = directives.find((dir) => dir[ioType].hasBindingPropertyName(attribute.name));\n      const binding = dir !== undefined ? dir : node;\n      this.bindings.set(attribute, binding);\n    };\n\n    // Node inputs (bound attributes) and text attributes can be bound to an\n    // input on a directive.\n    node.inputs.forEach((input) => setAttributeBinding(input, 'inputs'));\n    node.attributes.forEach((attr) => setAttributeBinding(attr, 'inputs'));\n    if (node instanceof Template) {\n      node.templateAttrs.forEach((attr) => setAttributeBinding(attr, 'inputs'));\n    }\n    // Node outputs (bound events) can be bound to an output on a directive.\n    node.outputs.forEach((output) => setAttributeBinding(output, 'outputs'));\n  }\n\n  // Unused visitors.\n  visitVariable(variable: Variable): void {}\n  visitReference(reference: Reference): void {}\n  visitTextAttribute(attribute: TextAttribute): void {}\n  visitBoundAttribute(attribute: BoundAttribute): void {}\n  visitBoundEvent(attribute: BoundEvent): void {}\n  visitBoundAttributeOrEvent(node: BoundAttribute | BoundEvent) {}\n  visitText(text: Text): void {}\n  visitBoundText(text: BoundText): void {}\n  visitIcu(icu: Icu): void {}\n  visitDeferredTrigger(trigger: DeferredTrigger): void {}\n  visitUnknownBlock(block: UnknownBlock) {}\n  visitLetDeclaration(decl: LetDeclaration) {}\n}\n\n/**\n * Processes a template and extract metadata about expressions and symbols within.\n *\n * This is a companion to the `DirectiveBinder` that doesn't require knowledge of directives matched\n * within the template in order to operate.\n *\n * Expressions are visited by the superclass `RecursiveAstVisitor`, with custom logic provided\n * by overridden methods from that visitor.\n */\nclass TemplateBinder extends CombinedRecursiveAstVisitor {\n  private visitNode = (node: Node) => node.visit(this);\n\n  private constructor(\n    private bindings: Map<AST, TemplateEntity>,\n    private symbols: Map<TemplateEntity, ScopedNode>,\n    private usedPipes: Set<string>,\n    private eagerPipes: Set<string>,\n    private deferBlocks: DeferBlockScopes,\n    private nestingLevel: Map<ScopedNode, number>,\n    private scope: Scope,\n    private rootNode: ScopedNode | null,\n    private level: number,\n  ) {\n    super();\n  }\n\n  /**\n   * Process a template and extract metadata about expressions and symbols within.\n   *\n   * @param nodeOrNodes the nodes of the template to process\n   * @param scope the `Scope` of the template being processed.\n   * @returns three maps which contain metadata about the template: `expressions` which interprets\n   * special `AST` nodes in expressions as pointing to references or variables declared within the\n   * template, `symbols` which maps those variables and references to the nested `Template` which\n   * declares them, if any, and `nestingLevel` which associates each `Template` with a integer\n   * nesting level (how many levels deep within the template structure the `Template` is), starting\n   * at 1.\n   */\n  static applyWithScope(\n    nodeOrNodes: ScopedNode | Node[],\n    scope: Scope,\n    expressions: Map<AST, TemplateEntity>,\n    symbols: Map<TemplateEntity, Template>,\n    nestingLevel: Map<ScopedNode, number>,\n    usedPipes: Set<string>,\n    eagerPipes: Set<string>,\n    deferBlocks: DeferBlockScopes,\n  ): void {\n    const template = nodeOrNodes instanceof Template ? nodeOrNodes : null;\n    // The top-level template has nesting level 0.\n    const binder = new TemplateBinder(\n      expressions,\n      symbols,\n      usedPipes,\n      eagerPipes,\n      deferBlocks,\n      nestingLevel,\n      scope,\n      template,\n      0,\n    );\n    binder.ingest(nodeOrNodes);\n  }\n\n  private ingest(nodeOrNodes: ScopedNode | Node[]): void {\n    if (nodeOrNodes instanceof Template) {\n      // For <ng-template>s, process only variables and child nodes. Inputs, outputs, templateAttrs,\n      // and references were all processed in the scope of the containing template.\n      nodeOrNodes.variables.forEach(this.visitNode);\n      nodeOrNodes.children.forEach(this.visitNode);\n\n      // Set the nesting level.\n      this.nestingLevel.set(nodeOrNodes, this.level);\n    } else if (nodeOrNodes instanceof IfBlockBranch) {\n      if (nodeOrNodes.expressionAlias !== null) {\n        this.visitNode(nodeOrNodes.expressionAlias);\n      }\n      nodeOrNodes.children.forEach(this.visitNode);\n      this.nestingLevel.set(nodeOrNodes, this.level);\n    } else if (nodeOrNodes instanceof ForLoopBlock) {\n      this.visitNode(nodeOrNodes.item);\n      nodeOrNodes.contextVariables.forEach((v) => this.visitNode(v));\n      nodeOrNodes.trackBy.visit(this);\n      nodeOrNodes.children.forEach(this.visitNode);\n      this.nestingLevel.set(nodeOrNodes, this.level);\n    } else if (nodeOrNodes instanceof DeferredBlock) {\n      if (this.scope.rootNode !== nodeOrNodes) {\n        throw new Error(\n          `Assertion error: resolved incorrect scope for deferred block ${nodeOrNodes}`,\n        );\n      }\n      this.deferBlocks.push([nodeOrNodes, this.scope]);\n      nodeOrNodes.children.forEach((node) => node.visit(this));\n      this.nestingLevel.set(nodeOrNodes, this.level);\n    } else if (\n      nodeOrNodes instanceof SwitchBlockCase ||\n      nodeOrNodes instanceof ForLoopBlockEmpty ||\n      nodeOrNodes instanceof DeferredBlockError ||\n      nodeOrNodes instanceof DeferredBlockPlaceholder ||\n      nodeOrNodes instanceof DeferredBlockLoading ||\n      nodeOrNodes instanceof Content\n    ) {\n      nodeOrNodes.children.forEach((node) => node.visit(this));\n      this.nestingLevel.set(nodeOrNodes, this.level);\n    } else if (nodeOrNodes instanceof HostElement) {\n      // Host elements are always at the top level.\n      this.nestingLevel.set(nodeOrNodes, 0);\n    } else {\n      // Visit each node from the top-level template.\n      nodeOrNodes.forEach(this.visitNode);\n    }\n  }\n\n  override visitTemplate(template: Template) {\n    // First, visit inputs, outputs and template attributes of the template node.\n    template.inputs.forEach(this.visitNode);\n    template.outputs.forEach(this.visitNode);\n    template.directives.forEach(this.visitNode);\n    template.templateAttrs.forEach(this.visitNode);\n    template.references.forEach(this.visitNode);\n\n    // Next, recurse into the template.\n    this.ingestScopedNode(template);\n  }\n\n  override visitVariable(variable: Variable) {\n    // Register the `Variable` as a symbol in the current `Template`.\n    if (this.rootNode !== null) {\n      this.symbols.set(variable, this.rootNode);\n    }\n  }\n\n  override visitReference(reference: Reference) {\n    // Register the `Reference` as a symbol in the current `Template`.\n    if (this.rootNode !== null) {\n      this.symbols.set(reference, this.rootNode);\n    }\n  }\n\n  override visitDeferredBlock(deferred: DeferredBlock) {\n    this.ingestScopedNode(deferred);\n    deferred.triggers.when?.value.visit(this);\n    deferred.prefetchTriggers.when?.value.visit(this);\n    deferred.hydrateTriggers.when?.value.visit(this);\n    deferred.hydrateTriggers.never?.visit(this);\n    deferred.placeholder && this.visitNode(deferred.placeholder);\n    deferred.loading && this.visitNode(deferred.loading);\n    deferred.error && this.visitNode(deferred.error);\n  }\n\n  override visitDeferredBlockPlaceholder(block: DeferredBlockPlaceholder) {\n    this.ingestScopedNode(block);\n  }\n\n  override visitDeferredBlockError(block: DeferredBlockError) {\n    this.ingestScopedNode(block);\n  }\n\n  override visitDeferredBlockLoading(block: DeferredBlockLoading) {\n    this.ingestScopedNode(block);\n  }\n\n  override visitSwitchBlockCase(block: SwitchBlockCase) {\n    block.expression?.visit(this);\n    this.ingestScopedNode(block);\n  }\n\n  override visitForLoopBlock(block: ForLoopBlock) {\n    block.expression.visit(this);\n    this.ingestScopedNode(block);\n    block.empty?.visit(this);\n  }\n\n  override visitForLoopBlockEmpty(block: ForLoopBlockEmpty) {\n    this.ingestScopedNode(block);\n  }\n\n  override visitIfBlockBranch(block: IfBlockBranch) {\n    block.expression?.visit(this);\n    this.ingestScopedNode(block);\n  }\n\n  override visitContent(content: Content) {\n    this.ingestScopedNode(content);\n  }\n\n  override visitLetDeclaration(decl: LetDeclaration) {\n    super.visitLetDeclaration(decl);\n\n    if (this.rootNode !== null) {\n      this.symbols.set(decl, this.rootNode);\n    }\n  }\n\n  override visitPipe(ast: BindingPipe, context: any): any {\n    this.usedPipes.add(ast.name);\n    if (!this.scope.isDeferred) {\n      this.eagerPipes.add(ast.name);\n    }\n    return super.visitPipe(ast, context);\n  }\n\n  // These five types of AST expressions can refer to expression roots, which could be variables\n  // or references in the current scope.\n\n  override visitPropertyRead(ast: PropertyRead, context: any): any {\n    this.maybeMap(ast, ast.name);\n    return super.visitPropertyRead(ast, context);\n  }\n\n  override visitSafePropertyRead(ast: SafePropertyRead, context: any): any {\n    this.maybeMap(ast, ast.name);\n    return super.visitSafePropertyRead(ast, context);\n  }\n\n  private ingestScopedNode(node: ScopedNode) {\n    const childScope = this.scope.getChildScope(node);\n    const binder = new TemplateBinder(\n      this.bindings,\n      this.symbols,\n      this.usedPipes,\n      this.eagerPipes,\n      this.deferBlocks,\n      this.nestingLevel,\n      childScope,\n      node,\n      this.level + 1,\n    );\n    binder.ingest(node);\n  }\n\n  private maybeMap(ast: PropertyRead | SafePropertyRead, name: string): void {\n    // If the receiver of the expression isn't the `ImplicitReceiver`, this isn't the root of an\n    // `AST` expression that maps to a `Variable` or `Reference`.\n    if (!(ast.receiver instanceof ImplicitReceiver) || ast.receiver instanceof ThisReceiver) {\n      return;\n    }\n\n    // Check whether the name exists in the current scope. If so, map it. Otherwise, the name is\n    // probably a property on the top-level component context.\n    const target = this.scope.lookup(name);\n    if (target !== null) {\n      this.bindings.set(ast, target);\n    }\n  }\n}\n\n/**\n * Metadata container for a `Target` that allows queries for specific bits of metadata.\n *\n * See `BoundTarget` for documentation on the individual methods.\n */\nclass R3BoundTarget<DirectiveT extends DirectiveMeta> implements BoundTarget<DirectiveT> {\n  /** Deferred blocks, ordered as they appear in the template. */\n  private deferredBlocks: DeferredBlock[];\n\n  /** Map of deferred blocks to their scope. */\n  private deferredScopes: Map<DeferredBlock, Scope>;\n\n  constructor(\n    readonly target: Target<DirectiveT>,\n    private directives: MatchedDirectives<DirectiveT>,\n    private eagerDirectives: DirectiveT[],\n    private missingDirectives: Set<string>,\n    private bindings: BindingsMap<DirectiveT>,\n    private references: ReferenceMap<DirectiveT>,\n    private exprTargets: Map<AST, TemplateEntity>,\n    private symbols: Map<TemplateEntity, Template>,\n    private nestingLevel: Map<ScopedNode, number>,\n    private scopedNodeEntities: ScopedNodeEntities,\n    private usedPipes: Set<string>,\n    private eagerPipes: Set<string>,\n    rawDeferred: DeferBlockScopes,\n  ) {\n    this.deferredBlocks = rawDeferred.map((current) => current[0]);\n    this.deferredScopes = new Map(rawDeferred);\n  }\n\n  getEntitiesInScope(node: ScopedNode | null): ReadonlySet<TemplateEntity> {\n    return this.scopedNodeEntities.get(node) ?? new Set();\n  }\n\n  getDirectivesOfNode(node: DirectiveOwner): DirectiveT[] | null {\n    return this.directives.get(node) || null;\n  }\n\n  getReferenceTarget(ref: Reference): ReferenceTarget<DirectiveT> | null {\n    return this.references.get(ref) || null;\n  }\n\n  getConsumerOfBinding(\n    binding: BoundAttribute | BoundEvent | TextAttribute,\n  ): DirectiveT | Element | Template | null {\n    return this.bindings.get(binding) || null;\n  }\n\n  getExpressionTarget(expr: AST): TemplateEntity | null {\n    return this.exprTargets.get(expr) || null;\n  }\n\n  getDefinitionNodeOfSymbol(symbol: TemplateEntity): ScopedNode | null {\n    return this.symbols.get(symbol) || null;\n  }\n\n  getNestingLevel(node: ScopedNode): number {\n    return this.nestingLevel.get(node) || 0;\n  }\n\n  getUsedDirectives(): DirectiveT[] {\n    const set = new Set<DirectiveT>();\n    this.directives.forEach((dirs) => dirs.forEach((dir) => set.add(dir)));\n    return Array.from(set.values());\n  }\n\n  getEagerlyUsedDirectives(): DirectiveT[] {\n    const set = new Set<DirectiveT>(this.eagerDirectives);\n    return Array.from(set.values());\n  }\n\n  getUsedPipes(): string[] {\n    return Array.from(this.usedPipes);\n  }\n\n  getEagerlyUsedPipes(): string[] {\n    return Array.from(this.eagerPipes);\n  }\n\n  getDeferBlocks(): DeferredBlock[] {\n    return this.deferredBlocks;\n  }\n\n  getDeferredTriggerTarget(block: DeferredBlock, trigger: DeferredTrigger): Element | null {\n    // Only triggers that refer to DOM nodes can be resolved.\n    if (\n      !(trigger instanceof InteractionDeferredTrigger) &&\n      !(trigger instanceof ViewportDeferredTrigger) &&\n      !(trigger instanceof HoverDeferredTrigger)\n    ) {\n      return null;\n    }\n\n    const name = trigger.reference;\n\n    if (name === null) {\n      let target: Element | null = null;\n\n      if (block.placeholder !== null) {\n        for (const child of block.placeholder.children) {\n          // Skip over comment nodes. Currently by default the template parser doesn't capture\n          // comments, but we have a safeguard here just in case since it can be enabled.\n          if (child instanceof Comment) {\n            continue;\n          }\n\n          // We can only infer the trigger if there's one root element node. Any other\n          // nodes at the root make it so that we can't infer the trigger anymore.\n          if (target !== null) {\n            return null;\n          }\n\n          if (child instanceof Element) {\n            target = child;\n          }\n        }\n      }\n\n      return target;\n    }\n\n    const outsideRef = this.findEntityInScope(block, name);\n\n    // First try to resolve the target in the scope of the main deferred block. Note that we\n    // skip triggers defined inside the main block itself, because they might not exist yet.\n    if (outsideRef instanceof Reference && this.getDefinitionNodeOfSymbol(outsideRef) !== block) {\n      const target = this.getReferenceTarget(outsideRef);\n\n      if (target !== null) {\n        return this.referenceTargetToElement(target);\n      }\n    }\n\n    // If the trigger couldn't be found in the main block, check the\n    // placeholder block which is shown before the main block has loaded.\n    if (block.placeholder !== null) {\n      const refInPlaceholder = this.findEntityInScope(block.placeholder, name);\n      const targetInPlaceholder =\n        refInPlaceholder instanceof Reference ? this.getReferenceTarget(refInPlaceholder) : null;\n\n      if (targetInPlaceholder !== null) {\n        return this.referenceTargetToElement(targetInPlaceholder);\n      }\n    }\n\n    return null;\n  }\n\n  isDeferred(element: Element): boolean {\n    for (const block of this.deferredBlocks) {\n      if (!this.deferredScopes.has(block)) {\n        continue;\n      }\n\n      const stack: Scope[] = [this.deferredScopes.get(block)!];\n\n      while (stack.length > 0) {\n        const current = stack.pop()!;\n\n        if (current.elementLikeInScope.has(element)) {\n          return true;\n        }\n\n        stack.push(...current.childScopes.values());\n      }\n    }\n\n    return false;\n  }\n\n  referencedDirectiveExists(name: string): boolean {\n    return !this.missingDirectives.has(name);\n  }\n\n  /**\n   * Finds an entity with a specific name in a scope.\n   * @param rootNode Root node of the scope.\n   * @param name Name of the entity.\n   */\n  private findEntityInScope(rootNode: ScopedNode, name: string): TemplateEntity | null {\n    const entities = this.getEntitiesInScope(rootNode);\n\n    for (const entity of entities) {\n      if (entity.name === name) {\n        return entity;\n      }\n    }\n\n    return null;\n  }\n\n  /** Coerces a `ReferenceTarget` to an `Element`, if possible. */\n  private referenceTargetToElement(target: ReferenceTarget<DirectiveT>): Element | null {\n    if (target instanceof Element) {\n      return target;\n    }\n\n    if (\n      target instanceof Template ||\n      target.node instanceof Component ||\n      target.node instanceof Directive ||\n      target.node instanceof HostElement\n    ) {\n      return null;\n    }\n\n    return this.referenceTargetToElement(target.node);\n  }\n}\n\nfunction extractScopedNodeEntities(rootScope: Scope, templateEntities: ScopedNodeEntities): void {\n  const entityMap = new Map<ScopedNode | null, Map<string, TemplateEntity>>();\n\n  function extractScopeEntities(scope: Scope): Map<string, TemplateEntity> {\n    if (entityMap.has(scope.rootNode)) {\n      return entityMap.get(scope.rootNode)!;\n    }\n\n    const currentEntities = scope.namedEntities;\n\n    let entities: Map<string, TemplateEntity>;\n    if (scope.parentScope !== null) {\n      entities = new Map([...extractScopeEntities(scope.parentScope), ...currentEntities]);\n    } else {\n      entities = new Map(currentEntities);\n    }\n\n    entityMap.set(scope.rootNode, entities);\n    return entities;\n  }\n\n  const scopesToProcess: Scope[] = [rootScope];\n  while (scopesToProcess.length > 0) {\n    const scope = scopesToProcess.pop()!;\n    for (const childScope of scope.childScopes.values()) {\n      scopesToProcess.push(childScope);\n    }\n    extractScopeEntities(scope);\n  }\n\n  for (const [template, entities] of entityMap) {\n    templateEntities.set(template, new Set(entities.values()));\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/**\n * An interface for retrieving documents by URL that the compiler uses to\n * load templates.\n *\n * This is an abstract class, rather than an interface, so that it can be used\n * as injection token.\n */\nexport abstract class ResourceLoader {\n  abstract get(url: string): Promise<string> | string;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  CompilerFacade,\n  CoreEnvironment,\n  ExportedCompilerFacade,\n  FactoryTarget,\n  LegacyInputPartialMapping,\n  OpaqueValue,\n  R3ComponentMetadataFacade,\n  R3DeclareComponentFacade,\n  R3DeclareDependencyMetadataFacade,\n  R3DeclareDirectiveDependencyFacade,\n  R3DeclareDirectiveFacade,\n  R3DeclareFactoryFacade,\n  R3DeclareInjectableFacade,\n  R3DeclareInjectorFacade,\n  R3DeclareNgModuleFacade,\n  R3DeclarePipeDependencyFacade,\n  R3DeclarePipeFacade,\n  R3DeclareQueryMetadataFacade,\n  R3DependencyMetadataFacade,\n  R3DirectiveMetadataFacade,\n  R3FactoryDefMetadataFacade,\n  R3InjectableMetadataFacade,\n  R3InjectorMetadataFacade,\n  R3NgModuleMetadataFacade,\n  R3PipeMetadataFacade,\n  R3QueryMetadataFacade,\n  R3TemplateDependencyFacade,\n} from './compiler_facade_interface';\nimport {ConstantPool} from './constant_pool';\nimport {\n  ChangeDetectionStrategy,\n  HostBinding,\n  HostListener,\n  Input,\n  Output,\n  ViewEncapsulation,\n} from './core';\nimport {compileInjectable} from './injectable_compiler_2';\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from './ml_parser/defaults';\nimport {\n  DeclareVarStmt,\n  Expression,\n  literal,\n  LiteralExpr,\n  Statement,\n  StmtModifier,\n  WrappedNodeExpr,\n} from './output/output_ast';\nimport {JitEvaluator} from './output/output_jit';\nimport {ParseError, ParseSourceSpan, r3JitTypeSourceSpan} from './parse_util';\nimport {DeferredBlock} from './render3/r3_ast';\nimport {compileFactoryFunction, R3DependencyMetadata} from './render3/r3_factory';\nimport {compileInjector, R3InjectorMetadata} from './render3/r3_injector_compiler';\nimport {R3JitReflector} from './render3/r3_jit';\nimport {\n  compileNgModule,\n  compileNgModuleDeclarationExpression,\n  R3NgModuleMetadata,\n  R3NgModuleMetadataKind,\n  R3SelectorScopeMode,\n} from './render3/r3_module_compiler';\nimport {compilePipeFromMetadata, R3PipeMetadata} from './render3/r3_pipe_compiler';\nimport {\n  createMayBeForwardRefExpression,\n  ForwardRefHandling,\n  getSafePropertyAccessString,\n  MaybeForwardRefExpression,\n  wrapReference,\n} from './render3/util';\nimport {\n  DeclarationListEmitMode,\n  DeferBlockDepsEmitMode,\n  R3ComponentDeferMetadata,\n  R3ComponentMetadata,\n  R3DirectiveDependencyMetadata,\n  R3DirectiveMetadata,\n  R3HostMetadata,\n  R3InputMetadata,\n  R3PipeDependencyMetadata,\n  R3QueryMetadata,\n  R3TemplateDependency,\n  R3TemplateDependencyKind,\n  R3TemplateDependencyMetadata,\n} from './render3/view/api';\nimport {\n  compileComponentFromMetadata,\n  compileDirectiveFromMetadata,\n  ParsedHostBindings,\n  parseHostBindings,\n  verifyHostBindings,\n} from './render3/view/compiler';\n\nimport type {BoundTarget} from './render3/view/t2_api';\nimport {R3TargetBinder} from './render3/view/t2_binder';\nimport {makeBindingParser, parseTemplate} from './render3/view/template';\nimport {ResourceLoader} from './resource_loader';\nimport {DomElementSchemaRegistry} from './schema/dom_element_schema_registry';\nimport {getJitStandaloneDefaultForVersion} from './util';\n\nexport class CompilerFacadeImpl implements CompilerFacade {\n  FactoryTarget = FactoryTarget;\n  ResourceLoader = ResourceLoader;\n  private elementSchemaRegistry = new DomElementSchemaRegistry();\n\n  constructor(private jitEvaluator = new JitEvaluator()) {}\n\n  compilePipe(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    facade: R3PipeMetadataFacade,\n  ): any {\n    const metadata: R3PipeMetadata = {\n      name: facade.name,\n      type: wrapReference(facade.type),\n      typeArgumentCount: 0,\n      deps: null,\n      pipeName: facade.pipeName,\n      pure: facade.pure,\n      isStandalone: facade.isStandalone,\n    };\n    const res = compilePipeFromMetadata(metadata);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n  }\n\n  compilePipeDeclaration(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    declaration: R3DeclarePipeFacade,\n  ): any {\n    const meta = convertDeclarePipeFacadeToMetadata(declaration);\n    const res = compilePipeFromMetadata(meta);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n  }\n\n  compileInjectable(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    facade: R3InjectableMetadataFacade,\n  ): any {\n    const {expression, statements} = compileInjectable(\n      {\n        name: facade.name,\n        type: wrapReference(facade.type),\n        typeArgumentCount: facade.typeArgumentCount,\n        providedIn: computeProvidedIn(facade.providedIn),\n        useClass: convertToProviderExpression(facade, 'useClass'),\n        useFactory: wrapExpression(facade, 'useFactory'),\n        useValue: convertToProviderExpression(facade, 'useValue'),\n        useExisting: convertToProviderExpression(facade, 'useExisting'),\n        deps: facade.deps?.map(convertR3DependencyMetadata),\n      },\n      /* resolveForwardRefs */ true,\n    );\n\n    return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, statements);\n  }\n\n  compileInjectableDeclaration(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    facade: R3DeclareInjectableFacade,\n  ): any {\n    const {expression, statements} = compileInjectable(\n      {\n        name: facade.type.name,\n        type: wrapReference(facade.type),\n        typeArgumentCount: 0,\n        providedIn: computeProvidedIn(facade.providedIn),\n        useClass: convertToProviderExpression(facade, 'useClass'),\n        useFactory: wrapExpression(facade, 'useFactory'),\n        useValue: convertToProviderExpression(facade, 'useValue'),\n        useExisting: convertToProviderExpression(facade, 'useExisting'),\n        deps: facade.deps?.map(convertR3DeclareDependencyMetadata),\n      },\n      /* resolveForwardRefs */ true,\n    );\n\n    return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, statements);\n  }\n\n  compileInjector(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    facade: R3InjectorMetadataFacade,\n  ): any {\n    const meta: R3InjectorMetadata = {\n      name: facade.name,\n      type: wrapReference(facade.type),\n      providers:\n        facade.providers && facade.providers.length > 0\n          ? new WrappedNodeExpr(facade.providers)\n          : null,\n      imports: facade.imports.map((i) => new WrappedNodeExpr(i)),\n    };\n    const res = compileInjector(meta);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n  }\n\n  compileInjectorDeclaration(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    declaration: R3DeclareInjectorFacade,\n  ): any {\n    const meta = convertDeclareInjectorFacadeToMetadata(declaration);\n    const res = compileInjector(meta);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n  }\n\n  compileNgModule(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    facade: R3NgModuleMetadataFacade,\n  ): any {\n    const meta: R3NgModuleMetadata = {\n      kind: R3NgModuleMetadataKind.Global,\n      type: wrapReference(facade.type),\n      bootstrap: facade.bootstrap.map(wrapReference),\n      declarations: facade.declarations.map(wrapReference),\n      publicDeclarationTypes: null, // only needed for types in AOT\n      imports: facade.imports.map(wrapReference),\n      includeImportTypes: true,\n      exports: facade.exports.map(wrapReference),\n      selectorScopeMode: R3SelectorScopeMode.Inline,\n      containsForwardDecls: false,\n      schemas: facade.schemas ? facade.schemas.map(wrapReference) : null,\n      id: facade.id ? new WrappedNodeExpr(facade.id) : null,\n    };\n    const res = compileNgModule(meta);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n  }\n\n  compileNgModuleDeclaration(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    declaration: R3DeclareNgModuleFacade,\n  ): any {\n    const expression = compileNgModuleDeclarationExpression(declaration);\n    return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, []);\n  }\n\n  compileDirective(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    facade: R3DirectiveMetadataFacade,\n  ): any {\n    const meta: R3DirectiveMetadata = convertDirectiveFacadeToMetadata(facade);\n    return this.compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta);\n  }\n\n  compileDirectiveDeclaration(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    declaration: R3DeclareDirectiveFacade,\n  ): any {\n    const typeSourceSpan = this.createParseSourceSpan(\n      'Directive',\n      declaration.type.name,\n      sourceMapUrl,\n    );\n    const meta = convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan);\n    return this.compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta);\n  }\n\n  private compileDirectiveFromMeta(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    meta: R3DirectiveMetadata,\n  ): any {\n    const constantPool = new ConstantPool();\n    const bindingParser = makeBindingParser();\n    const res = compileDirectiveFromMetadata(meta, constantPool, bindingParser);\n    return this.jitExpression(\n      res.expression,\n      angularCoreEnv,\n      sourceMapUrl,\n      constantPool.statements,\n    );\n  }\n\n  compileComponent(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    facade: R3ComponentMetadataFacade,\n  ): any {\n    // Parse the template and check for errors.\n    const {template, interpolation, defer} = parseJitTemplate(\n      facade.template,\n      facade.name,\n      sourceMapUrl,\n      facade.preserveWhitespaces,\n      facade.interpolation,\n      undefined,\n    );\n\n    // Compile the component metadata, including template, into an expression.\n    const meta: R3ComponentMetadata<R3TemplateDependency> = {\n      ...facade,\n      ...convertDirectiveFacadeToMetadata(facade),\n      selector: facade.selector || this.elementSchemaRegistry.getDefaultComponentElementName(),\n      template,\n      declarations: facade.declarations.map(convertDeclarationFacadeToMetadata),\n      declarationListEmitMode: DeclarationListEmitMode.Direct,\n      defer,\n\n      styles: [...facade.styles, ...template.styles],\n      encapsulation: facade.encapsulation,\n      interpolation,\n      changeDetection: facade.changeDetection ?? null,\n      animations: facade.animations != null ? new WrappedNodeExpr(facade.animations) : null,\n      viewProviders:\n        facade.viewProviders != null ? new WrappedNodeExpr(facade.viewProviders) : null,\n      relativeContextFilePath: '',\n      i18nUseExternalIds: true,\n      relativeTemplatePath: null,\n    };\n    const jitExpressionSourceMap = `ng:///${facade.name}.js`;\n    return this.compileComponentFromMeta(angularCoreEnv, jitExpressionSourceMap, meta);\n  }\n\n  compileComponentDeclaration(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    declaration: R3DeclareComponentFacade,\n  ): any {\n    const typeSourceSpan = this.createParseSourceSpan(\n      'Component',\n      declaration.type.name,\n      sourceMapUrl,\n    );\n    const meta = convertDeclareComponentFacadeToMetadata(declaration, typeSourceSpan, sourceMapUrl);\n    return this.compileComponentFromMeta(angularCoreEnv, sourceMapUrl, meta);\n  }\n\n  private compileComponentFromMeta(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    meta: R3ComponentMetadata<R3TemplateDependency>,\n  ): any {\n    const constantPool = new ConstantPool();\n    const bindingParser = makeBindingParser(meta.interpolation);\n    const res = compileComponentFromMetadata(meta, constantPool, bindingParser);\n    return this.jitExpression(\n      res.expression,\n      angularCoreEnv,\n      sourceMapUrl,\n      constantPool.statements,\n    );\n  }\n\n  compileFactory(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    meta: R3FactoryDefMetadataFacade,\n  ) {\n    const factoryRes = compileFactoryFunction({\n      name: meta.name,\n      type: wrapReference(meta.type),\n      typeArgumentCount: meta.typeArgumentCount,\n      deps: convertR3DependencyMetadataArray(meta.deps),\n      target: meta.target,\n    });\n    return this.jitExpression(\n      factoryRes.expression,\n      angularCoreEnv,\n      sourceMapUrl,\n      factoryRes.statements,\n    );\n  }\n\n  compileFactoryDeclaration(\n    angularCoreEnv: CoreEnvironment,\n    sourceMapUrl: string,\n    meta: R3DeclareFactoryFacade,\n  ) {\n    const factoryRes = compileFactoryFunction({\n      name: meta.type.name,\n      type: wrapReference(meta.type),\n      typeArgumentCount: 0,\n      deps: Array.isArray(meta.deps)\n        ? meta.deps.map(convertR3DeclareDependencyMetadata)\n        : meta.deps,\n      target: meta.target,\n    });\n    return this.jitExpression(\n      factoryRes.expression,\n      angularCoreEnv,\n      sourceMapUrl,\n      factoryRes.statements,\n    );\n  }\n\n  createParseSourceSpan(kind: string, typeName: string, sourceUrl: string): ParseSourceSpan {\n    return r3JitTypeSourceSpan(kind, typeName, sourceUrl);\n  }\n\n  /**\n   * JIT compiles an expression and returns the result of executing that expression.\n   *\n   * @param def the definition which will be compiled and executed to get the value to patch\n   * @param context an object map of @angular/core symbol names to symbols which will be available\n   * in the context of the compiled expression\n   * @param sourceUrl a URL to use for the source map of the compiled expression\n   * @param preStatements a collection of statements that should be evaluated before the expression.\n   */\n  private jitExpression(\n    def: Expression,\n    context: {[key: string]: any},\n    sourceUrl: string,\n    preStatements: Statement[],\n  ): any {\n    // The ConstantPool may contain Statements which declare variables used in the final expression.\n    // Therefore, its statements need to precede the actual JIT operation. The final statement is a\n    // declaration of $def which is set to the expression being compiled.\n    const statements: Statement[] = [\n      ...preStatements,\n      new DeclareVarStmt('$def', def, undefined, StmtModifier.Exported),\n    ];\n\n    const res = this.jitEvaluator.evaluateStatements(\n      sourceUrl,\n      statements,\n      new R3JitReflector(context),\n      /* enableSourceMaps */ true,\n    );\n    return res['$def'];\n  }\n}\n\nfunction convertToR3QueryMetadata(facade: R3QueryMetadataFacade): R3QueryMetadata {\n  return {\n    ...facade,\n    isSignal: facade.isSignal,\n    predicate: convertQueryPredicate(facade.predicate),\n    read: facade.read ? new WrappedNodeExpr(facade.read) : null,\n    static: facade.static,\n    emitDistinctChangesOnly: facade.emitDistinctChangesOnly,\n  };\n}\n\nfunction convertQueryDeclarationToMetadata(\n  declaration: R3DeclareQueryMetadataFacade,\n): R3QueryMetadata {\n  return {\n    propertyName: declaration.propertyName,\n    first: declaration.first ?? false,\n    predicate: convertQueryPredicate(declaration.predicate),\n    descendants: declaration.descendants ?? false,\n    read: declaration.read ? new WrappedNodeExpr(declaration.read) : null,\n    static: declaration.static ?? false,\n    emitDistinctChangesOnly: declaration.emitDistinctChangesOnly ?? true,\n    isSignal: !!declaration.isSignal,\n  };\n}\n\nfunction convertQueryPredicate(\n  predicate: OpaqueValue | string[],\n): MaybeForwardRefExpression | string[] {\n  return Array.isArray(predicate)\n    ? // The predicate is an array of strings so pass it through.\n      predicate\n    : // The predicate is a type - assume that we will need to unwrap any `forwardRef()` calls.\n      createMayBeForwardRefExpression(new WrappedNodeExpr(predicate), ForwardRefHandling.Wrapped);\n}\n\nfunction convertDirectiveFacadeToMetadata(facade: R3DirectiveMetadataFacade): R3DirectiveMetadata {\n  const inputsFromMetadata = parseInputsArray(facade.inputs || []);\n  const outputsFromMetadata = parseMappingStringArray(facade.outputs || []);\n  const propMetadata = facade.propMetadata;\n  const inputsFromType: Record<string, R3InputMetadata> = {};\n  const outputsFromType: Record<string, string> = {};\n  for (const field in propMetadata) {\n    if (propMetadata.hasOwnProperty(field)) {\n      propMetadata[field].forEach((ann) => {\n        if (isInput(ann)) {\n          inputsFromType[field] = {\n            bindingPropertyName: ann.alias || field,\n            classPropertyName: field,\n            required: ann.required || false,\n            // For JIT, decorators are used to declare signal inputs. That is because of\n            // a technical limitation where it's not possible to statically reflect class\n            // members of a directive/component at runtime before instantiating the class.\n            isSignal: !!ann.isSignal,\n            transformFunction: ann.transform != null ? new WrappedNodeExpr(ann.transform) : null,\n          };\n        } else if (isOutput(ann)) {\n          outputsFromType[field] = ann.alias || field;\n        }\n      });\n    }\n  }\n\n  const hostDirectives = facade.hostDirectives?.length\n    ? facade.hostDirectives.map((hostDirective) => {\n        return typeof hostDirective === 'function'\n          ? {\n              directive: wrapReference(hostDirective),\n              inputs: null,\n              outputs: null,\n              isForwardReference: false,\n            }\n          : {\n              directive: wrapReference(hostDirective.directive),\n              isForwardReference: false,\n              inputs: hostDirective.inputs ? parseMappingStringArray(hostDirective.inputs) : null,\n              outputs: hostDirective.outputs\n                ? parseMappingStringArray(hostDirective.outputs)\n                : null,\n            };\n      })\n    : null;\n\n  return {\n    ...facade,\n    typeArgumentCount: 0,\n    typeSourceSpan: facade.typeSourceSpan,\n    type: wrapReference(facade.type),\n    deps: null,\n    host: {\n      ...extractHostBindings(facade.propMetadata, facade.typeSourceSpan, facade.host),\n    },\n    inputs: {...inputsFromMetadata, ...inputsFromType},\n    outputs: {...outputsFromMetadata, ...outputsFromType},\n    queries: facade.queries.map(convertToR3QueryMetadata),\n    providers: facade.providers != null ? new WrappedNodeExpr(facade.providers) : null,\n    viewQueries: facade.viewQueries.map(convertToR3QueryMetadata),\n    fullInheritance: false,\n    hostDirectives,\n  };\n}\n\nfunction convertDeclareDirectiveFacadeToMetadata(\n  declaration: R3DeclareDirectiveFacade,\n  typeSourceSpan: ParseSourceSpan,\n): R3DirectiveMetadata {\n  const hostDirectives = declaration.hostDirectives?.length\n    ? declaration.hostDirectives.map((dir) => ({\n        directive: wrapReference(dir.directive),\n        isForwardReference: false,\n        inputs: dir.inputs ? getHostDirectiveBindingMapping(dir.inputs) : null,\n        outputs: dir.outputs ? getHostDirectiveBindingMapping(dir.outputs) : null,\n      }))\n    : null;\n\n  return {\n    name: declaration.type.name,\n    type: wrapReference(declaration.type),\n    typeSourceSpan,\n    selector: declaration.selector ?? null,\n    inputs: declaration.inputs ? inputsPartialMetadataToInputMetadata(declaration.inputs) : {},\n    outputs: declaration.outputs ?? {},\n    host: convertHostDeclarationToMetadata(declaration.host),\n    queries: (declaration.queries ?? []).map(convertQueryDeclarationToMetadata),\n    viewQueries: (declaration.viewQueries ?? []).map(convertQueryDeclarationToMetadata),\n    providers:\n      declaration.providers !== undefined ? new WrappedNodeExpr(declaration.providers) : null,\n    exportAs: declaration.exportAs ?? null,\n    usesInheritance: declaration.usesInheritance ?? false,\n    lifecycle: {usesOnChanges: declaration.usesOnChanges ?? false},\n    deps: null,\n    typeArgumentCount: 0,\n    fullInheritance: false,\n    isStandalone:\n      declaration.isStandalone ?? getJitStandaloneDefaultForVersion(declaration.version),\n    isSignal: declaration.isSignal ?? false,\n    hostDirectives,\n  };\n}\n\nfunction convertHostDeclarationToMetadata(\n  host: R3DeclareDirectiveFacade['host'] = {},\n): R3HostMetadata {\n  return {\n    attributes: convertOpaqueValuesToExpressions(host.attributes ?? {}),\n    listeners: host.listeners ?? {},\n    properties: host.properties ?? {},\n    specialAttributes: {\n      classAttr: host.classAttribute,\n      styleAttr: host.styleAttribute,\n    },\n  };\n}\n\n/**\n * Parses a host directive mapping where each odd array key is the name of an input/output\n * and each even key is its public name, e.g. `['one', 'oneAlias', 'two', 'two']`.\n */\nfunction getHostDirectiveBindingMapping(array: string[]) {\n  let result: {[publicName: string]: string} | null = null;\n\n  for (let i = 1; i < array.length; i += 2) {\n    result = result || {};\n    result[array[i - 1]] = array[i];\n  }\n\n  return result;\n}\n\nfunction convertOpaqueValuesToExpressions(obj: {[key: string]: OpaqueValue}): {\n  [key: string]: WrappedNodeExpr<unknown>;\n} {\n  const result: {[key: string]: WrappedNodeExpr<unknown>} = {};\n  for (const key of Object.keys(obj)) {\n    result[key] = new WrappedNodeExpr(obj[key]);\n  }\n  return result;\n}\n\nfunction convertDeclareComponentFacadeToMetadata(\n  decl: R3DeclareComponentFacade,\n  typeSourceSpan: ParseSourceSpan,\n  sourceMapUrl: string,\n): R3ComponentMetadata<R3TemplateDependencyMetadata> {\n  const {template, interpolation, defer} = parseJitTemplate(\n    decl.template,\n    decl.type.name,\n    sourceMapUrl,\n    decl.preserveWhitespaces ?? false,\n    decl.interpolation,\n    decl.deferBlockDependencies,\n  );\n\n  const declarations: R3TemplateDependencyMetadata[] = [];\n  if (decl.dependencies) {\n    for (const innerDep of decl.dependencies) {\n      switch (innerDep.kind) {\n        case 'directive':\n        case 'component':\n          declarations.push(convertDirectiveDeclarationToMetadata(innerDep));\n          break;\n        case 'pipe':\n          declarations.push(convertPipeDeclarationToMetadata(innerDep));\n          break;\n      }\n    }\n  } else if (decl.components || decl.directives || decl.pipes) {\n    // Existing declarations on NPM may not be using the new `dependencies` merged field, and may\n    // have separate fields for dependencies instead. Unify them for JIT compilation.\n    decl.components &&\n      declarations.push(\n        ...decl.components.map((dir) =>\n          convertDirectiveDeclarationToMetadata(dir, /* isComponent */ true),\n        ),\n      );\n    decl.directives &&\n      declarations.push(\n        ...decl.directives.map((dir) => convertDirectiveDeclarationToMetadata(dir)),\n      );\n    decl.pipes && declarations.push(...convertPipeMapToMetadata(decl.pipes));\n  }\n\n  const hasDirectiveDependencies = declarations.some(\n    ({kind}) =>\n      kind === R3TemplateDependencyKind.Directive || kind === R3TemplateDependencyKind.NgModule,\n  );\n\n  return {\n    ...convertDeclareDirectiveFacadeToMetadata(decl, typeSourceSpan),\n    template,\n    styles: decl.styles ?? [],\n    declarations,\n    viewProviders:\n      decl.viewProviders !== undefined ? new WrappedNodeExpr(decl.viewProviders) : null,\n    animations: decl.animations !== undefined ? new WrappedNodeExpr(decl.animations) : null,\n    defer,\n    changeDetection: decl.changeDetection ?? ChangeDetectionStrategy.Default,\n    encapsulation: decl.encapsulation ?? ViewEncapsulation.Emulated,\n    interpolation,\n    declarationListEmitMode: DeclarationListEmitMode.ClosureResolved,\n    relativeContextFilePath: '',\n    i18nUseExternalIds: true,\n    relativeTemplatePath: null,\n    hasDirectiveDependencies,\n  };\n}\n\nfunction convertDeclarationFacadeToMetadata(\n  declaration: R3TemplateDependencyFacade,\n): R3TemplateDependency {\n  return {\n    ...declaration,\n    type: new WrappedNodeExpr(declaration.type),\n  };\n}\n\nfunction convertDirectiveDeclarationToMetadata(\n  declaration: R3DeclareDirectiveDependencyFacade,\n  isComponent: true | null = null,\n): R3DirectiveDependencyMetadata {\n  return {\n    kind: R3TemplateDependencyKind.Directive,\n    isComponent: isComponent || declaration.kind === 'component',\n    selector: declaration.selector,\n    type: new WrappedNodeExpr(declaration.type),\n    inputs: declaration.inputs ?? [],\n    outputs: declaration.outputs ?? [],\n    exportAs: declaration.exportAs ?? null,\n  };\n}\n\nfunction convertPipeMapToMetadata(\n  pipes: R3DeclareComponentFacade['pipes'],\n): R3PipeDependencyMetadata[] {\n  if (!pipes) {\n    return [];\n  }\n\n  return Object.keys(pipes).map((name) => {\n    return {\n      kind: R3TemplateDependencyKind.Pipe,\n      name,\n      type: new WrappedNodeExpr(pipes[name]),\n    };\n  });\n}\n\nfunction convertPipeDeclarationToMetadata(\n  pipe: R3DeclarePipeDependencyFacade,\n): R3PipeDependencyMetadata {\n  return {\n    kind: R3TemplateDependencyKind.Pipe,\n    name: pipe.name,\n    type: new WrappedNodeExpr(pipe.type),\n  };\n}\n\nfunction parseJitTemplate(\n  template: string,\n  typeName: string,\n  sourceMapUrl: string,\n  preserveWhitespaces: boolean,\n  interpolation: [string, string] | undefined,\n  deferBlockDependencies: (() => Promise<unknown> | null)[] | undefined,\n) {\n  const interpolationConfig = interpolation\n    ? InterpolationConfig.fromArray(interpolation)\n    : DEFAULT_INTERPOLATION_CONFIG;\n  // Parse the template and check for errors.\n  const parsed = parseTemplate(template, sourceMapUrl, {\n    preserveWhitespaces,\n    interpolationConfig,\n  });\n  if (parsed.errors !== null) {\n    const errors = parsed.errors.map((err) => err.toString()).join(', ');\n    throw new Error(`Errors during JIT compilation of template for ${typeName}: ${errors}`);\n  }\n  const binder = new R3TargetBinder(null);\n  const boundTarget = binder.bind({template: parsed.nodes});\n\n  return {\n    template: parsed,\n    interpolation: interpolationConfig,\n    defer: createR3ComponentDeferMetadata(boundTarget, deferBlockDependencies),\n  };\n}\n\n/**\n * Convert the expression, if present to an `R3ProviderExpression`.\n *\n * In JIT mode we do not want the compiler to wrap the expression in a `forwardRef()` call because,\n * if it is referencing a type that has not yet been defined, it will have already been wrapped in\n * a `forwardRef()` - either by the application developer or during partial-compilation. Thus we can\n * use `ForwardRefHandling.None`.\n */\nfunction convertToProviderExpression(\n  obj: any,\n  property: string,\n): MaybeForwardRefExpression | undefined {\n  if (obj.hasOwnProperty(property)) {\n    return createMayBeForwardRefExpression(\n      new WrappedNodeExpr(obj[property]),\n      ForwardRefHandling.None,\n    );\n  } else {\n    return undefined;\n  }\n}\n\nfunction wrapExpression(obj: any, property: string): WrappedNodeExpr<any> | undefined {\n  if (obj.hasOwnProperty(property)) {\n    return new WrappedNodeExpr(obj[property]);\n  } else {\n    return undefined;\n  }\n}\n\nfunction computeProvidedIn(\n  providedIn: Function | string | null | undefined,\n): MaybeForwardRefExpression {\n  const expression =\n    typeof providedIn === 'function'\n      ? new WrappedNodeExpr(providedIn)\n      : new LiteralExpr(providedIn ?? null);\n  // See `convertToProviderExpression()` for why this uses `ForwardRefHandling.None`.\n  return createMayBeForwardRefExpression(expression, ForwardRefHandling.None);\n}\n\nfunction convertR3DependencyMetadataArray(\n  facades: R3DependencyMetadataFacade[] | null | undefined,\n): R3DependencyMetadata[] | null {\n  return facades == null ? null : facades.map(convertR3DependencyMetadata);\n}\n\nfunction convertR3DependencyMetadata(facade: R3DependencyMetadataFacade): R3DependencyMetadata {\n  const isAttributeDep = facade.attribute != null; // both `null` and `undefined`\n  const rawToken = facade.token === null ? null : new WrappedNodeExpr(facade.token);\n  // In JIT mode, if the dep is an `@Attribute()` then we use the attribute name given in\n  // `attribute` rather than the `token`.\n  const token = isAttributeDep ? new WrappedNodeExpr(facade.attribute) : rawToken;\n  return createR3DependencyMetadata(\n    token,\n    isAttributeDep,\n    facade.host,\n    facade.optional,\n    facade.self,\n    facade.skipSelf,\n  );\n}\n\nfunction convertR3DeclareDependencyMetadata(\n  facade: R3DeclareDependencyMetadataFacade,\n): R3DependencyMetadata {\n  const isAttributeDep = facade.attribute ?? false;\n  const token = facade.token === null ? null : new WrappedNodeExpr(facade.token);\n  return createR3DependencyMetadata(\n    token,\n    isAttributeDep,\n    facade.host ?? false,\n    facade.optional ?? false,\n    facade.self ?? false,\n    facade.skipSelf ?? false,\n  );\n}\n\nfunction createR3DependencyMetadata(\n  token: WrappedNodeExpr<unknown> | null,\n  isAttributeDep: boolean,\n  host: boolean,\n  optional: boolean,\n  self: boolean,\n  skipSelf: boolean,\n): R3DependencyMetadata {\n  // If the dep is an `@Attribute()` the `attributeNameType` ought to be the `unknown` type.\n  // But types are not available at runtime so we just use a literal `\"<unknown>\"` string as a dummy\n  // marker.\n  const attributeNameType = isAttributeDep ? literal('unknown') : null;\n  return {token, attributeNameType, host, optional, self, skipSelf};\n}\n\nfunction createR3ComponentDeferMetadata(\n  boundTarget: BoundTarget<any>,\n  deferBlockDependencies: (() => Promise<unknown> | null)[] | undefined,\n): R3ComponentDeferMetadata {\n  const deferredBlocks = boundTarget.getDeferBlocks();\n  const blocks = new Map<DeferredBlock, Expression | null>();\n\n  for (let i = 0; i < deferredBlocks.length; i++) {\n    const dependencyFn = deferBlockDependencies?.[i];\n    blocks.set(deferredBlocks[i], dependencyFn ? new WrappedNodeExpr(dependencyFn) : null);\n  }\n\n  return {mode: DeferBlockDepsEmitMode.PerBlock, blocks};\n}\n\nfunction extractHostBindings(\n  propMetadata: {[key: string]: any[]},\n  sourceSpan: ParseSourceSpan,\n  host?: {[key: string]: string},\n): ParsedHostBindings {\n  // First parse the declarations from the metadata.\n  const bindings = parseHostBindings(host || {});\n\n  // After that check host bindings for errors\n  const errors = verifyHostBindings(bindings, sourceSpan);\n  if (errors.length) {\n    throw new Error(errors.map((error: ParseError) => error.msg).join('\\n'));\n  }\n\n  // Next, loop over the properties of the object, looking for @HostBinding and @HostListener.\n  for (const field in propMetadata) {\n    if (propMetadata.hasOwnProperty(field)) {\n      propMetadata[field].forEach((ann) => {\n        if (isHostBinding(ann)) {\n          // Since this is a decorator, we know that the value is a class member. Always access it\n          // through `this` so that further down the line it can't be confused for a literal value\n          // (e.g. if there's a property called `true`).\n          bindings.properties[ann.hostPropertyName || field] = getSafePropertyAccessString(\n            'this',\n            field,\n          );\n        } else if (isHostListener(ann)) {\n          bindings.listeners[ann.eventName || field] = `${field}(${(ann.args || []).join(',')})`;\n        }\n      });\n    }\n  }\n\n  return bindings;\n}\n\nfunction isHostBinding(value: any): value is HostBinding {\n  return value.ngMetadataName === 'HostBinding';\n}\n\nfunction isHostListener(value: any): value is HostListener {\n  return value.ngMetadataName === 'HostListener';\n}\n\nfunction isInput(value: any): value is Input {\n  return value.ngMetadataName === 'Input';\n}\n\nfunction isOutput(value: any): value is Output {\n  return value.ngMetadataName === 'Output';\n}\n\nfunction inputsPartialMetadataToInputMetadata(\n  inputs: NonNullable<R3DeclareDirectiveFacade['inputs']>,\n) {\n  return Object.keys(inputs).reduce<Record<string, R3InputMetadata>>(\n    (result, minifiedClassName) => {\n      const value = inputs[minifiedClassName];\n\n      // Handle legacy partial input output.\n      if (typeof value === 'string' || Array.isArray(value)) {\n        result[minifiedClassName] = parseLegacyInputPartialOutput(value);\n      } else {\n        result[minifiedClassName] = {\n          bindingPropertyName: value.publicName,\n          classPropertyName: minifiedClassName,\n          transformFunction:\n            value.transformFunction !== null ? new WrappedNodeExpr(value.transformFunction) : null,\n          required: value.isRequired,\n          isSignal: value.isSignal,\n        };\n      }\n\n      return result;\n    },\n    {},\n  );\n}\n\n/**\n * Parses the legacy input partial output. For more details see `partial/directive.ts`.\n * TODO(legacy-partial-output-inputs): Remove in v18.\n */\nfunction parseLegacyInputPartialOutput(value: LegacyInputPartialMapping): R3InputMetadata {\n  if (typeof value === 'string') {\n    return {\n      bindingPropertyName: value,\n      classPropertyName: value,\n      transformFunction: null,\n      required: false,\n      // legacy partial output does not capture signal inputs.\n      isSignal: false,\n    };\n  }\n\n  return {\n    bindingPropertyName: value[0],\n    classPropertyName: value[1],\n    transformFunction: value[2] ? new WrappedNodeExpr(value[2]) : null,\n    required: false,\n    // legacy partial output does not capture signal inputs.\n    isSignal: false,\n  };\n}\n\nfunction parseInputsArray(\n  values: (string | {name: string; alias?: string; required?: boolean; transform?: Function})[],\n) {\n  return values.reduce<Record<string, R3InputMetadata>>((results, value) => {\n    if (typeof value === 'string') {\n      const [bindingPropertyName, classPropertyName] = parseMappingString(value);\n      results[classPropertyName] = {\n        bindingPropertyName,\n        classPropertyName,\n        required: false,\n        // Signal inputs not supported for the inputs array.\n        isSignal: false,\n        transformFunction: null,\n      };\n    } else {\n      results[value.name] = {\n        bindingPropertyName: value.alias || value.name,\n        classPropertyName: value.name,\n        required: value.required || false,\n        // Signal inputs not supported for the inputs array.\n        isSignal: false,\n        transformFunction: value.transform != null ? new WrappedNodeExpr(value.transform) : null,\n      };\n    }\n    return results;\n  }, {});\n}\n\nfunction parseMappingStringArray(values: string[]): Record<string, string> {\n  return values.reduce<Record<string, string>>((results, value) => {\n    const [alias, fieldName] = parseMappingString(value);\n    results[fieldName] = alias;\n    return results;\n  }, {});\n}\n\nfunction parseMappingString(value: string): [alias: string, fieldName: string] {\n  // Either the value is 'field' or 'field: property'. In the first case, `property` will\n  // be undefined, in which case the field name should also be used as the property name.\n  const [fieldName, bindingPropertyName] = value.split(':', 2).map((str) => str.trim());\n  return [bindingPropertyName ?? fieldName, fieldName];\n}\n\nfunction convertDeclarePipeFacadeToMetadata(declaration: R3DeclarePipeFacade): R3PipeMetadata {\n  return {\n    name: declaration.type.name,\n    type: wrapReference(declaration.type),\n    typeArgumentCount: 0,\n    pipeName: declaration.name,\n    deps: null,\n    pure: declaration.pure ?? true,\n    isStandalone:\n      declaration.isStandalone ?? getJitStandaloneDefaultForVersion(declaration.version),\n  };\n}\n\nfunction convertDeclareInjectorFacadeToMetadata(\n  declaration: R3DeclareInjectorFacade,\n): R3InjectorMetadata {\n  return {\n    name: declaration.type.name,\n    type: wrapReference(declaration.type),\n    providers:\n      declaration.providers !== undefined && declaration.providers.length > 0\n        ? new WrappedNodeExpr(declaration.providers)\n        : null,\n    imports:\n      declaration.imports !== undefined\n        ? declaration.imports.map((i) => new WrappedNodeExpr(i))\n        : [],\n  };\n}\n\nexport function publishFacade(global: any) {\n  const ng: ExportedCompilerFacade = global.ng || (global.ng = {});\n  ng.ɵcompilerFacade = new CompilerFacadeImpl();\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {MissingTranslationStrategy, ViewEncapsulation} from './core';\nimport {noUndefined} from './util';\n\nexport class CompilerConfig {\n  public defaultEncapsulation: ViewEncapsulation | null;\n  public preserveWhitespaces: boolean;\n  public strictInjectionParameters: boolean;\n\n  constructor({\n    defaultEncapsulation = ViewEncapsulation.Emulated,\n    preserveWhitespaces,\n    strictInjectionParameters,\n  }: {\n    defaultEncapsulation?: ViewEncapsulation;\n    preserveWhitespaces?: boolean;\n    strictInjectionParameters?: boolean;\n  } = {}) {\n    this.defaultEncapsulation = defaultEncapsulation;\n    this.preserveWhitespaces = preserveWhitespacesDefault(noUndefined(preserveWhitespaces));\n    this.strictInjectionParameters = strictInjectionParameters === true;\n  }\n}\n\nexport function preserveWhitespacesDefault(\n  preserveWhitespacesOption: boolean | null,\n  defaultSetting = false,\n): boolean {\n  return preserveWhitespacesOption === null ? defaultSetting : preserveWhitespacesOption;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as html from '../ml_parser/ast';\nimport {DEFAULT_CONTAINER_BLOCKS, InterpolationConfig} from '../ml_parser/defaults';\nimport {ParseTreeResult} from '../ml_parser/parser';\nimport {TokenType} from '../ml_parser/tokens';\nimport {ParseError} from '../parse_util';\n\nimport * as i18n from './i18n_ast';\nimport {createI18nMessageFactory, I18nMessageFactory} from './i18n_parser';\nimport {TranslationBundle} from './translation_bundle';\n\nconst _I18N_ATTR = 'i18n';\nconst _I18N_ATTR_PREFIX = 'i18n-';\nconst _I18N_COMMENT_PREFIX_REGEXP = /^i18n:?/;\nconst MEANING_SEPARATOR = '|';\nconst ID_SEPARATOR = '@@';\nlet i18nCommentsWarned = false;\n\n/**\n * Extract translatable messages from an html AST\n */\nexport function extractMessages(\n  nodes: html.Node[],\n  interpolationConfig: InterpolationConfig,\n  implicitTags: string[],\n  implicitAttrs: {[k: string]: string[]},\n  preserveSignificantWhitespace: boolean,\n): ExtractionResult {\n  const visitor = new _Visitor(implicitTags, implicitAttrs, preserveSignificantWhitespace);\n  return visitor.extract(nodes, interpolationConfig);\n}\n\nexport function mergeTranslations(\n  nodes: html.Node[],\n  translations: TranslationBundle,\n  interpolationConfig: InterpolationConfig,\n  implicitTags: string[],\n  implicitAttrs: {[k: string]: string[]},\n): ParseTreeResult {\n  const visitor = new _Visitor(implicitTags, implicitAttrs);\n  return visitor.merge(nodes, translations, interpolationConfig);\n}\n\nexport class ExtractionResult {\n  constructor(\n    public messages: i18n.Message[],\n    public errors: ParseError[],\n  ) {}\n}\n\nenum _VisitorMode {\n  Extract,\n  Merge,\n}\n\n/**\n * This Visitor is used:\n * 1. to extract all the translatable strings from an html AST (see `extract()`),\n * 2. to replace the translatable strings with the actual translations (see `merge()`)\n *\n * @internal\n */\nclass _Visitor implements html.Visitor {\n  // Using non-null assertions because all variables are (re)set in init()\n\n  private _depth!: number;\n\n  // <el i18n>...</el>\n  private _inI18nNode!: boolean;\n  private _inImplicitNode!: boolean;\n\n  // <!--i18n-->...<!--/i18n-->\n  private _inI18nBlock!: boolean;\n  private _blockMeaningAndDesc!: string;\n  private _blockChildren!: html.Node[];\n  private _blockStartDepth!: number;\n\n  // {<icu message>}\n  private _inIcu!: boolean;\n\n  // set to void 0 when not in a section\n  private _msgCountAtSectionStart: number | undefined;\n  private _errors!: ParseError[];\n  private _mode!: _VisitorMode;\n\n  // _VisitorMode.Extract only\n  private _messages!: i18n.Message[];\n\n  // _VisitorMode.Merge only\n  private _translations!: TranslationBundle;\n  private _createI18nMessage!: I18nMessageFactory;\n\n  constructor(\n    private _implicitTags: string[],\n    private _implicitAttrs: {[k: string]: string[]},\n    private readonly _preserveSignificantWhitespace: boolean = true,\n  ) {}\n\n  /**\n   * Extracts the messages from the tree\n   */\n  extract(nodes: html.Node[], interpolationConfig: InterpolationConfig): ExtractionResult {\n    this._init(_VisitorMode.Extract, interpolationConfig);\n\n    nodes.forEach((node) => node.visit(this, null));\n\n    if (this._inI18nBlock) {\n      this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n    }\n\n    return new ExtractionResult(this._messages, this._errors);\n  }\n\n  /**\n   * Returns a tree where all translatable nodes are translated\n   */\n  merge(\n    nodes: html.Node[],\n    translations: TranslationBundle,\n    interpolationConfig: InterpolationConfig,\n  ): ParseTreeResult {\n    this._init(_VisitorMode.Merge, interpolationConfig);\n    this._translations = translations;\n\n    // Construct a single fake root element\n    const wrapper = new html.Element(\n      'wrapper',\n      [],\n      [],\n      nodes,\n      false,\n      undefined!,\n      undefined!,\n      undefined,\n      false,\n    );\n\n    const translatedNode = wrapper.visit(this, null);\n\n    if (this._inI18nBlock) {\n      this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n    }\n\n    return new ParseTreeResult(translatedNode.children, this._errors);\n  }\n\n  visitExpansionCase(icuCase: html.ExpansionCase, context: any): any {\n    // Parse cases for translatable html attributes\n    const expression = html.visitAll(this, icuCase.expression, context);\n\n    if (this._mode === _VisitorMode.Merge) {\n      return new html.ExpansionCase(\n        icuCase.value,\n        expression,\n        icuCase.sourceSpan,\n        icuCase.valueSourceSpan,\n        icuCase.expSourceSpan,\n      );\n    }\n  }\n\n  visitExpansion(icu: html.Expansion, context: any): html.Expansion {\n    this._mayBeAddBlockChildren(icu);\n\n    const wasInIcu = this._inIcu;\n\n    if (!this._inIcu) {\n      // nested ICU messages should not be extracted but top-level translated as a whole\n      if (this._isInTranslatableSection) {\n        this._addMessage([icu]);\n      }\n      this._inIcu = true;\n    }\n\n    const cases = html.visitAll(this, icu.cases, context);\n\n    if (this._mode === _VisitorMode.Merge) {\n      icu = new html.Expansion(\n        icu.switchValue,\n        icu.type,\n        cases,\n        icu.sourceSpan,\n        icu.switchValueSourceSpan,\n      );\n    }\n\n    this._inIcu = wasInIcu;\n\n    return icu;\n  }\n\n  visitComment(comment: html.Comment, context: any): any {\n    const isOpening = _isOpeningComment(comment);\n\n    if (isOpening && this._isInTranslatableSection) {\n      this._reportError(comment, 'Could not start a block inside a translatable section');\n      return;\n    }\n\n    const isClosing = _isClosingComment(comment);\n\n    if (isClosing && !this._inI18nBlock) {\n      this._reportError(comment, 'Trying to close an unopened block');\n      return;\n    }\n\n    if (!this._inI18nNode && !this._inIcu) {\n      if (!this._inI18nBlock) {\n        if (isOpening) {\n          // deprecated from v5 you should use <ng-container i18n> instead of i18n comments\n          if (!i18nCommentsWarned && <any>console && <any>console.warn) {\n            i18nCommentsWarned = true;\n            const details = comment.sourceSpan.details ? `, ${comment.sourceSpan.details}` : '';\n            // TODO(ocombe): use a log service once there is a public one available\n            console.warn(\n              `I18n comments are deprecated, use an <ng-container> element instead (${comment.sourceSpan.start}${details})`,\n            );\n          }\n          this._inI18nBlock = true;\n          this._blockStartDepth = this._depth;\n          this._blockChildren = [];\n          this._blockMeaningAndDesc = comment\n            .value!.replace(_I18N_COMMENT_PREFIX_REGEXP, '')\n            .trim();\n          this._openTranslatableSection(comment);\n        }\n      } else {\n        if (isClosing) {\n          if (this._depth == this._blockStartDepth) {\n            this._closeTranslatableSection(comment, this._blockChildren);\n            this._inI18nBlock = false;\n            const message = this._addMessage(this._blockChildren, this._blockMeaningAndDesc)!;\n            // merge attributes in sections\n            const nodes = this._translateMessage(comment, message);\n            return html.visitAll(this, nodes);\n          } else {\n            this._reportError(comment, 'I18N blocks should not cross element boundaries');\n            return;\n          }\n        }\n      }\n    }\n  }\n\n  visitText(text: html.Text, context: any): html.Text {\n    if (this._isInTranslatableSection) {\n      this._mayBeAddBlockChildren(text);\n    }\n    return text;\n  }\n\n  visitElement(el: html.Element, context: any): html.Element | null {\n    return this._visitElementLike(el, context);\n  }\n\n  visitAttribute(attribute: html.Attribute, context: any): any {\n    throw new Error('unreachable code');\n  }\n\n  visitBlock(block: html.Block, context: any) {\n    html.visitAll(this, block.children, context);\n  }\n\n  visitBlockParameter(parameter: html.BlockParameter, context: any) {}\n\n  visitLetDeclaration(decl: html.LetDeclaration, context: any) {}\n\n  visitComponent(component: html.Component, context: any): html.Component | null {\n    return this._visitElementLike(component, context);\n  }\n\n  visitDirective(directive: html.Directive, context: any) {\n    throw new Error('unreachable code');\n  }\n\n  private _init(mode: _VisitorMode, interpolationConfig: InterpolationConfig): void {\n    this._mode = mode;\n    this._inI18nBlock = false;\n    this._inI18nNode = false;\n    this._depth = 0;\n    this._inIcu = false;\n    this._msgCountAtSectionStart = undefined;\n    this._errors = [];\n    this._messages = [];\n    this._inImplicitNode = false;\n    this._createI18nMessage = createI18nMessageFactory(\n      interpolationConfig,\n      DEFAULT_CONTAINER_BLOCKS,\n      // When dropping significant whitespace we need to retain whitespace tokens or\n      // else we won't be able to reuse source spans because empty tokens would be\n      // removed and cause a mismatch.\n      /* retainEmptyTokens */ !this._preserveSignificantWhitespace,\n      /* preserveExpressionWhitespace */ this._preserveSignificantWhitespace,\n    );\n  }\n\n  private _visitElementLike<T extends html.Element | html.Component>(\n    node: T,\n    context: any,\n  ): T | null {\n    this._mayBeAddBlockChildren(node);\n    this._depth++;\n    const wasInI18nNode = this._inI18nNode;\n    const wasInImplicitNode = this._inImplicitNode;\n    let childNodes: html.Node[] = [];\n    let translatedChildNodes: html.Node[] = undefined!;\n\n    // Extract:\n    // - top level nodes with the (implicit) \"i18n\" attribute if not already in a section\n    // - ICU messages\n    const nodeName = node instanceof html.Component ? node.tagName : node.name;\n    const i18nAttr = _getI18nAttr(node);\n    const i18nMeta = i18nAttr ? i18nAttr.value : '';\n    const isImplicit =\n      this._implicitTags.some((tag) => nodeName === tag) &&\n      !this._inIcu &&\n      !this._isInTranslatableSection;\n    const isTopLevelImplicit = !wasInImplicitNode && isImplicit;\n    this._inImplicitNode = wasInImplicitNode || isImplicit;\n\n    if (!this._isInTranslatableSection && !this._inIcu) {\n      if (i18nAttr || isTopLevelImplicit) {\n        this._inI18nNode = true;\n        const message = this._addMessage(node.children, i18nMeta)!;\n        translatedChildNodes = this._translateMessage(node, message);\n      }\n\n      if (this._mode == _VisitorMode.Extract) {\n        const isTranslatable = i18nAttr || isTopLevelImplicit;\n        if (isTranslatable) this._openTranslatableSection(node);\n        html.visitAll(this, node.children);\n        if (isTranslatable) this._closeTranslatableSection(node, node.children);\n      }\n    } else {\n      if (i18nAttr || isTopLevelImplicit) {\n        this._reportError(\n          node,\n          'Could not mark an element as translatable inside a translatable section',\n        );\n      }\n\n      if (this._mode == _VisitorMode.Extract) {\n        // Descend into child nodes for extraction\n        html.visitAll(this, node.children);\n      }\n    }\n\n    if (this._mode === _VisitorMode.Merge) {\n      const visitNodes = translatedChildNodes || node.children;\n      visitNodes.forEach((child) => {\n        const visited = child.visit(this, context);\n        if (visited && !this._isInTranslatableSection) {\n          // Do not add the children from translatable sections (= i18n blocks here)\n          // They will be added later in this loop when the block closes (i.e. on `<!-- /i18n -->`)\n          childNodes = childNodes.concat(visited);\n        }\n      });\n    }\n\n    this._visitAttributesOf(node);\n\n    this._depth--;\n    this._inI18nNode = wasInI18nNode;\n    this._inImplicitNode = wasInImplicitNode;\n\n    if (this._mode === _VisitorMode.Merge) {\n      if (node instanceof html.Element) {\n        return new html.Element(\n          node.name,\n          this._translateAttributes(node),\n          this._translateDirectives(node),\n          childNodes,\n          node.isSelfClosing,\n          node.sourceSpan,\n          node.startSourceSpan,\n          node.endSourceSpan,\n          node.isVoid,\n        ) as T;\n      } else {\n        return new html.Component(\n          node.componentName,\n          node.tagName,\n          node.fullName,\n          this._translateAttributes(node),\n          this._translateDirectives(node),\n          childNodes,\n          node.isSelfClosing,\n          node.sourceSpan,\n          node.startSourceSpan,\n          node.endSourceSpan,\n        ) as T;\n      }\n    }\n    return null;\n  }\n\n  // looks for translatable attributes\n  private _visitAttributesOf(el: html.Element | html.Component): void {\n    const explicitAttrNameToValue: {[k: string]: string} = {};\n    const implicitAttrNames: string[] =\n      this._implicitAttrs[el instanceof html.Component ? el.tagName || '' : el.name] || [];\n\n    el.attrs\n      .filter((attr) => attr instanceof html.Attribute && attr.name.startsWith(_I18N_ATTR_PREFIX))\n      .forEach((attr) => {\n        explicitAttrNameToValue[attr.name.slice(_I18N_ATTR_PREFIX.length)] = (\n          attr as html.Attribute\n        ).value;\n      });\n\n    el.attrs.forEach((attr) => {\n      if (attr.name in explicitAttrNameToValue) {\n        this._addMessage([attr], explicitAttrNameToValue[attr.name]);\n      } else if (implicitAttrNames.some((name) => attr.name === name)) {\n        this._addMessage([attr]);\n      }\n    });\n  }\n\n  // add a translatable message\n  private _addMessage(ast: html.Node[], msgMeta?: string): i18n.Message | null {\n    if (\n      ast.length == 0 ||\n      this._isEmptyAttributeValue(ast) ||\n      this._isPlaceholderOnlyAttributeValue(ast) ||\n      this._isPlaceholderOnlyMessage(ast)\n    ) {\n      // Do not create empty messages\n      return null;\n    }\n\n    const {meaning, description, id} = _parseMessageMeta(msgMeta);\n    const message = this._createI18nMessage(ast, meaning, description, id);\n    this._messages.push(message);\n    return message;\n  }\n\n  // Check for cases like `<div i18n-title title=\"\">`.\n  private _isEmptyAttributeValue(ast: html.Node[]): boolean {\n    if (!isAttrNode(ast)) return false;\n    const node = ast[0];\n\n    return node.value.trim() === '';\n  }\n\n  // Check for cases like `<div i18n-title title=\"{{ name }}\">`.\n  private _isPlaceholderOnlyAttributeValue(ast: html.Node[]): boolean {\n    if (!isAttrNode(ast)) return false;\n    const tokens = ast[0].valueTokens ?? [];\n\n    const interpolations = tokens.filter(\n      (token) => token.type === TokenType.ATTR_VALUE_INTERPOLATION,\n    );\n    const plainText = tokens\n      .filter((token) => token.type === TokenType.ATTR_VALUE_TEXT)\n      // `AttributeValueTextToken` always has exactly one part per its type.\n      .map((token) => token.parts[0].trim())\n      .join('');\n\n    // Check if there is a single interpolation and all text around it is empty.\n    return interpolations.length === 1 && plainText === '';\n  }\n\n  // Check for cases like `<div i18n>{{ name }}</div>`.\n  private _isPlaceholderOnlyMessage(ast: html.Node[]): boolean {\n    if (!isTextNode(ast)) return false;\n    const tokens = ast[0].tokens;\n\n    const interpolations = tokens.filter((token) => token.type === TokenType.INTERPOLATION);\n    const plainText = tokens\n      .filter((token) => token.type === TokenType.TEXT)\n      // `TextToken` always has exactly one part per its type.\n      .map((token) => token.parts[0].trim())\n      .join('');\n\n    // Check if there is a single interpolation and all text around it is empty.\n    return interpolations.length === 1 && plainText === '';\n  }\n\n  // Translates the given message given the `TranslationBundle`\n  // This is used for translating elements / blocks - see `_translateAttributes` for attributes\n  // no-op when called in extraction mode (returns [])\n  private _translateMessage(el: html.Node, message: i18n.Message): html.Node[] {\n    if (message && this._mode === _VisitorMode.Merge) {\n      const nodes = this._translations.get(message);\n\n      if (nodes) {\n        return nodes;\n      }\n\n      this._reportError(\n        el,\n        `Translation unavailable for message id=\"${this._translations.digest(message)}\"`,\n      );\n    }\n\n    return [];\n  }\n\n  // translate the attributes of an element and remove i18n specific attributes\n  private _translateAttributes(\n    node: html.Element | html.Component | html.Directive,\n  ): html.Attribute[] {\n    const i18nParsedMessageMeta: {\n      [name: string]: {meaning: string; description: string; id: string};\n    } = {};\n    const translatedAttributes: html.Attribute[] = [];\n\n    node.attrs.forEach((attr) => {\n      if (attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n        i18nParsedMessageMeta[attr.name.slice(_I18N_ATTR_PREFIX.length)] = _parseMessageMeta(\n          attr.value,\n        );\n      }\n    });\n\n    node.attrs.forEach((attr) => {\n      if (attr.name === _I18N_ATTR || attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n        // strip i18n specific attributes\n        return;\n      }\n\n      if (attr.value && attr.value != '' && i18nParsedMessageMeta.hasOwnProperty(attr.name)) {\n        const {meaning, description, id} = i18nParsedMessageMeta[attr.name];\n        const message: i18n.Message = this._createI18nMessage([attr], meaning, description, id);\n        const nodes = this._translations.get(message);\n        if (nodes) {\n          if (nodes.length == 0) {\n            translatedAttributes.push(\n              new html.Attribute(\n                attr.name,\n                '',\n                attr.sourceSpan,\n                undefined /* keySpan */,\n                undefined /* valueSpan */,\n                undefined /* valueTokens */,\n                undefined /* i18n */,\n              ),\n            );\n          } else if (nodes[0] instanceof html.Text) {\n            const value = (nodes[0] as html.Text).value;\n            translatedAttributes.push(\n              new html.Attribute(\n                attr.name,\n                value,\n                attr.sourceSpan,\n                undefined /* keySpan */,\n                undefined /* valueSpan */,\n                undefined /* valueTokens */,\n                undefined /* i18n */,\n              ),\n            );\n          } else {\n            this._reportError(\n              node,\n              `Unexpected translation for attribute \"${attr.name}\" (id=\"${\n                id || this._translations.digest(message)\n              }\")`,\n            );\n          }\n        } else {\n          this._reportError(\n            node,\n            `Translation unavailable for attribute \"${attr.name}\" (id=\"${\n              id || this._translations.digest(message)\n            }\")`,\n          );\n        }\n      } else {\n        translatedAttributes.push(attr);\n      }\n    });\n\n    return translatedAttributes;\n  }\n\n  private _translateDirectives(node: html.Element | html.Component): html.Directive[] {\n    return node.directives.map(\n      (dir) =>\n        new html.Directive(\n          dir.name,\n          this._translateAttributes(dir),\n          dir.sourceSpan,\n          dir.startSourceSpan,\n          dir.endSourceSpan,\n        ),\n    );\n  }\n\n  /**\n   * Add the node as a child of the block when:\n   * - we are in a block,\n   * - we are not inside a ICU message (those are handled separately),\n   * - the node is a \"direct child\" of the block\n   */\n  private _mayBeAddBlockChildren(node: html.Node): void {\n    if (this._inI18nBlock && !this._inIcu && this._depth == this._blockStartDepth) {\n      this._blockChildren.push(node);\n    }\n  }\n\n  /**\n   * Marks the start of a section, see `_closeTranslatableSection`\n   */\n  private _openTranslatableSection(node: html.Node): void {\n    if (this._isInTranslatableSection) {\n      this._reportError(node, 'Unexpected section start');\n    } else {\n      this._msgCountAtSectionStart = this._messages.length;\n    }\n  }\n\n  /**\n   * A translatable section could be:\n   * - the content of translatable element,\n   * - nodes between `<!-- i18n -->` and `<!-- /i18n -->` comments\n   */\n  private get _isInTranslatableSection(): boolean {\n    return this._msgCountAtSectionStart !== void 0;\n  }\n\n  /**\n   * Terminates a section.\n   *\n   * If a section has only one significant children (comments not significant) then we should not\n   * keep the message from this children:\n   *\n   * `<p i18n=\"meaning|description\">{ICU message}</p>` would produce two messages:\n   * - one for the <p> content with meaning and description,\n   * - another one for the ICU message.\n   *\n   * In this case the last message is discarded as it contains less information (the AST is\n   * otherwise identical).\n   *\n   * Note that we should still keep messages extracted from attributes inside the section (ie in the\n   * ICU message here)\n   */\n  private _closeTranslatableSection(node: html.Node, directChildren: html.Node[]): void {\n    if (!this._isInTranslatableSection) {\n      this._reportError(node, 'Unexpected section end');\n      return;\n    }\n\n    const startIndex = this._msgCountAtSectionStart;\n    const significantChildren: number = directChildren.reduce(\n      (count: number, node: html.Node): number => count + (node instanceof html.Comment ? 0 : 1),\n      0,\n    );\n\n    if (significantChildren == 1) {\n      for (let i = this._messages.length - 1; i >= startIndex!; i--) {\n        const ast = this._messages[i].nodes;\n        if (!(ast.length == 1 && ast[0] instanceof i18n.Text)) {\n          this._messages.splice(i, 1);\n          break;\n        }\n      }\n    }\n\n    this._msgCountAtSectionStart = undefined;\n  }\n\n  private _reportError(node: html.Node, msg: string): void {\n    this._errors.push(new ParseError(node.sourceSpan, msg));\n  }\n}\n\nfunction _isOpeningComment(n: html.Node): boolean {\n  return !!(n instanceof html.Comment && n.value && n.value.startsWith('i18n'));\n}\n\nfunction _isClosingComment(n: html.Node): boolean {\n  return !!(n instanceof html.Comment && n.value && n.value === '/i18n');\n}\n\nfunction _getI18nAttr(p: html.Element | html.Component): html.Attribute | null {\n  return (\n    (p.attrs.find((attr) => attr instanceof html.Attribute && attr.name === _I18N_ATTR) as\n      | html.Attribute\n      | undefined) || null\n  );\n}\n\nfunction _parseMessageMeta(i18n?: string): {meaning: string; description: string; id: string} {\n  if (!i18n) return {meaning: '', description: '', id: ''};\n\n  const idIndex = i18n.indexOf(ID_SEPARATOR);\n  const descIndex = i18n.indexOf(MEANING_SEPARATOR);\n  const [meaningAndDesc, id] =\n    idIndex > -1 ? [i18n.slice(0, idIndex), i18n.slice(idIndex + 2)] : [i18n, ''];\n  const [meaning, description] =\n    descIndex > -1\n      ? [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)]\n      : ['', meaningAndDesc];\n\n  return {meaning, description, id: id.trim()};\n}\n\nfunction isTextNode(ast: html.Node[]): ast is [html.Text] {\n  return ast.length === 1 && ast[0] instanceof html.Text;\n}\n\nfunction isAttrNode(ast: html.Node[]): ast is [html.Attribute] {\n  return ast.length === 1 && ast[0] instanceof html.Attribute;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {TagContentType, TagDefinition} from './tags';\n\nexport class XmlTagDefinition implements TagDefinition {\n  closedByParent: boolean = false;\n  implicitNamespacePrefix: string | null = null;\n  isVoid: boolean = false;\n  ignoreFirstLf: boolean = false;\n  canSelfClose: boolean = true;\n  preventNamespaceInheritance: boolean = false;\n\n  requireExtraParent(currentParent: string): boolean {\n    return false;\n  }\n\n  isClosedByChild(name: string): boolean {\n    return false;\n  }\n\n  getContentType(): TagContentType {\n    return TagContentType.PARSABLE_DATA;\n  }\n}\n\nconst _TAG_DEFINITION = new XmlTagDefinition();\n\nexport function getXmlTagDefinition(tagName: string): XmlTagDefinition {\n  return _TAG_DEFINITION;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {TokenizeOptions} from './lexer';\nimport {Parser, ParseTreeResult} from './parser';\nimport {getXmlTagDefinition} from './xml_tags';\n\nexport class XmlParser extends Parser {\n  constructor() {\n    super(getXmlTagDefinition);\n  }\n\n  override parse(source: string, url: string, options: TokenizeOptions = {}): ParseTreeResult {\n    // Blocks and let declarations aren't supported in an XML context.\n    return super.parse(source, url, {\n      ...options,\n      tokenizeBlocks: false,\n      tokenizeLet: false,\n      selectorlessEnabled: false,\n    });\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as ml from '../../ml_parser/ast';\nimport {XmlParser} from '../../ml_parser/xml_parser';\nimport {ParseError} from '../../parse_util';\nimport {digest} from '../digest';\nimport * as i18n from '../i18n_ast';\n\nimport {Serializer} from './serializer';\nimport * as xml from './xml_helper';\n\nconst _VERSION = '1.2';\nconst _XMLNS = 'urn:oasis:names:tc:xliff:document:1.2';\n// TODO(vicb): make this a param (s/_/-/)\nconst _DEFAULT_SOURCE_LANG = 'en';\nconst _PLACEHOLDER_TAG = 'x';\nconst _MARKER_TAG = 'mrk';\n\nconst _FILE_TAG = 'file';\nconst _SOURCE_TAG = 'source';\nconst _SEGMENT_SOURCE_TAG = 'seg-source';\nconst _ALT_TRANS_TAG = 'alt-trans';\nconst _TARGET_TAG = 'target';\nconst _UNIT_TAG = 'trans-unit';\nconst _CONTEXT_GROUP_TAG = 'context-group';\nconst _CONTEXT_TAG = 'context';\n\n// https://docs.oasis-open.org/xliff/v1.2/os/xliff-core.html\n// https://docs.oasis-open.org/xliff/v1.2/xliff-profile-html/xliff-profile-html-1.2.html\nexport class Xliff extends Serializer {\n  override write(messages: i18n.Message[], locale: string | null): string {\n    const visitor = new _WriteVisitor();\n    const transUnits: xml.Node[] = [];\n\n    messages.forEach((message) => {\n      let contextTags: xml.Node[] = [];\n      message.sources.forEach((source: i18n.MessageSpan) => {\n        let contextGroupTag = new xml.Tag(_CONTEXT_GROUP_TAG, {purpose: 'location'});\n        contextGroupTag.children.push(\n          new xml.CR(10),\n          new xml.Tag(_CONTEXT_TAG, {'context-type': 'sourcefile'}, [\n            new xml.Text(source.filePath),\n          ]),\n          new xml.CR(10),\n          new xml.Tag(_CONTEXT_TAG, {'context-type': 'linenumber'}, [\n            new xml.Text(`${source.startLine}`),\n          ]),\n          new xml.CR(8),\n        );\n        contextTags.push(new xml.CR(8), contextGroupTag);\n      });\n\n      const transUnit = new xml.Tag(_UNIT_TAG, {id: message.id, datatype: 'html'});\n      transUnit.children.push(\n        new xml.CR(8),\n        new xml.Tag(_SOURCE_TAG, {}, visitor.serialize(message.nodes)),\n        ...contextTags,\n      );\n\n      if (message.description) {\n        transUnit.children.push(\n          new xml.CR(8),\n          new xml.Tag('note', {priority: '1', from: 'description'}, [\n            new xml.Text(message.description),\n          ]),\n        );\n      }\n\n      if (message.meaning) {\n        transUnit.children.push(\n          new xml.CR(8),\n          new xml.Tag('note', {priority: '1', from: 'meaning'}, [new xml.Text(message.meaning)]),\n        );\n      }\n\n      transUnit.children.push(new xml.CR(6));\n\n      transUnits.push(new xml.CR(6), transUnit);\n    });\n\n    const body = new xml.Tag('body', {}, [...transUnits, new xml.CR(4)]);\n    const file = new xml.Tag(\n      'file',\n      {\n        'source-language': locale || _DEFAULT_SOURCE_LANG,\n        datatype: 'plaintext',\n        original: 'ng2.template',\n      },\n      [new xml.CR(4), body, new xml.CR(2)],\n    );\n    const xliff = new xml.Tag('xliff', {version: _VERSION, xmlns: _XMLNS}, [\n      new xml.CR(2),\n      file,\n      new xml.CR(),\n    ]);\n\n    return xml.serialize([\n      new xml.Declaration({version: '1.0', encoding: 'UTF-8'}),\n      new xml.CR(),\n      xliff,\n      new xml.CR(),\n    ]);\n  }\n\n  override load(\n    content: string,\n    url: string,\n  ): {locale: string; i18nNodesByMsgId: {[msgId: string]: i18n.Node[]}} {\n    // xliff to xml nodes\n    const xliffParser = new XliffParser();\n    const {locale, msgIdToHtml, errors} = xliffParser.parse(content, url);\n\n    // xml nodes to i18n nodes\n    const i18nNodesByMsgId: {[msgId: string]: i18n.Node[]} = {};\n    const converter = new XmlToI18n();\n\n    Object.keys(msgIdToHtml).forEach((msgId) => {\n      const {i18nNodes, errors: e} = converter.convert(msgIdToHtml[msgId], url);\n      errors.push(...e);\n      i18nNodesByMsgId[msgId] = i18nNodes;\n    });\n\n    if (errors.length) {\n      throw new Error(`xliff parse errors:\\n${errors.join('\\n')}`);\n    }\n\n    return {locale: locale!, i18nNodesByMsgId};\n  }\n\n  override digest(message: i18n.Message): string {\n    return digest(message);\n  }\n}\n\nclass _WriteVisitor implements i18n.Visitor {\n  visitText(text: i18n.Text, context?: any): xml.Node[] {\n    return [new xml.Text(text.value)];\n  }\n\n  visitContainer(container: i18n.Container, context?: any): xml.Node[] {\n    const nodes: xml.Node[] = [];\n    container.children.forEach((node: i18n.Node) => nodes.push(...node.visit(this)));\n    return nodes;\n  }\n\n  visitIcu(icu: i18n.Icu, context?: any): xml.Node[] {\n    const nodes = [new xml.Text(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n\n    Object.keys(icu.cases).forEach((c: string) => {\n      nodes.push(new xml.Text(`${c} {`), ...icu.cases[c].visit(this), new xml.Text(`} `));\n    });\n\n    nodes.push(new xml.Text(`}`));\n\n    return nodes;\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context?: any): xml.Node[] {\n    const ctype = getCtypeForTag(ph.tag);\n\n    if (ph.isVoid) {\n      // void tags have no children nor closing tags\n      return [\n        new xml.Tag(_PLACEHOLDER_TAG, {id: ph.startName, ctype, 'equiv-text': `<${ph.tag}/>`}),\n      ];\n    }\n\n    const startTagPh = new xml.Tag(_PLACEHOLDER_TAG, {\n      id: ph.startName,\n      ctype,\n      'equiv-text': `<${ph.tag}>`,\n    });\n    const closeTagPh = new xml.Tag(_PLACEHOLDER_TAG, {\n      id: ph.closeName,\n      ctype,\n      'equiv-text': `</${ph.tag}>`,\n    });\n\n    return [startTagPh, ...this.serialize(ph.children), closeTagPh];\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context?: any): xml.Node[] {\n    return [new xml.Tag(_PLACEHOLDER_TAG, {id: ph.name, 'equiv-text': `{{${ph.value}}}`})];\n  }\n\n  visitBlockPlaceholder(ph: i18n.BlockPlaceholder, context?: any): xml.Node[] {\n    const ctype = `x-${ph.name.toLowerCase().replace(/[^a-z0-9]/g, '-')}`;\n    const startTagPh = new xml.Tag(_PLACEHOLDER_TAG, {\n      id: ph.startName,\n      ctype,\n      'equiv-text': `@${ph.name}`,\n    });\n    const closeTagPh = new xml.Tag(_PLACEHOLDER_TAG, {id: ph.closeName, ctype, 'equiv-text': `}`});\n\n    return [startTagPh, ...this.serialize(ph.children), closeTagPh];\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): xml.Node[] {\n    const equivText = `{${ph.value.expression}, ${ph.value.type}, ${Object.keys(ph.value.cases)\n      .map((value: string) => value + ' {...}')\n      .join(' ')}}`;\n    return [new xml.Tag(_PLACEHOLDER_TAG, {id: ph.name, 'equiv-text': equivText})];\n  }\n\n  serialize(nodes: i18n.Node[]): xml.Node[] {\n    return [].concat(...nodes.map((node) => node.visit(this)));\n  }\n}\n\n// TODO(vicb): add error management (structure)\n// Extract messages as xml nodes from the xliff file\nclass XliffParser implements ml.Visitor {\n  // using non-null assertions because they're re(set) by parse()\n  private _unitMlString!: string | null;\n  private _errors!: ParseError[];\n  private _msgIdToHtml!: {[msgId: string]: string};\n  private _locale: string | null = null;\n\n  parse(xliff: string, url: string) {\n    this._unitMlString = null;\n    this._msgIdToHtml = {};\n\n    const xml = new XmlParser().parse(xliff, url);\n\n    this._errors = xml.errors;\n    ml.visitAll(this, xml.rootNodes, null);\n\n    return {\n      msgIdToHtml: this._msgIdToHtml,\n      errors: this._errors,\n      locale: this._locale,\n    };\n  }\n\n  visitElement(element: ml.Element, context: any): any {\n    switch (element.name) {\n      case _UNIT_TAG:\n        this._unitMlString = null!;\n        const idAttr = element.attrs.find((attr) => attr.name === 'id');\n        if (!idAttr) {\n          this._addError(element, `<${_UNIT_TAG}> misses the \"id\" attribute`);\n        } else {\n          const id = idAttr.value;\n          if (this._msgIdToHtml.hasOwnProperty(id)) {\n            this._addError(element, `Duplicated translations for msg ${id}`);\n          } else {\n            ml.visitAll(this, element.children, null);\n            if (typeof this._unitMlString === 'string') {\n              this._msgIdToHtml[id] = this._unitMlString;\n            } else {\n              this._addError(element, `Message ${id} misses a translation`);\n            }\n          }\n        }\n        break;\n\n      // ignore those tags\n      case _SOURCE_TAG:\n      case _SEGMENT_SOURCE_TAG:\n      case _ALT_TRANS_TAG:\n        break;\n\n      case _TARGET_TAG:\n        const innerTextStart = element.startSourceSpan.end.offset;\n        const innerTextEnd = element.endSourceSpan!.start.offset;\n        const content = element.startSourceSpan.start.file.content;\n        const innerText = content.slice(innerTextStart, innerTextEnd);\n        this._unitMlString = innerText;\n        break;\n\n      case _FILE_TAG:\n        const localeAttr = element.attrs.find((attr) => attr.name === 'target-language');\n        if (localeAttr) {\n          this._locale = localeAttr.value;\n        }\n        ml.visitAll(this, element.children, null);\n        break;\n\n      default:\n        // TODO(vicb): assert file structure, xliff version\n        // For now only recurse on unhandled nodes\n        ml.visitAll(this, element.children, null);\n    }\n  }\n\n  visitAttribute(attribute: ml.Attribute, context: any): any {}\n\n  visitText(text: ml.Text, context: any): any {}\n\n  visitComment(comment: ml.Comment, context: any): any {}\n\n  visitExpansion(expansion: ml.Expansion, context: any): any {}\n\n  visitExpansionCase(expansionCase: ml.ExpansionCase, context: any): any {}\n\n  visitBlock(block: ml.Block, context: any) {}\n\n  visitBlockParameter(parameter: ml.BlockParameter, context: any) {}\n\n  visitLetDeclaration(decl: ml.LetDeclaration, context: any) {}\n\n  visitComponent(component: ml.Component, context: any) {}\n\n  visitDirective(directive: ml.Directive, context: any) {}\n\n  private _addError(node: ml.Node, message: string): void {\n    this._errors.push(new ParseError(node.sourceSpan, message));\n  }\n}\n\n// Convert ml nodes (xliff syntax) to i18n nodes\nclass XmlToI18n implements ml.Visitor {\n  // using non-null assertion because it's re(set) by convert()\n  private _errors!: ParseError[];\n\n  convert(message: string, url: string) {\n    const xmlIcu = new XmlParser().parse(message, url, {tokenizeExpansionForms: true});\n    this._errors = xmlIcu.errors;\n\n    const i18nNodes =\n      this._errors.length > 0 || xmlIcu.rootNodes.length == 0\n        ? []\n        : [].concat(...ml.visitAll(this, xmlIcu.rootNodes));\n\n    return {\n      i18nNodes: i18nNodes,\n      errors: this._errors,\n    };\n  }\n\n  visitText(text: ml.Text, context: any) {\n    return new i18n.Text(text.value, text.sourceSpan);\n  }\n\n  visitElement(el: ml.Element, context: any): i18n.Placeholder | ml.Node[] | null {\n    if (el.name === _PLACEHOLDER_TAG) {\n      const nameAttr = el.attrs.find((attr) => attr.name === 'id');\n      if (nameAttr) {\n        return new i18n.Placeholder('', nameAttr.value, el.sourceSpan);\n      }\n\n      this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"id\" attribute`);\n      return null;\n    }\n\n    if (el.name === _MARKER_TAG) {\n      return [].concat(...ml.visitAll(this, el.children));\n    }\n\n    this._addError(el, `Unexpected tag`);\n    return null;\n  }\n\n  visitExpansion(icu: ml.Expansion, context: any) {\n    const caseMap: {[value: string]: i18n.Node} = {};\n\n    ml.visitAll(this, icu.cases).forEach((c: any) => {\n      caseMap[c.value] = new i18n.Container(c.nodes, icu.sourceSpan);\n    });\n\n    return new i18n.Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n  }\n\n  visitExpansionCase(icuCase: ml.ExpansionCase, context: any): any {\n    return {\n      value: icuCase.value,\n      nodes: ml.visitAll(this, icuCase.expression),\n    };\n  }\n\n  visitComment(comment: ml.Comment, context: any) {}\n\n  visitAttribute(attribute: ml.Attribute, context: any) {}\n\n  visitBlock(block: ml.Block, context: any) {}\n\n  visitBlockParameter(parameter: ml.BlockParameter, context: any) {}\n\n  visitLetDeclaration(decl: ml.LetDeclaration, context: any) {}\n\n  visitComponent(component: ml.Component, context: any) {\n    this._addError(component, 'Unexpected node');\n  }\n\n  visitDirective(directive: ml.Directive, context: any) {\n    this._addError(directive, 'Unexpected node');\n  }\n\n  private _addError(node: ml.Node, message: string): void {\n    this._errors.push(new ParseError(node.sourceSpan, message));\n  }\n}\n\nfunction getCtypeForTag(tag: string): string {\n  switch (tag.toLowerCase()) {\n    case 'br':\n      return 'lb';\n    case 'img':\n      return 'image';\n    default:\n      return `x-${tag}`;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as ml from '../../ml_parser/ast';\nimport {XmlParser} from '../../ml_parser/xml_parser';\nimport {ParseError} from '../../parse_util';\nimport {decimalDigest} from '../digest';\nimport * as i18n from '../i18n_ast';\n\nimport {Serializer} from './serializer';\nimport * as xml from './xml_helper';\n\nconst _VERSION = '2.0';\nconst _XMLNS = 'urn:oasis:names:tc:xliff:document:2.0';\n// TODO(vicb): make this a param (s/_/-/)\nconst _DEFAULT_SOURCE_LANG = 'en';\nconst _PLACEHOLDER_TAG = 'ph';\nconst _PLACEHOLDER_SPANNING_TAG = 'pc';\nconst _MARKER_TAG = 'mrk';\n\nconst _XLIFF_TAG = 'xliff';\nconst _SOURCE_TAG = 'source';\nconst _TARGET_TAG = 'target';\nconst _UNIT_TAG = 'unit';\n\n// https://docs.oasis-open.org/xliff/xliff-core/v2.0/os/xliff-core-v2.0-os.html\nexport class Xliff2 extends Serializer {\n  override write(messages: i18n.Message[], locale: string | null): string {\n    const visitor = new _WriteVisitor();\n    const units: xml.Node[] = [];\n\n    messages.forEach((message) => {\n      const unit = new xml.Tag(_UNIT_TAG, {id: message.id});\n      const notes = new xml.Tag('notes');\n\n      if (message.description || message.meaning) {\n        if (message.description) {\n          notes.children.push(\n            new xml.CR(8),\n            new xml.Tag('note', {category: 'description'}, [new xml.Text(message.description)]),\n          );\n        }\n\n        if (message.meaning) {\n          notes.children.push(\n            new xml.CR(8),\n            new xml.Tag('note', {category: 'meaning'}, [new xml.Text(message.meaning)]),\n          );\n        }\n      }\n\n      message.sources.forEach((source: i18n.MessageSpan) => {\n        notes.children.push(\n          new xml.CR(8),\n          new xml.Tag('note', {category: 'location'}, [\n            new xml.Text(\n              `${source.filePath}:${source.startLine}${\n                source.endLine !== source.startLine ? ',' + source.endLine : ''\n              }`,\n            ),\n          ]),\n        );\n      });\n\n      notes.children.push(new xml.CR(6));\n      unit.children.push(new xml.CR(6), notes);\n\n      const segment = new xml.Tag('segment');\n\n      segment.children.push(\n        new xml.CR(8),\n        new xml.Tag(_SOURCE_TAG, {}, visitor.serialize(message.nodes)),\n        new xml.CR(6),\n      );\n\n      unit.children.push(new xml.CR(6), segment, new xml.CR(4));\n\n      units.push(new xml.CR(4), unit);\n    });\n\n    const file = new xml.Tag('file', {'original': 'ng.template', id: 'ngi18n'}, [\n      ...units,\n      new xml.CR(2),\n    ]);\n\n    const xliff = new xml.Tag(\n      _XLIFF_TAG,\n      {version: _VERSION, xmlns: _XMLNS, srcLang: locale || _DEFAULT_SOURCE_LANG},\n      [new xml.CR(2), file, new xml.CR()],\n    );\n\n    return xml.serialize([\n      new xml.Declaration({version: '1.0', encoding: 'UTF-8'}),\n      new xml.CR(),\n      xliff,\n      new xml.CR(),\n    ]);\n  }\n\n  override load(\n    content: string,\n    url: string,\n  ): {locale: string; i18nNodesByMsgId: {[msgId: string]: i18n.Node[]}} {\n    // xliff to xml nodes\n    const xliff2Parser = new Xliff2Parser();\n    const {locale, msgIdToHtml, errors} = xliff2Parser.parse(content, url);\n\n    // xml nodes to i18n nodes\n    const i18nNodesByMsgId: {[msgId: string]: i18n.Node[]} = {};\n    const converter = new XmlToI18n();\n\n    Object.keys(msgIdToHtml).forEach((msgId) => {\n      const {i18nNodes, errors: e} = converter.convert(msgIdToHtml[msgId], url);\n      errors.push(...e);\n      i18nNodesByMsgId[msgId] = i18nNodes;\n    });\n\n    if (errors.length) {\n      throw new Error(`xliff2 parse errors:\\n${errors.join('\\n')}`);\n    }\n\n    return {locale: locale!, i18nNodesByMsgId};\n  }\n\n  override digest(message: i18n.Message): string {\n    return decimalDigest(message);\n  }\n}\n\nclass _WriteVisitor implements i18n.Visitor {\n  private _nextPlaceholderId = 0;\n\n  visitText(text: i18n.Text, context?: any): xml.Node[] {\n    return [new xml.Text(text.value)];\n  }\n\n  visitContainer(container: i18n.Container, context?: any): xml.Node[] {\n    const nodes: xml.Node[] = [];\n    container.children.forEach((node: i18n.Node) => nodes.push(...node.visit(this)));\n    return nodes;\n  }\n\n  visitIcu(icu: i18n.Icu, context?: any): xml.Node[] {\n    const nodes = [new xml.Text(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n\n    Object.keys(icu.cases).forEach((c: string) => {\n      nodes.push(new xml.Text(`${c} {`), ...icu.cases[c].visit(this), new xml.Text(`} `));\n    });\n\n    nodes.push(new xml.Text(`}`));\n\n    return nodes;\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context?: any): xml.Node[] {\n    const type = getTypeForTag(ph.tag);\n\n    if (ph.isVoid) {\n      const tagPh = new xml.Tag(_PLACEHOLDER_TAG, {\n        id: (this._nextPlaceholderId++).toString(),\n        equiv: ph.startName,\n        type: type,\n        disp: `<${ph.tag}/>`,\n      });\n      return [tagPh];\n    }\n\n    const tagPc = new xml.Tag(_PLACEHOLDER_SPANNING_TAG, {\n      id: (this._nextPlaceholderId++).toString(),\n      equivStart: ph.startName,\n      equivEnd: ph.closeName,\n      type: type,\n      dispStart: `<${ph.tag}>`,\n      dispEnd: `</${ph.tag}>`,\n    });\n    const nodes: xml.Node[] = [].concat(...ph.children.map((node) => node.visit(this)));\n    if (nodes.length) {\n      nodes.forEach((node: xml.Node) => tagPc.children.push(node));\n    } else {\n      tagPc.children.push(new xml.Text(''));\n    }\n\n    return [tagPc];\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context?: any): xml.Node[] {\n    const idStr = (this._nextPlaceholderId++).toString();\n    return [\n      new xml.Tag(_PLACEHOLDER_TAG, {\n        id: idStr,\n        equiv: ph.name,\n        disp: `{{${ph.value}}}`,\n      }),\n    ];\n  }\n\n  visitBlockPlaceholder(ph: i18n.BlockPlaceholder, context?: any): xml.Node[] {\n    const tagPc = new xml.Tag(_PLACEHOLDER_SPANNING_TAG, {\n      id: (this._nextPlaceholderId++).toString(),\n      equivStart: ph.startName,\n      equivEnd: ph.closeName,\n      type: 'other',\n      dispStart: `@${ph.name}`,\n      dispEnd: `}`,\n    });\n    const nodes: xml.Node[] = [].concat(...ph.children.map((node) => node.visit(this)));\n    if (nodes.length) {\n      nodes.forEach((node: xml.Node) => tagPc.children.push(node));\n    } else {\n      tagPc.children.push(new xml.Text(''));\n    }\n\n    return [tagPc];\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): xml.Node[] {\n    const cases = Object.keys(ph.value.cases)\n      .map((value: string) => value + ' {...}')\n      .join(' ');\n    const idStr = (this._nextPlaceholderId++).toString();\n    return [\n      new xml.Tag(_PLACEHOLDER_TAG, {\n        id: idStr,\n        equiv: ph.name,\n        disp: `{${ph.value.expression}, ${ph.value.type}, ${cases}}`,\n      }),\n    ];\n  }\n\n  serialize(nodes: i18n.Node[]): xml.Node[] {\n    this._nextPlaceholderId = 0;\n    return [].concat(...nodes.map((node) => node.visit(this)));\n  }\n}\n\n// Extract messages as xml nodes from the xliff file\nclass Xliff2Parser implements ml.Visitor {\n  // using non-null assertions because they're all (re)set by parse()\n  private _unitMlString!: string | null;\n  private _errors!: ParseError[];\n  private _msgIdToHtml!: {[msgId: string]: string};\n  private _locale: string | null = null;\n\n  parse(xliff: string, url: string) {\n    this._unitMlString = null;\n    this._msgIdToHtml = {};\n\n    const xml = new XmlParser().parse(xliff, url);\n\n    this._errors = xml.errors;\n    ml.visitAll(this, xml.rootNodes, null);\n\n    return {\n      msgIdToHtml: this._msgIdToHtml,\n      errors: this._errors,\n      locale: this._locale,\n    };\n  }\n\n  visitElement(element: ml.Element, context: any): any {\n    switch (element.name) {\n      case _UNIT_TAG:\n        this._unitMlString = null;\n        const idAttr = element.attrs.find((attr) => attr.name === 'id');\n        if (!idAttr) {\n          this._addError(element, `<${_UNIT_TAG}> misses the \"id\" attribute`);\n        } else {\n          const id = idAttr.value;\n          if (this._msgIdToHtml.hasOwnProperty(id)) {\n            this._addError(element, `Duplicated translations for msg ${id}`);\n          } else {\n            ml.visitAll(this, element.children, null);\n            if (typeof this._unitMlString === 'string') {\n              this._msgIdToHtml[id] = this._unitMlString;\n            } else {\n              this._addError(element, `Message ${id} misses a translation`);\n            }\n          }\n        }\n        break;\n\n      case _SOURCE_TAG:\n        // ignore source message\n        break;\n\n      case _TARGET_TAG:\n        const innerTextStart = element.startSourceSpan.end.offset;\n        const innerTextEnd = element.endSourceSpan!.start.offset;\n        const content = element.startSourceSpan.start.file.content;\n        const innerText = content.slice(innerTextStart, innerTextEnd);\n        this._unitMlString = innerText;\n        break;\n\n      case _XLIFF_TAG:\n        const localeAttr = element.attrs.find((attr) => attr.name === 'trgLang');\n        if (localeAttr) {\n          this._locale = localeAttr.value;\n        }\n\n        const versionAttr = element.attrs.find((attr) => attr.name === 'version');\n        if (versionAttr) {\n          const version = versionAttr.value;\n          if (version !== '2.0') {\n            this._addError(\n              element,\n              `The XLIFF file version ${version} is not compatible with XLIFF 2.0 serializer`,\n            );\n          } else {\n            ml.visitAll(this, element.children, null);\n          }\n        }\n        break;\n      default:\n        ml.visitAll(this, element.children, null);\n    }\n  }\n\n  visitAttribute(attribute: ml.Attribute, context: any): any {}\n\n  visitText(text: ml.Text, context: any): any {}\n\n  visitComment(comment: ml.Comment, context: any): any {}\n\n  visitExpansion(expansion: ml.Expansion, context: any): any {}\n\n  visitExpansionCase(expansionCase: ml.ExpansionCase, context: any): any {}\n\n  visitBlock(block: ml.Block, context: any) {}\n\n  visitBlockParameter(parameter: ml.BlockParameter, context: any) {}\n\n  visitLetDeclaration(decl: ml.LetDeclaration, context: any) {}\n\n  visitComponent(component: ml.Component, context: any) {}\n\n  visitDirective(directive: ml.Directive, context: any) {}\n\n  private _addError(node: ml.Node, message: string): void {\n    this._errors.push(new ParseError(node.sourceSpan, message));\n  }\n}\n\n// Convert ml nodes (xliff syntax) to i18n nodes\nclass XmlToI18n implements ml.Visitor {\n  // using non-null assertion because re(set) by convert()\n  private _errors!: ParseError[];\n\n  convert(message: string, url: string) {\n    const xmlIcu = new XmlParser().parse(message, url, {tokenizeExpansionForms: true});\n    this._errors = xmlIcu.errors;\n\n    const i18nNodes =\n      this._errors.length > 0 || xmlIcu.rootNodes.length == 0\n        ? []\n        : [].concat(...ml.visitAll(this, xmlIcu.rootNodes));\n\n    return {\n      i18nNodes,\n      errors: this._errors,\n    };\n  }\n\n  visitText(text: ml.Text, context: any) {\n    return new i18n.Text(text.value, text.sourceSpan);\n  }\n\n  visitElement(el: ml.Element, context: any): i18n.Node[] | null {\n    switch (el.name) {\n      case _PLACEHOLDER_TAG:\n        const nameAttr = el.attrs.find((attr) => attr.name === 'equiv');\n        if (nameAttr) {\n          return [new i18n.Placeholder('', nameAttr.value, el.sourceSpan)];\n        }\n\n        this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"equiv\" attribute`);\n        break;\n      case _PLACEHOLDER_SPANNING_TAG:\n        const startAttr = el.attrs.find((attr) => attr.name === 'equivStart');\n        const endAttr = el.attrs.find((attr) => attr.name === 'equivEnd');\n\n        if (!startAttr) {\n          this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"equivStart\" attribute`);\n        } else if (!endAttr) {\n          this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"equivEnd\" attribute`);\n        } else {\n          const startId = startAttr.value;\n          const endId = endAttr.value;\n\n          const nodes: i18n.Node[] = [];\n\n          return nodes.concat(\n            new i18n.Placeholder('', startId, el.sourceSpan),\n            ...el.children.map((node) => node.visit(this, null)),\n            new i18n.Placeholder('', endId, el.sourceSpan),\n          );\n        }\n        break;\n      case _MARKER_TAG:\n        return [].concat(...ml.visitAll(this, el.children));\n      default:\n        this._addError(el, `Unexpected tag`);\n    }\n\n    return null;\n  }\n\n  visitExpansion(icu: ml.Expansion, context: any) {\n    const caseMap: {[value: string]: i18n.Node} = {};\n\n    ml.visitAll(this, icu.cases).forEach((c: any) => {\n      caseMap[c.value] = new i18n.Container(c.nodes, icu.sourceSpan);\n    });\n\n    return new i18n.Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n  }\n\n  visitExpansionCase(icuCase: ml.ExpansionCase, context: any): any {\n    return {\n      value: icuCase.value,\n      nodes: [].concat(...ml.visitAll(this, icuCase.expression)),\n    };\n  }\n\n  visitComment(comment: ml.Comment, context: any) {}\n\n  visitAttribute(attribute: ml.Attribute, context: any) {}\n\n  visitBlock(block: ml.Block, context: any) {}\n\n  visitBlockParameter(parameter: ml.BlockParameter, context: any) {}\n\n  visitLetDeclaration(decl: ml.LetDeclaration, context: any) {}\n\n  visitComponent(component: ml.Component, context: any) {\n    this._addError(component, 'Unexpected node');\n  }\n\n  visitDirective(directive: ml.Directive, context: any) {\n    this._addError(directive, 'Unexpected node');\n  }\n\n  private _addError(node: ml.Node, message: string): void {\n    this._errors.push(new ParseError(node.sourceSpan, message));\n  }\n}\n\nfunction getTypeForTag(tag: string): string {\n  switch (tag.toLowerCase()) {\n    case 'br':\n    case 'b':\n    case 'i':\n    case 'u':\n      return 'fmt';\n    case 'img':\n      return 'image';\n    case 'a':\n      return 'link';\n    default:\n      return 'other';\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as ml from '../../ml_parser/ast';\nimport {XmlParser} from '../../ml_parser/xml_parser';\nimport {ParseError} from '../../parse_util';\nimport * as i18n from '../i18n_ast';\n\nimport {PlaceholderMapper, Serializer, SimplePlaceholderMapper} from './serializer';\nimport {digest, toPublicName} from './xmb';\n\nconst _TRANSLATIONS_TAG = 'translationbundle';\nconst _TRANSLATION_TAG = 'translation';\nconst _PLACEHOLDER_TAG = 'ph';\n\nexport class Xtb extends Serializer {\n  override write(messages: i18n.Message[], locale: string | null): string {\n    throw new Error('Unsupported');\n  }\n\n  override load(\n    content: string,\n    url: string,\n  ): {locale: string; i18nNodesByMsgId: {[msgId: string]: i18n.Node[]}} {\n    // xtb to xml nodes\n    const xtbParser = new XtbParser();\n    const {locale, msgIdToHtml, errors} = xtbParser.parse(content, url);\n\n    // xml nodes to i18n nodes\n    const i18nNodesByMsgId: {[msgId: string]: i18n.Node[]} = {};\n    const converter = new XmlToI18n();\n\n    // Because we should be able to load xtb files that rely on features not supported by angular,\n    // we need to delay the conversion of html to i18n nodes so that non angular messages are not\n    // converted\n    Object.keys(msgIdToHtml).forEach((msgId) => {\n      const valueFn = function () {\n        const {i18nNodes, errors} = converter.convert(msgIdToHtml[msgId], url);\n        if (errors.length) {\n          throw new Error(`xtb parse errors:\\n${errors.join('\\n')}`);\n        }\n        return i18nNodes;\n      };\n      createLazyProperty(i18nNodesByMsgId, msgId, valueFn);\n    });\n\n    if (errors.length) {\n      throw new Error(`xtb parse errors:\\n${errors.join('\\n')}`);\n    }\n\n    return {locale: locale!, i18nNodesByMsgId};\n  }\n\n  override digest(message: i18n.Message): string {\n    return digest(message);\n  }\n\n  override createNameMapper(message: i18n.Message): PlaceholderMapper {\n    return new SimplePlaceholderMapper(message, toPublicName);\n  }\n}\n\nfunction createLazyProperty(messages: any, id: string, valueFn: () => any) {\n  Object.defineProperty(messages, id, {\n    configurable: true,\n    enumerable: true,\n    get: function () {\n      const value = valueFn();\n      Object.defineProperty(messages, id, {enumerable: true, value});\n      return value;\n    },\n    set: (_) => {\n      throw new Error('Could not overwrite an XTB translation');\n    },\n  });\n}\n\n// Extract messages as xml nodes from the xtb file\nclass XtbParser implements ml.Visitor {\n  // using non-null assertions because they're (re)set by parse()\n  private _bundleDepth!: number;\n  private _errors!: ParseError[];\n  private _msgIdToHtml!: {[msgId: string]: string};\n  private _locale: string | null = null;\n\n  parse(xtb: string, url: string) {\n    this._bundleDepth = 0;\n    this._msgIdToHtml = {};\n\n    // We can not parse the ICU messages at this point as some messages might not originate\n    // from Angular that could not be lex'd.\n    const xml = new XmlParser().parse(xtb, url);\n\n    this._errors = xml.errors;\n    ml.visitAll(this, xml.rootNodes);\n\n    return {\n      msgIdToHtml: this._msgIdToHtml,\n      errors: this._errors,\n      locale: this._locale,\n    };\n  }\n\n  visitElement(element: ml.Element, context: any): any {\n    switch (element.name) {\n      case _TRANSLATIONS_TAG:\n        this._bundleDepth++;\n        if (this._bundleDepth > 1) {\n          this._addError(element, `<${_TRANSLATIONS_TAG}> elements can not be nested`);\n        }\n        const langAttr = element.attrs.find((attr) => attr.name === 'lang');\n        if (langAttr) {\n          this._locale = langAttr.value;\n        }\n        ml.visitAll(this, element.children, null);\n        this._bundleDepth--;\n        break;\n\n      case _TRANSLATION_TAG:\n        const idAttr = element.attrs.find((attr) => attr.name === 'id');\n        if (!idAttr) {\n          this._addError(element, `<${_TRANSLATION_TAG}> misses the \"id\" attribute`);\n        } else {\n          const id = idAttr.value;\n          if (this._msgIdToHtml.hasOwnProperty(id)) {\n            this._addError(element, `Duplicated translations for msg ${id}`);\n          } else {\n            const innerTextStart = element.startSourceSpan.end.offset;\n            const innerTextEnd = element.endSourceSpan!.start.offset;\n            const content = element.startSourceSpan.start.file.content;\n            const innerText = content.slice(innerTextStart!, innerTextEnd!);\n            this._msgIdToHtml[id] = innerText;\n          }\n        }\n        break;\n\n      default:\n        this._addError(element, 'Unexpected tag');\n    }\n  }\n\n  visitAttribute(attribute: ml.Attribute, context: any): any {}\n\n  visitText(text: ml.Text, context: any): any {}\n\n  visitComment(comment: ml.Comment, context: any): any {}\n\n  visitExpansion(expansion: ml.Expansion, context: any): any {}\n\n  visitExpansionCase(expansionCase: ml.ExpansionCase, context: any): any {}\n\n  visitBlock(block: ml.Block, context: any) {}\n\n  visitBlockParameter(block: ml.BlockParameter, context: any) {}\n\n  visitLetDeclaration(decl: ml.LetDeclaration, context: any) {}\n\n  visitComponent(component: ml.Component, context: any) {\n    this._addError(component, 'Unexpected node');\n  }\n\n  visitDirective(directive: ml.Directive, context: any) {\n    this._addError(directive, 'Unexpected node');\n  }\n\n  private _addError(node: ml.Node, message: string): void {\n    this._errors.push(new ParseError(node.sourceSpan, message));\n  }\n}\n\n// Convert ml nodes (xtb syntax) to i18n nodes\nclass XmlToI18n implements ml.Visitor {\n  // using non-null assertion because it's (re)set by convert()\n  private _errors!: ParseError[];\n\n  convert(message: string, url: string) {\n    const xmlIcu = new XmlParser().parse(message, url, {tokenizeExpansionForms: true});\n    this._errors = xmlIcu.errors;\n\n    const i18nNodes =\n      this._errors.length > 0 || xmlIcu.rootNodes.length == 0\n        ? []\n        : ml.visitAll(this, xmlIcu.rootNodes);\n\n    return {\n      i18nNodes,\n      errors: this._errors,\n    };\n  }\n\n  visitText(text: ml.Text, context: any) {\n    return new i18n.Text(text.value, text.sourceSpan);\n  }\n\n  visitExpansion(icu: ml.Expansion, context: any) {\n    const caseMap: {[value: string]: i18n.Node} = {};\n\n    ml.visitAll(this, icu.cases).forEach((c) => {\n      caseMap[c.value] = new i18n.Container(c.nodes, icu.sourceSpan);\n    });\n\n    return new i18n.Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n  }\n\n  visitExpansionCase(icuCase: ml.ExpansionCase, context: any): any {\n    return {\n      value: icuCase.value,\n      nodes: ml.visitAll(this, icuCase.expression),\n    };\n  }\n\n  visitElement(el: ml.Element, context: any): i18n.Placeholder | null {\n    if (el.name === _PLACEHOLDER_TAG) {\n      const nameAttr = el.attrs.find((attr) => attr.name === 'name');\n      if (nameAttr) {\n        return new i18n.Placeholder('', nameAttr.value, el.sourceSpan);\n      }\n\n      this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"name\" attribute`);\n    } else {\n      this._addError(el, `Unexpected tag`);\n    }\n    return null;\n  }\n\n  visitComment(comment: ml.Comment, context: any) {}\n\n  visitAttribute(attribute: ml.Attribute, context: any) {}\n\n  visitBlock(block: ml.Block, context: any) {}\n\n  visitBlockParameter(block: ml.BlockParameter, context: any) {}\n\n  visitLetDeclaration(decl: ml.LetDeclaration, context: any) {}\n\n  visitComponent(component: ml.Component, context: any) {\n    this._addError(component, 'Unexpected node');\n  }\n\n  visitDirective(directive: ml.Directive, context: any) {\n    this._addError(directive, 'Unexpected node');\n  }\n\n  private _addError(node: ml.Node, message: string): void {\n    this._errors.push(new ParseError(node.sourceSpan, message));\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {MissingTranslationStrategy} from '../core';\nimport * as html from '../ml_parser/ast';\nimport {HtmlParser} from '../ml_parser/html_parser';\nimport {ParseError} from '../parse_util';\nimport {Console} from '../util';\n\nimport * as i18n from './i18n_ast';\nimport {PlaceholderMapper, Serializer} from './serializers/serializer';\nimport {escapeXml} from './serializers/xml_helper';\n\n/**\n * A container for translated messages\n */\nexport class TranslationBundle {\n  private _i18nToHtml: I18nToHtmlVisitor;\n\n  constructor(\n    private _i18nNodesByMsgId: {[msgId: string]: i18n.Node[]} = {},\n    locale: string | null,\n    public digest: (m: i18n.Message) => string,\n    public mapperFactory?: (m: i18n.Message) => PlaceholderMapper,\n    missingTranslationStrategy: MissingTranslationStrategy = MissingTranslationStrategy.Warning,\n    console?: Console,\n  ) {\n    this._i18nToHtml = new I18nToHtmlVisitor(\n      _i18nNodesByMsgId,\n      locale,\n      digest,\n      mapperFactory!,\n      missingTranslationStrategy,\n      console,\n    );\n  }\n\n  // Creates a `TranslationBundle` by parsing the given `content` with the `serializer`.\n  static load(\n    content: string,\n    url: string,\n    serializer: Serializer,\n    missingTranslationStrategy: MissingTranslationStrategy,\n    console?: Console,\n  ): TranslationBundle {\n    const {locale, i18nNodesByMsgId} = serializer.load(content, url);\n    const digestFn = (m: i18n.Message) => serializer.digest(m);\n    const mapperFactory = (m: i18n.Message) => serializer.createNameMapper(m)!;\n    return new TranslationBundle(\n      i18nNodesByMsgId,\n      locale,\n      digestFn,\n      mapperFactory,\n      missingTranslationStrategy,\n      console,\n    );\n  }\n\n  // Returns the translation as HTML nodes from the given source message.\n  get(srcMsg: i18n.Message): html.Node[] {\n    const html = this._i18nToHtml.convert(srcMsg);\n\n    if (html.errors.length) {\n      throw new Error(html.errors.join('\\n'));\n    }\n\n    return html.nodes;\n  }\n\n  has(srcMsg: i18n.Message): boolean {\n    return this.digest(srcMsg) in this._i18nNodesByMsgId;\n  }\n}\n\nclass I18nToHtmlVisitor implements i18n.Visitor {\n  // using non-null assertions because they're (re)set by convert()\n  private _srcMsg!: i18n.Message;\n  private _errors: ParseError[] = [];\n  private _contextStack: {msg: i18n.Message; mapper: (name: string) => string}[] = [];\n  private _mapper!: (name: string) => string;\n\n  constructor(\n    private _i18nNodesByMsgId: {[msgId: string]: i18n.Node[]} = {},\n    private _locale: string | null,\n    private _digest: (m: i18n.Message) => string,\n    private _mapperFactory: (m: i18n.Message) => PlaceholderMapper,\n    private _missingTranslationStrategy: MissingTranslationStrategy,\n    private _console?: Console,\n  ) {}\n\n  convert(srcMsg: i18n.Message): {nodes: html.Node[]; errors: ParseError[]} {\n    this._contextStack.length = 0;\n    this._errors.length = 0;\n\n    // i18n to text\n    const text = this._convertToText(srcMsg);\n\n    // text to html\n    const url = srcMsg.nodes[0].sourceSpan.start.file.url;\n    const html = new HtmlParser().parse(text, url, {tokenizeExpansionForms: true});\n\n    return {\n      nodes: html.rootNodes,\n      errors: [...this._errors, ...html.errors],\n    };\n  }\n\n  visitText(text: i18n.Text, context?: any): string {\n    // `convert()` uses an `HtmlParser` to return `html.Node`s\n    // we should then make sure that any special characters are escaped\n    return escapeXml(text.value);\n  }\n\n  visitContainer(container: i18n.Container, context?: any): any {\n    return container.children.map((n) => n.visit(this)).join('');\n  }\n\n  visitIcu(icu: i18n.Icu, context?: any): any {\n    const cases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);\n\n    // TODO(vicb): Once all format switch to using expression placeholders\n    // we should throw when the placeholder is not in the source message\n    const exp = this._srcMsg.placeholders.hasOwnProperty(icu.expression)\n      ? this._srcMsg.placeholders[icu.expression].text\n      : icu.expression;\n\n    return `{${exp}, ${icu.type}, ${cases.join(' ')}}`;\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context?: any): string {\n    const phName = this._mapper(ph.name);\n    if (this._srcMsg.placeholders.hasOwnProperty(phName)) {\n      return this._srcMsg.placeholders[phName].text;\n    }\n\n    if (this._srcMsg.placeholderToMessage.hasOwnProperty(phName)) {\n      return this._convertToText(this._srcMsg.placeholderToMessage[phName]);\n    }\n\n    this._addError(ph, `Unknown placeholder \"${ph.name}\"`);\n    return '';\n  }\n\n  // Loaded message contains only placeholders (vs tag and icu placeholders).\n  // However when a translation can not be found, we need to serialize the source message\n  // which can contain tag placeholders\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context?: any): string {\n    const tag = `${ph.tag}`;\n    const attrs = Object.keys(ph.attrs)\n      .map((name) => `${name}=\"${ph.attrs[name]}\"`)\n      .join(' ');\n    if (ph.isVoid) {\n      return `<${tag} ${attrs}/>`;\n    }\n    const children = ph.children.map((c: i18n.Node) => c.visit(this)).join('');\n    return `<${tag} ${attrs}>${children}</${tag}>`;\n  }\n\n  // Loaded message contains only placeholders (vs tag and icu placeholders).\n  // However when a translation can not be found, we need to serialize the source message\n  // which can contain tag placeholders\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): string {\n    // An ICU placeholder references the source message to be serialized\n    return this._convertToText(this._srcMsg.placeholderToMessage[ph.name]);\n  }\n\n  visitBlockPlaceholder(ph: i18n.BlockPlaceholder, context?: any): string {\n    const params = ph.parameters.length === 0 ? '' : ` (${ph.parameters.join('; ')})`;\n    const children = ph.children.map((c: i18n.Node) => c.visit(this)).join('');\n    return `@${ph.name}${params} {${children}}`;\n  }\n\n  /**\n   * Convert a source message to a translated text string:\n   * - text nodes are replaced with their translation,\n   * - placeholders are replaced with their content,\n   * - ICU nodes are converted to ICU expressions.\n   */\n  private _convertToText(srcMsg: i18n.Message): string {\n    const id = this._digest(srcMsg);\n    const mapper = this._mapperFactory ? this._mapperFactory(srcMsg) : null;\n    let nodes: i18n.Node[];\n\n    this._contextStack.push({msg: this._srcMsg, mapper: this._mapper});\n    this._srcMsg = srcMsg;\n\n    if (this._i18nNodesByMsgId.hasOwnProperty(id)) {\n      // When there is a translation use its nodes as the source\n      // And create a mapper to convert serialized placeholder names to internal names\n      nodes = this._i18nNodesByMsgId[id];\n      this._mapper = (name: string) => (mapper ? mapper.toInternalName(name)! : name);\n    } else {\n      // When no translation has been found\n      // - report an error / a warning / nothing,\n      // - use the nodes from the original message\n      // - placeholders are already internal and need no mapper\n      if (this._missingTranslationStrategy === MissingTranslationStrategy.Error) {\n        const ctx = this._locale ? ` for locale \"${this._locale}\"` : '';\n        this._addError(srcMsg.nodes[0], `Missing translation for message \"${id}\"${ctx}`);\n      } else if (\n        this._console &&\n        this._missingTranslationStrategy === MissingTranslationStrategy.Warning\n      ) {\n        const ctx = this._locale ? ` for locale \"${this._locale}\"` : '';\n        this._console.warn(`Missing translation for message \"${id}\"${ctx}`);\n      }\n      nodes = srcMsg.nodes;\n      this._mapper = (name: string) => name;\n    }\n    const text = nodes.map((node) => node.visit(this)).join('');\n    const context = this._contextStack.pop()!;\n    this._srcMsg = context.msg;\n    this._mapper = context.mapper;\n    return text;\n  }\n\n  private _addError(el: i18n.Node, msg: string) {\n    this._errors.push(new ParseError(el.sourceSpan, msg));\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {MissingTranslationStrategy} from '../core';\nimport {DEFAULT_INTERPOLATION_CONFIG} from '../ml_parser/defaults';\nimport {HtmlParser} from '../ml_parser/html_parser';\nimport {TokenizeOptions} from '../ml_parser/lexer';\nimport {ParseTreeResult} from '../ml_parser/parser';\nimport {Console} from '../util';\n\nimport {digest} from './digest';\nimport {mergeTranslations} from './extractor_merger';\nimport {Serializer} from './serializers/serializer';\nimport {Xliff} from './serializers/xliff';\nimport {Xliff2} from './serializers/xliff2';\nimport {Xmb} from './serializers/xmb';\nimport {Xtb} from './serializers/xtb';\nimport {TranslationBundle} from './translation_bundle';\n\nexport class I18NHtmlParser implements HtmlParser {\n  // @override\n  getTagDefinition: any;\n\n  private _translationBundle: TranslationBundle;\n\n  constructor(\n    private _htmlParser: HtmlParser,\n    translations?: string,\n    translationsFormat?: string,\n    missingTranslation: MissingTranslationStrategy = MissingTranslationStrategy.Warning,\n    console?: Console,\n  ) {\n    if (translations) {\n      const serializer = createSerializer(translationsFormat);\n      this._translationBundle = TranslationBundle.load(\n        translations,\n        'i18n',\n        serializer,\n        missingTranslation,\n        console,\n      );\n    } else {\n      this._translationBundle = new TranslationBundle(\n        {},\n        null,\n        digest,\n        undefined,\n        missingTranslation,\n        console,\n      );\n    }\n  }\n\n  parse(source: string, url: string, options: TokenizeOptions = {}): ParseTreeResult {\n    const interpolationConfig = options.interpolationConfig || DEFAULT_INTERPOLATION_CONFIG;\n    const parseResult = this._htmlParser.parse(source, url, {interpolationConfig, ...options});\n\n    if (parseResult.errors.length) {\n      return new ParseTreeResult(parseResult.rootNodes, parseResult.errors);\n    }\n\n    return mergeTranslations(\n      parseResult.rootNodes,\n      this._translationBundle,\n      interpolationConfig,\n      [],\n      {},\n    );\n  }\n}\n\nfunction createSerializer(format?: string): Serializer {\n  format = (format || 'xlf').toLowerCase();\n\n  switch (format) {\n    case 'xmb':\n      return new Xmb();\n    case 'xtb':\n      return new Xtb();\n    case 'xliff2':\n    case 'xlf2':\n      return new Xliff2();\n    case 'xliff':\n    case 'xlf':\n    default:\n      return new Xliff();\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {InterpolationConfig} from '../ml_parser/defaults';\nimport {HtmlParser} from '../ml_parser/html_parser';\nimport {WhitespaceVisitor, visitAllWithSiblings} from '../ml_parser/html_whitespaces';\nimport {ParseError} from '../parse_util';\n\nimport {extractMessages} from './extractor_merger';\nimport * as i18n from './i18n_ast';\nimport {PlaceholderMapper, Serializer} from './serializers/serializer';\n\n/**\n * A container for message extracted from the templates.\n */\nexport class MessageBundle {\n  private _messages: i18n.Message[] = [];\n\n  constructor(\n    private _htmlParser: HtmlParser,\n    private _implicitTags: string[],\n    private _implicitAttrs: {[k: string]: string[]},\n    private _locale: string | null = null,\n    private readonly _preserveWhitespace = true,\n  ) {}\n\n  updateFromTemplate(\n    source: string,\n    url: string,\n    interpolationConfig: InterpolationConfig,\n  ): ParseError[] {\n    const htmlParserResult = this._htmlParser.parse(source, url, {\n      tokenizeExpansionForms: true,\n      interpolationConfig,\n    });\n\n    if (htmlParserResult.errors.length) {\n      return htmlParserResult.errors;\n    }\n\n    // Trim unnecessary whitespace from extracted messages if requested. This\n    // makes the messages more durable to trivial whitespace changes without\n    // affected message IDs.\n    const rootNodes = this._preserveWhitespace\n      ? htmlParserResult.rootNodes\n      : visitAllWithSiblings(\n          new WhitespaceVisitor(/* preserveSignificantWhitespace */ false),\n          htmlParserResult.rootNodes,\n        );\n\n    const i18nParserResult = extractMessages(\n      rootNodes,\n      interpolationConfig,\n      this._implicitTags,\n      this._implicitAttrs,\n      /* preserveSignificantWhitespace */ this._preserveWhitespace,\n    );\n\n    if (i18nParserResult.errors.length) {\n      return i18nParserResult.errors;\n    }\n\n    this._messages.push(...i18nParserResult.messages);\n    return [];\n  }\n\n  // Return the message in the internal format\n  // The public (serialized) format might be different, see the `write` method.\n  getMessages(): i18n.Message[] {\n    return this._messages;\n  }\n\n  write(serializer: Serializer, filterSources?: (path: string) => string): string {\n    const messages: {[id: string]: i18n.Message} = {};\n    const mapperVisitor = new MapPlaceholderNames();\n\n    // Deduplicate messages based on their ID\n    this._messages.forEach((message) => {\n      const id = serializer.digest(message);\n      if (!messages.hasOwnProperty(id)) {\n        messages[id] = message;\n      } else {\n        messages[id].sources.push(...message.sources);\n      }\n    });\n\n    // Transform placeholder names using the serializer mapping\n    const msgList = Object.keys(messages).map((id) => {\n      const mapper = serializer.createNameMapper(messages[id]);\n      const src = messages[id];\n      const nodes = mapper ? mapperVisitor.convert(src.nodes, mapper) : src.nodes;\n      let transformedMessage = new i18n.Message(nodes, {}, {}, src.meaning, src.description, id);\n      transformedMessage.sources = src.sources;\n      if (filterSources) {\n        transformedMessage.sources.forEach(\n          (source: i18n.MessageSpan) => (source.filePath = filterSources(source.filePath)),\n        );\n      }\n      return transformedMessage;\n    });\n\n    return serializer.write(msgList, this._locale);\n  }\n}\n\n// Transform an i18n AST by renaming the placeholder nodes with the given mapper\nclass MapPlaceholderNames extends i18n.CloneVisitor {\n  convert(nodes: i18n.Node[], mapper: PlaceholderMapper): i18n.Node[] {\n    return mapper ? nodes.map((n) => n.visit(this, mapper)) : nodes;\n  }\n\n  override visitTagPlaceholder(\n    ph: i18n.TagPlaceholder,\n    mapper: PlaceholderMapper,\n  ): i18n.TagPlaceholder {\n    const startName = mapper.toPublicName(ph.startName)!;\n    const closeName = ph.closeName ? mapper.toPublicName(ph.closeName)! : ph.closeName;\n    const children = ph.children.map((n) => n.visit(this, mapper));\n    return new i18n.TagPlaceholder(\n      ph.tag,\n      ph.attrs,\n      startName,\n      closeName,\n      children,\n      ph.isVoid,\n      ph.sourceSpan,\n      ph.startSourceSpan,\n      ph.endSourceSpan,\n    );\n  }\n\n  override visitBlockPlaceholder(\n    ph: i18n.BlockPlaceholder,\n    mapper: PlaceholderMapper,\n  ): i18n.BlockPlaceholder {\n    const startName = mapper.toPublicName(ph.startName)!;\n    const closeName = ph.closeName ? mapper.toPublicName(ph.closeName)! : ph.closeName;\n    const children = ph.children.map((n) => n.visit(this, mapper));\n    return new i18n.BlockPlaceholder(\n      ph.name,\n      ph.parameters,\n      startName,\n      closeName,\n      children,\n      ph.sourceSpan,\n      ph.startSourceSpan,\n      ph.endSourceSpan,\n    );\n  }\n\n  override visitPlaceholder(ph: i18n.Placeholder, mapper: PlaceholderMapper): i18n.Placeholder {\n    return new i18n.Placeholder(ph.value, mapper.toPublicName(ph.name)!, ph.sourceSpan);\n  }\n\n  override visitIcuPlaceholder(\n    ph: i18n.IcuPlaceholder,\n    mapper: PlaceholderMapper,\n  ): i18n.IcuPlaceholder {\n    return new i18n.IcuPlaceholder(ph.value, mapper.toPublicName(ph.name)!, ph.sourceSpan);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport * as o from '../output/output_ast';\n\nimport {Identifiers as R3} from './r3_identifiers';\nimport {devOnlyGuardedExpression} from './util';\nimport {R3DeferPerComponentDependency} from './view/api';\n\nexport type CompileClassMetadataFn = (metadata: R3ClassMetadata) => o.Expression;\n\n/**\n * Metadata of a class which captures the original Angular decorators of a class. The original\n * decorators are preserved in the generated code to allow TestBed APIs to recompile the class\n * using the original decorator with a set of overrides applied.\n */\nexport interface R3ClassMetadata {\n  /**\n   * The class type for which the metadata is captured.\n   */\n  type: o.Expression;\n\n  /**\n   * An expression representing the Angular decorators that were applied on the class.\n   */\n  decorators: o.Expression;\n\n  /**\n   * An expression representing the Angular decorators applied to constructor parameters, or `null`\n   * if there is no constructor.\n   */\n  ctorParameters: o.Expression | null;\n\n  /**\n   * An expression representing the Angular decorators that were applied on the properties of the\n   * class, or `null` if no properties have decorators.\n   */\n  propDecorators: o.Expression | null;\n}\n\nexport function compileClassMetadata(metadata: R3ClassMetadata): o.InvokeFunctionExpr {\n  const fnCall = internalCompileClassMetadata(metadata);\n  return o.arrowFn([], [devOnlyGuardedExpression(fnCall).toStmt()]).callFn([]);\n}\n\n/** Compiles only the `setClassMetadata` call without any additional wrappers. */\nfunction internalCompileClassMetadata(metadata: R3ClassMetadata): o.InvokeFunctionExpr {\n  return o\n    .importExpr(R3.setClassMetadata)\n    .callFn([\n      metadata.type,\n      metadata.decorators,\n      metadata.ctorParameters ?? o.literal(null),\n      metadata.propDecorators ?? o.literal(null),\n    ]);\n}\n\n/**\n * Wraps the `setClassMetadata` function with extra logic that dynamically\n * loads dependencies from `@defer` blocks.\n *\n * Generates a call like this:\n * ```ts\n * setClassMetadataAsync(type, () => [\n *   import('./cmp-a').then(m => m.CmpA);\n *   import('./cmp-b').then(m => m.CmpB);\n * ], (CmpA, CmpB) => {\n *   setClassMetadata(type, decorators, ctorParameters, propParameters);\n * });\n * ```\n *\n * Similar to the `setClassMetadata` call, it's wrapped into the `ngDevMode`\n * check to tree-shake away this code in production mode.\n */\nexport function compileComponentClassMetadata(\n  metadata: R3ClassMetadata,\n  dependencies: R3DeferPerComponentDependency[] | null,\n): o.Expression {\n  if (dependencies === null || dependencies.length === 0) {\n    // If there are no deferrable symbols - just generate a regular `setClassMetadata` call.\n    return compileClassMetadata(metadata);\n  }\n\n  return internalCompileSetClassMetadataAsync(\n    metadata,\n    dependencies.map((dep) => new o.FnParam(dep.symbolName, o.DYNAMIC_TYPE)),\n    compileComponentMetadataAsyncResolver(dependencies),\n  );\n}\n\n/**\n * Identical to `compileComponentClassMetadata`. Used for the cases where we're unable to\n * analyze the deferred block dependencies, but we have a reference to the compiled\n * dependency resolver function that we can use as is.\n * @param metadata Class metadata for the internal `setClassMetadata` call.\n * @param deferResolver Expression representing the deferred dependency loading function.\n * @param deferredDependencyNames Names of the dependencies that are being loaded asynchronously.\n */\nexport function compileOpaqueAsyncClassMetadata(\n  metadata: R3ClassMetadata,\n  deferResolver: o.Expression,\n  deferredDependencyNames: string[],\n): o.Expression {\n  return internalCompileSetClassMetadataAsync(\n    metadata,\n    deferredDependencyNames.map((name) => new o.FnParam(name, o.DYNAMIC_TYPE)),\n    deferResolver,\n  );\n}\n\n/**\n * Internal logic used to compile a `setClassMetadataAsync` call.\n * @param metadata Class metadata for the internal `setClassMetadata` call.\n * @param wrapperParams Parameters to be set on the callback that wraps `setClassMetata`.\n * @param dependencyResolverFn Function to resolve the deferred dependencies.\n */\nfunction internalCompileSetClassMetadataAsync(\n  metadata: R3ClassMetadata,\n  wrapperParams: o.FnParam[],\n  dependencyResolverFn: o.Expression,\n): o.Expression {\n  // Omit the wrapper since it'll be added around `setClassMetadataAsync` instead.\n  const setClassMetadataCall = internalCompileClassMetadata(metadata);\n  const setClassMetaWrapper = o.arrowFn(wrapperParams, [setClassMetadataCall.toStmt()]);\n  const setClassMetaAsync = o\n    .importExpr(R3.setClassMetadataAsync)\n    .callFn([metadata.type, dependencyResolverFn, setClassMetaWrapper]);\n\n  return o.arrowFn([], [devOnlyGuardedExpression(setClassMetaAsync).toStmt()]).callFn([]);\n}\n\n/**\n * Compiles the function that loads the dependencies for the\n * entire component in `setClassMetadataAsync`.\n */\nexport function compileComponentMetadataAsyncResolver(\n  dependencies: R3DeferPerComponentDependency[],\n): o.ArrowFunctionExpr {\n  const dynamicImports = dependencies.map(({symbolName, importPath, isDefaultImport}) => {\n    // e.g. `(m) => m.CmpA`\n    const innerFn =\n      // Default imports are always accessed through the `default` property.\n      o.arrowFn(\n        [new o.FnParam('m', o.DYNAMIC_TYPE)],\n        o.variable('m').prop(isDefaultImport ? 'default' : symbolName),\n      );\n\n    // e.g. `import('./cmp-a').then(...)`\n    return new o.DynamicImportExpr(importPath).prop('then').callFn([innerFn]);\n  });\n\n  // e.g. `() => [ ... ];`\n  return o.arrowFn([], o.literalArr(dynamicImports));\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport * as o from '../../output/output_ast';\nimport {\n  compileComponentMetadataAsyncResolver,\n  R3ClassMetadata,\n} from '../r3_class_metadata_compiler';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {R3DeferPerComponentDependency} from '../view/api';\nimport {DefinitionMap} from '../view/util';\n\nimport {R3DeclareClassMetadata, R3DeclareClassMetadataAsync} from './api';\n\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION = '12.0.0';\n\n/**\n * Minimum version at which deferred blocks are supported in the linker.\n */\nconst MINIMUM_PARTIAL_LINKER_DEFER_SUPPORT_VERSION = '18.0.0';\n\nexport function compileDeclareClassMetadata(metadata: R3ClassMetadata): o.Expression {\n  const definitionMap = new DefinitionMap<R3DeclareClassMetadata>();\n  definitionMap.set('minVersion', o.literal(MINIMUM_PARTIAL_LINKER_VERSION));\n  definitionMap.set('version', o.literal('20.3.6'));\n  definitionMap.set('ngImport', o.importExpr(R3.core));\n  definitionMap.set('type', metadata.type);\n  definitionMap.set('decorators', metadata.decorators);\n  definitionMap.set('ctorParameters', metadata.ctorParameters);\n  definitionMap.set('propDecorators', metadata.propDecorators);\n\n  return o.importExpr(R3.declareClassMetadata).callFn([definitionMap.toLiteralMap()]);\n}\n\nexport function compileComponentDeclareClassMetadata(\n  metadata: R3ClassMetadata,\n  dependencies: R3DeferPerComponentDependency[] | null,\n): o.Expression {\n  if (dependencies === null || dependencies.length === 0) {\n    return compileDeclareClassMetadata(metadata);\n  }\n\n  const definitionMap = new DefinitionMap<R3DeclareClassMetadataAsync>();\n  const callbackReturnDefinitionMap = new DefinitionMap<R3ClassMetadata>();\n  callbackReturnDefinitionMap.set('decorators', metadata.decorators);\n  callbackReturnDefinitionMap.set('ctorParameters', metadata.ctorParameters ?? o.literal(null));\n  callbackReturnDefinitionMap.set('propDecorators', metadata.propDecorators ?? o.literal(null));\n\n  definitionMap.set('minVersion', o.literal(MINIMUM_PARTIAL_LINKER_DEFER_SUPPORT_VERSION));\n  definitionMap.set('version', o.literal('20.3.6'));\n  definitionMap.set('ngImport', o.importExpr(R3.core));\n  definitionMap.set('type', metadata.type);\n  definitionMap.set('resolveDeferredDeps', compileComponentMetadataAsyncResolver(dependencies));\n  definitionMap.set(\n    'resolveMetadata',\n    o.arrowFn(\n      dependencies.map((dep) => new o.FnParam(dep.symbolName, o.DYNAMIC_TYPE)),\n      callbackReturnDefinitionMap.toLiteralMap(),\n    ),\n  );\n\n  return o.importExpr(R3.declareClassMetadataAsync).callFn([definitionMap.toLiteralMap()]);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport * as o from '../../output/output_ast';\nimport {R3DependencyMetadata} from '../r3_factory';\nimport {DefinitionMap} from '../view/util';\n\nimport {R3DeclareDependencyMetadata} from './api';\n\n/**\n * Creates an array literal expression from the given array, mapping all values to an expression\n * using the provided mapping function. If the array is empty or null, then null is returned.\n *\n * @param values The array to transfer into literal array expression.\n * @param mapper The logic to use for creating an expression for the array's values.\n * @returns An array literal expression representing `values`, or null if `values` is empty or\n * is itself null.\n */\nexport function toOptionalLiteralArray<T>(\n  values: T[] | null,\n  mapper: (value: T) => o.Expression,\n): o.LiteralArrayExpr | null {\n  if (values === null || values.length === 0) {\n    return null;\n  }\n  return o.literalArr(values.map((value) => mapper(value)));\n}\n\n/**\n * Creates an object literal expression from the given object, mapping all values to an expression\n * using the provided mapping function. If the object has no keys, then null is returned.\n *\n * @param object The object to transfer into an object literal expression.\n * @param mapper The logic to use for creating an expression for the object's values.\n * @returns An object literal expression representing `object`, or null if `object` does not have\n * any keys.\n */\nexport function toOptionalLiteralMap<T>(\n  object: {[key: string]: T},\n  mapper: (value: T) => o.Expression,\n): o.LiteralMapExpr | null {\n  const entries = Object.keys(object).map((key) => {\n    const value = object[key];\n    return {key, value: mapper(value), quoted: true};\n  });\n\n  if (entries.length > 0) {\n    return o.literalMap(entries);\n  } else {\n    return null;\n  }\n}\n\nexport function compileDependencies(\n  deps: R3DependencyMetadata[] | 'invalid' | null,\n): o.LiteralExpr | o.LiteralArrayExpr {\n  if (deps === 'invalid') {\n    // The `deps` can be set to the string \"invalid\"  by the `unwrapConstructorDependencies()`\n    // function, which tries to convert `ConstructorDeps` into `R3DependencyMetadata[]`.\n    return o.literal('invalid');\n  } else if (deps === null) {\n    return o.literal(null);\n  } else {\n    return o.literalArr(deps.map(compileDependency));\n  }\n}\n\nexport function compileDependency(dep: R3DependencyMetadata): o.LiteralMapExpr {\n  const depMeta = new DefinitionMap<R3DeclareDependencyMetadata>();\n  depMeta.set('token', dep.token);\n  if (dep.attributeNameType !== null) {\n    depMeta.set('attribute', o.literal(true));\n  }\n  if (dep.host) {\n    depMeta.set('host', o.literal(true));\n  }\n  if (dep.optional) {\n    depMeta.set('optional', o.literal(true));\n  }\n  if (dep.self) {\n    depMeta.set('self', o.literal(true));\n  }\n  if (dep.skipSelf) {\n    depMeta.set('skipSelf', o.literal(true));\n  }\n  return depMeta.toLiteralMap();\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport * as o from '../../output/output_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {\n  convertFromMaybeForwardRefExpression,\n  generateForwardRef,\n  R3CompiledExpression,\n} from '../util';\nimport {R3DirectiveMetadata, R3HostMetadata, R3QueryMetadata} from '../view/api';\nimport {createDirectiveType, createHostDirectivesMappingArray} from '../view/compiler';\nimport {\n  asLiteral,\n  conditionallyCreateDirectiveBindingLiteral,\n  DefinitionMap,\n  UNSAFE_OBJECT_KEY_NAME_REGEXP,\n} from '../view/util';\n\nimport {R3DeclareDirectiveMetadata, R3DeclareQueryMetadata} from './api';\nimport {toOptionalLiteralMap} from './util';\n\n/**\n * Compile a directive declaration defined by the `R3DirectiveMetadata`.\n */\nexport function compileDeclareDirectiveFromMetadata(\n  meta: R3DirectiveMetadata,\n): R3CompiledExpression {\n  const definitionMap = createDirectiveDefinitionMap(meta);\n\n  const expression = o.importExpr(R3.declareDirective).callFn([definitionMap.toLiteralMap()]);\n  const type = createDirectiveType(meta);\n\n  return {expression, type, statements: []};\n}\n\n/**\n * Gathers the declaration fields for a directive into a `DefinitionMap`. This allows for reusing\n * this logic for components, as they extend the directive metadata.\n */\nexport function createDirectiveDefinitionMap(\n  meta: R3DirectiveMetadata,\n): DefinitionMap<R3DeclareDirectiveMetadata> {\n  const definitionMap = new DefinitionMap<R3DeclareDirectiveMetadata>();\n  const minVersion = getMinimumVersionForPartialOutput(meta);\n\n  definitionMap.set('minVersion', o.literal(minVersion));\n  definitionMap.set('version', o.literal('20.3.6'));\n\n  // e.g. `type: MyDirective`\n  definitionMap.set('type', meta.type.value);\n\n  if (meta.isStandalone !== undefined) {\n    definitionMap.set('isStandalone', o.literal(meta.isStandalone));\n  }\n  if (meta.isSignal) {\n    definitionMap.set('isSignal', o.literal(meta.isSignal));\n  }\n\n  // e.g. `selector: 'some-dir'`\n  if (meta.selector !== null) {\n    definitionMap.set('selector', o.literal(meta.selector));\n  }\n\n  definitionMap.set(\n    'inputs',\n    needsNewInputPartialOutput(meta)\n      ? createInputsPartialMetadata(meta.inputs)\n      : legacyInputsPartialMetadata(meta.inputs),\n  );\n  definitionMap.set('outputs', conditionallyCreateDirectiveBindingLiteral(meta.outputs));\n\n  definitionMap.set('host', compileHostMetadata(meta.host));\n\n  definitionMap.set('providers', meta.providers);\n\n  if (meta.queries.length > 0) {\n    definitionMap.set('queries', o.literalArr(meta.queries.map(compileQuery)));\n  }\n\n  if (meta.viewQueries.length > 0) {\n    definitionMap.set('viewQueries', o.literalArr(meta.viewQueries.map(compileQuery)));\n  }\n\n  if (meta.exportAs !== null) {\n    definitionMap.set('exportAs', asLiteral(meta.exportAs));\n  }\n\n  if (meta.usesInheritance) {\n    definitionMap.set('usesInheritance', o.literal(true));\n  }\n\n  if (meta.lifecycle.usesOnChanges) {\n    definitionMap.set('usesOnChanges', o.literal(true));\n  }\n\n  if (meta.hostDirectives?.length) {\n    definitionMap.set('hostDirectives', createHostDirectives(meta.hostDirectives));\n  }\n\n  definitionMap.set('ngImport', o.importExpr(R3.core));\n\n  return definitionMap;\n}\n\n/**\n * Determines the minimum linker version for the partial output\n * generated for this directive.\n *\n * Every time we make a breaking change to the declaration interface or partial-linker\n * behavior, we must update the minimum versions to prevent old partial-linkers from\n * incorrectly processing the declaration.\n *\n * NOTE: Do not include any prerelease in these versions as they are ignored.\n */\nfunction getMinimumVersionForPartialOutput(meta: R3DirectiveMetadata): string {\n  // We are starting with the oldest minimum version that can work for common\n  // directive partial compilation output. As we discover usages of new features\n  // that require a newer partial output emit, we bump the `minVersion`. Our goal\n  // is to keep libraries as much compatible with older linker versions as possible.\n  let minVersion = '14.0.0';\n\n  // Note: in order to allow consuming Angular libraries that have been compiled with 16.1+ in\n  // Angular 16.0, we only force a minimum version of 16.1 if input transform feature as introduced\n  // in 16.1 is actually used.\n  const hasDecoratorTransformFunctions = Object.values(meta.inputs).some(\n    (input) => input.transformFunction !== null,\n  );\n  if (hasDecoratorTransformFunctions) {\n    minVersion = '16.1.0';\n  }\n\n  // If there are input flags and we need the new emit, use the actual minimum version,\n  // where this was introduced. i.e. in 17.1.0\n  // TODO(legacy-partial-output-inputs): Remove in v18.\n  if (needsNewInputPartialOutput(meta)) {\n    minVersion = '17.1.0';\n  }\n\n  // If there are signal-based queries, partial output generates an extra field\n  // that should be parsed by linkers. Ensure a proper minimum linker version.\n  if (meta.queries.some((q) => q.isSignal) || meta.viewQueries.some((q) => q.isSignal)) {\n    minVersion = '17.2.0';\n  }\n\n  return minVersion;\n}\n\n/**\n * Gets whether the given directive needs the new input partial output structure\n * that can hold additional metadata like `isRequired`, `isSignal` etc.\n */\nfunction needsNewInputPartialOutput(meta: R3DirectiveMetadata): boolean {\n  return Object.values(meta.inputs).some((input) => input.isSignal);\n}\n\n/**\n * Compiles the metadata of a single query into its partial declaration form as declared\n * by `R3DeclareQueryMetadata`.\n */\nfunction compileQuery(query: R3QueryMetadata): o.LiteralMapExpr {\n  const meta = new DefinitionMap<R3DeclareQueryMetadata>();\n  meta.set('propertyName', o.literal(query.propertyName));\n  if (query.first) {\n    meta.set('first', o.literal(true));\n  }\n  meta.set(\n    'predicate',\n    Array.isArray(query.predicate)\n      ? asLiteral(query.predicate)\n      : convertFromMaybeForwardRefExpression(query.predicate),\n  );\n  if (!query.emitDistinctChangesOnly) {\n    // `emitDistinctChangesOnly` is special because we expect it to be `true`.\n    // Therefore we explicitly emit the field, and explicitly place it only when it's `false`.\n    meta.set('emitDistinctChangesOnly', o.literal(false));\n  } else {\n    // The linker will assume that an absent `emitDistinctChangesOnly` flag is by default `true`.\n  }\n  if (query.descendants) {\n    meta.set('descendants', o.literal(true));\n  }\n  meta.set('read', query.read);\n  if (query.static) {\n    meta.set('static', o.literal(true));\n  }\n  if (query.isSignal) {\n    meta.set('isSignal', o.literal(true));\n  }\n  return meta.toLiteralMap();\n}\n\n/**\n * Compiles the host metadata into its partial declaration form as declared\n * in `R3DeclareDirectiveMetadata['host']`\n */\nfunction compileHostMetadata(meta: R3HostMetadata): o.LiteralMapExpr | null {\n  const hostMetadata = new DefinitionMap<NonNullable<R3DeclareDirectiveMetadata['host']>>();\n  hostMetadata.set(\n    'attributes',\n    toOptionalLiteralMap(meta.attributes, (expression) => expression),\n  );\n  hostMetadata.set('listeners', toOptionalLiteralMap(meta.listeners, o.literal));\n  hostMetadata.set('properties', toOptionalLiteralMap(meta.properties, o.literal));\n\n  if (meta.specialAttributes.styleAttr) {\n    hostMetadata.set('styleAttribute', o.literal(meta.specialAttributes.styleAttr));\n  }\n  if (meta.specialAttributes.classAttr) {\n    hostMetadata.set('classAttribute', o.literal(meta.specialAttributes.classAttr));\n  }\n\n  if (hostMetadata.values.length > 0) {\n    return hostMetadata.toLiteralMap();\n  } else {\n    return null;\n  }\n}\n\nfunction createHostDirectives(\n  hostDirectives: NonNullable<R3DirectiveMetadata['hostDirectives']>,\n): o.LiteralArrayExpr {\n  const expressions = hostDirectives.map((current) => {\n    const keys = [\n      {\n        key: 'directive',\n        value: current.isForwardReference\n          ? generateForwardRef(current.directive.type)\n          : current.directive.type,\n        quoted: false,\n      },\n    ];\n    const inputsLiteral = current.inputs ? createHostDirectivesMappingArray(current.inputs) : null;\n    const outputsLiteral = current.outputs\n      ? createHostDirectivesMappingArray(current.outputs)\n      : null;\n\n    if (inputsLiteral) {\n      keys.push({key: 'inputs', value: inputsLiteral, quoted: false});\n    }\n\n    if (outputsLiteral) {\n      keys.push({key: 'outputs', value: outputsLiteral, quoted: false});\n    }\n\n    return o.literalMap(keys);\n  });\n\n  // If there's a forward reference, we generate a `function() { return [{directive: HostDir}] }`,\n  // otherwise we can save some bytes by using a plain array, e.g. `[{directive: HostDir}]`.\n  return o.literalArr(expressions);\n}\n\n/**\n * Generates partial output metadata for inputs of a directive.\n *\n * The generated structure is expected to match `R3DeclareDirectiveFacade['inputs']`.\n */\nfunction createInputsPartialMetadata(inputs: R3DirectiveMetadata['inputs']): o.Expression | null {\n  const keys = Object.getOwnPropertyNames(inputs);\n  if (keys.length === 0) {\n    return null;\n  }\n\n  return o.literalMap(\n    keys.map((declaredName) => {\n      const value = inputs[declaredName];\n\n      return {\n        key: declaredName,\n        // put quotes around keys that contain potentially unsafe characters\n        quoted: UNSAFE_OBJECT_KEY_NAME_REGEXP.test(declaredName),\n        value: o.literalMap([\n          {key: 'classPropertyName', quoted: false, value: asLiteral(value.classPropertyName)},\n          {key: 'publicName', quoted: false, value: asLiteral(value.bindingPropertyName)},\n          {key: 'isSignal', quoted: false, value: asLiteral(value.isSignal)},\n          {key: 'isRequired', quoted: false, value: asLiteral(value.required)},\n          {key: 'transformFunction', quoted: false, value: value.transformFunction ?? o.NULL_EXPR},\n        ]),\n      };\n    }),\n  );\n}\n\n/**\n * Pre v18 legacy partial output for inputs.\n *\n * Previously, inputs did not capture metadata like `isSignal` in the partial compilation output.\n * To enable capturing such metadata, we restructured how input metadata is communicated in the\n * partial output. This would make libraries incompatible with older Angular FW versions where the\n * linker would not know how to handle this new \"format\". For this reason, if we know this metadata\n * does not need to be captured- we fall back to the old format. This is what this function\n * generates.\n *\n * See:\n * https://github.com/angular/angular/blob/d4b423690210872b5c32a322a6090beda30b05a3/packages/core/src/compiler/compiler_facade_interface.ts#L197-L199\n */\nfunction legacyInputsPartialMetadata(inputs: R3DirectiveMetadata['inputs']): o.Expression | null {\n  // TODO(legacy-partial-output-inputs): Remove function in v18.\n\n  const keys = Object.getOwnPropertyNames(inputs);\n  if (keys.length === 0) {\n    return null;\n  }\n\n  return o.literalMap(\n    keys.map((declaredName) => {\n      const value = inputs[declaredName];\n      const publicName = value.bindingPropertyName;\n      const differentDeclaringName = publicName !== declaredName;\n      let result: o.Expression;\n\n      if (differentDeclaringName || value.transformFunction !== null) {\n        const values = [asLiteral(publicName), asLiteral(declaredName)];\n        if (value.transformFunction !== null) {\n          values.push(value.transformFunction);\n        }\n        result = o.literalArr(values);\n      } else {\n        result = asLiteral(publicName);\n      }\n\n      return {\n        key: declaredName,\n        // put quotes around keys that contain potentially unsafe characters\n        quoted: UNSAFE_OBJECT_KEY_NAME_REGEXP.test(declaredName),\n        value: result,\n      };\n    }),\n  );\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport * as core from '../../core';\nimport {DEFAULT_INTERPOLATION_CONFIG} from '../../ml_parser/defaults';\nimport * as o from '../../output/output_ast';\nimport {ParseLocation, ParseSourceFile, ParseSourceSpan} from '../../parse_util';\nimport {RecursiveVisitor, visitAll} from '../r3_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {generateForwardRef, R3CompiledExpression} from '../util';\nimport {\n  DeclarationListEmitMode,\n  DeferBlockDepsEmitMode,\n  R3ComponentMetadata,\n  R3TemplateDependencyKind,\n  R3TemplateDependencyMetadata,\n} from '../view/api';\nimport {createComponentType} from '../view/compiler';\nimport {ParsedTemplate} from '../view/template';\nimport {DefinitionMap} from '../view/util';\n\nimport {\n  R3DeclareComponentMetadata,\n  R3DeclareDirectiveDependencyMetadata,\n  R3DeclareNgModuleDependencyMetadata,\n  R3DeclarePipeDependencyMetadata,\n} from './api';\nimport {createDirectiveDefinitionMap} from './directive';\nimport {toOptionalLiteralArray} from './util';\n\nexport interface DeclareComponentTemplateInfo {\n  /**\n   * The string contents of the template.\n   *\n   * This is the \"logical\" template string, after expansion of any escaped characters (for inline\n   * templates). This may differ from the actual template bytes as they appear in the .ts file.\n   */\n  content: string;\n\n  /**\n   * A full path to the file which contains the template.\n   *\n   * This can be either the original .ts file if the template is inline, or the .html file if an\n   * external file was used.\n   */\n  sourceUrl: string;\n\n  /**\n   * Whether the template was inline (using `template`) or external (using `templateUrl`).\n   */\n  isInline: boolean;\n\n  /**\n   * If the template was defined inline by a direct string literal, then this is that literal\n   * expression. Otherwise `null`, if the template was not defined inline or was not a literal.\n   */\n  inlineTemplateLiteralExpression: o.Expression | null;\n}\n\n/**\n * Compile a component declaration defined by the `R3ComponentMetadata`.\n */\nexport function compileDeclareComponentFromMetadata(\n  meta: R3ComponentMetadata<R3TemplateDependencyMetadata>,\n  template: ParsedTemplate,\n  additionalTemplateInfo: DeclareComponentTemplateInfo,\n): R3CompiledExpression {\n  const definitionMap = createComponentDefinitionMap(meta, template, additionalTemplateInfo);\n\n  const expression = o.importExpr(R3.declareComponent).callFn([definitionMap.toLiteralMap()]);\n  const type = createComponentType(meta);\n\n  return {expression, type, statements: []};\n}\n\n/**\n * Gathers the declaration fields for a component into a `DefinitionMap`.\n */\nexport function createComponentDefinitionMap(\n  meta: R3ComponentMetadata<R3TemplateDependencyMetadata>,\n  template: ParsedTemplate,\n  templateInfo: DeclareComponentTemplateInfo,\n): DefinitionMap<R3DeclareComponentMetadata> {\n  const definitionMap: DefinitionMap<R3DeclareComponentMetadata> =\n    createDirectiveDefinitionMap(meta);\n  const blockVisitor = new BlockPresenceVisitor();\n  visitAll(blockVisitor, template.nodes);\n\n  definitionMap.set('template', getTemplateExpression(template, templateInfo));\n\n  if (templateInfo.isInline) {\n    definitionMap.set('isInline', o.literal(true));\n  }\n\n  // Set the minVersion to 17.0.0 if the component is using at least one block in its template.\n  // We don't do this for templates without blocks, in order to preserve backwards compatibility.\n  if (blockVisitor.hasBlocks) {\n    definitionMap.set('minVersion', o.literal('17.0.0'));\n  }\n\n  definitionMap.set('styles', toOptionalLiteralArray(meta.styles, o.literal));\n  definitionMap.set('dependencies', compileUsedDependenciesMetadata(meta));\n  definitionMap.set('viewProviders', meta.viewProviders);\n  definitionMap.set('animations', meta.animations);\n\n  if (meta.changeDetection !== null) {\n    if (typeof meta.changeDetection === 'object') {\n      throw new Error('Impossible state! Change detection flag is not resolved!');\n    }\n\n    definitionMap.set(\n      'changeDetection',\n      o\n        .importExpr(R3.ChangeDetectionStrategy)\n        .prop(core.ChangeDetectionStrategy[meta.changeDetection]),\n    );\n  }\n  if (meta.encapsulation !== core.ViewEncapsulation.Emulated) {\n    definitionMap.set(\n      'encapsulation',\n      o.importExpr(R3.ViewEncapsulation).prop(core.ViewEncapsulation[meta.encapsulation]),\n    );\n  }\n  if (meta.interpolation !== DEFAULT_INTERPOLATION_CONFIG) {\n    definitionMap.set(\n      'interpolation',\n      o.literalArr([o.literal(meta.interpolation.start), o.literal(meta.interpolation.end)]),\n    );\n  }\n\n  if (template.preserveWhitespaces === true) {\n    definitionMap.set('preserveWhitespaces', o.literal(true));\n  }\n\n  if (meta.defer.mode === DeferBlockDepsEmitMode.PerBlock) {\n    const resolvers: o.Expression[] = [];\n    let hasResolvers = false;\n\n    for (const deps of meta.defer.blocks.values()) {\n      // Note: we need to push a `null` even if there are no dependencies, because matching of\n      // defer resolver functions to defer blocks happens by index and not adding an array\n      // entry for a block can throw off the blocks coming after it.\n      if (deps === null) {\n        resolvers.push(o.literal(null));\n      } else {\n        resolvers.push(deps);\n        hasResolvers = true;\n      }\n    }\n    // If *all* the resolvers are null, we can skip the field.\n    if (hasResolvers) {\n      definitionMap.set('deferBlockDependencies', o.literalArr(resolvers));\n    }\n  } else {\n    throw new Error('Unsupported defer function emit mode in partial compilation');\n  }\n\n  return definitionMap;\n}\n\nfunction getTemplateExpression(\n  template: ParsedTemplate,\n  templateInfo: DeclareComponentTemplateInfo,\n): o.Expression {\n  // If the template has been defined using a direct literal, we use that expression directly\n  // without any modifications. This is ensures proper source mapping from the partially\n  // compiled code to the source file declaring the template. Note that this does not capture\n  // template literals referenced indirectly through an identifier.\n  if (templateInfo.inlineTemplateLiteralExpression !== null) {\n    return templateInfo.inlineTemplateLiteralExpression;\n  }\n\n  // If the template is defined inline but not through a literal, the template has been resolved\n  // through static interpretation. We create a literal but cannot provide any source span. Note\n  // that we cannot use the expression defining the template because the linker expects the template\n  // to be defined as a literal in the declaration.\n  if (templateInfo.isInline) {\n    return o.literal(templateInfo.content, null, null);\n  }\n\n  // The template is external so we must synthesize an expression node with\n  // the appropriate source-span.\n  const contents = templateInfo.content;\n  const file = new ParseSourceFile(contents, templateInfo.sourceUrl);\n  const start = new ParseLocation(file, 0, 0, 0);\n  const end = computeEndLocation(file, contents);\n  const span = new ParseSourceSpan(start, end);\n  return o.literal(contents, null, span);\n}\n\nfunction computeEndLocation(file: ParseSourceFile, contents: string): ParseLocation {\n  const length = contents.length;\n  let lineStart = 0;\n  let lastLineStart = 0;\n  let line = 0;\n  do {\n    lineStart = contents.indexOf('\\n', lastLineStart);\n    if (lineStart !== -1) {\n      lastLineStart = lineStart + 1;\n      line++;\n    }\n  } while (lineStart !== -1);\n\n  return new ParseLocation(file, length, line, length - lastLineStart);\n}\n\nfunction compileUsedDependenciesMetadata(\n  meta: R3ComponentMetadata<R3TemplateDependencyMetadata>,\n): o.LiteralArrayExpr | null {\n  const wrapType =\n    meta.declarationListEmitMode !== DeclarationListEmitMode.Direct\n      ? generateForwardRef\n      : (expr: o.Expression) => expr;\n\n  if (meta.declarationListEmitMode === DeclarationListEmitMode.RuntimeResolved) {\n    throw new Error(`Unsupported emit mode`);\n  }\n\n  return toOptionalLiteralArray(meta.declarations, (decl) => {\n    switch (decl.kind) {\n      case R3TemplateDependencyKind.Directive:\n        const dirMeta = new DefinitionMap<R3DeclareDirectiveDependencyMetadata>();\n        dirMeta.set('kind', o.literal(decl.isComponent ? 'component' : 'directive'));\n        dirMeta.set('type', wrapType(decl.type));\n        dirMeta.set('selector', o.literal(decl.selector));\n        dirMeta.set('inputs', toOptionalLiteralArray(decl.inputs, o.literal));\n        dirMeta.set('outputs', toOptionalLiteralArray(decl.outputs, o.literal));\n        dirMeta.set('exportAs', toOptionalLiteralArray(decl.exportAs, o.literal));\n        return dirMeta.toLiteralMap();\n      case R3TemplateDependencyKind.Pipe:\n        const pipeMeta = new DefinitionMap<R3DeclarePipeDependencyMetadata>();\n        pipeMeta.set('kind', o.literal('pipe'));\n        pipeMeta.set('type', wrapType(decl.type));\n        pipeMeta.set('name', o.literal(decl.name));\n        return pipeMeta.toLiteralMap();\n      case R3TemplateDependencyKind.NgModule:\n        const ngModuleMeta = new DefinitionMap<R3DeclareNgModuleDependencyMetadata>();\n        ngModuleMeta.set('kind', o.literal('ngmodule'));\n        ngModuleMeta.set('type', wrapType(decl.type));\n        return ngModuleMeta.toLiteralMap();\n    }\n  });\n}\n\nclass BlockPresenceVisitor extends RecursiveVisitor {\n  hasBlocks = false;\n\n  override visitDeferredBlock(): void {\n    this.hasBlocks = true;\n  }\n\n  override visitDeferredBlockPlaceholder(): void {\n    this.hasBlocks = true;\n  }\n\n  override visitDeferredBlockLoading(): void {\n    this.hasBlocks = true;\n  }\n\n  override visitDeferredBlockError(): void {\n    this.hasBlocks = true;\n  }\n\n  override visitIfBlock(): void {\n    this.hasBlocks = true;\n  }\n\n  override visitIfBlockBranch(): void {\n    this.hasBlocks = true;\n  }\n\n  override visitForLoopBlock(): void {\n    this.hasBlocks = true;\n  }\n\n  override visitForLoopBlockEmpty(): void {\n    this.hasBlocks = true;\n  }\n\n  override visitSwitchBlock(): void {\n    this.hasBlocks = true;\n  }\n\n  override visitSwitchBlockCase(): void {\n    this.hasBlocks = true;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport {FactoryTarget} from '../../compiler_facade_interface';\nimport * as o from '../../output/output_ast';\nimport {createFactoryType, R3FactoryMetadata} from '../r3_factory';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {R3CompiledExpression} from '../util';\nimport {DefinitionMap} from '../view/util';\n\nimport {R3DeclareFactoryMetadata} from './api';\nimport {compileDependencies} from './util';\n\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION = '12.0.0';\n\nexport function compileDeclareFactoryFunction(meta: R3FactoryMetadata): R3CompiledExpression {\n  const definitionMap = new DefinitionMap<R3DeclareFactoryMetadata>();\n  definitionMap.set('minVersion', o.literal(MINIMUM_PARTIAL_LINKER_VERSION));\n  definitionMap.set('version', o.literal('20.3.6'));\n  definitionMap.set('ngImport', o.importExpr(R3.core));\n  definitionMap.set('type', meta.type.value);\n  definitionMap.set('deps', compileDependencies(meta.deps));\n  definitionMap.set('target', o.importExpr(R3.FactoryTarget).prop(FactoryTarget[meta.target]));\n\n  return {\n    expression: o.importExpr(R3.declareFactory).callFn([definitionMap.toLiteralMap()]),\n    statements: [],\n    type: createFactoryType(meta),\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport {createInjectableType, R3InjectableMetadata} from '../../injectable_compiler_2';\nimport * as o from '../../output/output_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {convertFromMaybeForwardRefExpression, R3CompiledExpression} from '../util';\nimport {DefinitionMap} from '../view/util';\n\nimport {R3DeclareInjectableMetadata} from './api';\nimport {compileDependency} from './util';\n\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION = '12.0.0';\n\n/**\n * Compile a Injectable declaration defined by the `R3InjectableMetadata`.\n */\nexport function compileDeclareInjectableFromMetadata(\n  meta: R3InjectableMetadata,\n): R3CompiledExpression {\n  const definitionMap = createInjectableDefinitionMap(meta);\n\n  const expression = o.importExpr(R3.declareInjectable).callFn([definitionMap.toLiteralMap()]);\n  const type = createInjectableType(meta);\n\n  return {expression, type, statements: []};\n}\n\n/**\n * Gathers the declaration fields for a Injectable into a `DefinitionMap`.\n */\nexport function createInjectableDefinitionMap(\n  meta: R3InjectableMetadata,\n): DefinitionMap<R3DeclareInjectableMetadata> {\n  const definitionMap = new DefinitionMap<R3DeclareInjectableMetadata>();\n\n  definitionMap.set('minVersion', o.literal(MINIMUM_PARTIAL_LINKER_VERSION));\n  definitionMap.set('version', o.literal('20.3.6'));\n  definitionMap.set('ngImport', o.importExpr(R3.core));\n  definitionMap.set('type', meta.type.value);\n\n  // Only generate providedIn property if it has a non-null value\n  if (meta.providedIn !== undefined) {\n    const providedIn = convertFromMaybeForwardRefExpression(meta.providedIn);\n    if ((providedIn as o.LiteralExpr).value !== null) {\n      definitionMap.set('providedIn', providedIn);\n    }\n  }\n\n  if (meta.useClass !== undefined) {\n    definitionMap.set('useClass', convertFromMaybeForwardRefExpression(meta.useClass));\n  }\n  if (meta.useExisting !== undefined) {\n    definitionMap.set('useExisting', convertFromMaybeForwardRefExpression(meta.useExisting));\n  }\n  if (meta.useValue !== undefined) {\n    definitionMap.set('useValue', convertFromMaybeForwardRefExpression(meta.useValue));\n  }\n  // Factories do not contain `ForwardRef`s since any types are already wrapped in a function call\n  // so the types will not be eagerly evaluated. Therefore we do not need to process this expression\n  // with `convertFromProviderExpression()`.\n  if (meta.useFactory !== undefined) {\n    definitionMap.set('useFactory', meta.useFactory);\n  }\n\n  if (meta.deps !== undefined) {\n    definitionMap.set('deps', o.literalArr(meta.deps.map(compileDependency)));\n  }\n\n  return definitionMap;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport * as o from '../../output/output_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {createInjectorType, R3InjectorMetadata} from '../r3_injector_compiler';\nimport {R3CompiledExpression} from '../util';\nimport {DefinitionMap} from '../view/util';\n\nimport {R3DeclareInjectorMetadata} from './api';\n\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION = '12.0.0';\n\nexport function compileDeclareInjectorFromMetadata(meta: R3InjectorMetadata): R3CompiledExpression {\n  const definitionMap = createInjectorDefinitionMap(meta);\n\n  const expression = o.importExpr(R3.declareInjector).callFn([definitionMap.toLiteralMap()]);\n  const type = createInjectorType(meta);\n\n  return {expression, type, statements: []};\n}\n\n/**\n * Gathers the declaration fields for an Injector into a `DefinitionMap`.\n */\nfunction createInjectorDefinitionMap(\n  meta: R3InjectorMetadata,\n): DefinitionMap<R3DeclareInjectorMetadata> {\n  const definitionMap = new DefinitionMap<R3DeclareInjectorMetadata>();\n\n  definitionMap.set('minVersion', o.literal(MINIMUM_PARTIAL_LINKER_VERSION));\n  definitionMap.set('version', o.literal('20.3.6'));\n  definitionMap.set('ngImport', o.importExpr(R3.core));\n\n  definitionMap.set('type', meta.type.value);\n  definitionMap.set('providers', meta.providers);\n  if (meta.imports.length > 0) {\n    definitionMap.set('imports', o.literalArr(meta.imports));\n  }\n\n  return definitionMap;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport * as o from '../../output/output_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {\n  createNgModuleType,\n  R3NgModuleMetadata,\n  R3NgModuleMetadataKind,\n} from '../r3_module_compiler';\nimport {R3CompiledExpression, refsToArray} from '../util';\nimport {DefinitionMap} from '../view/util';\n\nimport {R3DeclareNgModuleMetadata} from './api';\n\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION = '14.0.0';\n\nexport function compileDeclareNgModuleFromMetadata(meta: R3NgModuleMetadata): R3CompiledExpression {\n  const definitionMap = createNgModuleDefinitionMap(meta);\n\n  const expression = o.importExpr(R3.declareNgModule).callFn([definitionMap.toLiteralMap()]);\n  const type = createNgModuleType(meta);\n\n  return {expression, type, statements: []};\n}\n\n/**\n * Gathers the declaration fields for an NgModule into a `DefinitionMap`.\n */\nfunction createNgModuleDefinitionMap(\n  meta: R3NgModuleMetadata,\n): DefinitionMap<R3DeclareNgModuleMetadata> {\n  const definitionMap = new DefinitionMap<R3DeclareNgModuleMetadata>();\n\n  if (meta.kind === R3NgModuleMetadataKind.Local) {\n    throw new Error(\n      'Invalid path! Local compilation mode should not get into the partial compilation path',\n    );\n  }\n\n  definitionMap.set('minVersion', o.literal(MINIMUM_PARTIAL_LINKER_VERSION));\n  definitionMap.set('version', o.literal('20.3.6'));\n  definitionMap.set('ngImport', o.importExpr(R3.core));\n  definitionMap.set('type', meta.type.value);\n\n  // We only generate the keys in the metadata if the arrays contain values.\n\n  // We must wrap the arrays inside a function if any of the values are a forward reference to a\n  // not-yet-declared class. This is to support JIT execution of the `ɵɵngDeclareNgModule()` call.\n  // In the linker these wrappers are stripped and then reapplied for the `ɵɵdefineNgModule()` call.\n\n  if (meta.bootstrap.length > 0) {\n    definitionMap.set('bootstrap', refsToArray(meta.bootstrap, meta.containsForwardDecls));\n  }\n\n  if (meta.declarations.length > 0) {\n    definitionMap.set('declarations', refsToArray(meta.declarations, meta.containsForwardDecls));\n  }\n\n  if (meta.imports.length > 0) {\n    definitionMap.set('imports', refsToArray(meta.imports, meta.containsForwardDecls));\n  }\n\n  if (meta.exports.length > 0) {\n    definitionMap.set('exports', refsToArray(meta.exports, meta.containsForwardDecls));\n  }\n\n  if (meta.schemas !== null && meta.schemas.length > 0) {\n    definitionMap.set('schemas', o.literalArr(meta.schemas.map((ref) => ref.value)));\n  }\n\n  if (meta.id !== null) {\n    definitionMap.set('id', meta.id);\n  }\n\n  return definitionMap;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport * as o from '../../output/output_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {createPipeType, R3PipeMetadata} from '../r3_pipe_compiler';\nimport {R3CompiledExpression} from '../util';\nimport {DefinitionMap} from '../view/util';\n\nimport {R3DeclarePipeMetadata} from './api';\n\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION = '14.0.0';\n\n/**\n * Compile a Pipe declaration defined by the `R3PipeMetadata`.\n */\nexport function compileDeclarePipeFromMetadata(meta: R3PipeMetadata): R3CompiledExpression {\n  const definitionMap = createPipeDefinitionMap(meta);\n\n  const expression = o.importExpr(R3.declarePipe).callFn([definitionMap.toLiteralMap()]);\n  const type = createPipeType(meta);\n\n  return {expression, type, statements: []};\n}\n\n/**\n * Gathers the declaration fields for a Pipe into a `DefinitionMap`.\n */\nexport function createPipeDefinitionMap(\n  meta: R3PipeMetadata,\n): DefinitionMap<R3DeclarePipeMetadata> {\n  const definitionMap = new DefinitionMap<R3DeclarePipeMetadata>();\n\n  definitionMap.set('minVersion', o.literal(MINIMUM_PARTIAL_LINKER_VERSION));\n  definitionMap.set('version', o.literal('20.3.6'));\n  definitionMap.set('ngImport', o.importExpr(R3.core));\n\n  // e.g. `type: MyPipe`\n  definitionMap.set('type', meta.type.value);\n\n  if (meta.isStandalone !== undefined) {\n    definitionMap.set('isStandalone', o.literal(meta.isStandalone));\n  }\n\n  // e.g. `name: \"myPipe\"`\n  definitionMap.set('name', o.literal(meta.pipeName ?? meta.name));\n\n  if (meta.pure === false) {\n    // e.g. `pure: false`\n    definitionMap.set('pure', o.literal(meta.pure));\n  }\n\n  return definitionMap;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {mapLiteral} from '../output/map_util';\nimport * as o from '../output/output_ast';\n\nimport {Identifiers as R3} from './r3_identifiers';\nimport {devOnlyGuardedExpression} from './util';\n\n/**\n * Info needed for runtime errors related to a class, such as the location in which the class is\n * defined.\n */\nexport interface R3ClassDebugInfo {\n  /** The class identifier */\n  type: o.Expression;\n\n  /**\n   * A string literal containing the original class name as appears in its definition.\n   */\n  className: o.Expression;\n\n  /**\n   * A string literal containing the relative path of the file in which the class is defined.\n   *\n   * The path is relative to the project root. The compiler does the best effort to find the project\n   * root (e.g., using the rootDir of tsconfig), but if it fails this field is set to null,\n   * indicating that the file path was failed to be computed. In this case, the downstream consumers\n   * of the debug info will usually ignore the `lineNumber` field as well and just show the\n   * `className`. For security reasons we never show the absolute file path and prefer to just\n   * return null here.\n   */\n  filePath: o.Expression | null;\n\n  /**\n   * A number literal number containing the line number in which this class is defined.\n   */\n  lineNumber: o.Expression;\n\n  /**\n   * Whether to check if this component is being rendered without its NgModule being loaded into the\n   * browser. Such checks is carried out only in dev mode.\n   */\n  forbidOrphanRendering: boolean;\n}\n\n/**\n * Generate an ngDevMode guarded call to setClassDebugInfo with the debug info about the class\n * (e.g., the file name in which the class is defined)\n */\nexport function compileClassDebugInfo(debugInfo: R3ClassDebugInfo): o.Expression {\n  const debugInfoObject: {\n    className: o.Expression;\n    filePath?: o.Expression;\n    lineNumber?: o.Expression;\n    forbidOrphanRendering?: o.Expression;\n  } = {\n    className: debugInfo.className,\n  };\n\n  // Include file path and line number only if the file relative path is calculated successfully.\n  if (debugInfo.filePath) {\n    debugInfoObject.filePath = debugInfo.filePath;\n    debugInfoObject.lineNumber = debugInfo.lineNumber;\n  }\n\n  // Include forbidOrphanRendering only if it's set to true (to reduce generated code)\n  if (debugInfo.forbidOrphanRendering) {\n    debugInfoObject.forbidOrphanRendering = o.literal(true);\n  }\n\n  const fnCall = o\n    .importExpr(R3.setClassDebugInfo)\n    .callFn([debugInfo.type, mapLiteral(debugInfoObject)]);\n  const iife = o.arrowFn([], [devOnlyGuardedExpression(fnCall).toStmt()]);\n  return iife.callFn([]);\n}\n","/*!\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as o from '../output/output_ast';\nimport {Identifiers as R3} from './r3_identifiers';\nimport {devOnlyGuardedExpression} from './util';\n\n/** Metadata necessary to compile HMR-related code call. */\nexport interface R3HmrMetadata {\n  /** Component class for which HMR is being enabled. */\n  type: o.Expression;\n\n  /** Name of the component class. */\n  className: string;\n\n  /** File path of the component class. */\n  filePath: string;\n\n  /**\n   * When the compiler generates new imports, they get produced as namespace imports\n   * (e.g. import * as i0 from '@angular/core'). These namespaces have to be captured and passed\n   * along to the update callback.\n   */\n  namespaceDependencies: R3HmrNamespaceDependency[];\n\n  /**\n   * HMR update functions cannot contain imports so any locals the generated code depends on\n   * (e.g. references to imports within the same file or imported symbols) have to be passed in\n   * as function parameters. This array contains the names and runtime representation of the locals.\n   */\n  localDependencies: {name: string; runtimeRepresentation: o.Expression}[];\n}\n\n/** HMR dependency on a namespace import. */\nexport interface R3HmrNamespaceDependency {\n  /** Module name of the import. */\n  moduleName: string;\n\n  /**\n   * Name under which to refer to the namespace inside\n   * HMR-related code. Must be a valid JS identifier.\n   */\n  assignedName: string;\n}\n\n/**\n * Compiles the expression that initializes HMR for a class.\n * @param meta HMR metadata extracted from the class.\n */\nexport function compileHmrInitializer(meta: R3HmrMetadata): o.Expression {\n  const moduleName = 'm';\n  const dataName = 'd';\n  const timestampName = 't';\n  const idName = 'id';\n  const importCallbackName = `${meta.className}_HmrLoad`;\n  const namespaces = meta.namespaceDependencies.map((dep) => {\n    return new o.ExternalExpr({moduleName: dep.moduleName, name: null});\n  });\n\n  // m.default\n  const defaultRead = o.variable(moduleName).prop('default');\n\n  // ɵɵreplaceMetadata(Comp, m.default, [...namespaces], [...locals], import.meta, id);\n  const replaceCall = o\n    .importExpr(R3.replaceMetadata)\n    .callFn([\n      meta.type,\n      defaultRead,\n      o.literalArr(namespaces),\n      o.literalArr(meta.localDependencies.map((l) => l.runtimeRepresentation)),\n      o.variable('import').prop('meta'),\n      o.variable(idName),\n    ]);\n\n  // (m) => m.default && ɵɵreplaceMetadata(...)\n  const replaceCallback = o.arrowFn([new o.FnParam(moduleName)], defaultRead.and(replaceCall));\n\n  // getReplaceMetadataURL(id, timestamp, import.meta.url)\n  const url = o\n    .importExpr(R3.getReplaceMetadataURL)\n    .callFn([\n      o.variable(idName),\n      o.variable(timestampName),\n      o.variable('import').prop('meta').prop('url'),\n    ]);\n\n  // function Cmp_HmrLoad(t) {\n  //   import(/* @vite-ignore */ url).then((m) => m.default && replaceMetadata(...));\n  // }\n  const importCallback = new o.DeclareFunctionStmt(\n    importCallbackName,\n    [new o.FnParam(timestampName)],\n    [\n      // The vite-ignore special comment is required to prevent Vite from generating a superfluous\n      // warning for each usage within the development code. If Vite provides a method to\n      // programmatically avoid this warning in the future, this added comment can be removed here.\n      new o.DynamicImportExpr(url, null, '@vite-ignore')\n        .prop('then')\n        .callFn([replaceCallback])\n        .toStmt(),\n    ],\n    null,\n    o.StmtModifier.Final,\n  );\n\n  // (d) => d.id === id && Cmp_HmrLoad(d.timestamp)\n  const updateCallback = o.arrowFn(\n    [new o.FnParam(dataName)],\n    o\n      .variable(dataName)\n      .prop('id')\n      .identical(o.variable(idName))\n      .and(o.variable(importCallbackName).callFn([o.variable(dataName).prop('timestamp')])),\n  );\n\n  // Cmp_HmrLoad(Date.now());\n  // Initial call to kick off the loading in order to avoid edge cases with components\n  // coming from lazy chunks that change before the chunk has loaded.\n  const initialCall = o\n    .variable(importCallbackName)\n    .callFn([o.variable('Date').prop('now').callFn([])]);\n\n  // import.meta.hot\n  const hotRead = o.variable('import').prop('meta').prop('hot');\n\n  // import.meta.hot.on('angular:component-update', () => ...);\n  const hotListener = hotRead\n    .clone()\n    .prop('on')\n    .callFn([o.literal('angular:component-update'), updateCallback]);\n\n  return o\n    .arrowFn(\n      [],\n      [\n        // const id = <id>;\n        new o.DeclareVarStmt(\n          idName,\n          o.literal(encodeURIComponent(`${meta.filePath}@${meta.className}`)),\n          null,\n          o.StmtModifier.Final,\n        ),\n        // function Cmp_HmrLoad() {...}.\n        importCallback,\n        // ngDevMode && Cmp_HmrLoad(Date.now());\n        devOnlyGuardedExpression(initialCall).toStmt(),\n        // ngDevMode && import.meta.hot && import.meta.hot.on(...)\n        devOnlyGuardedExpression(hotRead.and(hotListener)).toStmt(),\n      ],\n    )\n    .callFn([]);\n}\n\n/**\n * Compiles the HMR update callback for a class.\n * @param definitions Compiled definitions for the class (e.g. `defineComponent` calls).\n * @param constantStatements Supporting constants statements that were generated alongside\n *  the definition.\n * @param meta HMR metadata extracted from the class.\n */\nexport function compileHmrUpdateCallback(\n  definitions: {name: string; initializer: o.Expression | null; statements: o.Statement[]}[],\n  constantStatements: o.Statement[],\n  meta: R3HmrMetadata,\n): o.DeclareFunctionStmt {\n  const namespaces = 'ɵɵnamespaces';\n  const params = [meta.className, namespaces].map((name) => new o.FnParam(name, o.DYNAMIC_TYPE));\n  const body: o.Statement[] = [];\n\n  for (const local of meta.localDependencies) {\n    params.push(new o.FnParam(local.name));\n  }\n\n  // Declare variables that read out the individual namespaces.\n  for (let i = 0; i < meta.namespaceDependencies.length; i++) {\n    body.push(\n      new o.DeclareVarStmt(\n        meta.namespaceDependencies[i].assignedName,\n        o.variable(namespaces).key(o.literal(i)),\n        o.DYNAMIC_TYPE,\n        o.StmtModifier.Final,\n      ),\n    );\n  }\n\n  body.push(...constantStatements);\n\n  for (const field of definitions) {\n    if (field.initializer !== null) {\n      body.push(o.variable(meta.className).prop(field.name).set(field.initializer).toStmt());\n\n      for (const stmt of field.statements) {\n        body.push(stmt);\n      }\n    }\n  }\n\n  return new o.DeclareFunctionStmt(\n    `${meta.className}_UpdateMetadata`,\n    params,\n    body,\n    null,\n    o.StmtModifier.Final,\n  );\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of the compiler package.\n */\n\nimport {Version} from './util';\n\nexport const VERSION = new Version('20.3.6');\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n//////////////////////////////////////\n// THIS FILE HAS GLOBAL SIDE EFFECT //\n//       (see bottom of file)       //\n//////////////////////////////////////\n\n/**\n * @module\n * @description\n * Entry point for all APIs of the compiler package.\n *\n * <div class=\"callout is-critical\">\n *   <header>Unstable APIs</header>\n *   <p>\n *     All compiler apis are currently considered experimental and private!\n *   </p>\n *   <p>\n *     We expect the APIs in this package to keep on changing. Do not rely on them.\n *   </p>\n * </div>\n */\n\nimport * as core from './core';\nimport {publishFacade} from './jit_compiler_facade';\nimport * as outputAst from './output/output_ast';\nimport {global} from './util';\n\nexport {SECURITY_SCHEMA} from './schema/dom_security_schema';\nexport {CUSTOM_ELEMENTS_SCHEMA, NO_ERRORS_SCHEMA, SchemaMetadata} from './core';\nexport {core};\n\nexport {CompilerConfig, preserveWhitespacesDefault} from './config';\nexport {ConstantPool} from './constant_pool';\nexport {\n  ChangeDetectionStrategy,\n  emitDistinctChangesOnlyDefaultValue,\n  ViewEncapsulation,\n} from './core';\nexport * from './expression_parser/ast';\nexport * from './expression_parser/lexer';\nexport * from './expression_parser/parser';\nexport * from './i18n/index';\nexport * from './injectable_compiler_2';\nexport {publishFacade} from './jit_compiler_facade';\nexport * from './ml_parser/ast';\nexport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from './ml_parser/defaults';\nexport * from './ml_parser/html_parser';\nexport * from './ml_parser/html_tags';\nexport {LexerRange} from './ml_parser/lexer';\nexport {ParseTreeResult, TreeError} from './ml_parser/parser';\nexport * from './ml_parser/tags';\nexport {TokenType as LexerTokenType} from './ml_parser/tokens';\nexport * from './ml_parser/xml_parser';\nexport {EmitterVisitorContext} from './output/abstract_emitter';\nexport {\n  ArrayType,\n  ArrowFunctionExpr,\n  BinaryOperator,\n  BinaryOperatorExpr,\n  BuiltinType,\n  BuiltinTypeName,\n  CommaExpr,\n  ConditionalExpr,\n  DeclareFunctionStmt,\n  DeclareVarStmt,\n  DYNAMIC_TYPE,\n  DynamicImportExpr,\n  Expression,\n  ExpressionStatement,\n  ExpressionType,\n  ExpressionVisitor,\n  ExternalExpr,\n  ExternalReference,\n  FunctionExpr,\n  IfStmt,\n  InstantiateExpr,\n  InvokeFunctionExpr,\n  jsDocComment,\n  JSDocComment,\n  leadingComment,\n  LeadingComment,\n  literal,\n  LiteralArrayExpr,\n  LiteralExpr,\n  literalMap,\n  LiteralMapExpr,\n  LocalizedString,\n  MapType,\n  NONE_TYPE,\n  NotExpr,\n  ParenthesizedExpr,\n  ReadKeyExpr,\n  ReadPropExpr,\n  ReadVarExpr,\n  ReturnStatement,\n  Statement,\n  StatementVisitor,\n  StmtModifier,\n  STRING_TYPE,\n  TaggedTemplateLiteralExpr,\n  TemplateLiteralElementExpr,\n  TemplateLiteralExpr,\n  TransplantedType,\n  Type,\n  TypeModifier,\n  TypeofExpr,\n  TypeVisitor,\n  UnaryOperator,\n  UnaryOperatorExpr,\n  VoidExpr,\n  WrappedNodeExpr,\n} from './output/output_ast';\nexport {JitEvaluator} from './output/output_jit';\nexport {SourceMap} from './output/source_map';\nexport * from './parse_util';\nexport * from './render3/partial/api';\nexport {\n  compileComponentDeclareClassMetadata,\n  compileDeclareClassMetadata,\n} from './render3/partial/class_metadata';\nexport {\n  compileDeclareComponentFromMetadata,\n  DeclareComponentTemplateInfo,\n} from './render3/partial/component';\nexport {compileDeclareDirectiveFromMetadata} from './render3/partial/directive';\nexport {compileDeclareFactoryFunction} from './render3/partial/factory';\nexport {compileDeclareInjectableFromMetadata} from './render3/partial/injectable';\nexport {compileDeclareInjectorFromMetadata} from './render3/partial/injector';\nexport {compileDeclareNgModuleFromMetadata} from './render3/partial/ng_module';\nexport {compileDeclarePipeFromMetadata} from './render3/partial/pipe';\nexport {\n  BlockNode as TmplAstBlockNode,\n  BoundAttribute as TmplAstBoundAttribute,\n  BoundDeferredTrigger as TmplAstBoundDeferredTrigger,\n  BoundEvent as TmplAstBoundEvent,\n  BoundText as TmplAstBoundText,\n  Content as TmplAstContent,\n  DeferredBlock as TmplAstDeferredBlock,\n  DeferredBlockError as TmplAstDeferredBlockError,\n  DeferredBlockLoading as TmplAstDeferredBlockLoading,\n  DeferredBlockPlaceholder as TmplAstDeferredBlockPlaceholder,\n  DeferredBlockTriggers as TmplAstDeferredBlockTriggers,\n  DeferredTrigger as TmplAstDeferredTrigger,\n  Element as TmplAstElement,\n  ForLoopBlock as TmplAstForLoopBlock,\n  ForLoopBlockEmpty as TmplAstForLoopBlockEmpty,\n  HoverDeferredTrigger as TmplAstHoverDeferredTrigger,\n  Icu as TmplAstIcu,\n  IdleDeferredTrigger as TmplAstIdleDeferredTrigger,\n  IfBlock as TmplAstIfBlock,\n  IfBlockBranch as TmplAstIfBlockBranch,\n  ImmediateDeferredTrigger as TmplAstImmediateDeferredTrigger,\n  InteractionDeferredTrigger as TmplAstInteractionDeferredTrigger,\n  LetDeclaration as TmplAstLetDeclaration,\n  NeverDeferredTrigger as TmplAstNeverDeferredTrigger,\n  Node as TmplAstNode,\n  RecursiveVisitor as TmplAstRecursiveVisitor,\n  Reference as TmplAstReference,\n  SwitchBlock as TmplAstSwitchBlock,\n  SwitchBlockCase as TmplAstSwitchBlockCase,\n  Template as TmplAstTemplate,\n  Text as TmplAstText,\n  TextAttribute as TmplAstTextAttribute,\n  TimerDeferredTrigger as TmplAstTimerDeferredTrigger,\n  UnknownBlock as TmplAstUnknownBlock,\n  Variable as TmplAstVariable,\n  ViewportDeferredTrigger as TmplAstViewportDeferredTrigger,\n  HostElement as TmplAstHostElement,\n  Component as TmplAstComponent,\n  Directive as TmplAstDirective,\n  visitAll as tmplAstVisitAll,\n  Visitor as TmplAstVisitor,\n} from './render3/r3_ast';\nexport {compileClassDebugInfo, R3ClassDebugInfo} from './render3/r3_class_debug_info_compiler';\nexport {\n  compileClassMetadata,\n  CompileClassMetadataFn,\n  compileComponentClassMetadata,\n  compileOpaqueAsyncClassMetadata,\n  R3ClassMetadata,\n} from './render3/r3_class_metadata_compiler';\nexport {\n  compileFactoryFunction,\n  R3DependencyMetadata,\n  R3FactoryMetadata,\n} from './render3/r3_factory';\nexport {\n  compileHmrInitializer,\n  compileHmrUpdateCallback,\n  R3HmrMetadata,\n  R3HmrNamespaceDependency,\n} from './render3/r3_hmr_compiler';\nexport {Identifiers as R3Identifiers} from './render3/r3_identifiers';\nexport {compileInjector, R3InjectorMetadata} from './render3/r3_injector_compiler';\nexport {\n  compileNgModule,\n  R3NgModuleMetadata,\n  R3NgModuleMetadataGlobal,\n  R3NgModuleMetadataKind,\n  R3SelectorScopeMode,\n} from './render3/r3_module_compiler';\nexport {compilePipeFromMetadata, R3PipeMetadata} from './render3/r3_pipe_compiler';\nexport {\n  createMayBeForwardRefExpression,\n  devOnlyGuardedExpression,\n  ForwardRefHandling,\n  getSafePropertyAccessString,\n  MaybeForwardRefExpression,\n  R3CompiledExpression,\n  R3Reference,\n} from './render3/util';\nexport * from './render3/view/api';\nexport {\n  compileComponentFromMetadata,\n  compileDeferResolverFunction,\n  compileDirectiveFromMetadata,\n  encapsulateStyle,\n  ParsedHostBindings,\n  parseHostBindings,\n  verifyHostBindings,\n} from './render3/view/compiler';\nexport * from './render3/view/t2_api';\nexport * from './render3/view/t2_binder';\nexport {\n  makeBindingParser,\n  ParsedTemplate,\n  parseTemplate,\n  ParseTemplateOptions,\n} from './render3/view/template';\nexport {CombinedRecursiveAstVisitor} from './combined_visitor';\n\n// Note: BindingParser is intentionally exported as a type only, because it should\n// be constructed through `makeBindingParser`, rather than its constructor.\nexport {type BindingParser} from './template_parser/binding_parser';\nexport {createCssSelectorFromNode} from './render3/view/util';\nexport * from './resource_loader';\nexport * from './schema/dom_element_schema_registry';\nexport * from './schema/element_schema_registry';\nexport * from './directive_matching';\nexport {Version, escapeRegExp} from './util';\nexport * from './version';\nexport {outputAst};\nexport {CompilerFacadeImpl} from './jit_compiler_facade';\nexport {FactoryTarget} from './compiler_facade_interface';\nexport {QueryFlags} from './render3/view/query_generation';\nexport {setEnableTemplateSourceLocations} from './render3/view/config';\n\n// This file only reexports content of the `src` folder. Keep it that way.\n\n// This function call has a global side effects and publishes the compiler into global namespace for\n// the late binding of the Compiler to the @angular/core for jit compilation.\npublishFacade(global);\n","'use strict';\n/**\n * @license Angular v<unknown>\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\nconst global = globalThis;\n// __Zone_symbol_prefix global can be used to override the default zone\n// symbol prefix with a custom one if needed.\nfunction __symbol__(name) {\n    const symbolPrefix = global['__Zone_symbol_prefix'] || '__zone_symbol__';\n    return symbolPrefix + name;\n}\nfunction initZone() {\n    const performance = global['performance'];\n    function mark(name) {\n        performance && performance['mark'] && performance['mark'](name);\n    }\n    function performanceMeasure(name, label) {\n        performance && performance['measure'] && performance['measure'](name, label);\n    }\n    mark('Zone');\n    class ZoneImpl {\n        static __symbol__ = __symbol__;\n        static assertZonePatched() {\n            if (global['Promise'] !== patches['ZoneAwarePromise']) {\n                throw new Error('Zone.js has detected that ZoneAwarePromise `(window|global).Promise` ' +\n                    'has been overwritten.\\n' +\n                    'Most likely cause is that a Promise polyfill has been loaded ' +\n                    'after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. ' +\n                    'If you must load one, do so before loading zone.js.)');\n            }\n        }\n        static get root() {\n            let zone = ZoneImpl.current;\n            while (zone.parent) {\n                zone = zone.parent;\n            }\n            return zone;\n        }\n        static get current() {\n            return _currentZoneFrame.zone;\n        }\n        static get currentTask() {\n            return _currentTask;\n        }\n        static __load_patch(name, fn, ignoreDuplicate = false) {\n            if (patches.hasOwnProperty(name)) {\n                // `checkDuplicate` option is defined from global variable\n                // so it works for all modules.\n                // `ignoreDuplicate` can work for the specified module\n                const checkDuplicate = global[__symbol__('forceDuplicateZoneCheck')] === true;\n                if (!ignoreDuplicate && checkDuplicate) {\n                    throw Error('Already loaded patch: ' + name);\n                }\n            }\n            else if (!global['__Zone_disable_' + name]) {\n                const perfName = 'Zone:' + name;\n                mark(perfName);\n                patches[name] = fn(global, ZoneImpl, _api);\n                performanceMeasure(perfName, perfName);\n            }\n        }\n        get parent() {\n            return this._parent;\n        }\n        get name() {\n            return this._name;\n        }\n        _parent;\n        _name;\n        _properties;\n        _zoneDelegate;\n        constructor(parent, zoneSpec) {\n            this._parent = parent;\n            this._name = zoneSpec ? zoneSpec.name || 'unnamed' : '<root>';\n            this._properties = (zoneSpec && zoneSpec.properties) || {};\n            this._zoneDelegate = new _ZoneDelegate(this, this._parent && this._parent._zoneDelegate, zoneSpec);\n        }\n        get(key) {\n            const zone = this.getZoneWith(key);\n            if (zone)\n                return zone._properties[key];\n        }\n        getZoneWith(key) {\n            let current = this;\n            while (current) {\n                if (current._properties.hasOwnProperty(key)) {\n                    return current;\n                }\n                current = current._parent;\n            }\n            return null;\n        }\n        fork(zoneSpec) {\n            if (!zoneSpec)\n                throw new Error('ZoneSpec required!');\n            return this._zoneDelegate.fork(this, zoneSpec);\n        }\n        wrap(callback, source) {\n            if (typeof callback !== 'function') {\n                throw new Error('Expecting function got: ' + callback);\n            }\n            const _callback = this._zoneDelegate.intercept(this, callback, source);\n            const zone = this;\n            return function () {\n                return zone.runGuarded(_callback, this, arguments, source);\n            };\n        }\n        run(callback, applyThis, applyArgs, source) {\n            _currentZoneFrame = { parent: _currentZoneFrame, zone: this };\n            try {\n                return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);\n            }\n            finally {\n                _currentZoneFrame = _currentZoneFrame.parent;\n            }\n        }\n        runGuarded(callback, applyThis = null, applyArgs, source) {\n            _currentZoneFrame = { parent: _currentZoneFrame, zone: this };\n            try {\n                try {\n                    return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);\n                }\n                catch (error) {\n                    if (this._zoneDelegate.handleError(this, error)) {\n                        throw error;\n                    }\n                }\n            }\n            finally {\n                _currentZoneFrame = _currentZoneFrame.parent;\n            }\n        }\n        runTask(task, applyThis, applyArgs) {\n            if (task.zone != this) {\n                throw new Error('A task can only be run in the zone of creation! (Creation: ' +\n                    (task.zone || NO_ZONE).name +\n                    '; Execution: ' +\n                    this.name +\n                    ')');\n            }\n            const zoneTask = task;\n            // https://github.com/angular/zone.js/issues/778, sometimes eventTask\n            // will run in notScheduled(canceled) state, we should not try to\n            // run such kind of task but just return\n            const { type, data: { isPeriodic = false, isRefreshable = false } = {} } = task;\n            if (task.state === notScheduled && (type === eventTask || type === macroTask)) {\n                return;\n            }\n            const reEntryGuard = task.state != running;\n            reEntryGuard && zoneTask._transitionTo(running, scheduled);\n            const previousTask = _currentTask;\n            _currentTask = zoneTask;\n            _currentZoneFrame = { parent: _currentZoneFrame, zone: this };\n            try {\n                if (type == macroTask && task.data && !isPeriodic && !isRefreshable) {\n                    task.cancelFn = undefined;\n                }\n                try {\n                    return this._zoneDelegate.invokeTask(this, zoneTask, applyThis, applyArgs);\n                }\n                catch (error) {\n                    if (this._zoneDelegate.handleError(this, error)) {\n                        throw error;\n                    }\n                }\n            }\n            finally {\n                // if the task's state is notScheduled or unknown, then it has already been cancelled\n                // we should not reset the state to scheduled\n                const state = task.state;\n                if (state !== notScheduled && state !== unknown) {\n                    if (type == eventTask || isPeriodic || (isRefreshable && state === scheduling)) {\n                        reEntryGuard && zoneTask._transitionTo(scheduled, running, scheduling);\n                    }\n                    else {\n                        const zoneDelegates = zoneTask._zoneDelegates;\n                        this._updateTaskCount(zoneTask, -1);\n                        reEntryGuard && zoneTask._transitionTo(notScheduled, running, notScheduled);\n                        if (isRefreshable) {\n                            zoneTask._zoneDelegates = zoneDelegates;\n                        }\n                    }\n                }\n                _currentZoneFrame = _currentZoneFrame.parent;\n                _currentTask = previousTask;\n            }\n        }\n        scheduleTask(task) {\n            if (task.zone && task.zone !== this) {\n                // check if the task was rescheduled, the newZone\n                // should not be the children of the original zone\n                let newZone = this;\n                while (newZone) {\n                    if (newZone === task.zone) {\n                        throw Error(`can not reschedule task to ${this.name} which is descendants of the original zone ${task.zone.name}`);\n                    }\n                    newZone = newZone.parent;\n                }\n            }\n            task._transitionTo(scheduling, notScheduled);\n            const zoneDelegates = [];\n            task._zoneDelegates = zoneDelegates;\n            task._zone = this;\n            try {\n                task = this._zoneDelegate.scheduleTask(this, task);\n            }\n            catch (err) {\n                // should set task's state to unknown when scheduleTask throw error\n                // because the err may from reschedule, so the fromState maybe notScheduled\n                task._transitionTo(unknown, scheduling, notScheduled);\n                // TODO: @JiaLiPassion, should we check the result from handleError?\n                this._zoneDelegate.handleError(this, err);\n                throw err;\n            }\n            if (task._zoneDelegates === zoneDelegates) {\n                // we have to check because internally the delegate can reschedule the task.\n                this._updateTaskCount(task, 1);\n            }\n            if (task.state == scheduling) {\n                task._transitionTo(scheduled, scheduling);\n            }\n            return task;\n        }\n        scheduleMicroTask(source, callback, data, customSchedule) {\n            return this.scheduleTask(new ZoneTask(microTask, source, callback, data, customSchedule, undefined));\n        }\n        scheduleMacroTask(source, callback, data, customSchedule, customCancel) {\n            return this.scheduleTask(new ZoneTask(macroTask, source, callback, data, customSchedule, customCancel));\n        }\n        scheduleEventTask(source, callback, data, customSchedule, customCancel) {\n            return this.scheduleTask(new ZoneTask(eventTask, source, callback, data, customSchedule, customCancel));\n        }\n        cancelTask(task) {\n            if (task.zone != this)\n                throw new Error('A task can only be cancelled in the zone of creation! (Creation: ' +\n                    (task.zone || NO_ZONE).name +\n                    '; Execution: ' +\n                    this.name +\n                    ')');\n            if (task.state !== scheduled && task.state !== running) {\n                return;\n            }\n            task._transitionTo(canceling, scheduled, running);\n            try {\n                this._zoneDelegate.cancelTask(this, task);\n            }\n            catch (err) {\n                // if error occurs when cancelTask, transit the state to unknown\n                task._transitionTo(unknown, canceling);\n                this._zoneDelegate.handleError(this, err);\n                throw err;\n            }\n            this._updateTaskCount(task, -1);\n            task._transitionTo(notScheduled, canceling);\n            task.runCount = -1;\n            return task;\n        }\n        _updateTaskCount(task, count) {\n            const zoneDelegates = task._zoneDelegates;\n            if (count == -1) {\n                task._zoneDelegates = null;\n            }\n            for (let i = 0; i < zoneDelegates.length; i++) {\n                zoneDelegates[i]._updateTaskCount(task.type, count);\n            }\n        }\n    }\n    const DELEGATE_ZS = {\n        name: '',\n        onHasTask: (delegate, _, target, hasTaskState) => delegate.hasTask(target, hasTaskState),\n        onScheduleTask: (delegate, _, target, task) => delegate.scheduleTask(target, task),\n        onInvokeTask: (delegate, _, target, task, applyThis, applyArgs) => delegate.invokeTask(target, task, applyThis, applyArgs),\n        onCancelTask: (delegate, _, target, task) => delegate.cancelTask(target, task),\n    };\n    class _ZoneDelegate {\n        get zone() {\n            return this._zone;\n        }\n        _zone;\n        _taskCounts = {\n            'microTask': 0,\n            'macroTask': 0,\n            'eventTask': 0,\n        };\n        _parentDelegate;\n        _forkDlgt;\n        _forkZS;\n        _forkCurrZone;\n        _interceptDlgt;\n        _interceptZS;\n        _interceptCurrZone;\n        _invokeDlgt;\n        _invokeZS;\n        _invokeCurrZone;\n        _handleErrorDlgt;\n        _handleErrorZS;\n        _handleErrorCurrZone;\n        _scheduleTaskDlgt;\n        _scheduleTaskZS;\n        _scheduleTaskCurrZone;\n        _invokeTaskDlgt;\n        _invokeTaskZS;\n        _invokeTaskCurrZone;\n        _cancelTaskDlgt;\n        _cancelTaskZS;\n        _cancelTaskCurrZone;\n        _hasTaskDlgt;\n        _hasTaskDlgtOwner;\n        _hasTaskZS;\n        _hasTaskCurrZone;\n        constructor(zone, parentDelegate, zoneSpec) {\n            this._zone = zone;\n            this._parentDelegate = parentDelegate;\n            this._forkZS = zoneSpec && (zoneSpec && zoneSpec.onFork ? zoneSpec : parentDelegate._forkZS);\n            this._forkDlgt = zoneSpec && (zoneSpec.onFork ? parentDelegate : parentDelegate._forkDlgt);\n            this._forkCurrZone =\n                zoneSpec && (zoneSpec.onFork ? this._zone : parentDelegate._forkCurrZone);\n            this._interceptZS =\n                zoneSpec && (zoneSpec.onIntercept ? zoneSpec : parentDelegate._interceptZS);\n            this._interceptDlgt =\n                zoneSpec && (zoneSpec.onIntercept ? parentDelegate : parentDelegate._interceptDlgt);\n            this._interceptCurrZone =\n                zoneSpec && (zoneSpec.onIntercept ? this._zone : parentDelegate._interceptCurrZone);\n            this._invokeZS = zoneSpec && (zoneSpec.onInvoke ? zoneSpec : parentDelegate._invokeZS);\n            this._invokeDlgt =\n                zoneSpec && (zoneSpec.onInvoke ? parentDelegate : parentDelegate._invokeDlgt);\n            this._invokeCurrZone =\n                zoneSpec && (zoneSpec.onInvoke ? this._zone : parentDelegate._invokeCurrZone);\n            this._handleErrorZS =\n                zoneSpec && (zoneSpec.onHandleError ? zoneSpec : parentDelegate._handleErrorZS);\n            this._handleErrorDlgt =\n                zoneSpec && (zoneSpec.onHandleError ? parentDelegate : parentDelegate._handleErrorDlgt);\n            this._handleErrorCurrZone =\n                zoneSpec && (zoneSpec.onHandleError ? this._zone : parentDelegate._handleErrorCurrZone);\n            this._scheduleTaskZS =\n                zoneSpec && (zoneSpec.onScheduleTask ? zoneSpec : parentDelegate._scheduleTaskZS);\n            this._scheduleTaskDlgt =\n                zoneSpec && (zoneSpec.onScheduleTask ? parentDelegate : parentDelegate._scheduleTaskDlgt);\n            this._scheduleTaskCurrZone =\n                zoneSpec && (zoneSpec.onScheduleTask ? this._zone : parentDelegate._scheduleTaskCurrZone);\n            this._invokeTaskZS =\n                zoneSpec && (zoneSpec.onInvokeTask ? zoneSpec : parentDelegate._invokeTaskZS);\n            this._invokeTaskDlgt =\n                zoneSpec && (zoneSpec.onInvokeTask ? parentDelegate : parentDelegate._invokeTaskDlgt);\n            this._invokeTaskCurrZone =\n                zoneSpec && (zoneSpec.onInvokeTask ? this._zone : parentDelegate._invokeTaskCurrZone);\n            this._cancelTaskZS =\n                zoneSpec && (zoneSpec.onCancelTask ? zoneSpec : parentDelegate._cancelTaskZS);\n            this._cancelTaskDlgt =\n                zoneSpec && (zoneSpec.onCancelTask ? parentDelegate : parentDelegate._cancelTaskDlgt);\n            this._cancelTaskCurrZone =\n                zoneSpec && (zoneSpec.onCancelTask ? this._zone : parentDelegate._cancelTaskCurrZone);\n            this._hasTaskZS = null;\n            this._hasTaskDlgt = null;\n            this._hasTaskDlgtOwner = null;\n            this._hasTaskCurrZone = null;\n            const zoneSpecHasTask = zoneSpec && zoneSpec.onHasTask;\n            const parentHasTask = parentDelegate && parentDelegate._hasTaskZS;\n            if (zoneSpecHasTask || parentHasTask) {\n                // If we need to report hasTask, than this ZS needs to do ref counting on tasks. In such\n                // a case all task related interceptors must go through this ZD. We can't short circuit it.\n                this._hasTaskZS = zoneSpecHasTask ? zoneSpec : DELEGATE_ZS;\n                this._hasTaskDlgt = parentDelegate;\n                this._hasTaskDlgtOwner = this;\n                this._hasTaskCurrZone = this._zone;\n                if (!zoneSpec.onScheduleTask) {\n                    this._scheduleTaskZS = DELEGATE_ZS;\n                    this._scheduleTaskDlgt = parentDelegate;\n                    this._scheduleTaskCurrZone = this._zone;\n                }\n                if (!zoneSpec.onInvokeTask) {\n                    this._invokeTaskZS = DELEGATE_ZS;\n                    this._invokeTaskDlgt = parentDelegate;\n                    this._invokeTaskCurrZone = this._zone;\n                }\n                if (!zoneSpec.onCancelTask) {\n                    this._cancelTaskZS = DELEGATE_ZS;\n                    this._cancelTaskDlgt = parentDelegate;\n                    this._cancelTaskCurrZone = this._zone;\n                }\n            }\n        }\n        fork(targetZone, zoneSpec) {\n            return this._forkZS\n                ? this._forkZS.onFork(this._forkDlgt, this.zone, targetZone, zoneSpec)\n                : new ZoneImpl(targetZone, zoneSpec);\n        }\n        intercept(targetZone, callback, source) {\n            return this._interceptZS\n                ? this._interceptZS.onIntercept(this._interceptDlgt, this._interceptCurrZone, targetZone, callback, source)\n                : callback;\n        }\n        invoke(targetZone, callback, applyThis, applyArgs, source) {\n            return this._invokeZS\n                ? this._invokeZS.onInvoke(this._invokeDlgt, this._invokeCurrZone, targetZone, callback, applyThis, applyArgs, source)\n                : callback.apply(applyThis, applyArgs);\n        }\n        handleError(targetZone, error) {\n            return this._handleErrorZS\n                ? this._handleErrorZS.onHandleError(this._handleErrorDlgt, this._handleErrorCurrZone, targetZone, error)\n                : true;\n        }\n        scheduleTask(targetZone, task) {\n            let returnTask = task;\n            if (this._scheduleTaskZS) {\n                if (this._hasTaskZS) {\n                    returnTask._zoneDelegates.push(this._hasTaskDlgtOwner);\n                }\n                returnTask = this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt, this._scheduleTaskCurrZone, targetZone, task);\n                if (!returnTask)\n                    returnTask = task;\n            }\n            else {\n                if (task.scheduleFn) {\n                    task.scheduleFn(task);\n                }\n                else if (task.type == microTask) {\n                    scheduleMicroTask(task);\n                }\n                else {\n                    throw new Error('Task is missing scheduleFn.');\n                }\n            }\n            return returnTask;\n        }\n        invokeTask(targetZone, task, applyThis, applyArgs) {\n            return this._invokeTaskZS\n                ? this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt, this._invokeTaskCurrZone, targetZone, task, applyThis, applyArgs)\n                : task.callback.apply(applyThis, applyArgs);\n        }\n        cancelTask(targetZone, task) {\n            let value;\n            if (this._cancelTaskZS) {\n                value = this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt, this._cancelTaskCurrZone, targetZone, task);\n            }\n            else {\n                if (!task.cancelFn) {\n                    throw Error('Task is not cancelable');\n                }\n                value = task.cancelFn(task);\n            }\n            return value;\n        }\n        hasTask(targetZone, isEmpty) {\n            // hasTask should not throw error so other ZoneDelegate\n            // can still trigger hasTask callback\n            try {\n                this._hasTaskZS &&\n                    this._hasTaskZS.onHasTask(this._hasTaskDlgt, this._hasTaskCurrZone, targetZone, isEmpty);\n            }\n            catch (err) {\n                this.handleError(targetZone, err);\n            }\n        }\n        _updateTaskCount(type, count) {\n            const counts = this._taskCounts;\n            const prev = counts[type];\n            const next = (counts[type] = prev + count);\n            if (next < 0) {\n                throw new Error('More tasks executed then were scheduled.');\n            }\n            if (prev == 0 || next == 0) {\n                const isEmpty = {\n                    microTask: counts['microTask'] > 0,\n                    macroTask: counts['macroTask'] > 0,\n                    eventTask: counts['eventTask'] > 0,\n                    change: type,\n                };\n                this.hasTask(this._zone, isEmpty);\n            }\n        }\n    }\n    class ZoneTask {\n        type;\n        source;\n        invoke;\n        callback;\n        data;\n        scheduleFn;\n        cancelFn;\n        _zone = null;\n        runCount = 0;\n        _zoneDelegates = null;\n        _state = 'notScheduled';\n        constructor(type, source, callback, options, scheduleFn, cancelFn) {\n            this.type = type;\n            this.source = source;\n            this.data = options;\n            this.scheduleFn = scheduleFn;\n            this.cancelFn = cancelFn;\n            if (!callback) {\n                throw new Error('callback is not defined');\n            }\n            this.callback = callback;\n            const self = this;\n            // TODO: @JiaLiPassion options should have interface\n            if (type === eventTask && options && options.useG) {\n                this.invoke = ZoneTask.invokeTask;\n            }\n            else {\n                this.invoke = function () {\n                    return ZoneTask.invokeTask.call(global, self, this, arguments);\n                };\n            }\n        }\n        static invokeTask(task, target, args) {\n            if (!task) {\n                task = this;\n            }\n            _numberOfNestedTaskFrames++;\n            try {\n                task.runCount++;\n                return task.zone.runTask(task, target, args);\n            }\n            finally {\n                if (_numberOfNestedTaskFrames == 1) {\n                    drainMicroTaskQueue();\n                }\n                _numberOfNestedTaskFrames--;\n            }\n        }\n        get zone() {\n            return this._zone;\n        }\n        get state() {\n            return this._state;\n        }\n        cancelScheduleRequest() {\n            this._transitionTo(notScheduled, scheduling);\n        }\n        _transitionTo(toState, fromState1, fromState2) {\n            if (this._state === fromState1 || this._state === fromState2) {\n                this._state = toState;\n                if (toState == notScheduled) {\n                    this._zoneDelegates = null;\n                }\n            }\n            else {\n                throw new Error(`${this.type} '${this.source}': can not transition to '${toState}', expecting state '${fromState1}'${fromState2 ? \" or '\" + fromState2 + \"'\" : ''}, was '${this._state}'.`);\n            }\n        }\n        toString() {\n            if (this.data && typeof this.data.handleId !== 'undefined') {\n                return this.data.handleId.toString();\n            }\n            else {\n                return Object.prototype.toString.call(this);\n            }\n        }\n        // add toJSON method to prevent cyclic error when\n        // call JSON.stringify(zoneTask)\n        toJSON() {\n            return {\n                type: this.type,\n                state: this.state,\n                source: this.source,\n                zone: this.zone.name,\n                runCount: this.runCount,\n            };\n        }\n    }\n    //////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////\n    ///  MICROTASK QUEUE\n    //////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////\n    const symbolSetTimeout = __symbol__('setTimeout');\n    const symbolPromise = __symbol__('Promise');\n    const symbolThen = __symbol__('then');\n    let _microTaskQueue = [];\n    let _isDrainingMicrotaskQueue = false;\n    let nativeMicroTaskQueuePromise;\n    function nativeScheduleMicroTask(func) {\n        if (!nativeMicroTaskQueuePromise) {\n            if (global[symbolPromise]) {\n                nativeMicroTaskQueuePromise = global[symbolPromise].resolve(0);\n            }\n        }\n        if (nativeMicroTaskQueuePromise) {\n            let nativeThen = nativeMicroTaskQueuePromise[symbolThen];\n            if (!nativeThen) {\n                // native Promise is not patchable, we need to use `then` directly\n                // issue 1078\n                nativeThen = nativeMicroTaskQueuePromise['then'];\n            }\n            nativeThen.call(nativeMicroTaskQueuePromise, func);\n        }\n        else {\n            global[symbolSetTimeout](func, 0);\n        }\n    }\n    function scheduleMicroTask(task) {\n        // if we are not running in any task, and there has not been anything scheduled\n        // we must bootstrap the initial task creation by manually scheduling the drain\n        if (_numberOfNestedTaskFrames === 0 && _microTaskQueue.length === 0) {\n            // We are not running in Task, so we need to kickstart the microtask queue.\n            nativeScheduleMicroTask(drainMicroTaskQueue);\n        }\n        task && _microTaskQueue.push(task);\n    }\n    function drainMicroTaskQueue() {\n        if (!_isDrainingMicrotaskQueue) {\n            _isDrainingMicrotaskQueue = true;\n            while (_microTaskQueue.length) {\n                const queue = _microTaskQueue;\n                _microTaskQueue = [];\n                for (let i = 0; i < queue.length; i++) {\n                    const task = queue[i];\n                    try {\n                        task.zone.runTask(task, null, null);\n                    }\n                    catch (error) {\n                        _api.onUnhandledError(error);\n                    }\n                }\n            }\n            _api.microtaskDrainDone();\n            _isDrainingMicrotaskQueue = false;\n        }\n    }\n    //////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////\n    ///  BOOTSTRAP\n    //////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////\n    const NO_ZONE = { name: 'NO ZONE' };\n    const notScheduled = 'notScheduled', scheduling = 'scheduling', scheduled = 'scheduled', running = 'running', canceling = 'canceling', unknown = 'unknown';\n    const microTask = 'microTask', macroTask = 'macroTask', eventTask = 'eventTask';\n    const patches = {};\n    const _api = {\n        symbol: __symbol__,\n        currentZoneFrame: () => _currentZoneFrame,\n        onUnhandledError: noop,\n        microtaskDrainDone: noop,\n        scheduleMicroTask: scheduleMicroTask,\n        showUncaughtError: () => !ZoneImpl[__symbol__('ignoreConsoleErrorUncaughtError')],\n        patchEventTarget: () => [],\n        patchOnProperties: noop,\n        patchMethod: () => noop,\n        bindArguments: () => [],\n        patchThen: () => noop,\n        patchMacroTask: () => noop,\n        patchEventPrototype: () => noop,\n        isIEOrEdge: () => false,\n        getGlobalObjects: () => undefined,\n        ObjectDefineProperty: () => noop,\n        ObjectGetOwnPropertyDescriptor: () => undefined,\n        ObjectCreate: () => undefined,\n        ArraySlice: () => [],\n        patchClass: () => noop,\n        wrapWithCurrentZone: () => noop,\n        filterProperties: () => [],\n        attachOriginToPatched: () => noop,\n        _redefineProperty: () => noop,\n        patchCallbacks: () => noop,\n        nativeScheduleMicroTask: nativeScheduleMicroTask,\n    };\n    let _currentZoneFrame = { parent: null, zone: new ZoneImpl(null, null) };\n    let _currentTask = null;\n    let _numberOfNestedTaskFrames = 0;\n    function noop() { }\n    performanceMeasure('Zone', 'Zone');\n    return ZoneImpl;\n}\n\nfunction loadZone() {\n    // if global['Zone'] already exists (maybe zone.js was already loaded or\n    // some other lib also registered a global object named Zone), we may need\n    // to throw an error, but sometimes user may not want this error.\n    // For example,\n    // we have two web pages, page1 includes zone.js, page2 doesn't.\n    // and the 1st time user load page1 and page2, everything work fine,\n    // but when user load page2 again, error occurs because global['Zone'] already exists.\n    // so we add a flag to let user choose whether to throw this error or not.\n    // By default, if existing Zone is from zone.js, we will not throw the error.\n    const global = globalThis;\n    const checkDuplicate = global[__symbol__('forceDuplicateZoneCheck')] === true;\n    if (global['Zone'] && (checkDuplicate || typeof global['Zone'].__symbol__ !== 'function')) {\n        throw new Error('Zone already loaded.');\n    }\n    // Initialize global `Zone` constant.\n    global['Zone'] ??= initZone();\n    return global['Zone'];\n}\n\n/**\n * Suppress closure compiler errors about unknown 'Zone' variable\n * @fileoverview\n * @suppress {undefinedVars,globalThis,missingRequire}\n */\n/// <reference types=\"node\"/>\n// issue #989, to reduce bundle size, use short name\n/** Object.getOwnPropertyDescriptor */\nconst ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n/** Object.defineProperty */\nconst ObjectDefineProperty = Object.defineProperty;\n/** Object.getPrototypeOf */\nconst ObjectGetPrototypeOf = Object.getPrototypeOf;\n/** Object.create */\nconst ObjectCreate = Object.create;\n/** Array.prototype.slice */\nconst ArraySlice = Array.prototype.slice;\n/** addEventListener string const */\nconst ADD_EVENT_LISTENER_STR = 'addEventListener';\n/** removeEventListener string const */\nconst REMOVE_EVENT_LISTENER_STR = 'removeEventListener';\n/** zoneSymbol addEventListener */\nconst ZONE_SYMBOL_ADD_EVENT_LISTENER = __symbol__(ADD_EVENT_LISTENER_STR);\n/** zoneSymbol removeEventListener */\nconst ZONE_SYMBOL_REMOVE_EVENT_LISTENER = __symbol__(REMOVE_EVENT_LISTENER_STR);\n/** true string const */\nconst TRUE_STR = 'true';\n/** false string const */\nconst FALSE_STR = 'false';\n/** Zone symbol prefix string const. */\nconst ZONE_SYMBOL_PREFIX = __symbol__('');\nfunction wrapWithCurrentZone(callback, source) {\n    return Zone.current.wrap(callback, source);\n}\nfunction scheduleMacroTaskWithCurrentZone(source, callback, data, customSchedule, customCancel) {\n    return Zone.current.scheduleMacroTask(source, callback, data, customSchedule, customCancel);\n}\nconst zoneSymbol = __symbol__;\nconst isWindowExists = typeof window !== 'undefined';\nconst internalWindow = isWindowExists ? window : undefined;\nconst _global = (isWindowExists && internalWindow) || globalThis;\nconst REMOVE_ATTRIBUTE = 'removeAttribute';\nfunction bindArguments(args, source) {\n    for (let i = args.length - 1; i >= 0; i--) {\n        if (typeof args[i] === 'function') {\n            args[i] = wrapWithCurrentZone(args[i], source + '_' + i);\n        }\n    }\n    return args;\n}\nfunction patchPrototype(prototype, fnNames) {\n    const source = prototype.constructor['name'];\n    for (let i = 0; i < fnNames.length; i++) {\n        const name = fnNames[i];\n        const delegate = prototype[name];\n        if (delegate) {\n            const prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, name);\n            if (!isPropertyWritable(prototypeDesc)) {\n                continue;\n            }\n            prototype[name] = ((delegate) => {\n                const patched = function () {\n                    return delegate.apply(this, bindArguments(arguments, source + '.' + name));\n                };\n                attachOriginToPatched(patched, delegate);\n                return patched;\n            })(delegate);\n        }\n    }\n}\nfunction isPropertyWritable(propertyDesc) {\n    if (!propertyDesc) {\n        return true;\n    }\n    if (propertyDesc.writable === false) {\n        return false;\n    }\n    return !(typeof propertyDesc.get === 'function' && typeof propertyDesc.set === 'undefined');\n}\nconst isWebWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;\n// Make sure to access `process` through `_global` so that WebPack does not accidentally browserify\n// this code.\nconst isNode = !('nw' in _global) &&\n    typeof _global.process !== 'undefined' &&\n    _global.process.toString() === '[object process]';\nconst isBrowser = !isNode && !isWebWorker && !!(isWindowExists && internalWindow['HTMLElement']);\n// we are in electron of nw, so we are both browser and nodejs\n// Make sure to access `process` through `_global` so that WebPack does not accidentally browserify\n// this code.\nconst isMix = typeof _global.process !== 'undefined' &&\n    _global.process.toString() === '[object process]' &&\n    !isWebWorker &&\n    !!(isWindowExists && internalWindow['HTMLElement']);\nconst zoneSymbolEventNames$1 = {};\nconst enableBeforeunloadSymbol = zoneSymbol('enable_beforeunload');\nconst wrapFn = function (event) {\n    // https://github.com/angular/zone.js/issues/911, in IE, sometimes\n    // event will be undefined, so we need to use window.event\n    event = event || _global.event;\n    if (!event) {\n        return;\n    }\n    let eventNameSymbol = zoneSymbolEventNames$1[event.type];\n    if (!eventNameSymbol) {\n        eventNameSymbol = zoneSymbolEventNames$1[event.type] = zoneSymbol('ON_PROPERTY' + event.type);\n    }\n    const target = this || event.target || _global;\n    const listener = target[eventNameSymbol];\n    let result;\n    if (isBrowser && target === internalWindow && event.type === 'error') {\n        // window.onerror have different signature\n        // https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onerror#window.onerror\n        // and onerror callback will prevent default when callback return true\n        const errorEvent = event;\n        result =\n            listener &&\n                listener.call(this, errorEvent.message, errorEvent.filename, errorEvent.lineno, errorEvent.colno, errorEvent.error);\n        if (result === true) {\n            event.preventDefault();\n        }\n    }\n    else {\n        result = listener && listener.apply(this, arguments);\n        if (\n        // https://github.com/angular/angular/issues/47579\n        // https://www.w3.org/TR/2011/WD-html5-20110525/history.html#beforeunloadevent\n        // This is the only specific case we should check for. The spec defines that the\n        // `returnValue` attribute represents the message to show the user. When the event\n        // is created, this attribute must be set to the empty string.\n        event.type === 'beforeunload' &&\n            // To prevent any breaking changes resulting from this change, given that\n            // it was already causing a significant number of failures in G3, we have hidden\n            // that behavior behind a global configuration flag. Consumers can enable this\n            // flag explicitly if they want the `beforeunload` event to be handled as defined\n            // in the specification.\n            _global[enableBeforeunloadSymbol] &&\n            // The IDL event definition is `attribute DOMString returnValue`, so we check whether\n            // `typeof result` is a string.\n            typeof result === 'string') {\n            event.returnValue = result;\n        }\n        else if (result != undefined && !result) {\n            event.preventDefault();\n        }\n    }\n    return result;\n};\nfunction patchProperty(obj, prop, prototype) {\n    let desc = ObjectGetOwnPropertyDescriptor(obj, prop);\n    if (!desc && prototype) {\n        // when patch window object, use prototype to check prop exist or not\n        const prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, prop);\n        if (prototypeDesc) {\n            desc = { enumerable: true, configurable: true };\n        }\n    }\n    // if the descriptor not exists or is not configurable\n    // just return\n    if (!desc || !desc.configurable) {\n        return;\n    }\n    const onPropPatchedSymbol = zoneSymbol('on' + prop + 'patched');\n    if (obj.hasOwnProperty(onPropPatchedSymbol) && obj[onPropPatchedSymbol]) {\n        return;\n    }\n    // A property descriptor cannot have getter/setter and be writable\n    // deleting the writable and value properties avoids this error:\n    //\n    // TypeError: property descriptors must not specify a value or be writable when a\n    // getter or setter has been specified\n    delete desc.writable;\n    delete desc.value;\n    const originalDescGet = desc.get;\n    const originalDescSet = desc.set;\n    // slice(2) cuz 'onclick' -> 'click', etc\n    const eventName = prop.slice(2);\n    let eventNameSymbol = zoneSymbolEventNames$1[eventName];\n    if (!eventNameSymbol) {\n        eventNameSymbol = zoneSymbolEventNames$1[eventName] = zoneSymbol('ON_PROPERTY' + eventName);\n    }\n    desc.set = function (newValue) {\n        // In some versions of Windows, the `this` context may be undefined\n        // in on-property callbacks.\n        // To handle this edge case, we check if `this` is falsy and\n        // fallback to `_global` if needed.\n        let target = this;\n        if (!target && obj === _global) {\n            target = _global;\n        }\n        if (!target) {\n            return;\n        }\n        const previousValue = target[eventNameSymbol];\n        if (typeof previousValue === 'function') {\n            target.removeEventListener(eventName, wrapFn);\n        }\n        // https://github.com/angular/zone.js/issues/978\n        // If an inline handler (like `onload`) was defined before zone.js was loaded,\n        // call the original descriptor's setter to clean it up.\n        originalDescSet?.call(target, null);\n        target[eventNameSymbol] = newValue;\n        if (typeof newValue === 'function') {\n            target.addEventListener(eventName, wrapFn, false);\n        }\n    };\n    // The getter would return undefined for unassigned properties but the default value of an\n    // unassigned property is null\n    desc.get = function () {\n        // in some of windows's onproperty callback, this is undefined\n        // so we need to check it\n        let target = this;\n        if (!target && obj === _global) {\n            target = _global;\n        }\n        if (!target) {\n            return null;\n        }\n        const listener = target[eventNameSymbol];\n        if (listener) {\n            return listener;\n        }\n        else if (originalDescGet) {\n            // result will be null when use inline event attribute,\n            // such as <button onclick=\"func();\">OK</button>\n            // because the onclick function is internal raw uncompiled handler\n            // the onclick will be evaluated when first time event was triggered or\n            // the property is accessed, https://github.com/angular/zone.js/issues/525\n            // so we should use original native get to retrieve the handler\n            let value = originalDescGet.call(this);\n            if (value) {\n                desc.set.call(this, value);\n                if (typeof target[REMOVE_ATTRIBUTE] === 'function') {\n                    target.removeAttribute(prop);\n                }\n                return value;\n            }\n        }\n        return null;\n    };\n    ObjectDefineProperty(obj, prop, desc);\n    obj[onPropPatchedSymbol] = true;\n}\nfunction patchOnProperties(obj, properties, prototype) {\n    if (properties) {\n        for (let i = 0; i < properties.length; i++) {\n            patchProperty(obj, 'on' + properties[i], prototype);\n        }\n    }\n    else {\n        const onProperties = [];\n        for (const prop in obj) {\n            if (prop.slice(0, 2) == 'on') {\n                onProperties.push(prop);\n            }\n        }\n        for (let j = 0; j < onProperties.length; j++) {\n            patchProperty(obj, onProperties[j], prototype);\n        }\n    }\n}\nconst originalInstanceKey = zoneSymbol('originalInstance');\n// wrap some native API on `window`\nfunction patchClass(className) {\n    const OriginalClass = _global[className];\n    if (!OriginalClass)\n        return;\n    // keep original class in global\n    _global[zoneSymbol(className)] = OriginalClass;\n    _global[className] = function () {\n        const a = bindArguments(arguments, className);\n        switch (a.length) {\n            case 0:\n                this[originalInstanceKey] = new OriginalClass();\n                break;\n            case 1:\n                this[originalInstanceKey] = new OriginalClass(a[0]);\n                break;\n            case 2:\n                this[originalInstanceKey] = new OriginalClass(a[0], a[1]);\n                break;\n            case 3:\n                this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2]);\n                break;\n            case 4:\n                this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2], a[3]);\n                break;\n            default:\n                throw new Error('Arg list too long.');\n        }\n    };\n    // attach original delegate to patched function\n    attachOriginToPatched(_global[className], OriginalClass);\n    const instance = new OriginalClass(function () { });\n    let prop;\n    for (prop in instance) {\n        // https://bugs.webkit.org/show_bug.cgi?id=44721\n        if (className === 'XMLHttpRequest' && prop === 'responseBlob')\n            continue;\n        (function (prop) {\n            if (typeof instance[prop] === 'function') {\n                _global[className].prototype[prop] = function () {\n                    return this[originalInstanceKey][prop].apply(this[originalInstanceKey], arguments);\n                };\n            }\n            else {\n                ObjectDefineProperty(_global[className].prototype, prop, {\n                    set: function (fn) {\n                        if (typeof fn === 'function') {\n                            this[originalInstanceKey][prop] = wrapWithCurrentZone(fn, className + '.' + prop);\n                            // keep callback in wrapped function so we can\n                            // use it in Function.prototype.toString to return\n                            // the native one.\n                            attachOriginToPatched(this[originalInstanceKey][prop], fn);\n                        }\n                        else {\n                            this[originalInstanceKey][prop] = fn;\n                        }\n                    },\n                    get: function () {\n                        return this[originalInstanceKey][prop];\n                    },\n                });\n            }\n        })(prop);\n    }\n    for (prop in OriginalClass) {\n        if (prop !== 'prototype' && OriginalClass.hasOwnProperty(prop)) {\n            _global[className][prop] = OriginalClass[prop];\n        }\n    }\n}\nfunction patchMethod(target, name, patchFn) {\n    let proto = target;\n    while (proto && !proto.hasOwnProperty(name)) {\n        proto = ObjectGetPrototypeOf(proto);\n    }\n    if (!proto && target[name]) {\n        // somehow we did not find it, but we can see it. This happens on IE for Window properties.\n        proto = target;\n    }\n    const delegateName = zoneSymbol(name);\n    let delegate = null;\n    if (proto && (!(delegate = proto[delegateName]) || !proto.hasOwnProperty(delegateName))) {\n        delegate = proto[delegateName] = proto[name];\n        // check whether proto[name] is writable\n        // some property is readonly in safari, such as HtmlCanvasElement.prototype.toBlob\n        const desc = proto && ObjectGetOwnPropertyDescriptor(proto, name);\n        if (isPropertyWritable(desc)) {\n            const patchDelegate = patchFn(delegate, delegateName, name);\n            proto[name] = function () {\n                return patchDelegate(this, arguments);\n            };\n            attachOriginToPatched(proto[name], delegate);\n        }\n    }\n    return delegate;\n}\n// TODO: @JiaLiPassion, support cancel task later if necessary\nfunction patchMacroTask(obj, funcName, metaCreator) {\n    let setNative = null;\n    function scheduleTask(task) {\n        const data = task.data;\n        data.args[data.cbIdx] = function () {\n            task.invoke.apply(this, arguments);\n        };\n        setNative.apply(data.target, data.args);\n        return task;\n    }\n    setNative = patchMethod(obj, funcName, (delegate) => function (self, args) {\n        const meta = metaCreator(self, args);\n        if (meta.cbIdx >= 0 && typeof args[meta.cbIdx] === 'function') {\n            return scheduleMacroTaskWithCurrentZone(meta.name, args[meta.cbIdx], meta, scheduleTask);\n        }\n        else {\n            // cause an error by calling it directly.\n            return delegate.apply(self, args);\n        }\n    });\n}\nfunction attachOriginToPatched(patched, original) {\n    patched[zoneSymbol('OriginalDelegate')] = original;\n}\nlet isDetectedIEOrEdge = false;\nlet ieOrEdge = false;\nfunction isIEOrEdge() {\n    if (isDetectedIEOrEdge) {\n        return ieOrEdge;\n    }\n    isDetectedIEOrEdge = true;\n    try {\n        const ua = internalWindow.navigator.userAgent;\n        if (ua.indexOf('MSIE ') !== -1 || ua.indexOf('Trident/') !== -1 || ua.indexOf('Edge/') !== -1) {\n            ieOrEdge = true;\n        }\n    }\n    catch (error) { }\n    return ieOrEdge;\n}\nfunction isFunction(value) {\n    return typeof value === 'function';\n}\nfunction isNumber(value) {\n    return typeof value === 'number';\n}\n\n/**\n * @fileoverview\n * @suppress {missingRequire}\n */\n// an identifier to tell ZoneTask do not create a new invoke closure\nconst OPTIMIZED_ZONE_EVENT_TASK_DATA = {\n    useG: true,\n};\nconst zoneSymbolEventNames = {};\nconst globalSources = {};\nconst EVENT_NAME_SYMBOL_REGX = new RegExp('^' + ZONE_SYMBOL_PREFIX + '(\\\\w+)(true|false)$');\nconst IMMEDIATE_PROPAGATION_SYMBOL = zoneSymbol('propagationStopped');\nfunction prepareEventNames(eventName, eventNameToString) {\n    const falseEventName = (eventNameToString ? eventNameToString(eventName) : eventName) + FALSE_STR;\n    const trueEventName = (eventNameToString ? eventNameToString(eventName) : eventName) + TRUE_STR;\n    const symbol = ZONE_SYMBOL_PREFIX + falseEventName;\n    const symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;\n    zoneSymbolEventNames[eventName] = {};\n    zoneSymbolEventNames[eventName][FALSE_STR] = symbol;\n    zoneSymbolEventNames[eventName][TRUE_STR] = symbolCapture;\n}\nfunction patchEventTarget(_global, api, apis, patchOptions) {\n    const ADD_EVENT_LISTENER = (patchOptions && patchOptions.add) || ADD_EVENT_LISTENER_STR;\n    const REMOVE_EVENT_LISTENER = (patchOptions && patchOptions.rm) || REMOVE_EVENT_LISTENER_STR;\n    const LISTENERS_EVENT_LISTENER = (patchOptions && patchOptions.listeners) || 'eventListeners';\n    const REMOVE_ALL_LISTENERS_EVENT_LISTENER = (patchOptions && patchOptions.rmAll) || 'removeAllListeners';\n    const zoneSymbolAddEventListener = zoneSymbol(ADD_EVENT_LISTENER);\n    const ADD_EVENT_LISTENER_SOURCE = '.' + ADD_EVENT_LISTENER + ':';\n    const PREPEND_EVENT_LISTENER = 'prependListener';\n    const PREPEND_EVENT_LISTENER_SOURCE = '.' + PREPEND_EVENT_LISTENER + ':';\n    const invokeTask = function (task, target, event) {\n        // for better performance, check isRemoved which is set\n        // by removeEventListener\n        if (task.isRemoved) {\n            return;\n        }\n        const delegate = task.callback;\n        if (typeof delegate === 'object' && delegate.handleEvent) {\n            // create the bind version of handleEvent when invoke\n            task.callback = (event) => delegate.handleEvent(event);\n            task.originalDelegate = delegate;\n        }\n        // invoke static task.invoke\n        // need to try/catch error here, otherwise, the error in one event listener\n        // will break the executions of the other event listeners. Also error will\n        // not remove the event listener when `once` options is true.\n        let error;\n        try {\n            task.invoke(task, target, [event]);\n        }\n        catch (err) {\n            error = err;\n        }\n        const options = task.options;\n        if (options && typeof options === 'object' && options.once) {\n            // if options.once is true, after invoke once remove listener here\n            // only browser need to do this, nodejs eventEmitter will cal removeListener\n            // inside EventEmitter.once\n            const delegate = task.originalDelegate ? task.originalDelegate : task.callback;\n            target[REMOVE_EVENT_LISTENER].call(target, event.type, delegate, options);\n        }\n        return error;\n    };\n    function globalCallback(context, event, isCapture) {\n        // https://github.com/angular/zone.js/issues/911, in IE, sometimes\n        // event will be undefined, so we need to use window.event\n        event = event || _global.event;\n        if (!event) {\n            return;\n        }\n        // event.target is needed for Samsung TV and SourceBuffer\n        // || global is needed https://github.com/angular/zone.js/issues/190\n        const target = context || event.target || _global;\n        const tasks = target[zoneSymbolEventNames[event.type][isCapture ? TRUE_STR : FALSE_STR]];\n        if (tasks) {\n            const errors = [];\n            // invoke all tasks which attached to current target with given event.type and capture = false\n            // for performance concern, if task.length === 1, just invoke\n            if (tasks.length === 1) {\n                const err = invokeTask(tasks[0], target, event);\n                err && errors.push(err);\n            }\n            else {\n                // https://github.com/angular/zone.js/issues/836\n                // copy the tasks array before invoke, to avoid\n                // the callback will remove itself or other listener\n                const copyTasks = tasks.slice();\n                for (let i = 0; i < copyTasks.length; i++) {\n                    if (event && event[IMMEDIATE_PROPAGATION_SYMBOL] === true) {\n                        break;\n                    }\n                    const err = invokeTask(copyTasks[i], target, event);\n                    err && errors.push(err);\n                }\n            }\n            // Since there is only one error, we don't need to schedule microTask\n            // to throw the error.\n            if (errors.length === 1) {\n                throw errors[0];\n            }\n            else {\n                for (let i = 0; i < errors.length; i++) {\n                    const err = errors[i];\n                    api.nativeScheduleMicroTask(() => {\n                        throw err;\n                    });\n                }\n            }\n        }\n    }\n    // global shared zoneAwareCallback to handle all event callback with capture = false\n    const globalZoneAwareCallback = function (event) {\n        return globalCallback(this, event, false);\n    };\n    // global shared zoneAwareCallback to handle all event callback with capture = true\n    const globalZoneAwareCaptureCallback = function (event) {\n        return globalCallback(this, event, true);\n    };\n    function patchEventTargetMethods(obj, patchOptions) {\n        if (!obj) {\n            return false;\n        }\n        let useGlobalCallback = true;\n        if (patchOptions && patchOptions.useG !== undefined) {\n            useGlobalCallback = patchOptions.useG;\n        }\n        const validateHandler = patchOptions && patchOptions.vh;\n        let checkDuplicate = true;\n        if (patchOptions && patchOptions.chkDup !== undefined) {\n            checkDuplicate = patchOptions.chkDup;\n        }\n        let returnTarget = false;\n        if (patchOptions && patchOptions.rt !== undefined) {\n            returnTarget = patchOptions.rt;\n        }\n        let proto = obj;\n        while (proto && !proto.hasOwnProperty(ADD_EVENT_LISTENER)) {\n            proto = ObjectGetPrototypeOf(proto);\n        }\n        if (!proto && obj[ADD_EVENT_LISTENER]) {\n            // somehow we did not find it, but we can see it. This happens on IE for Window properties.\n            proto = obj;\n        }\n        if (!proto) {\n            return false;\n        }\n        if (proto[zoneSymbolAddEventListener]) {\n            return false;\n        }\n        const eventNameToString = patchOptions && patchOptions.eventNameToString;\n        // We use a shared global `taskData` to pass data for `scheduleEventTask`,\n        // eliminating the need to create a new object solely for passing data.\n        // WARNING: This object has a static lifetime, meaning it is not created\n        // each time `addEventListener` is called. It is instantiated only once\n        // and captured by reference inside the `addEventListener` and\n        // `removeEventListener` functions. Do not add any new properties to this\n        // object, as doing so would necessitate maintaining the information\n        // between `addEventListener` calls.\n        const taskData = {};\n        const nativeAddEventListener = (proto[zoneSymbolAddEventListener] = proto[ADD_EVENT_LISTENER]);\n        const nativeRemoveEventListener = (proto[zoneSymbol(REMOVE_EVENT_LISTENER)] =\n            proto[REMOVE_EVENT_LISTENER]);\n        const nativeListeners = (proto[zoneSymbol(LISTENERS_EVENT_LISTENER)] =\n            proto[LISTENERS_EVENT_LISTENER]);\n        const nativeRemoveAllListeners = (proto[zoneSymbol(REMOVE_ALL_LISTENERS_EVENT_LISTENER)] =\n            proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER]);\n        let nativePrependEventListener;\n        if (patchOptions && patchOptions.prepend) {\n            nativePrependEventListener = proto[zoneSymbol(patchOptions.prepend)] =\n                proto[patchOptions.prepend];\n        }\n        /**\n         * This util function will build an option object with passive option\n         * to handle all possible input from the user.\n         */\n        function buildEventListenerOptions(options, passive) {\n            if (!passive) {\n                return options;\n            }\n            if (typeof options === 'boolean') {\n                return { capture: options, passive: true };\n            }\n            if (!options) {\n                return { passive: true };\n            }\n            if (typeof options === 'object' && options.passive !== false) {\n                return { ...options, passive: true };\n            }\n            return options;\n        }\n        const customScheduleGlobal = function (task) {\n            // if there is already a task for the eventName + capture,\n            // just return, because we use the shared globalZoneAwareCallback here.\n            if (taskData.isExisting) {\n                return;\n            }\n            return nativeAddEventListener.call(taskData.target, taskData.eventName, taskData.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, taskData.options);\n        };\n        /**\n         * In the context of events and listeners, this function will be\n         * called at the end by `cancelTask`, which, in turn, calls `task.cancelFn`.\n         * Cancelling a task is primarily used to remove event listeners from\n         * the task target.\n         */\n        const customCancelGlobal = function (task) {\n            // if task is not marked as isRemoved, this call is directly\n            // from Zone.prototype.cancelTask, we should remove the task\n            // from tasksList of target first\n            if (!task.isRemoved) {\n                const symbolEventNames = zoneSymbolEventNames[task.eventName];\n                let symbolEventName;\n                if (symbolEventNames) {\n                    symbolEventName = symbolEventNames[task.capture ? TRUE_STR : FALSE_STR];\n                }\n                const existingTasks = symbolEventName && task.target[symbolEventName];\n                if (existingTasks) {\n                    for (let i = 0; i < existingTasks.length; i++) {\n                        const existingTask = existingTasks[i];\n                        if (existingTask === task) {\n                            existingTasks.splice(i, 1);\n                            // set isRemoved to data for faster invokeTask check\n                            task.isRemoved = true;\n                            if (task.removeAbortListener) {\n                                task.removeAbortListener();\n                                task.removeAbortListener = null;\n                            }\n                            if (existingTasks.length === 0) {\n                                // all tasks for the eventName + capture have gone,\n                                // remove globalZoneAwareCallback and remove the task cache from target\n                                task.allRemoved = true;\n                                task.target[symbolEventName] = null;\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n            // if all tasks for the eventName + capture have gone,\n            // we will really remove the global event callback,\n            // if not, return\n            if (!task.allRemoved) {\n                return;\n            }\n            return nativeRemoveEventListener.call(task.target, task.eventName, task.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, task.options);\n        };\n        const customScheduleNonGlobal = function (task) {\n            return nativeAddEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);\n        };\n        const customSchedulePrepend = function (task) {\n            return nativePrependEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);\n        };\n        const customCancelNonGlobal = function (task) {\n            return nativeRemoveEventListener.call(task.target, task.eventName, task.invoke, task.options);\n        };\n        const customSchedule = useGlobalCallback ? customScheduleGlobal : customScheduleNonGlobal;\n        const customCancel = useGlobalCallback ? customCancelGlobal : customCancelNonGlobal;\n        const compareTaskCallbackVsDelegate = function (task, delegate) {\n            const typeOfDelegate = typeof delegate;\n            return ((typeOfDelegate === 'function' && task.callback === delegate) ||\n                (typeOfDelegate === 'object' && task.originalDelegate === delegate));\n        };\n        const compare = patchOptions?.diff || compareTaskCallbackVsDelegate;\n        const unpatchedEvents = Zone[zoneSymbol('UNPATCHED_EVENTS')];\n        const passiveEvents = _global[zoneSymbol('PASSIVE_EVENTS')];\n        function copyEventListenerOptions(options) {\n            if (typeof options === 'object' && options !== null) {\n                // We need to destructure the target `options` object since it may\n                // be frozen or sealed (possibly provided implicitly by a third-party\n                // library), or its properties may be readonly.\n                const newOptions = { ...options };\n                // The `signal` option was recently introduced, which caused regressions in\n                // third-party scenarios where `AbortController` was directly provided to\n                // `addEventListener` as options. For instance, in cases like\n                // `document.addEventListener('keydown', callback, abortControllerInstance)`,\n                // which is valid because `AbortController` includes a `signal` getter, spreading\n                // `{...options}` wouldn't copy the `signal`. Additionally, using `Object.create`\n                // isn't feasible since `AbortController` is a built-in object type, and attempting\n                // to create a new object directly with it as the prototype might result in\n                // unexpected behavior.\n                if (options.signal) {\n                    newOptions.signal = options.signal;\n                }\n                return newOptions;\n            }\n            return options;\n        }\n        const makeAddListener = function (nativeListener, addSource, customScheduleFn, customCancelFn, returnTarget = false, prepend = false) {\n            return function () {\n                const target = this || _global;\n                let eventName = arguments[0];\n                if (patchOptions && patchOptions.transferEventName) {\n                    eventName = patchOptions.transferEventName(eventName);\n                }\n                let delegate = arguments[1];\n                if (!delegate) {\n                    return nativeListener.apply(this, arguments);\n                }\n                if (isNode && eventName === 'uncaughtException') {\n                    // don't patch uncaughtException of nodejs to prevent endless loop\n                    return nativeListener.apply(this, arguments);\n                }\n                // To improve `addEventListener` performance, we will create the callback\n                // for the task later when the task is invoked.\n                let isEventListenerObject = false;\n                if (typeof delegate !== 'function') {\n                    // This checks whether the provided listener argument is an object with\n                    // a `handleEvent` method (since we can call `addEventListener` with a\n                    // function `event => ...` or with an object `{ handleEvent: event => ... }`).\n                    if (!delegate.handleEvent) {\n                        return nativeListener.apply(this, arguments);\n                    }\n                    isEventListenerObject = true;\n                }\n                if (validateHandler && !validateHandler(nativeListener, delegate, target, arguments)) {\n                    return;\n                }\n                const passive = !!passiveEvents && passiveEvents.indexOf(eventName) !== -1;\n                const options = copyEventListenerOptions(buildEventListenerOptions(arguments[2], passive));\n                const signal = options?.signal;\n                if (signal?.aborted) {\n                    // the signal is an aborted one, just return without attaching the event listener.\n                    return;\n                }\n                if (unpatchedEvents) {\n                    // check unpatched list\n                    for (let i = 0; i < unpatchedEvents.length; i++) {\n                        if (eventName === unpatchedEvents[i]) {\n                            if (passive) {\n                                return nativeListener.call(target, eventName, delegate, options);\n                            }\n                            else {\n                                return nativeListener.apply(this, arguments);\n                            }\n                        }\n                    }\n                }\n                const capture = !options ? false : typeof options === 'boolean' ? true : options.capture;\n                const once = options && typeof options === 'object' ? options.once : false;\n                const zone = Zone.current;\n                let symbolEventNames = zoneSymbolEventNames[eventName];\n                if (!symbolEventNames) {\n                    prepareEventNames(eventName, eventNameToString);\n                    symbolEventNames = zoneSymbolEventNames[eventName];\n                }\n                const symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];\n                let existingTasks = target[symbolEventName];\n                let isExisting = false;\n                if (existingTasks) {\n                    // already have task registered\n                    isExisting = true;\n                    if (checkDuplicate) {\n                        for (let i = 0; i < existingTasks.length; i++) {\n                            if (compare(existingTasks[i], delegate)) {\n                                // same callback, same capture, same event name, just return\n                                return;\n                            }\n                        }\n                    }\n                }\n                else {\n                    existingTasks = target[symbolEventName] = [];\n                }\n                let source;\n                const constructorName = target.constructor['name'];\n                const targetSource = globalSources[constructorName];\n                if (targetSource) {\n                    source = targetSource[eventName];\n                }\n                if (!source) {\n                    source =\n                        constructorName +\n                            addSource +\n                            (eventNameToString ? eventNameToString(eventName) : eventName);\n                }\n                // In the code below, `options` should no longer be reassigned; instead, it\n                // should only be mutated. This is because we pass that object to the native\n                // `addEventListener`.\n                // It's generally recommended to use the same object reference for options.\n                // This ensures consistency and avoids potential issues.\n                taskData.options = options;\n                if (once) {\n                    // When using `addEventListener` with the `once` option, we don't pass\n                    // the `once` option directly to the native `addEventListener` method.\n                    // Instead, we keep the `once` setting and handle it ourselves.\n                    taskData.options.once = false;\n                }\n                taskData.target = target;\n                taskData.capture = capture;\n                taskData.eventName = eventName;\n                taskData.isExisting = isExisting;\n                const data = useGlobalCallback ? OPTIMIZED_ZONE_EVENT_TASK_DATA : undefined;\n                // keep taskData into data to allow onScheduleEventTask to access the task information\n                if (data) {\n                    data.taskData = taskData;\n                }\n                if (signal) {\n                    // When using `addEventListener` with the `signal` option, we don't pass\n                    // the `signal` option directly to the native `addEventListener` method.\n                    // Instead, we keep the `signal` setting and handle it ourselves.\n                    taskData.options.signal = undefined;\n                }\n                // The `scheduleEventTask` function will ultimately call `customScheduleGlobal`,\n                // which in turn calls the native `addEventListener`. This is why `taskData.options`\n                // is updated before scheduling the task, as `customScheduleGlobal` uses\n                // `taskData.options` to pass it to the native `addEventListener`.\n                const task = zone.scheduleEventTask(source, delegate, data, customScheduleFn, customCancelFn);\n                if (signal) {\n                    // after task is scheduled, we need to store the signal back to task.options\n                    taskData.options.signal = signal;\n                    // Wrapping `task` in a weak reference would not prevent memory leaks. Weak references are\n                    // primarily used for preventing strong references cycles. `onAbort` is always reachable\n                    // as it's an event listener, so its closure retains a strong reference to the `task`.\n                    const onAbort = () => task.zone.cancelTask(task);\n                    nativeListener.call(signal, 'abort', onAbort, { once: true });\n                    // We need to remove the `abort` listener when the event listener is going to be removed,\n                    // as it creates a closure that captures `task`. This closure retains a reference to the\n                    // `task` object even after it goes out of scope, preventing `task` from being garbage\n                    // collected.\n                    task.removeAbortListener = () => signal.removeEventListener('abort', onAbort);\n                }\n                // should clear taskData.target to avoid memory leak\n                // issue, https://github.com/angular/angular/issues/20442\n                taskData.target = null;\n                // need to clear up taskData because it is a global object\n                if (data) {\n                    data.taskData = null;\n                }\n                // have to save those information to task in case\n                // application may call task.zone.cancelTask() directly\n                if (once) {\n                    taskData.options.once = true;\n                }\n                if (typeof task.options !== 'boolean') {\n                    // We should save the options on the task (if it's an object) because\n                    // we'll be using `task.options` later when removing the event listener\n                    // and passing it back to `removeEventListener`.\n                    task.options = options;\n                }\n                task.target = target;\n                task.capture = capture;\n                task.eventName = eventName;\n                if (isEventListenerObject) {\n                    // save original delegate for compare to check duplicate\n                    task.originalDelegate = delegate;\n                }\n                if (!prepend) {\n                    existingTasks.push(task);\n                }\n                else {\n                    existingTasks.unshift(task);\n                }\n                if (returnTarget) {\n                    return target;\n                }\n            };\n        };\n        proto[ADD_EVENT_LISTENER] = makeAddListener(nativeAddEventListener, ADD_EVENT_LISTENER_SOURCE, customSchedule, customCancel, returnTarget);\n        if (nativePrependEventListener) {\n            proto[PREPEND_EVENT_LISTENER] = makeAddListener(nativePrependEventListener, PREPEND_EVENT_LISTENER_SOURCE, customSchedulePrepend, customCancel, returnTarget, true);\n        }\n        proto[REMOVE_EVENT_LISTENER] = function () {\n            const target = this || _global;\n            let eventName = arguments[0];\n            if (patchOptions && patchOptions.transferEventName) {\n                eventName = patchOptions.transferEventName(eventName);\n            }\n            const options = arguments[2];\n            const capture = !options ? false : typeof options === 'boolean' ? true : options.capture;\n            const delegate = arguments[1];\n            if (!delegate) {\n                return nativeRemoveEventListener.apply(this, arguments);\n            }\n            if (validateHandler &&\n                !validateHandler(nativeRemoveEventListener, delegate, target, arguments)) {\n                return;\n            }\n            const symbolEventNames = zoneSymbolEventNames[eventName];\n            let symbolEventName;\n            if (symbolEventNames) {\n                symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];\n            }\n            const existingTasks = symbolEventName && target[symbolEventName];\n            // `existingTasks` may not exist if the `addEventListener` was called before\n            // it was patched by zone.js. Please refer to the attached issue for\n            // clarification, particularly after the `if` condition, before calling\n            // the native `removeEventListener`.\n            if (existingTasks) {\n                for (let i = 0; i < existingTasks.length; i++) {\n                    const existingTask = existingTasks[i];\n                    if (compare(existingTask, delegate)) {\n                        existingTasks.splice(i, 1);\n                        // set isRemoved to data for faster invokeTask check\n                        existingTask.isRemoved = true;\n                        if (existingTasks.length === 0) {\n                            // all tasks for the eventName + capture have gone,\n                            // remove globalZoneAwareCallback and remove the task cache from target\n                            existingTask.allRemoved = true;\n                            target[symbolEventName] = null;\n                            // in the target, we have an event listener which is added by on_property\n                            // such as target.onclick = function() {}, so we need to clear this internal\n                            // property too if all delegates with capture=false were removed\n                            // https:// github.com/angular/angular/issues/31643\n                            // https://github.com/angular/angular/issues/54581\n                            if (!capture && typeof eventName === 'string') {\n                                const onPropertySymbol = ZONE_SYMBOL_PREFIX + 'ON_PROPERTY' + eventName;\n                                target[onPropertySymbol] = null;\n                            }\n                        }\n                        // In all other conditions, when `addEventListener` is called after being\n                        // patched by zone.js, we would always find an event task on the `EventTarget`.\n                        // This will trigger `cancelFn` on the `existingTask`, leading to `customCancelGlobal`,\n                        // which ultimately removes an event listener and cleans up the abort listener\n                        // (if an `AbortSignal` was provided when scheduling a task).\n                        existingTask.zone.cancelTask(existingTask);\n                        if (returnTarget) {\n                            return target;\n                        }\n                        return;\n                    }\n                }\n            }\n            // https://github.com/angular/zone.js/issues/930\n            // We may encounter a situation where the `addEventListener` was\n            // called on the event target before zone.js is loaded, resulting\n            // in no task being stored on the event target due to its invocation\n            // of the native implementation. In this scenario, we simply need to\n            // invoke the native `removeEventListener`.\n            return nativeRemoveEventListener.apply(this, arguments);\n        };\n        proto[LISTENERS_EVENT_LISTENER] = function () {\n            const target = this || _global;\n            let eventName = arguments[0];\n            if (patchOptions && patchOptions.transferEventName) {\n                eventName = patchOptions.transferEventName(eventName);\n            }\n            const listeners = [];\n            const tasks = findEventTasks(target, eventNameToString ? eventNameToString(eventName) : eventName);\n            for (let i = 0; i < tasks.length; i++) {\n                const task = tasks[i];\n                let delegate = task.originalDelegate ? task.originalDelegate : task.callback;\n                listeners.push(delegate);\n            }\n            return listeners;\n        };\n        proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER] = function () {\n            const target = this || _global;\n            let eventName = arguments[0];\n            if (!eventName) {\n                const keys = Object.keys(target);\n                for (let i = 0; i < keys.length; i++) {\n                    const prop = keys[i];\n                    const match = EVENT_NAME_SYMBOL_REGX.exec(prop);\n                    let evtName = match && match[1];\n                    // in nodejs EventEmitter, removeListener event is\n                    // used for monitoring the removeListener call,\n                    // so just keep removeListener eventListener until\n                    // all other eventListeners are removed\n                    if (evtName && evtName !== 'removeListener') {\n                        this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, evtName);\n                    }\n                }\n                // remove removeListener listener finally\n                this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, 'removeListener');\n            }\n            else {\n                if (patchOptions && patchOptions.transferEventName) {\n                    eventName = patchOptions.transferEventName(eventName);\n                }\n                const symbolEventNames = zoneSymbolEventNames[eventName];\n                if (symbolEventNames) {\n                    const symbolEventName = symbolEventNames[FALSE_STR];\n                    const symbolCaptureEventName = symbolEventNames[TRUE_STR];\n                    const tasks = target[symbolEventName];\n                    const captureTasks = target[symbolCaptureEventName];\n                    if (tasks) {\n                        const removeTasks = tasks.slice();\n                        for (let i = 0; i < removeTasks.length; i++) {\n                            const task = removeTasks[i];\n                            let delegate = task.originalDelegate ? task.originalDelegate : task.callback;\n                            this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);\n                        }\n                    }\n                    if (captureTasks) {\n                        const removeTasks = captureTasks.slice();\n                        for (let i = 0; i < removeTasks.length; i++) {\n                            const task = removeTasks[i];\n                            let delegate = task.originalDelegate ? task.originalDelegate : task.callback;\n                            this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);\n                        }\n                    }\n                }\n            }\n            if (returnTarget) {\n                return this;\n            }\n        };\n        // for native toString patch\n        attachOriginToPatched(proto[ADD_EVENT_LISTENER], nativeAddEventListener);\n        attachOriginToPatched(proto[REMOVE_EVENT_LISTENER], nativeRemoveEventListener);\n        if (nativeRemoveAllListeners) {\n            attachOriginToPatched(proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER], nativeRemoveAllListeners);\n        }\n        if (nativeListeners) {\n            attachOriginToPatched(proto[LISTENERS_EVENT_LISTENER], nativeListeners);\n        }\n        return true;\n    }\n    let results = [];\n    for (let i = 0; i < apis.length; i++) {\n        results[i] = patchEventTargetMethods(apis[i], patchOptions);\n    }\n    return results;\n}\nfunction findEventTasks(target, eventName) {\n    if (!eventName) {\n        const foundTasks = [];\n        for (let prop in target) {\n            const match = EVENT_NAME_SYMBOL_REGX.exec(prop);\n            let evtName = match && match[1];\n            if (evtName && (!eventName || evtName === eventName)) {\n                const tasks = target[prop];\n                if (tasks) {\n                    for (let i = 0; i < tasks.length; i++) {\n                        foundTasks.push(tasks[i]);\n                    }\n                }\n            }\n        }\n        return foundTasks;\n    }\n    let symbolEventName = zoneSymbolEventNames[eventName];\n    if (!symbolEventName) {\n        prepareEventNames(eventName);\n        symbolEventName = zoneSymbolEventNames[eventName];\n    }\n    const captureFalseTasks = target[symbolEventName[FALSE_STR]];\n    const captureTrueTasks = target[symbolEventName[TRUE_STR]];\n    if (!captureFalseTasks) {\n        return captureTrueTasks ? captureTrueTasks.slice() : [];\n    }\n    else {\n        return captureTrueTasks\n            ? captureFalseTasks.concat(captureTrueTasks)\n            : captureFalseTasks.slice();\n    }\n}\nfunction patchEventPrototype(global, api) {\n    const Event = global['Event'];\n    if (Event && Event.prototype) {\n        api.patchMethod(Event.prototype, 'stopImmediatePropagation', (delegate) => function (self, args) {\n            self[IMMEDIATE_PROPAGATION_SYMBOL] = true;\n            // we need to call the native stopImmediatePropagation\n            // in case in some hybrid application, some part of\n            // application will be controlled by zone, some are not\n            delegate && delegate.apply(self, args);\n        });\n    }\n}\n\n/**\n * @fileoverview\n * @suppress {missingRequire}\n */\nfunction patchQueueMicrotask(global, api) {\n    api.patchMethod(global, 'queueMicrotask', (delegate) => {\n        return function (self, args) {\n            Zone.current.scheduleMicroTask('queueMicrotask', args[0]);\n        };\n    });\n}\n\n/**\n * @fileoverview\n * @suppress {missingRequire}\n */\nconst taskSymbol = zoneSymbol('zoneTask');\nfunction patchTimer(window, setName, cancelName, nameSuffix) {\n    let setNative = null;\n    let clearNative = null;\n    setName += nameSuffix;\n    cancelName += nameSuffix;\n    const tasksByHandleId = {};\n    function scheduleTask(task) {\n        const data = task.data;\n        data.args[0] = function () {\n            return task.invoke.apply(this, arguments);\n        };\n        const handleOrId = setNative.apply(window, data.args);\n        // Whlist on Node.js when get can the ID by using `[Symbol.toPrimitive]()` we do\n        // to this so that we do not cause potentally leaks when using `setTimeout`\n        // since this can be periodic when using `.refresh`.\n        if (isNumber(handleOrId)) {\n            data.handleId = handleOrId;\n        }\n        else {\n            data.handle = handleOrId;\n            // On Node.js a timeout and interval can be restarted over and over again by using the `.refresh` method.\n            data.isRefreshable = isFunction(handleOrId.refresh);\n        }\n        return task;\n    }\n    function clearTask(task) {\n        const { handle, handleId } = task.data;\n        return clearNative.call(window, handle ?? handleId);\n    }\n    setNative = patchMethod(window, setName, (delegate) => function (self, args) {\n        if (isFunction(args[0])) {\n            const options = {\n                isRefreshable: false,\n                isPeriodic: nameSuffix === 'Interval',\n                delay: nameSuffix === 'Timeout' || nameSuffix === 'Interval' ? args[1] || 0 : undefined,\n                args: args,\n            };\n            const callback = args[0];\n            args[0] = function timer() {\n                try {\n                    return callback.apply(this, arguments);\n                }\n                finally {\n                    // issue-934, task will be cancelled\n                    // even it is a periodic task such as\n                    // setInterval\n                    // https://github.com/angular/angular/issues/40387\n                    // Cleanup tasksByHandleId should be handled before scheduleTask\n                    // Since some zoneSpec may intercept and doesn't trigger\n                    // scheduleFn(scheduleTask) provided here.\n                    const { handle, handleId, isPeriodic, isRefreshable } = options;\n                    if (!isPeriodic && !isRefreshable) {\n                        if (handleId) {\n                            // in non-nodejs env, we remove timerId\n                            // from local cache\n                            delete tasksByHandleId[handleId];\n                        }\n                        else if (handle) {\n                            // Node returns complex objects as handleIds\n                            // we remove task reference from timer object\n                            handle[taskSymbol] = null;\n                        }\n                    }\n                }\n            };\n            const task = scheduleMacroTaskWithCurrentZone(setName, args[0], options, scheduleTask, clearTask);\n            if (!task) {\n                return task;\n            }\n            // Node.js must additionally support the ref and unref functions.\n            const { handleId, handle, isRefreshable, isPeriodic } = task.data;\n            if (handleId) {\n                // for non nodejs env, we save handleId: task\n                // mapping in local cache for clearTimeout\n                tasksByHandleId[handleId] = task;\n            }\n            else if (handle) {\n                // for nodejs env, we save task\n                // reference in timerId Object for clearTimeout\n                handle[taskSymbol] = task;\n                if (isRefreshable && !isPeriodic) {\n                    const originalRefresh = handle.refresh;\n                    handle.refresh = function () {\n                        const { zone, state } = task;\n                        if (state === 'notScheduled') {\n                            task._state = 'scheduled';\n                            zone._updateTaskCount(task, 1);\n                        }\n                        else if (state === 'running') {\n                            task._state = 'scheduling';\n                        }\n                        return originalRefresh.call(this);\n                    };\n                }\n            }\n            return handle ?? handleId ?? task;\n        }\n        else {\n            // cause an error by calling it directly.\n            return delegate.apply(window, args);\n        }\n    });\n    clearNative = patchMethod(window, cancelName, (delegate) => function (self, args) {\n        const id = args[0];\n        let task;\n        if (isNumber(id)) {\n            // non nodejs env.\n            task = tasksByHandleId[id];\n            delete tasksByHandleId[id];\n        }\n        else {\n            // nodejs env ?? other environments.\n            task = id?.[taskSymbol];\n            if (task) {\n                id[taskSymbol] = null;\n            }\n            else {\n                task = id;\n            }\n        }\n        if (task?.type) {\n            if (task.cancelFn) {\n                // Do not cancel already canceled functions\n                task.zone.cancelTask(task);\n            }\n        }\n        else {\n            // cause an error by calling it directly.\n            delegate.apply(window, args);\n        }\n    });\n}\n\nfunction patchCustomElements(_global, api) {\n    const { isBrowser, isMix } = api.getGlobalObjects();\n    if ((!isBrowser && !isMix) || !_global['customElements'] || !('customElements' in _global)) {\n        return;\n    }\n    // https://html.spec.whatwg.org/multipage/custom-elements.html#concept-custom-element-definition-lifecycle-callbacks\n    const callbacks = [\n        'connectedCallback',\n        'disconnectedCallback',\n        'adoptedCallback',\n        'attributeChangedCallback',\n        'formAssociatedCallback',\n        'formDisabledCallback',\n        'formResetCallback',\n        'formStateRestoreCallback',\n    ];\n    api.patchCallbacks(api, _global.customElements, 'customElements', 'define', callbacks);\n}\n\nfunction eventTargetPatch(_global, api) {\n    if (Zone[api.symbol('patchEventTarget')]) {\n        // EventTarget is already patched.\n        return;\n    }\n    const { eventNames, zoneSymbolEventNames, TRUE_STR, FALSE_STR, ZONE_SYMBOL_PREFIX } = api.getGlobalObjects();\n    //  predefine all __zone_symbol__ + eventName + true/false string\n    for (let i = 0; i < eventNames.length; i++) {\n        const eventName = eventNames[i];\n        const falseEventName = eventName + FALSE_STR;\n        const trueEventName = eventName + TRUE_STR;\n        const symbol = ZONE_SYMBOL_PREFIX + falseEventName;\n        const symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;\n        zoneSymbolEventNames[eventName] = {};\n        zoneSymbolEventNames[eventName][FALSE_STR] = symbol;\n        zoneSymbolEventNames[eventName][TRUE_STR] = symbolCapture;\n    }\n    const EVENT_TARGET = _global['EventTarget'];\n    if (!EVENT_TARGET || !EVENT_TARGET.prototype) {\n        return;\n    }\n    api.patchEventTarget(_global, api, [EVENT_TARGET && EVENT_TARGET.prototype]);\n    return true;\n}\nfunction patchEvent(global, api) {\n    api.patchEventPrototype(global, api);\n}\n\n/**\n * @fileoverview\n * @suppress {globalThis}\n */\nfunction filterProperties(target, onProperties, ignoreProperties) {\n    if (!ignoreProperties || ignoreProperties.length === 0) {\n        return onProperties;\n    }\n    const tip = ignoreProperties.filter((ip) => ip.target === target);\n    if (tip.length === 0) {\n        return onProperties;\n    }\n    const targetIgnoreProperties = tip[0].ignoreProperties;\n    return onProperties.filter((op) => targetIgnoreProperties.indexOf(op) === -1);\n}\nfunction patchFilteredProperties(target, onProperties, ignoreProperties, prototype) {\n    // check whether target is available, sometimes target will be undefined\n    // because different browser or some 3rd party plugin.\n    if (!target) {\n        return;\n    }\n    const filteredProperties = filterProperties(target, onProperties, ignoreProperties);\n    patchOnProperties(target, filteredProperties, prototype);\n}\n/**\n * Get all event name properties which the event name startsWith `on`\n * from the target object itself, inherited properties are not considered.\n */\nfunction getOnEventNames(target) {\n    return Object.getOwnPropertyNames(target)\n        .filter((name) => name.startsWith('on') && name.length > 2)\n        .map((name) => name.substring(2));\n}\nfunction propertyDescriptorPatch(api, _global) {\n    if (isNode && !isMix) {\n        return;\n    }\n    if (Zone[api.symbol('patchEvents')]) {\n        // events are already been patched by legacy patch.\n        return;\n    }\n    const ignoreProperties = _global['__Zone_ignore_on_properties'];\n    // for browsers that we can patch the descriptor:  Chrome & Firefox\n    let patchTargets = [];\n    if (isBrowser) {\n        const internalWindow = window;\n        patchTargets = patchTargets.concat([\n            'Document',\n            'SVGElement',\n            'Element',\n            'HTMLElement',\n            'HTMLBodyElement',\n            'HTMLMediaElement',\n            'HTMLFrameSetElement',\n            'HTMLFrameElement',\n            'HTMLIFrameElement',\n            'HTMLMarqueeElement',\n            'Worker',\n        ]);\n        const ignoreErrorProperties = [];\n        // In older browsers like IE or Edge, event handler properties (e.g., `onclick`)\n        // may not be defined directly on the `window` object but on its prototype (`WindowPrototype`).\n        // To ensure complete coverage, we use the prototype when checking\n        // for and patching these properties.\n        patchFilteredProperties(internalWindow, getOnEventNames(internalWindow), ignoreProperties ? ignoreProperties.concat(ignoreErrorProperties) : ignoreProperties, ObjectGetPrototypeOf(internalWindow));\n    }\n    patchTargets = patchTargets.concat([\n        'XMLHttpRequest',\n        'XMLHttpRequestEventTarget',\n        'IDBIndex',\n        'IDBRequest',\n        'IDBOpenDBRequest',\n        'IDBDatabase',\n        'IDBTransaction',\n        'IDBCursor',\n        'WebSocket',\n    ]);\n    for (let i = 0; i < patchTargets.length; i++) {\n        const target = _global[patchTargets[i]];\n        target?.prototype &&\n            patchFilteredProperties(target.prototype, getOnEventNames(target.prototype), ignoreProperties);\n    }\n}\n\n/**\n * @fileoverview\n * @suppress {missingRequire}\n */\nfunction patchBrowser(Zone) {\n    Zone.__load_patch('legacy', (global) => {\n        const legacyPatch = global[Zone.__symbol__('legacyPatch')];\n        if (legacyPatch) {\n            legacyPatch();\n        }\n    });\n    Zone.__load_patch('timers', (global) => {\n        const set = 'set';\n        const clear = 'clear';\n        patchTimer(global, set, clear, 'Timeout');\n        patchTimer(global, set, clear, 'Interval');\n        patchTimer(global, set, clear, 'Immediate');\n    });\n    Zone.__load_patch('requestAnimationFrame', (global) => {\n        patchTimer(global, 'request', 'cancel', 'AnimationFrame');\n        patchTimer(global, 'mozRequest', 'mozCancel', 'AnimationFrame');\n        patchTimer(global, 'webkitRequest', 'webkitCancel', 'AnimationFrame');\n    });\n    Zone.__load_patch('blocking', (global, Zone) => {\n        const blockingMethods = ['alert', 'prompt', 'confirm'];\n        for (let i = 0; i < blockingMethods.length; i++) {\n            const name = blockingMethods[i];\n            patchMethod(global, name, (delegate, symbol, name) => {\n                return function (s, args) {\n                    return Zone.current.run(delegate, global, args, name);\n                };\n            });\n        }\n    });\n    Zone.__load_patch('EventTarget', (global, Zone, api) => {\n        patchEvent(global, api);\n        eventTargetPatch(global, api);\n        // patch XMLHttpRequestEventTarget's addEventListener/removeEventListener\n        const XMLHttpRequestEventTarget = global['XMLHttpRequestEventTarget'];\n        if (XMLHttpRequestEventTarget && XMLHttpRequestEventTarget.prototype) {\n            api.patchEventTarget(global, api, [XMLHttpRequestEventTarget.prototype]);\n        }\n    });\n    Zone.__load_patch('MutationObserver', (global, Zone, api) => {\n        patchClass('MutationObserver');\n        patchClass('WebKitMutationObserver');\n    });\n    Zone.__load_patch('IntersectionObserver', (global, Zone, api) => {\n        patchClass('IntersectionObserver');\n    });\n    Zone.__load_patch('FileReader', (global, Zone, api) => {\n        patchClass('FileReader');\n    });\n    Zone.__load_patch('on_property', (global, Zone, api) => {\n        propertyDescriptorPatch(api, global);\n    });\n    Zone.__load_patch('customElements', (global, Zone, api) => {\n        patchCustomElements(global, api);\n    });\n    Zone.__load_patch('XHR', (global, Zone) => {\n        // Treat XMLHttpRequest as a macrotask.\n        patchXHR(global);\n        const XHR_TASK = zoneSymbol('xhrTask');\n        const XHR_SYNC = zoneSymbol('xhrSync');\n        const XHR_LISTENER = zoneSymbol('xhrListener');\n        const XHR_SCHEDULED = zoneSymbol('xhrScheduled');\n        const XHR_URL = zoneSymbol('xhrURL');\n        const XHR_ERROR_BEFORE_SCHEDULED = zoneSymbol('xhrErrorBeforeScheduled');\n        function patchXHR(window) {\n            const XMLHttpRequest = window['XMLHttpRequest'];\n            if (!XMLHttpRequest) {\n                // XMLHttpRequest is not available in service worker\n                return;\n            }\n            const XMLHttpRequestPrototype = XMLHttpRequest.prototype;\n            function findPendingTask(target) {\n                return target[XHR_TASK];\n            }\n            let oriAddListener = XMLHttpRequestPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];\n            let oriRemoveListener = XMLHttpRequestPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];\n            if (!oriAddListener) {\n                const XMLHttpRequestEventTarget = window['XMLHttpRequestEventTarget'];\n                if (XMLHttpRequestEventTarget) {\n                    const XMLHttpRequestEventTargetPrototype = XMLHttpRequestEventTarget.prototype;\n                    oriAddListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];\n                    oriRemoveListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];\n                }\n            }\n            const READY_STATE_CHANGE = 'readystatechange';\n            const SCHEDULED = 'scheduled';\n            function scheduleTask(task) {\n                const data = task.data;\n                const target = data.target;\n                target[XHR_SCHEDULED] = false;\n                target[XHR_ERROR_BEFORE_SCHEDULED] = false;\n                // remove existing event listener\n                const listener = target[XHR_LISTENER];\n                if (!oriAddListener) {\n                    oriAddListener = target[ZONE_SYMBOL_ADD_EVENT_LISTENER];\n                    oriRemoveListener = target[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];\n                }\n                if (listener) {\n                    oriRemoveListener.call(target, READY_STATE_CHANGE, listener);\n                }\n                const newListener = (target[XHR_LISTENER] = () => {\n                    if (target.readyState === target.DONE) {\n                        // sometimes on some browsers XMLHttpRequest will fire onreadystatechange with\n                        // readyState=4 multiple times, so we need to check task state here\n                        if (!data.aborted && target[XHR_SCHEDULED] && task.state === SCHEDULED) {\n                            // check whether the xhr has registered onload listener\n                            // if that is the case, the task should invoke after all\n                            // onload listeners finish.\n                            // Also if the request failed without response (status = 0), the load event handler\n                            // will not be triggered, in that case, we should also invoke the placeholder callback\n                            // to close the XMLHttpRequest::send macroTask.\n                            // https://github.com/angular/angular/issues/38795\n                            const loadTasks = target[Zone.__symbol__('loadfalse')];\n                            if (target.status !== 0 && loadTasks && loadTasks.length > 0) {\n                                const oriInvoke = task.invoke;\n                                task.invoke = function () {\n                                    // need to load the tasks again, because in other\n                                    // load listener, they may remove themselves\n                                    const loadTasks = target[Zone.__symbol__('loadfalse')];\n                                    for (let i = 0; i < loadTasks.length; i++) {\n                                        if (loadTasks[i] === task) {\n                                            loadTasks.splice(i, 1);\n                                        }\n                                    }\n                                    if (!data.aborted && task.state === SCHEDULED) {\n                                        oriInvoke.call(task);\n                                    }\n                                };\n                                loadTasks.push(task);\n                            }\n                            else {\n                                task.invoke();\n                            }\n                        }\n                        else if (!data.aborted && target[XHR_SCHEDULED] === false) {\n                            // error occurs when xhr.send()\n                            target[XHR_ERROR_BEFORE_SCHEDULED] = true;\n                        }\n                    }\n                });\n                oriAddListener.call(target, READY_STATE_CHANGE, newListener);\n                const storedTask = target[XHR_TASK];\n                if (!storedTask) {\n                    target[XHR_TASK] = task;\n                }\n                sendNative.apply(target, data.args);\n                target[XHR_SCHEDULED] = true;\n                return task;\n            }\n            function placeholderCallback() { }\n            function clearTask(task) {\n                const data = task.data;\n                // Note - ideally, we would call data.target.removeEventListener here, but it's too late\n                // to prevent it from firing. So instead, we store info for the event listener.\n                data.aborted = true;\n                return abortNative.apply(data.target, data.args);\n            }\n            const openNative = patchMethod(XMLHttpRequestPrototype, 'open', () => function (self, args) {\n                self[XHR_SYNC] = args[2] == false;\n                self[XHR_URL] = args[1];\n                return openNative.apply(self, args);\n            });\n            const XMLHTTPREQUEST_SOURCE = 'XMLHttpRequest.send';\n            const fetchTaskAborting = zoneSymbol('fetchTaskAborting');\n            const fetchTaskScheduling = zoneSymbol('fetchTaskScheduling');\n            const sendNative = patchMethod(XMLHttpRequestPrototype, 'send', () => function (self, args) {\n                if (Zone.current[fetchTaskScheduling] === true) {\n                    // a fetch is scheduling, so we are using xhr to polyfill fetch\n                    // and because we already schedule macroTask for fetch, we should\n                    // not schedule a macroTask for xhr again\n                    return sendNative.apply(self, args);\n                }\n                if (self[XHR_SYNC]) {\n                    // if the XHR is sync there is no task to schedule, just execute the code.\n                    return sendNative.apply(self, args);\n                }\n                else {\n                    const options = {\n                        target: self,\n                        url: self[XHR_URL],\n                        isPeriodic: false,\n                        args: args,\n                        aborted: false,\n                    };\n                    const task = scheduleMacroTaskWithCurrentZone(XMLHTTPREQUEST_SOURCE, placeholderCallback, options, scheduleTask, clearTask);\n                    if (self &&\n                        self[XHR_ERROR_BEFORE_SCHEDULED] === true &&\n                        !options.aborted &&\n                        task.state === SCHEDULED) {\n                        // xhr request throw error when send\n                        // we should invoke task instead of leaving a scheduled\n                        // pending macroTask\n                        task.invoke();\n                    }\n                }\n            });\n            const abortNative = patchMethod(XMLHttpRequestPrototype, 'abort', () => function (self, args) {\n                const task = findPendingTask(self);\n                if (task && typeof task.type == 'string') {\n                    // If the XHR has already completed, do nothing.\n                    // If the XHR has already been aborted, do nothing.\n                    // Fix #569, call abort multiple times before done will cause\n                    // macroTask task count be negative number\n                    if (task.cancelFn == null || (task.data && task.data.aborted)) {\n                        return;\n                    }\n                    task.zone.cancelTask(task);\n                }\n                else if (Zone.current[fetchTaskAborting] === true) {\n                    // the abort is called from fetch polyfill, we need to call native abort of XHR.\n                    return abortNative.apply(self, args);\n                }\n                // Otherwise, we are trying to abort an XHR which has not yet been sent, so there is no\n                // task\n                // to cancel. Do nothing.\n            });\n        }\n    });\n    Zone.__load_patch('geolocation', (global) => {\n        /// GEO_LOCATION\n        if (global['navigator'] && global['navigator'].geolocation) {\n            patchPrototype(global['navigator'].geolocation, ['getCurrentPosition', 'watchPosition']);\n        }\n    });\n    Zone.__load_patch('PromiseRejectionEvent', (global, Zone) => {\n        // handle unhandled promise rejection\n        function findPromiseRejectionHandler(evtName) {\n            return function (e) {\n                const eventTasks = findEventTasks(global, evtName);\n                eventTasks.forEach((eventTask) => {\n                    // windows has added unhandledrejection event listener\n                    // trigger the event listener\n                    const PromiseRejectionEvent = global['PromiseRejectionEvent'];\n                    if (PromiseRejectionEvent) {\n                        const evt = new PromiseRejectionEvent(evtName, {\n                            promise: e.promise,\n                            reason: e.rejection,\n                        });\n                        eventTask.invoke(evt);\n                    }\n                });\n            };\n        }\n        if (global['PromiseRejectionEvent']) {\n            Zone[zoneSymbol('unhandledPromiseRejectionHandler')] =\n                findPromiseRejectionHandler('unhandledrejection');\n            Zone[zoneSymbol('rejectionHandledHandler')] =\n                findPromiseRejectionHandler('rejectionhandled');\n        }\n    });\n    Zone.__load_patch('queueMicrotask', (global, Zone, api) => {\n        patchQueueMicrotask(global, api);\n    });\n}\n\nfunction patchPromise(Zone) {\n    Zone.__load_patch('ZoneAwarePromise', (global, Zone, api) => {\n        const ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n        const ObjectDefineProperty = Object.defineProperty;\n        function readableObjectToString(obj) {\n            if (obj && obj.toString === Object.prototype.toString) {\n                const className = obj.constructor && obj.constructor.name;\n                return (className ? className : '') + ': ' + JSON.stringify(obj);\n            }\n            return obj ? obj.toString() : Object.prototype.toString.call(obj);\n        }\n        const __symbol__ = api.symbol;\n        const _uncaughtPromiseErrors = [];\n        const isDisableWrappingUncaughtPromiseRejection = global[__symbol__('DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION')] !== false;\n        const symbolPromise = __symbol__('Promise');\n        const symbolThen = __symbol__('then');\n        const creationTrace = '__creationTrace__';\n        api.onUnhandledError = (e) => {\n            if (api.showUncaughtError()) {\n                const rejection = e && e.rejection;\n                if (rejection) {\n                    console.error('Unhandled Promise rejection:', rejection instanceof Error ? rejection.message : rejection, '; Zone:', e.zone.name, '; Task:', e.task && e.task.source, '; Value:', rejection, rejection instanceof Error ? rejection.stack : undefined);\n                }\n                else {\n                    console.error(e);\n                }\n            }\n        };\n        api.microtaskDrainDone = () => {\n            while (_uncaughtPromiseErrors.length) {\n                const uncaughtPromiseError = _uncaughtPromiseErrors.shift();\n                try {\n                    uncaughtPromiseError.zone.runGuarded(() => {\n                        if (uncaughtPromiseError.throwOriginal) {\n                            throw uncaughtPromiseError.rejection;\n                        }\n                        throw uncaughtPromiseError;\n                    });\n                }\n                catch (error) {\n                    handleUnhandledRejection(error);\n                }\n            }\n        };\n        const UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL = __symbol__('unhandledPromiseRejectionHandler');\n        function handleUnhandledRejection(e) {\n            api.onUnhandledError(e);\n            try {\n                const handler = Zone[UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL];\n                if (typeof handler === 'function') {\n                    handler.call(this, e);\n                }\n            }\n            catch (err) { }\n        }\n        function isThenable(value) {\n            return value && typeof value.then === 'function';\n        }\n        function forwardResolution(value) {\n            return value;\n        }\n        function forwardRejection(rejection) {\n            return ZoneAwarePromise.reject(rejection);\n        }\n        const symbolState = __symbol__('state');\n        const symbolValue = __symbol__('value');\n        const symbolFinally = __symbol__('finally');\n        const symbolParentPromiseValue = __symbol__('parentPromiseValue');\n        const symbolParentPromiseState = __symbol__('parentPromiseState');\n        const source = 'Promise.then';\n        const UNRESOLVED = null;\n        const RESOLVED = true;\n        const REJECTED = false;\n        const REJECTED_NO_CATCH = 0;\n        function makeResolver(promise, state) {\n            return (v) => {\n                try {\n                    resolvePromise(promise, state, v);\n                }\n                catch (err) {\n                    resolvePromise(promise, false, err);\n                }\n                // Do not return value or you will break the Promise spec.\n            };\n        }\n        const once = function () {\n            let wasCalled = false;\n            return function wrapper(wrappedFunction) {\n                return function () {\n                    if (wasCalled) {\n                        return;\n                    }\n                    wasCalled = true;\n                    wrappedFunction.apply(null, arguments);\n                };\n            };\n        };\n        const TYPE_ERROR = 'Promise resolved with itself';\n        const CURRENT_TASK_TRACE_SYMBOL = __symbol__('currentTaskTrace');\n        // Promise Resolution\n        function resolvePromise(promise, state, value) {\n            const onceWrapper = once();\n            if (promise === value) {\n                throw new TypeError(TYPE_ERROR);\n            }\n            if (promise[symbolState] === UNRESOLVED) {\n                // should only get value.then once based on promise spec.\n                let then = null;\n                try {\n                    if (typeof value === 'object' || typeof value === 'function') {\n                        then = value && value.then;\n                    }\n                }\n                catch (err) {\n                    onceWrapper(() => {\n                        resolvePromise(promise, false, err);\n                    })();\n                    return promise;\n                }\n                // if (value instanceof ZoneAwarePromise) {\n                if (state !== REJECTED &&\n                    value instanceof ZoneAwarePromise &&\n                    value.hasOwnProperty(symbolState) &&\n                    value.hasOwnProperty(symbolValue) &&\n                    value[symbolState] !== UNRESOLVED) {\n                    clearRejectedNoCatch(value);\n                    resolvePromise(promise, value[symbolState], value[symbolValue]);\n                }\n                else if (state !== REJECTED && typeof then === 'function') {\n                    try {\n                        then.call(value, onceWrapper(makeResolver(promise, state)), onceWrapper(makeResolver(promise, false)));\n                    }\n                    catch (err) {\n                        onceWrapper(() => {\n                            resolvePromise(promise, false, err);\n                        })();\n                    }\n                }\n                else {\n                    promise[symbolState] = state;\n                    const queue = promise[symbolValue];\n                    promise[symbolValue] = value;\n                    if (promise[symbolFinally] === symbolFinally) {\n                        // the promise is generated by Promise.prototype.finally\n                        if (state === RESOLVED) {\n                            // the state is resolved, should ignore the value\n                            // and use parent promise value\n                            promise[symbolState] = promise[symbolParentPromiseState];\n                            promise[symbolValue] = promise[symbolParentPromiseValue];\n                        }\n                    }\n                    // record task information in value when error occurs, so we can\n                    // do some additional work such as render longStackTrace\n                    if (state === REJECTED && value instanceof Error) {\n                        // check if longStackTraceZone is here\n                        const trace = Zone.currentTask &&\n                            Zone.currentTask.data &&\n                            Zone.currentTask.data[creationTrace];\n                        if (trace) {\n                            // only keep the long stack trace into error when in longStackTraceZone\n                            ObjectDefineProperty(value, CURRENT_TASK_TRACE_SYMBOL, {\n                                configurable: true,\n                                enumerable: false,\n                                writable: true,\n                                value: trace,\n                            });\n                        }\n                    }\n                    for (let i = 0; i < queue.length;) {\n                        scheduleResolveOrReject(promise, queue[i++], queue[i++], queue[i++], queue[i++]);\n                    }\n                    if (queue.length == 0 && state == REJECTED) {\n                        promise[symbolState] = REJECTED_NO_CATCH;\n                        let uncaughtPromiseError = value;\n                        try {\n                            // Here we throws a new Error to print more readable error log\n                            // and if the value is not an error, zone.js builds an `Error`\n                            // Object here to attach the stack information.\n                            throw new Error('Uncaught (in promise): ' +\n                                readableObjectToString(value) +\n                                (value && value.stack ? '\\n' + value.stack : ''));\n                        }\n                        catch (err) {\n                            uncaughtPromiseError = err;\n                        }\n                        if (isDisableWrappingUncaughtPromiseRejection) {\n                            // If disable wrapping uncaught promise reject\n                            // use the value instead of wrapping it.\n                            uncaughtPromiseError.throwOriginal = true;\n                        }\n                        uncaughtPromiseError.rejection = value;\n                        uncaughtPromiseError.promise = promise;\n                        uncaughtPromiseError.zone = Zone.current;\n                        uncaughtPromiseError.task = Zone.currentTask;\n                        _uncaughtPromiseErrors.push(uncaughtPromiseError);\n                        api.scheduleMicroTask(); // to make sure that it is running\n                    }\n                }\n            }\n            // Resolving an already resolved promise is a noop.\n            return promise;\n        }\n        const REJECTION_HANDLED_HANDLER = __symbol__('rejectionHandledHandler');\n        function clearRejectedNoCatch(promise) {\n            if (promise[symbolState] === REJECTED_NO_CATCH) {\n                // if the promise is rejected no catch status\n                // and queue.length > 0, means there is a error handler\n                // here to handle the rejected promise, we should trigger\n                // windows.rejectionhandled eventHandler or nodejs rejectionHandled\n                // eventHandler\n                try {\n                    const handler = Zone[REJECTION_HANDLED_HANDLER];\n                    if (handler && typeof handler === 'function') {\n                        handler.call(this, { rejection: promise[symbolValue], promise: promise });\n                    }\n                }\n                catch (err) { }\n                promise[symbolState] = REJECTED;\n                for (let i = 0; i < _uncaughtPromiseErrors.length; i++) {\n                    if (promise === _uncaughtPromiseErrors[i].promise) {\n                        _uncaughtPromiseErrors.splice(i, 1);\n                    }\n                }\n            }\n        }\n        function scheduleResolveOrReject(promise, zone, chainPromise, onFulfilled, onRejected) {\n            clearRejectedNoCatch(promise);\n            const promiseState = promise[symbolState];\n            const delegate = promiseState\n                ? typeof onFulfilled === 'function'\n                    ? onFulfilled\n                    : forwardResolution\n                : typeof onRejected === 'function'\n                    ? onRejected\n                    : forwardRejection;\n            zone.scheduleMicroTask(source, () => {\n                try {\n                    const parentPromiseValue = promise[symbolValue];\n                    const isFinallyPromise = !!chainPromise && symbolFinally === chainPromise[symbolFinally];\n                    if (isFinallyPromise) {\n                        // if the promise is generated from finally call, keep parent promise's state and value\n                        chainPromise[symbolParentPromiseValue] = parentPromiseValue;\n                        chainPromise[symbolParentPromiseState] = promiseState;\n                    }\n                    // should not pass value to finally callback\n                    const value = zone.run(delegate, undefined, isFinallyPromise && delegate !== forwardRejection && delegate !== forwardResolution\n                        ? []\n                        : [parentPromiseValue]);\n                    resolvePromise(chainPromise, true, value);\n                }\n                catch (error) {\n                    // if error occurs, should always return this error\n                    resolvePromise(chainPromise, false, error);\n                }\n            }, chainPromise);\n        }\n        const ZONE_AWARE_PROMISE_TO_STRING = 'function ZoneAwarePromise() { [native code] }';\n        const noop = function () { };\n        const AggregateError = global.AggregateError;\n        class ZoneAwarePromise {\n            static toString() {\n                return ZONE_AWARE_PROMISE_TO_STRING;\n            }\n            static resolve(value) {\n                if (value instanceof ZoneAwarePromise) {\n                    return value;\n                }\n                return resolvePromise(new this(null), RESOLVED, value);\n            }\n            static reject(error) {\n                return resolvePromise(new this(null), REJECTED, error);\n            }\n            static withResolvers() {\n                const result = {};\n                result.promise = new ZoneAwarePromise((res, rej) => {\n                    result.resolve = res;\n                    result.reject = rej;\n                });\n                return result;\n            }\n            static any(values) {\n                if (!values || typeof values[Symbol.iterator] !== 'function') {\n                    return Promise.reject(new AggregateError([], 'All promises were rejected'));\n                }\n                const promises = [];\n                let count = 0;\n                try {\n                    for (let v of values) {\n                        count++;\n                        promises.push(ZoneAwarePromise.resolve(v));\n                    }\n                }\n                catch (err) {\n                    return Promise.reject(new AggregateError([], 'All promises were rejected'));\n                }\n                if (count === 0) {\n                    return Promise.reject(new AggregateError([], 'All promises were rejected'));\n                }\n                let finished = false;\n                const errors = [];\n                return new ZoneAwarePromise((resolve, reject) => {\n                    for (let i = 0; i < promises.length; i++) {\n                        promises[i].then((v) => {\n                            if (finished) {\n                                return;\n                            }\n                            finished = true;\n                            resolve(v);\n                        }, (err) => {\n                            errors.push(err);\n                            count--;\n                            if (count === 0) {\n                                finished = true;\n                                reject(new AggregateError(errors, 'All promises were rejected'));\n                            }\n                        });\n                    }\n                });\n            }\n            static race(values) {\n                let resolve;\n                let reject;\n                let promise = new this((res, rej) => {\n                    resolve = res;\n                    reject = rej;\n                });\n                function onResolve(value) {\n                    resolve(value);\n                }\n                function onReject(error) {\n                    reject(error);\n                }\n                for (let value of values) {\n                    if (!isThenable(value)) {\n                        value = this.resolve(value);\n                    }\n                    value.then(onResolve, onReject);\n                }\n                return promise;\n            }\n            static all(values) {\n                return ZoneAwarePromise.allWithCallback(values);\n            }\n            static allSettled(values) {\n                const P = this && this.prototype instanceof ZoneAwarePromise ? this : ZoneAwarePromise;\n                return P.allWithCallback(values, {\n                    thenCallback: (value) => ({ status: 'fulfilled', value }),\n                    errorCallback: (err) => ({ status: 'rejected', reason: err }),\n                });\n            }\n            static allWithCallback(values, callback) {\n                let resolve;\n                let reject;\n                let promise = new this((res, rej) => {\n                    resolve = res;\n                    reject = rej;\n                });\n                // Start at 2 to prevent prematurely resolving if .then is called immediately.\n                let unresolvedCount = 2;\n                let valueIndex = 0;\n                const resolvedValues = [];\n                for (let value of values) {\n                    if (!isThenable(value)) {\n                        value = this.resolve(value);\n                    }\n                    const curValueIndex = valueIndex;\n                    try {\n                        value.then((value) => {\n                            resolvedValues[curValueIndex] = callback ? callback.thenCallback(value) : value;\n                            unresolvedCount--;\n                            if (unresolvedCount === 0) {\n                                resolve(resolvedValues);\n                            }\n                        }, (err) => {\n                            if (!callback) {\n                                reject(err);\n                            }\n                            else {\n                                resolvedValues[curValueIndex] = callback.errorCallback(err);\n                                unresolvedCount--;\n                                if (unresolvedCount === 0) {\n                                    resolve(resolvedValues);\n                                }\n                            }\n                        });\n                    }\n                    catch (thenErr) {\n                        reject(thenErr);\n                    }\n                    unresolvedCount++;\n                    valueIndex++;\n                }\n                // Make the unresolvedCount zero-based again.\n                unresolvedCount -= 2;\n                if (unresolvedCount === 0) {\n                    resolve(resolvedValues);\n                }\n                return promise;\n            }\n            constructor(executor) {\n                const promise = this;\n                if (!(promise instanceof ZoneAwarePromise)) {\n                    throw new Error('Must be an instanceof Promise.');\n                }\n                promise[symbolState] = UNRESOLVED;\n                promise[symbolValue] = []; // queue;\n                try {\n                    const onceWrapper = once();\n                    executor &&\n                        executor(onceWrapper(makeResolver(promise, RESOLVED)), onceWrapper(makeResolver(promise, REJECTED)));\n                }\n                catch (error) {\n                    resolvePromise(promise, false, error);\n                }\n            }\n            get [Symbol.toStringTag]() {\n                return 'Promise';\n            }\n            get [Symbol.species]() {\n                return ZoneAwarePromise;\n            }\n            then(onFulfilled, onRejected) {\n                // We must read `Symbol.species` safely because `this` may be anything. For instance, `this`\n                // may be an object without a prototype (created through `Object.create(null)`); thus\n                // `this.constructor` will be undefined. One of the use cases is SystemJS creating\n                // prototype-less objects (modules) via `Object.create(null)`. The SystemJS creates an empty\n                // object and copies promise properties into that object (within the `getOrCreateLoad`\n                // function). The zone.js then checks if the resolved value has the `then` method and\n                // invokes it with the `value` context. Otherwise, this will throw an error: `TypeError:\n                // Cannot read properties of undefined (reading 'Symbol(Symbol.species)')`.\n                let C = this.constructor?.[Symbol.species];\n                if (!C || typeof C !== 'function') {\n                    C = this.constructor || ZoneAwarePromise;\n                }\n                const chainPromise = new C(noop);\n                const zone = Zone.current;\n                if (this[symbolState] == UNRESOLVED) {\n                    this[symbolValue].push(zone, chainPromise, onFulfilled, onRejected);\n                }\n                else {\n                    scheduleResolveOrReject(this, zone, chainPromise, onFulfilled, onRejected);\n                }\n                return chainPromise;\n            }\n            catch(onRejected) {\n                return this.then(null, onRejected);\n            }\n            finally(onFinally) {\n                // See comment on the call to `then` about why thee `Symbol.species` is safely accessed.\n                let C = this.constructor?.[Symbol.species];\n                if (!C || typeof C !== 'function') {\n                    C = ZoneAwarePromise;\n                }\n                const chainPromise = new C(noop);\n                chainPromise[symbolFinally] = symbolFinally;\n                const zone = Zone.current;\n                if (this[symbolState] == UNRESOLVED) {\n                    this[symbolValue].push(zone, chainPromise, onFinally, onFinally);\n                }\n                else {\n                    scheduleResolveOrReject(this, zone, chainPromise, onFinally, onFinally);\n                }\n                return chainPromise;\n            }\n        }\n        // Protect against aggressive optimizers dropping seemingly unused properties.\n        // E.g. Closure Compiler in advanced mode.\n        ZoneAwarePromise['resolve'] = ZoneAwarePromise.resolve;\n        ZoneAwarePromise['reject'] = ZoneAwarePromise.reject;\n        ZoneAwarePromise['race'] = ZoneAwarePromise.race;\n        ZoneAwarePromise['all'] = ZoneAwarePromise.all;\n        const NativePromise = (global[symbolPromise] = global['Promise']);\n        global['Promise'] = ZoneAwarePromise;\n        const symbolThenPatched = __symbol__('thenPatched');\n        function patchThen(Ctor) {\n            const proto = Ctor.prototype;\n            const prop = ObjectGetOwnPropertyDescriptor(proto, 'then');\n            if (prop && (prop.writable === false || !prop.configurable)) {\n                // check Ctor.prototype.then propertyDescriptor is writable or not\n                // in meteor env, writable is false, we should ignore such case\n                return;\n            }\n            const originalThen = proto.then;\n            // Keep a reference to the original method.\n            proto[symbolThen] = originalThen;\n            Ctor.prototype.then = function (onResolve, onReject) {\n                const wrapped = new ZoneAwarePromise((resolve, reject) => {\n                    originalThen.call(this, resolve, reject);\n                });\n                return wrapped.then(onResolve, onReject);\n            };\n            Ctor[symbolThenPatched] = true;\n        }\n        api.patchThen = patchThen;\n        function zoneify(fn) {\n            return function (self, args) {\n                let resultPromise = fn.apply(self, args);\n                if (resultPromise instanceof ZoneAwarePromise) {\n                    return resultPromise;\n                }\n                let ctor = resultPromise.constructor;\n                if (!ctor[symbolThenPatched]) {\n                    patchThen(ctor);\n                }\n                return resultPromise;\n            };\n        }\n        if (NativePromise) {\n            patchThen(NativePromise);\n            patchMethod(global, 'fetch', (delegate) => zoneify(delegate));\n        }\n        // This is not part of public API, but it is useful for tests, so we expose it.\n        Promise[Zone.__symbol__('uncaughtPromiseErrors')] = _uncaughtPromiseErrors;\n        return ZoneAwarePromise;\n    });\n}\n\nfunction patchToString(Zone) {\n    // override Function.prototype.toString to make zone.js patched function\n    // look like native function\n    Zone.__load_patch('toString', (global) => {\n        // patch Func.prototype.toString to let them look like native\n        const originalFunctionToString = Function.prototype.toString;\n        const ORIGINAL_DELEGATE_SYMBOL = zoneSymbol('OriginalDelegate');\n        const PROMISE_SYMBOL = zoneSymbol('Promise');\n        const ERROR_SYMBOL = zoneSymbol('Error');\n        const newFunctionToString = function toString() {\n            if (typeof this === 'function') {\n                const originalDelegate = this[ORIGINAL_DELEGATE_SYMBOL];\n                if (originalDelegate) {\n                    if (typeof originalDelegate === 'function') {\n                        return originalFunctionToString.call(originalDelegate);\n                    }\n                    else {\n                        return Object.prototype.toString.call(originalDelegate);\n                    }\n                }\n                if (this === Promise) {\n                    const nativePromise = global[PROMISE_SYMBOL];\n                    if (nativePromise) {\n                        return originalFunctionToString.call(nativePromise);\n                    }\n                }\n                if (this === Error) {\n                    const nativeError = global[ERROR_SYMBOL];\n                    if (nativeError) {\n                        return originalFunctionToString.call(nativeError);\n                    }\n                }\n            }\n            return originalFunctionToString.call(this);\n        };\n        newFunctionToString[ORIGINAL_DELEGATE_SYMBOL] = originalFunctionToString;\n        Function.prototype.toString = newFunctionToString;\n        // patch Object.prototype.toString to let them look like native\n        const originalObjectToString = Object.prototype.toString;\n        const PROMISE_OBJECT_TO_STRING = '[object Promise]';\n        Object.prototype.toString = function () {\n            if (typeof Promise === 'function' && this instanceof Promise) {\n                return PROMISE_OBJECT_TO_STRING;\n            }\n            return originalObjectToString.call(this);\n        };\n    });\n}\n\nfunction patchCallbacks(api, target, targetName, method, callbacks) {\n    const symbol = Zone.__symbol__(method);\n    if (target[symbol]) {\n        return;\n    }\n    const nativeDelegate = (target[symbol] = target[method]);\n    target[method] = function (name, opts, options) {\n        if (opts && opts.prototype) {\n            callbacks.forEach(function (callback) {\n                const source = `${targetName}.${method}::` + callback;\n                const prototype = opts.prototype;\n                // Note: the `patchCallbacks` is used for patching the `document.registerElement` and\n                // `customElements.define`. We explicitly wrap the patching code into try-catch since\n                // callbacks may be already patched by other web components frameworks (e.g. LWC), and they\n                // make those properties non-writable. This means that patching callback will throw an error\n                // `cannot assign to read-only property`. See this code as an example:\n                // https://github.com/salesforce/lwc/blob/master/packages/@lwc/engine-core/src/framework/base-bridge-element.ts#L180-L186\n                // We don't want to stop the application rendering if we couldn't patch some\n                // callback, e.g. `attributeChangedCallback`.\n                try {\n                    if (prototype.hasOwnProperty(callback)) {\n                        const descriptor = api.ObjectGetOwnPropertyDescriptor(prototype, callback);\n                        if (descriptor && descriptor.value) {\n                            descriptor.value = api.wrapWithCurrentZone(descriptor.value, source);\n                            api._redefineProperty(opts.prototype, callback, descriptor);\n                        }\n                        else if (prototype[callback]) {\n                            prototype[callback] = api.wrapWithCurrentZone(prototype[callback], source);\n                        }\n                    }\n                    else if (prototype[callback]) {\n                        prototype[callback] = api.wrapWithCurrentZone(prototype[callback], source);\n                    }\n                }\n                catch {\n                    // Note: we leave the catch block empty since there's no way to handle the error related\n                    // to non-writable property.\n                }\n            });\n        }\n        return nativeDelegate.call(target, name, opts, options);\n    };\n    api.attachOriginToPatched(target[method], nativeDelegate);\n}\n\nfunction patchUtil(Zone) {\n    Zone.__load_patch('util', (global, Zone, api) => {\n        // Collect native event names by looking at properties\n        // on the global namespace, e.g. 'onclick'.\n        const eventNames = getOnEventNames(global);\n        api.patchOnProperties = patchOnProperties;\n        api.patchMethod = patchMethod;\n        api.bindArguments = bindArguments;\n        api.patchMacroTask = patchMacroTask;\n        // In earlier version of zone.js (<0.9.0), we use env name `__zone_symbol__BLACK_LISTED_EVENTS`\n        // to define which events will not be patched by `Zone.js`. In newer version (>=0.9.0), we\n        // change the env name to `__zone_symbol__UNPATCHED_EVENTS` to keep the name consistent with\n        // angular repo. The  `__zone_symbol__BLACK_LISTED_EVENTS` is deprecated, but it is still be\n        // supported for backwards compatibility.\n        const SYMBOL_BLACK_LISTED_EVENTS = Zone.__symbol__('BLACK_LISTED_EVENTS');\n        const SYMBOL_UNPATCHED_EVENTS = Zone.__symbol__('UNPATCHED_EVENTS');\n        if (global[SYMBOL_UNPATCHED_EVENTS]) {\n            global[SYMBOL_BLACK_LISTED_EVENTS] = global[SYMBOL_UNPATCHED_EVENTS];\n        }\n        if (global[SYMBOL_BLACK_LISTED_EVENTS]) {\n            Zone[SYMBOL_BLACK_LISTED_EVENTS] = Zone[SYMBOL_UNPATCHED_EVENTS] =\n                global[SYMBOL_BLACK_LISTED_EVENTS];\n        }\n        api.patchEventPrototype = patchEventPrototype;\n        api.patchEventTarget = patchEventTarget;\n        api.isIEOrEdge = isIEOrEdge;\n        api.ObjectDefineProperty = ObjectDefineProperty;\n        api.ObjectGetOwnPropertyDescriptor = ObjectGetOwnPropertyDescriptor;\n        api.ObjectCreate = ObjectCreate;\n        api.ArraySlice = ArraySlice;\n        api.patchClass = patchClass;\n        api.wrapWithCurrentZone = wrapWithCurrentZone;\n        api.filterProperties = filterProperties;\n        api.attachOriginToPatched = attachOriginToPatched;\n        api._redefineProperty = Object.defineProperty;\n        api.patchCallbacks = patchCallbacks;\n        api.getGlobalObjects = () => ({\n            globalSources,\n            zoneSymbolEventNames,\n            eventNames,\n            isBrowser,\n            isMix,\n            isNode,\n            TRUE_STR,\n            FALSE_STR,\n            ZONE_SYMBOL_PREFIX,\n            ADD_EVENT_LISTENER_STR,\n            REMOVE_EVENT_LISTENER_STR,\n        });\n    });\n}\n\nfunction patchCommon(Zone) {\n    patchPromise(Zone);\n    patchToString(Zone);\n    patchUtil(Zone);\n}\n\nconst Zone$1 = loadZone();\npatchCommon(Zone$1);\npatchBrowser(Zone$1);\n"],"mappings":"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CAAE,EAAIF,CACnE,CAWO,IAAMG,GAAkC,IAAI,IAAI,CACrD,UACA,QACA,kBACA,iBACA,MACA,eACD,CAAA,EAMK,SAAUC,GAA8BtS,EAAgB,CAG5D,OAAOqS,GAAgC,IAAIrS,EAAS,YAAW,CAAE,CACnE,KC3FsBuS,QAAqB,CAmB1C,ECdKC,GAAU,UACVC,GAAS,SACTC,GAAS,SACTC,GAAS,SA0DFC,GAAmB,CAC9B,q7BAGA,wvCACA,s7CACA,gPACA,0kCACA,uBACA,2CACA,uBACA,wCACA,uBACA,kCACA,yCACA,4LACA,uKACA,eACA,yBACA,iCACA,wSACA,8GACA,sCACA,+BACA,4BACA,2BACA,0BACA,8BACA,yCACA,6BACA,0BACA,uDACA,wCACA,qCACA,uGACA,iGACA,6QACA,mDACA,sBACA,wCACA,6BACA,kMACA,qKACA,8ZACA,+BACA,8BACA,6BACA,+JACA,yBACA,4HACA,8BACA,yDACA,2DACA,sCACA,kDACA,uIACA,yCACA,6EACA,wDACA,wBACA,gDACA,yBACA,2BACA,qCACA,mCACA,0HACA,0GACA,iCACA,0BACA,kEACA,sBACA,2CACA,wBACA,8BACA,mHACA,+DACA,oHACA,iDACA,wDACA,0BACA,wMACA,8BACA,2BACA,sDACA,iCACA,yBACA,wHACA,wBACA,+BACA,qCACA,wCACA,6BACA,+BACA,2BACA,mBACA,sBACA,8BACA,sBACA,4BACA,kCACA,0BACA,+BACA,gCACA,gCACA,6BACA,2BACA,sBACA,+CACA,+CACA,+CACA,+CACA,6BACA,sBACA,sBACA,0BACA,2BACA,uBACA,2BACA,iCACA,0BACA,qBACA,2BACA,qBACA,oCACA,wBACA,oCACA,2BACA,qCACA,oBACA,qBACA,mBACA,uBACA,2BACA,sBACA,8BACA,+BACA,qCACA,2BACA,mDACA,yBACA,2BACA,mBACA,8CACA,6BACA,qBACA,mCACA,kCACA,kCACA,oBACA,0BACA,8BACA,2BACA,wEACA,gFACA,yBACA,8BACA,qBACA,8rCACA,qBACA,wBACA,yBACA,uBAC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","names":["_SELECTOR_REGEXP","CssSelector","_CssSelector","selector","results","_addResult","res","cssSel","cssSelector","match","current","inNot","tag","prefix","attribute","attr","result","escaping","i","char","element","name","value","klass","notSelector","SelectorMatcher","_SelectorMatcher","notSelectors","notMatcher","cssSelectors","callbackCtxt","listContext","SelectorListContext","matcher","classNames","attrs","selectable","SelectorContext","isTerminal","className","terminalMap","terminalValuesMap","partialMap","partialValuesMap","map","terminalList","matchedCallback","selectables","starSelectables","nestedSelector","selectors","cbContext","callback","SelectorlessMatcher","registry","ViewEncapsulation","ChangeDetectionStrategy","InputFlags","CUSTOM_ELEMENTS_SCHEMA","NO_ERRORS_SCHEMA","SecurityContext","MissingTranslationStrategy","parserSelectorToSimpleSelector","selector","classes","parserSelectorToNegativeSelector","parserSelectorToR3Selector","positive","negative","notSelector","parseSelectorToR3Selector","CssSelector","FactoryTarget","R3TemplateDependencyKind","ViewEncapsulation","textEncoder","computeDigest","message","sha1","serializeNodes","decimalDigest","computeDecimalDigest","visitor","_SerializerIgnoreIcuExpVisitor","parts","a","computeMsgId","_SerializerVisitor","text","context","container","child","icu","strCases","k","ph","serializerVisitor","nodes","str","textEncoder","utf8","words32","bytesToWords32","Endian","len","w","b","c","d","e","i","h0","h1","h2","h3","h4","j","rol32","fkVal","fk","f","temp","add32","toHexU32","value","index","fingerprint","view","hi","hash32","lo","msg","meaning","msgFingerprint","length","end","res","mix","remainder","add32to64","low","high","count","bytes","endian","size","wordAt","byteAt","word","TypeModifier","Type","modifiers","modifier","BuiltinTypeName","BuiltinType","name","ExpressionType","typeParams","DYNAMIC_TYPE","BuiltinType","BuiltinTypeName","INFERRED_TYPE","BOOL_TYPE","INT_TYPE","NUMBER_TYPE","STRING_TYPE","FUNCTION_TYPE","NONE_TYPE","UnaryOperator","BinaryOperator","nullSafeIsEquivalent","base","other","areAllEquivalentPredicate","equivalentPredicate","len","i","areAllEquivalent","baseElement","otherElement","Expression","type","sourceSpan","name","ReadPropExpr","index","ReadKeyExpr","params","pure","InvokeFunctionExpr","InstantiateExpr","trueCase","falseCase","ConditionalExpr","rhs","BinaryOperatorExpr","TYPED_NULL_EXPR","ExpressionStatement","ReadVarExpr","_ReadVarExpr","visitor","context","value","TypeofExpr","_TypeofExpr","expr","VoidExpr","_VoidExpr","WrappedNodeExpr","_WrappedNodeExpr","node","_InvokeFunctionExpr","fn","args","arg","TaggedTemplateLiteralExpr","_TaggedTemplateLiteralExpr","tag","template","_InstantiateExpr","classExpr","LiteralExpr","_LiteralExpr","TemplateLiteralExpr","_TemplateLiteralExpr","elements","expressions","a","b","el","TemplateLiteralElementExpr","_TemplateLiteralElementExpr","text","rawText","escapeForTemplateLiteral","escapeSlashes","LiteralPiece","PlaceholderPiece","associatedMessage","MEANING_SEPARATOR","ID_SEPARATOR","LEGACY_ID_INDICATOR","LocalizedString","_LocalizedString","metaBlock","messageParts","placeHolderNames","legacyId","createCookedRawString","partIndex","placeholder","messagePart","computeMsgId","str","escapeStartingColon","escapeColons","range","ExternalExpr","_ExternalExpr","typeParams","ConditionalExpr","_ConditionalExpr","Expression","condition","trueCase","falseCase","type","sourceSpan","nullSafeIsEquivalent","visitor","context","NotExpr","_NotExpr","Expression","condition","sourceSpan","BOOL_TYPE","visitor","context","FnParam","_FnParam","name","type","param","FunctionExpr","_FunctionExpr","params","statements","DeclareFunctionStmt","areAllEquivalent","modifiers","p","ArrowFunctionExpr","_ArrowFunctionExpr","body","DeclareVarStmt","INFERRED_TYPE","UnaryOperatorExpr","_UnaryOperatorExpr","operator","expr","parens","NUMBER_TYPE","ParenthesizedExpr","_ParenthesizedExpr","BinaryOperatorExpr","_BinaryOperatorExpr","lhs","rhs","op","BinaryOperator","ReadPropExpr","_ReadPropExpr","receiver","value","ReadKeyExpr","_ReadKeyExpr","index","LiteralArrayExpr","_LiteralArrayExpr","entries","LiteralMapEntry","_LiteralMapEntry","key","quoted","LiteralMapExpr","_LiteralMapExpr","entriesClone","entry","NULL_EXPR","LiteralExpr","TYPED_NULL_EXPR","INFERRED_TYPE","StmtModifier","LeadingComment","text","multiline","trailingNewline","JSDocComment","tags","serializeTags","Statement","modifiers","sourceSpan","leadingComments","modifier","leadingComment","DeclareVarStmt","_DeclareVarStmt","name","value","type","stmt","visitor","context","DeclareFunctionStmt","_DeclareFunctionStmt","params","statements","areAllEquivalent","ExpressionStatement","_ExpressionStatement","expr","ReturnStatement","_ReturnStatement","IfStmt","_IfStmt","condition","trueCase","falseCase","jsDocComment","tags","JSDocComment","variable","name","type","sourceSpan","ReadVarExpr","importExpr","id","typeParams","ExternalExpr","expressionType","expr","typeModifiers","typeParams","ExpressionType","typeofExpr","expr","TypeofExpr","literalArr","values","type","sourceSpan","LiteralArrayExpr","literalMap","LiteralMapExpr","e","LiteralMapEntry","not","expr","sourceSpan","NotExpr","fn","params","body","type","name","FunctionExpr","arrowFn","ArrowFunctionExpr","ifStmt","condition","thenClause","elseClause","leadingComments","IfStmt","taggedTemplate","tag","template","TaggedTemplateLiteralExpr","literal","value","LiteralExpr","localizedString","metaBlock","messageParts","placeholderNames","expressions","LocalizedString","tagToString","tag","out","serializeTags","tags","CONSTANT_PREFIX","UNKNOWN_VALUE_KEY","o.variable","KEY_CONTEXT","POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS","FixupExpression","_FixupExpression","o.Expression","resolved","visitor","context","expression","ConstantPool","isClosureCompilerEnabled","literal","forceShared","o.LiteralExpr","isLongStringLiteral","key","GenericKeyFn","fixup","newValue","name","value","usage","o.FunctionExpr","o.ReturnStatement","o.DeclareVarStmt","o.INFERRED_TYPE","o.StmtModifier","def","expr","id","o.LiteralArrayExpr","argumentsForKey","e","o.literalArr","entries","expressionForKey","o.literalMap","index","fn","prefix","useUniqueName","isArrow","o.ArrowFunctionExpr","current","o.DeclareFunctionStmt","values","resultMap","literalFactory","literalFactoryArguments","resultExpressions","parameters","isVariable","o.FnParam","o.DYNAMIC_TYPE","pureFunctionDeclaration","o.arrowFn","alwaysIncludeSuffix","count","result","_GenericKeyFn","entry","o.LiteralMapExpr","o.ExternalExpr","o.ReadVarExpr","o.TypeofExpr","CORE","Identifiers","DASH_CASE_REGEXP","dashCaseToCamelCase","input","m","splitAtColon","defaultValues","_splitAt","splitAtPeriod","character","characterIndex","utf8Encode","str","encoded","index","codePoint","low","stringify","token","name","result","newLineIndex","Version","full","splits","_global","V1_TO_18","getJitStandaloneDefaultForVersion","version","VERSION","JS_B64_PREFIX","SourceMapGenerator","file","url","content","col0","sourceUrl","sourceLine0","sourceCol0","sourcesIndex","sources","sourcesContent","i","mappings","lastCol0","lastSourceIndex","lastSourceLine0","lastSourceCol0","segments","segment","segAsStr","toBase64VLQ","toBase64String","value","b64","i1","i2","i3","toBase64Digit","out","digit","B64_DIGITS","_SINGLE_QUOTE_ESCAPE_STRING_RE","_LEGAL_IDENTIFIER_RE","_INDENT_WITH","_EmittedLine","indent","BINARY_OPERATORS","o.BinaryOperator","EmitterVisitorContext","_EmitterVisitorContext","_indent","from","lastPart","part","newLine","l","_createIndent","genFilePath","startsAtLine","map","firstOffsetMapped","mapFirstOffsetIfNeeded","line","lineIdx","spans","parts","spanIdx","span","source","sourceLine","sourceCol","column","emittedLine","columnsLeft","partIndex","AbstractEmitterVisitor","_escapeDollarInStrings","stmt","ctx","comment","o.JSDocComment","hasElseCase","expr","shouldParenthesize","o.ArrowFunctionExpr","expression","ast","escapeIdentifier","head","opStr","o.UnaryOperator","parens","operator","entry","expressions","separator","handler","incrementedIndent","statements","input","escapeDollar","alwaysQuote","body","match","count","res","typeWithParameters","type","numParams","o.expressionType","params","o.DYNAMIC_TYPE","getSafePropertyAccessString","accessor","escapedName","jitOnlyGuardedExpression","guardedExpression","guardedExpression","guard","expr","guardExpr","o.ExternalExpr","guardNotDefined","o.BinaryOperatorExpr","o.BinaryOperator","o.TypeofExpr","o.literal","guardUndefinedOrTrue","wrapReference","value","wrapped","o.WrappedNodeExpr","refsToArray","refs","shouldForwardDeclare","values","o.literalArr","ref","o.arrowFn","createMayBeForwardRefExpression","expression","forwardRef","convertFromMaybeForwardRefExpression","generateForwardRef","o.importExpr","Identifiers","R3FactoryDelegateType","compileFactoryFunction","meta","t","o.variable","baseFactoryVar","typeForCtor","isDelegatedFactoryMetadata","ctorExpr","o.InstantiateExpr","injectDependencies","body","retExpr","makeConditionalFactory","nonCtorExpr","r","o.DeclareVarStmt","o.NULL_EXPR","o.INFERRED_TYPE","ctorStmt","R3","o.ifStmt","delegateArgs","factoryExpr","o.InvokeFunctionExpr","isExpressionFactoryMetadata","getInheritedFactoryCall","baseFactory","o.ReturnStatement","factoryFn","o.fn","o.FnParam","o.DYNAMIC_TYPE","o\n            .arrowFn","createFactoryType","ctorDepsType","createCtorDepsType","o.NONE_TYPE","o.expressionType","typeWithParameters","deps","target","dep","index","compileInjectDependency","flags","FactoryTarget","flagsParam","injectArgs","injectFn","getInjectFn","hasTypes","attributeTypes","type","createCtorDepType","entries","o.literalMap","ParseSpan","start","end","absoluteOffset","AbsoluteSourceSpan","AST","span","sourceSpan","ASTWithName","nameSpan","visitor","context","ImplicitReceiver","ThisReceiver","Chain","expressions","Conditional","condition","trueExp","falseExp","PropertyRead","receiver","name","SafePropertyRead","KeyedRead","key","SafeKeyedRead","BindingPipeType","BindingPipe","exp","args","LiteralPrimitive","LiteralArray","LiteralMap","keys","strings","Binary","operation","left","right","op","Unary","_Unary","operator","binaryOp","binaryLeft","binaryRight","PrefixNot","TypeofExpression","VoidExpression","NonNullAssert","Call","argumentSpan","SafeCall","TaggedTemplateLiteral","tag","template","TemplateLiteral","elements","TemplateLiteralElement","text","ParenthesizedExpression","ASTWithSource","ast","source","location","errors","VariableBinding","ExpressionBinding","RecursiveAstVisitor","i","asts","ParsedProperty","keySpan","valueSpan","ParsedPropertyType","ParsedEventType","ParsedEvent","targetOrPhase","handler","handlerSpan","ParsedVariable","BindingType","BoundElementProperty","securityContext","unit","TagContentType","splitNsName","elementName","fatal","colonIndex","isNgContainer","tagName","isNgContent","isNgTemplate","getNsPrefix","fullName","mergeNsAndName","prefix","localName","_visitor","BoundText","i18n","TextAttribute","BoundAttribute","_BoundAttribute","prop","BoundEvent","_BoundEvent","phase","event","attributes","inputs","outputs","directives","children","references","isSelfClosing","startSourceSpan","endSourceSpan","isVoid","DeferredTrigger","prefetchSpan","whenOrOnSourceSpan","hydrateSpan","BoundDeferredTrigger","whenSourceSpan","NeverDeferredTrigger","IdleDeferredTrigger","ImmediateDeferredTrigger","HoverDeferredTrigger","reference","onSourceSpan","TimerDeferredTrigger","delay","InteractionDeferredTrigger","ViewportDeferredTrigger","BlockNode","DeferredBlockPlaceholder","minimumTime","DeferredBlockLoading","afterTime","DeferredBlockError","DeferredBlock","triggers","prefetchTriggers","hydrateTriggers","placeholder","loading","error","mainBlockSpan","visitAll","remainingBlocks","x","k","SwitchBlock","cases","unknownBlocks","SwitchBlockCase","ForLoopBlock","item","trackBy","trackKeywordSpan","contextVariables","empty","ForLoopBlockEmpty","IfBlock","branches","IfBlockBranch","expressionAlias","UnknownBlock","componentName","Template","templateAttrs","variables","Content","selector","Variable","Reference","vars","placeholders","HostElement","tagNames","bindings","listeners","visitAll","visitor","nodes","result","node","newNode","Message","placeholders","placeholderToMessage","meaning","description","customId","serializeMessage","value","sourceSpan","context","Container","children","Icu","expression","type","cases","expressionPlaceholder","TagPlaceholder","tag","attrs","startName","closeName","isVoid","startSourceSpan","endSourceSpan","Placeholder","name","IcuPlaceholder","BlockPlaceholder","parameters","serializeMessage","messageNodes","visitor","LocalizeMessageStringVisitor","n","text","container","child","icu","strCases","k","ph","children","tag","strAttrs","strChildren","node","text","decl","attrs","name","doctype","_visitor","_Visitor","toPublicName","internalName","I18N_ATTR","I18N_ATTR_PREFIX","I18N_ICU_VAR_PREFIX","isI18nAttribute","name","hasI18nAttrs","node","attr","icuFromI18nMessage","message","formatI18nPlaceholderNamesInMap","params","useCamelCase","_params","key","formatI18nPlaceholderName","publicName","chunks","postfix","raw","c","UNSAFE_OBJECT_KEY_NAME_REGEXP","TEMPORARY_NAME","CONTEXT_NAME","RENDER_FLAGS","temporaryAllocator","pushStatement","temp","o.DeclareVarStmt","o.DYNAMIC_TYPE","o.variable","asLiteral","value","o.literalArr","o.literal","o.INFERRED_TYPE","conditionallyCreateDirectiveBindingLiteral","map","forInputs","keys","o.literalMap","declaredName","minifiedName","expressionValue","differentDeclaringName","hasDecoratorInputTransform","flags","InputFlags","result","DefinitionMap","existing","createCssSelectorFromNode","elementName","t.Element","attributes","getAttrsForDirectiveMatching","cssSelector","CssSelector","elementNameNoNs","splitNsName","nameNoNs","className","elOrTpl","attributesMap","t.Template","a","i","BindingType","o","compileInjectable","meta","resolveForwardRefs","factoryMeta","FactoryTarget","useClassOnSelf","deps","compileFactoryFunction","R3FactoryDelegateType","delegateToFactory","o.arrowFn","o.importExpr","Identifiers","token","injectableProps","convertFromMaybeForwardRefExpression","o\n        .importExpr","createInjectableType","o.ExpressionType","typeWithParameters","type","useType","unwrapForwardRefs","createFactoryFunction","unwrappedType","t","o.FnParam","UNUSABLE_INTERPOLATION_REGEXPS","assertInterpolationSymbols","identifier","start","end","regexp","InterpolationConfig","_InterpolationConfig","markers","DEFAULT_INTERPOLATION_CONFIG","DEFAULT_CONTAINER_BLOCKS","$EOF","$BSPACE","$TAB","$LF","$VTAB","$FF","$CR","$SPACE","$BANG","$DQ","$HASH","$$","$PERCENT","$AMPERSAND","$SQ","$LPAREN","$RPAREN","$STAR","$PLUS","$COMMA","$MINUS","$PERIOD","$SLASH","$COLON","$SEMICOLON","$LT","$EQ","$GT","$QUESTION","$0","$7","$9","$A","$E","$F","$X","$Z","$LBRACKET","$BACKSLASH","$RBRACKET","$CARET","$_","$a","$b","$e","$f","$n","$r","$t","$u","$v","$x","$z","$LBRACE","$BAR","$RBRACE","$NBSP","$AT","$BT","isWhitespace","code","isDigit","isAsciiLetter","isAsciiHexDigit","isNewLine","isOctalDigit","isQuote","ParseLocation","_ParseLocation","file","offset","line","col","delta","source","len","chars.$LF","priorLine","ch","maxChars","maxLines","content","startOffset","endOffset","ctxChars","ctxLines","ParseSourceFile","url","ParseSourceSpan","fullStart","details","ParseErrorLevel","ParseError","span","msg","level","relatedError","ctx","r3JitTypeSourceSpan","kind","typeName","sourceUrl","sourceFileName","sourceFile","_anonymousTypeIndex","identifierName","compileIdentifier","ref","stringify","sanitizeIdentifier","makeTemplateObjectPolyfill","AbstractJsEmitterVisitor","AbstractEmitterVisitor","ast","stmt","elements","part","escapeIdentifier","expression","expr","isObjectLiteral","o.LiteralMapExpr","parts","param","policy","getPolicy","trustedTypes","global","s","trustedScriptFromString","script","newTrustedFunctionForJIT","args","fnArgs","fnBody","body","fn","JitEvaluator","statements","refResolver","createSourceMaps","converter","JitEmitterVisitor","EmitterVisitorContext","isUseStrictStatement","vars","createSourceMap","fnArgNames","fnArgValues","argName","emptyFn","headerLines","o.ReturnStatement","resultVar","o.LiteralMapEntry","o.StmtModifier","id","statement","compileInjector","definitionMap","R3","createInjectorType","R3JitReflector","context","R3SelectorScopeMode","R3NgModuleMetadataKind","compileNgModule","refsToArray","setNgModuleScopeCall","generateSetNgModuleScopeCall","createNgModuleType","compileNgModuleDeclarationExpression","o.WrappedNodeExpr","moduleType","declarations","exports","imports","includeImportTypes","publicDeclarationTypes","tupleTypeOf","tupleOfTypes","o.NONE_TYPE","scopeMap","fnCall","o.InvokeFunctionExpr","guardedCall","jitOnlyGuardedExpression","iife","o.FunctionExpr","exp","types","o.typeofExpr","o.expressionType","typeofTypes","compilePipeFromMetadata","metadata","definitionMapValues","createPipeType","o.LiteralExpr","R3TemplateDependencyKind","animationKeywords","scopedAtRuleIdentifiers","ShadowCss","cssText","selector","hostSelector","comments","_commentRe","m","_commentWithHashRe","newLinesMatches","_newLinesRe","COMMENT_PLACEHOLDER","scopedCssText","commentIdx","_commentWithHashPlaceHolderRe","scopeSelector","unscopedKeyframesSet","scopedKeyframesCssText","processRules","rule","_","quote","keyframeName","endSpaces","unescapeQuotes","keyframe","spaces1","spaces2","animationDeclarations","original","leadingSpaces","quotedName","nonQuotedName","_match","commaSeparatedKeyframes","_cssContentNextSelectorRe","_cssContentRuleRe","unscopedRules","r","_cssContentUnscopedRuleRe","_cssColonHostRe","hostSelectors","otherSelectors","convertedSelectors","hostSelectorArray","p","convertedSelector","_polyfillHostNoCombinator","_polyfillHost","length","parens","prev","char","_cssColonHostContextReGlobal","selectorText","pseudoPrefix","contextSelectorGroups","match","_cssColonHostContextRe","newContextSelectors","contextSelectorGroupsLength","repeatGroups","j","contextSelectors","_combineHostContextSelectors","_shadowDOMSelectorsRe","pattern","atRule","CssRule","_shadowDeepSelectors","_polyfillHostNoCombinatorRe","isParentSelector","selectorSplitRe","deepParts","shallowPart","otherParts","lre","rre","_selectorReSuffix","_polyfillHostRe","replaceBy","_hnc","before","colon","after","isRe","attrName","_scopeSelectorPart","scopedP","_polyfillHostNoCombinatorOutsidePseudoFunction","matches","_pseudoFunctionAwareScopeSelectorPart","selectorPart","scopedPart","pseudoSelectorParts","pseudoSelectorMatch","_cssPrefixWithPseudoSelectorFunction","openedBrackets","index","currentSymbol","cssPseudoSelectorFunction","selectorToScope","scopedInnerPart","SafeSelector","scopedSelector","startIndex","res","sep","hasHost","separator","_colonHostContextRe","_polyfillHostContext","_colonHostRe","keep","pseudo","_ph","_cssScopedPseudoFunctionPrefix","_parenSuffix","_hostContextPattern","BLOCK_PLACEHOLDER","_ruleRe","CONTENT_PAIRS","COMMA_IN_PLACEHOLDER","SEMI_IN_PLACEHOLDER","COLON_IN_PLACEHOLDER","_cssCommaInPlaceholderReGlobal","_cssSemiInPlaceholderReGlobal","_cssColonInPlaceholderReGlobal","input","ruleCallback","escaped","escapeInStrings","inputWithEscapedBlocks","escapeBlocks","nextBlockIndex","escapedResult","suffix","contentPrefix","unescapeInStrings","StringWithEscapedBlocks","escapedString","blocks","charPairs","placeholder","resultParts","escapedBlocks","openCharCount","nonBlockStartIndex","blockStartIndex","openChar","closeChar","ESCAPE_IN_STRING_MAP","currentQuoteChar","str","isQuoted","hostMarker","otherSelectorsHasHost","combined","contextSelector","previousSelectors","groups","multiples","OpKind","ExpressionKind","VariableFlags","SemanticVariableKind","CompatibilityMode","BindingKind","I18nParamResolutionTime","I18nExpressionFor","I18nParamValueFlags","Namespace","DeferTriggerKind","I18nContextKind","TemplateKind","ConsumesSlot","DependsOnSlotContext","ConsumesVarsTrait","UsesVarOffset","TRAIT_CONSUMES_SLOT","TRAIT_DEPENDS_ON_SLOT_CONTEXT","TRAIT_CONSUMES_VARS","hasConsumesSlotTrait","op","hasDependsOnSlotContextTrait","hasConsumesVarsTrait","hasUsesVarOffsetTrait","createStatementOp","NEW_OP","createVariableOp","xref","variable","initializer","createInterpolateTextOp","interpolation","sourceSpan","Interpolation","strings","expressions","i18nPlaceholders","createBindingOp","target","unit","securityContext","isTextAttribute","isStructuralTemplateAttribute","templateKind","i18nMessage","createPropertyOp","bindingKind","i18nContext","createTwoWayPropertyOp","createStylePropOp","createClassPropOp","createStyleMapOp","createClassMapOp","createAttributeOp","namespace","createAdvanceOp","createConditionalOp","test","conditions","createRepeaterOp","repeaterCreate","targetSlot","collection","createAnimationBindingOp","animationKind","animationBindingKind","createDeferWhenOp","modifier","createI18nExpressionOp","i18nOwner","handle","icuPlaceholder","i18nPlaceholder","resolutionTime","usage","createI18nApplyOp","owner","createStoreLetOp","isIrExpression","ExpressionBase","o.Expression","LexicalReadExpr","_LexicalReadExpr","visitor","other","ReferenceExpr","_ReferenceExpr","StoreLetExpr","_StoreLetExpr","transform","transformExpressionsInExpression","ContextLetReferenceExpr","_ContextLetReferenceExpr","ContextExpr","_ContextExpr","view","TrackContextExpr","_TrackContextExpr","NextContextExpr","_NextContextExpr","GetCurrentViewExpr","_GetCurrentViewExpr","RestoreViewExpr","_RestoreViewExpr","ResetViewExpr","_ResetViewExpr","TwoWayBindingSetExpr","_TwoWayBindingSetExpr","ReadVariableExpr","_ReadVariableExpr","PureFunctionExpr","_PureFunctionExpr","arg","idx","VisitorContextFlag","PureFunctionParameterExpr","_PureFunctionParameterExpr","PipeBindingExpr","_PipeBindingExpr","PipeBindingVariadicExpr","_PipeBindingVariadicExpr","numArgs","SafePropertyReadExpr","_SafePropertyReadExpr","receiver","SafeKeyedReadExpr","_SafeKeyedReadExpr","SafeInvokeFunctionExpr","_SafeInvokeFunctionExpr","SafeTernaryExpr","_SafeTernaryExpr","guard","EmptyExpr","_EmptyExpr","AssignTemporaryExpr","_AssignTemporaryExpr","ReadTemporaryExpr","_ReadTemporaryExpr","SlotLiteralExpr","_SlotLiteralExpr","slot","ConditionalCaseExpr","_ConditionalCaseExpr","alias","ConstCollectedExpr","_ConstCollectedExpr","visitExpressionsInOp","transformExpressionsInOp","transformExpressionsInInterpolation","transformExpressionsInStatement","condition","innerOp","o.BinaryOperatorExpr","o.UnaryOperatorExpr","o.ReadPropExpr","o.ReadKeyExpr","o.LiteralArrayExpr","o.ConditionalExpr","o.TypeofExpr","o.VoidExpr","o.LocalizedString","o.NotExpr","o.TaggedTemplateLiteralExpr","e","o.ArrowFunctionExpr","o.TemplateLiteralExpr","o.ParenthesizedExpr","o.ReadVarExpr","o.ExternalExpr","o.ExpressionStatement","o.IfStmt","caseStatement","isStringLiteral","OpList","_OpList","oldLast","ops","first","current","next","oldOp","newOp","newOps","listId","oldPrev","oldNext","last","byList","SlotHandle","elementContainerOpKinds","isElementOrContainerOp","createElementStartOp","tag","startSourceSpan","wholeSourceSpan","createTemplateOp","functionNameSuffix","createConditionalCreateOp","createConditionalBranchCreateOp","createRepeaterCreateOp","primaryView","emptyView","track","varNames","emptyTag","emptyI18nPlaceholder","createElementEndOp","createDisableBindingsOp","createEnableBindingsOp","createTextOp","initialValue","createAnimationStringOp","createAnimationOp","callbackOps","handlerOps","createListenerOp","legacyAnimationPhase","eventTarget","hostListener","handlerList","createAnimationListenerOp","createTwoWayListenerOp","createPipeOp","createNamespaceOp","createProjectionDefOp","def","createProjectionOp","fallbackView","createExtractedAttributeOp","createDeferOp","main","mainSlot","ownResolverFn","resolverFn","createDeferOnOp","defer","trigger","createDeclareLetOp","createI18nMessageOp","i18nBlock","messagePlaceholder","postprocessingParams","needsPostprocessing","createI18nStartOp","root","createI18nEndOp","createIcuStartOp","createIcuEndOp","createIcuPlaceholderOp","createI18nContextOp","contextKind","createI18nAttributesOp","createSourceLocationOp","templatePath","locations","createDomPropertyOp","CTX_REF","CompilationJobKind","TemplateCompilationMode","CompilationJob","componentName","pool","compatibility","mode","ComponentCompilationJob","relativeContextFilePath","i18nUseExternalIds","deferMeta","allDeferrableDepsFn","relativeTemplatePath","enableDebugLocations","ViewCompilationUnit","parent","newConst","initializers","CompilationUnit","ir.OpList","ir.OpKind","listenerOp","trackOp","job","HostBindingCompilationJob","HostBindingCompilationUnit","deleteAnyCasts","ir.transformExpressionsInOp","removeAnys","ir.VisitorContextFlag","ir.LexicalReadExpr","applyI18nExpressions","i18nContexts","needsApplication","ir.createI18nApplyOp","nextContext","assignI18nSlotDependencies","updateOp","i18nExpressionsInProgress","state","createOp","ir.hasConsumesSlotTrait","ir.I18nExpressionFor","opToRemove","hasDifferentTarget","ir.hasDependsOnSlotContextTrait","ir.visitExpressionsInOp","attachSourceLocations","ir.createSourceLocationOp","createOpXrefMap","extractAttributes","extractAttributeOp","ir.BindingKind","ir.createExtractedAttributeOp","lookupElement","ir.CompatibilityMode","ir.EmptyExpr","SecurityContext","extractedAttributeOp","el","ir.Interpolation","extractable","ownerOp","ARIA_PREFIX","isAriaAttribute","specializeBindings","ir.isElementOrContainerOp","ir.createAnimationBindingOp","ir.createAttributeOp","ir.createDomPropertyOp","ir.createPropertyOp","ir.createTwoWayPropertyOp","CHAIN_COMPATIBILITY","MAX_CHAIN_LENGTH","chain","chainOperationsInList","opList","instruction","collapseSingletonInterpolations","generateConditionalExpressions","defaultCase","cond","ir.SlotLiteralExpr","tmp","ir.AssignTemporaryExpr","caseExpressionTemporaryXref","conditionalCase","useTmp","ir.ReadTemporaryExpr","o.BinaryOperator","BINARY_OPERATORS","namespaceForKey","namespacePrefixKey","NAMESPACES","ir.Namespace","keyForNamespace","k","n","prefixWithNamespace","strippedTag","literalOrArrayLiteral","collectElementConsts","allElementAttributes","ElementAttributes","attrArray","serializeAttributes","getConstIndex","FLYWEIGHT_ARRAY","nameToValue","trustedValueFn","array","getAttributeNameLiterals","ir.isStringLiteral","o.taggedTemplate","o.TemplateLiteralElementExpr","nameLiteral","bindings","classes","i18n","projectAs","styles","template","parsedR3Selector","core.parseSelectorToR3Selector","convertAnimations","getAnimationOp","ir.createAnimationStringOp","ir.createAnimationOp","ir.createStatementOp","convertI18nBindings","i18nAttributesByElem","i18nAttributesForElem","ir.createI18nExpressionOp","ir.I18nParamResolutionTime","createI18nContexts","attrContextByMessage","ir.createI18nContextOp","ir.I18nContextKind","blockContextByI18nBlock","contextOp","rootContext","currentI18nOp","deduplicateTextBindings","seen","seenForElement","configureDeferInstructions","ir.ConstCollectedExpr","resolveDeferTargetNames","scopes","getScopeForView","scope","Scope","resolveTrigger","deferOwnerView","placeholderView","ir.DeferTriggerKind","placeholderOp","step","defers","deferOp","REPLACEMENTS","IGNORED_OP_KINDS","collapseEmptyInstructions","opReplacements","startKind","mergedKind","prevOp","expandSafeReads","safeTransform","ternaryTransform","needsTemporaryInSafeAccess","ir.SafeInvokeFunctionExpr","ir.PipeBindingExpr","temporariesIn","temporaries","ir.transformExpressionsInExpression","eliminateTemporaryAssignments","tmps","read","safeTernaryWithTemporary","ir.SafeTernaryExpr","isSafeAccessExpression","ir.SafePropertyReadExpr","ir.SafeKeyedReadExpr","isUnsafeAccessExpression","isAccessExpression","deepestSafeTernary","st","dst","o.NULL_EXPR","ESCAPE","ELEMENT_MARKER","TEMPLATE_MARKER","TAG_CLOSE_MARKER","CONTEXT_MARKER","LIST_START_MARKER","LIST_END_MARKER","LIST_DELIMITER","extractI18nMessages","i18nMessagesByContext","i18nBlocks","i18nMessageOp","createI18nMessage","currentIcu","icuContext","rootI18nBlock","rootMessage","subMessage","formatIcuPlaceholder","formattedParams","formatParams","formattedPostprocessingParams","v","ir.createI18nMessageOp","values","formatValue","placeholderValues","serializedValues","formatParamValues","ir.I18nParamValueFlags","elementValue","templateValue","tagMarker","closeMarker","generateAdvance","slotMap","slotContext","consumer","ir.createAdvanceOp","generateLocalLetReferences","ir.SemanticVariableKind","ir.createVariableOp","ir.StoreLetExpr","ir.VariableFlags","generateProjectionDefs","share","selectors","projectionSlotIndex","defExpr","parseSelectorToR3Selector","ir.createProjectionDefOp","generateVariables","recursivelyProcessView","parentScope","generateVariablesInScopeForView","isCallback","ir.NextContextExpr","scopeView","ir.ContextExpr","ir.CTX_REF","ir.ReferenceExpr","decl","ir.ContextLetReferenceExpr","collectConstExpressions","STYLE_DOT","CLASS_DOT","STYLE_BANG","CLASS_BANG","BANG_IMPORTANT","parseHostStyleProperties","isCssCustomProperty","hyphenate","property","parseProperty","overrideIndex","unitIndex","mapLiteral","obj","quoted","IcuSerializerVisitor","text","container","child","icu","strCases","ph","serializer","serializeIcuNode","NodeWithI18n","Text","tokens","Expansion","switchValue","cases","switchValueSourceSpan","ExpansionCase","valueSourceSpan","expSourceSpan","Attribute","keySpan","valueSpan","valueTokens","Element","attrs","directives","children","isSelfClosing","endSourceSpan","isVoid","Comment","Block","parameters","nameSpan","Component","tagName","fullName","Directive","BlockParameter","LetDeclaration","visitAll","nodes","visit","astResult","NAMED_ENTITIES","NGSP_UNICODE","TokenizeResult","tokens","errors","nonNormalizedIcuExpressions","tokenize","source","url","getTagDefinition","options","tokenizer","_Tokenizer","ParseSourceFile","mergeTextTokens","_CR_OR_CRLF_REGEXP","_unexpectedCharacterErrorMsg","charCode","chars.$EOF","_unknownEntityErrorMsg","entitySrc","_unparsableEntityErrorMsg","type","entityStr","CharacterReferenceType","SUPPORTED_BLOCKS","_file","_getTagDefinition","DEFAULT_INTERPOLATION_CONFIG","c","range","EscapedCharacterCursor","PlainCharacterCursor","e","content","start","chars.$LT","chars.$BANG","chars.$LBRACKET","chars.$MINUS","chars.$SLASH","chars.$AT","chars.$RBRACE","spacesInNameAllowed","nameCursor","code","chars.isWhitespace","isBlockNameChar","startToken","chars.$LPAREN","isNotWhitespace","chars.$RPAREN","chars.$LBRACE","isBlockParameterChar","inQuote","openParens","chars.$SEMICOLON","char","chars.$BACKSLASH","chars.isQuote","token","chars.$EQ","chars.isNewLine","allowDigit","chars.isAsciiLetter","chars.$$","chars.$_","chars.isDigit","inner","isExpansionCaseStart","parts","end","ParseError","msg","span","error","CursorError","compareCharCodeCaseInsensitive","location","chars","len","initialPosition","i","predicate","cursor","blockName","textTokenType","chars.$HASH","isHex","chars.$x","chars.$X","codeStart","isDigitEntityEnd","entityType","strNum","nameStart","isNamedEntityEnd","name","consumeEntities","endMarkerPredicate","tagCloseStart","foundEndMarker","chars.$AMPERSAND","contentStart","chars.$GT","endPredicate","nameOrPrefixStart","prefix","chars.$COLON","isPrefixEnd","tagName","closingTagName","openToken","isSelectorlessNameStart","isAttributeTerminator","contentTokenType","TagContentType","isNameEnd","isSelectorlessNameChar","attrNameStart","chars.$SQ","chars.$DQ","nameEndPredicate","openBrackets","chars.$RBRACKET","prefixAndName","quoteChar","tokenType","clone","condition","chars.$COMMA","normalizedCondition","conditionToken","value","interpolationTokenType","endInterpolation","current","interpolationStart","prematureEndPredicate","expressionStart","inComment","tmp","chars.$a","chars.$z","chars.$A","chars.$Z","isInterpolation","chars.$0","chars.$9","chars.isAsciiHexDigit","peek","code1","code2","toUpperCaseCharCode","srcTokens","dstTokens","lastDstToken","_PlainCharacterCursor","fileOrCursor","state","other","leadingTriviaCodePoints","fullStart","startLocation","endLocation","fullStartLocation","ParseSourceSpan","pos","currentChar","chars.$LF","ParseLocation","_EscapedCharacterCursor","chars.$n","chars.$r","chars.$CR","chars.$v","chars.$VTAB","chars.$t","chars.$TAB","chars.$b","chars.$BSPACE","chars.$f","chars.$FF","chars.$u","digitStart","length","chars.isOctalDigit","octal","previous","hex","TreeError","_TreeError","elementName","ParseTreeResult","rootNodes","tokenizeResult","parser","_TreeBuilder","__TreeBuilder","tagDefinitionResolver","leftoverContainer","html.Block","prev","_startToken","text","endToken","sourceSpan","html.Comment","switchValue","cases","expCase","html.Expansion","exp","expansionCaseParser","expSourceSpan","html.ExpansionCase","expansionFormStack","lastOnStack","startSpan","parent","decodeEntity","endSpan","html.Text","el","startTagToken","attrs","directives","fullName","tagDef","selfClosing","getNsPrefix","html.Element","isClosedByChild","componentName","closestElement","node","html.Component","attributesResult","directivesResult","container","suffix","errMsg","nodeOrName","endTagToken","expectedName","expectedType","endSourceSpan","unexpectedCloseTagDetected","stackIndex","attrName","mergeNsAndName","attrEnd","valueTokens","valueStartSpan","valueEnd","valueToken","valueSpan","html.Attribute","nameToken","attributes","startSourceSpanEnd","startSourceSpan","html.Directive","parameters","paramToken","html.BlockParameter","block","startOffset","nameSpan","html.LetDeclaration","nameString","parentName","parentTagName","splitNsName","parentTagDefinition","stack","element","match","entity","PRESERVE_WS_ATTR_NAME","SKIP_WS_TRIM_TAGS","WS_CHARS","NO_WS_REGEXP","WS_REPLACE_REGEXP","hasPreserveWhitespacesAttr","attr","replaceNgsp","WhitespaceVisitor","preserveSignificantWhitespace","originalNodeMap","requireContext","context","newElement","visitAllWithSiblings","attribute","isNotBlank","hasExpansionSibling","createWhitespaceProcessedTextToken","firstToken","trimLeadingWhitespace","lastToken","trimTrailingWhitespace","processed","processWhitespace","trimLeadingAndTrailingWhitespace","result","comment","expansion","newExpansion","expansionCase","newExpansionCase","newBlock","parameter","decl","directive","_node","transformTextToken","isFirstTokenInTag","isLastTokenInTag","maybeTrimmedStart","transform","visitor","nodes","ast","astResult","TokenType","StringTokenKind","KEYWORDS","Lexer","_Scanner","Token","index","numValue","strValue","operator","StringToken","kind","newCharacterToken","newIdentifierToken","newPrivateIdentifierToken","newKeywordToken","newOperatorToken","newNumberToken","n","newErrorToken","message","EOF","input","chars.$SPACE","isIdentifierStart","chars.$PERIOD","chars.$BT","chars.$PLUS","chars.$PERCENT","chars.$CARET","chars.$STAR","chars.$QUESTION","chars.$BAR","chars.$NBSP","str","one","twoCode","two","threeCode","three","isIdentifierPart","identifierName","simple","hasSeparators","isExponentStart","isExponentSign","parseIntAutoRadix","quote","buffer","marker","last","dollar","offset","position","unescapedCode","unescape","chars.$e","chars.$E","SplitInterpolation","strings","expressions","offsets","TemplateBindingParseResult","templateBindings","warnings","getLocation","Parser","_lexer","_supportsDirectPipeReferences","parseSourceSpan","absoluteOffset","interpolationConfig","sourceToLex","_ParseAST","ASTWithSource","checker","SimpleExpressionChecker","simplExpressionErrors","getParseError","templateKey","templateValue","absoluteKeyOffset","absoluteValueOffset","AbsoluteSourceSpan","interpolatedTokens","expressionNodes","expressionSpan","expressionText","hasComments","s","expression","ParseSpan","interpolation","Interpolation","inputToTemplateIndexMap","getIndexMapForOriginalTemplate","atInterpolation","extendLastString","interpStart","interpEnd","exprStart","exprEnd","fullEnd","piece","sourceSpanOrLocation","LiteralPrimitive","outerQuote","nextChar","startIndex","endIndex","charIndex","expressionEnd","currentQuote","escapeCount","ParseContextFlags","parseFlags","supportsDirectPipeReferences","artificialEndIndex","serial","cb","ret","op","Binary","tok","exprs","expr","errorIndex","artificialStart","artificialEnd","EmptyExpr","Chain","nameId","fullSpanEnd","args","BindingPipeType","BindingPipe","yes","no","Conditional","right","Unary","PrefixNot","TypeofExpression","VoidExpression","NonNullAssert","ParenthesizedExpression","ThisReceiver","elements","LiteralArray","ImplicitReceiver","literalValue","terminator","keys","values","keyStart","quoted","key","literalMapKey","PropertyRead","LiteralMap","readReceiver","isSafe","id","SafePropertyRead","operation","receiver","argumentStart","argumentSpan","SafeCall","Call","positionals","operatorFound","bindings","letBinding","binding","binaryReceiver","KeyedRead","SafeKeyedRead","spanEnd","asBinding","ExpressionBinding","VariableBinding","spanStart","tag","template","TaggedTemplateLiteral","TemplateLiteral","TemplateLiteralElement","partStart","extraMessage","errorMessage","locationText","RecursiveAstVisitor","offsetMap","consumedInOriginalTemplate","consumedInInput","tokenIndex","currentToken","decoded","encoded","lengthOfParts","sum","serialize","SerializeExpressionVisitor","interleave","zip","literal","expr.ImplicitReceiver","left","l","_SECURITY_SCHEMA","SECURITY_SCHEMA","registerContext","SecurityContext","ctx","specs","spec","IFRAME_SECURITY_SENSITIVE_ATTRS","isIframeSecuritySensitiveAttr","ElementSchemaRegistry","BOOLEAN","NUMBER","STRING","OBJECT","SCHEMA","_ATTR_TO_PROP","_PROP_TO_ATTR","inverted","propertyName","attributeName","DomElementSchemaRegistry","encodedType","events","strType","strProperties","properties","typeNames","superName","superType","prop","superEvent","property","propName","schemaMetas","schema","NO_ERRORS_SCHEMA","isNgContainer","isNgContent","CUSTOM_ELEMENTS_SCHEMA","isAttribute","elementProperties","dashCaseToCamelCase","camelCaseProp","userProvidedProp","val","unit","strVal","errorMsg","_isPixelDimensionStyle","valAndSuffixMatch","HtmlTagDefinition","closedByChildren","implicitNamespacePrefix","contentType","closedByParent","isVoid","ignoreFirstLf","preventNamespaceInheritance","canSelfClose","DEFAULT_TAG_DEFINITION","TAG_DEFINITIONS","getHtmlTagDefinition","knownTagName","TAG_TO_PLACEHOLDER_NAMES","PlaceholderRegistry","signature","upperTag","baseName","upperName","uniqueName","placeholder","strAttrs","params","base","_expParser","ExpressionParser","ExpressionLexer","createI18nMessageFactory","containerBlocks","retainEmptyTokens","preserveExpressionWhitespace","_I18nVisitor","meaning","description","customId","visitNodeFn","noopVisitNodeFn","_html","i18n","_expressionParser","_interpolationConfig","_containerBlocks","_retainEmptyTokens","_preserveExpressionWhitespace","i18nodes","html.visitAll","i18n.Message","component","i18n.Text","icu","i18nIcuCases","i18nIcu","i18n.Icu","caze","i18n.Container","expPh","phName","i18n.IcuPlaceholder","_icuCase","_context","children","param","startPhName","closePhName","i18n.BlockPlaceholder","_parameter","visitAttribute","nodeName","dir","i18nNode","i18n.TagPlaceholder","previousI18n","hasInterpolation","startMarker","endMarker","extractPlaceholderName","i18n.Placeholder","normalized","reusePreviousSourceSpans","serializeExpression","assertSingleContainerMessage","assertEquivalentNodes","previousNodes","_CUSTOM_PH_EXP","TRUSTED_TYPES_SINKS","isTrustedTypesSink","setI18nRefs","trimmedNode","originalNode","html.NodeWithI18n","I18nMetaVisitor","keepI18nAttrs","enableI18nLegacyMessageIdFormat","DEFAULT_CONTAINER_BLOCKS","meta","currentMessage","icuFromI18nMessage","hasI18nAttrs","attrsMeta","I18N_ATTR","trimmedNodes","I18N_ATTR_PREFIX","isTrustedType","parseI18nMeta","decimalDigest","computeDigest","computeDecimalDigest","previousMessage","I18N_MEANING_SEPARATOR","I18N_ID_SEPARATOR","idIndex","descIndex","meaningAndDesc","i18nMetaToJSDoc","tags","o.jsDocComment","GOOG_GET_MSG","createGoogleGetMsgStatements","variable","closureVar","placeholderValues","messageString","serializeI18nMessageForGetMsg","o.literal","mapLiteral","formatI18nPlaceholderNamesInMap","o.literalMap","formatI18nPlaceholderName","googGetMsgStmt","o.DeclareVarStmt","o.variable","o.INFERRED_TYPE","o.StmtModifier","i18nAssignmentStmt","o.ExpressionStatement","GetMsgSerializerVisitor","child","serializeIcuNode","ph","serializerVisitor","createLocalizeStatements","messageParts","placeHolders","serializeI18nMessageForLocalize","getSourceSpan","localizedString","o.localizedString","variableInitialization","LocalizeSerializerVisitor","placeholderToMessage","pieces","o.LiteralPiece","associatedMessage","o.PlaceholderPiece","processMessagePieces","startNode","endNode","createEmptyMessagePart","part","NG_I18N_CLOSURE_MODE","TRANSLATION_VAR_PREFIX","I18N_ICU_MAPPING_PREFIX","ESCAPE","CLOSURE_TRANSLATION_VAR_PREFIX","getTranslationConstPrefix","extra","declareI18nVariable","collectI18nConsts","job","fileBasedI18nSuffix","extractedAttributesByI18nContext","i18nAttributesByElement","i18nExpressionsByElement","messages","ir.OpKind","ir.I18nExpressionFor","i18nValuesByContext","messageConstIndices","mainVar","statements","collectMessage","i18nConst","attributesForMessage","ir.OpList","elem","ir.isElementOrContainerOp","i18nAttributes","i18nExpressions","seenPropertyNames","i18nExpr","seen","i18nAttributeConfig","i18nExprValue","o.LiteralArrayExpr","msgIndex","messageOp","subMessagePlaceholders","subMessageId","subMessage","subMessageVar","subMessageStatements","subMessages","addSubMessageParams","i18nGenerateClosureVar","transformFn","postprocessingParams","formattedPostprocessingParams","extraTransformFnParams","o.importExpr","Identifiers","getTranslationDeclStmts","o.literalArr","paramsObject","o.ifStmt","createClosureModeGuard","o\n        .typeofExpr","o.STRING_TYPE","pool","messageId","useExternalIds","uniqueSuffix","sanitizeIdentifier","convertI18nText","currentI18n","currentIcu","textNodeI18nBlocks","textNodeIcus","icuPlaceholderByText","icuPlaceholderOp","ir.createIcuPlaceholderOp","i18nOp","icuOp","icuPlaceholder","contextId","resolutionTime","ir.I18nParamResolutionTime","ops","ir.createI18nExpressionOp","liftLocalRefs","localRefs","serializeLocalRefs","refs","constRefs","ref","emitNamespaceChanges","activeNamespace","ir.Namespace","ir.createNamespaceOp","parse","styles","parenDepth","valueStart","propStart","currentProp","hyphenate","styleVal","v","parseExtractedStyles","ir.BindingKind","ir.isStringLiteral","target","ir.TemplateKind","parsedStyles","ir.createExtractedAttributeOp","parsedClasses","parsedClass","nameFunctionsAndVariables","addNamesToView","ir.CompatibilityMode","compatibility","varNames","animationKind","animation","getVariableName","ViewCompilationUnit","emptyView","fallbackView","childView","normalizeStylePropName","stripImportant","ir.visitExpressionsInOp","ir.ReadVariableExpr","ir.SemanticVariableKind","compatPrefix","importantIndex","mergeNextContextExpressions","mergeNextContextsInOps","ir.NextContextExpr","mergeSteps","tryToMerge","candidate","flags","ir.isIrExpression","ir.VisitorContextFlag","ir.ExpressionKind","CONTAINER_TAG","generateNgContainerOps","updatedElementXrefs","lookupElement","xref","disableBindings","view","ir.createDisableBindingsOp","ir.createEnableBindingsOp","kindTest","kindWithInterpolationTest","ir.Interpolation","basicListenerKindTest","nonInterpolationPropertyKindTest","CREATE_ORDERING","UPDATE_ORDERING","keepLast","UPDATE_HOST_ORDERING","handledOpKinds","orderOps","orderWithin","ordering","CompilationJobKind","opList","opsToOrder","firstTargetInGroup","currentTarget","ir.hasDependsOnSlotContextTrait","reorder","groups","groupIndex","o","group","removeContentSelectors","createOpXrefMap","lookupInXrefMap","isSelectAttribute","map","createPipes","processPipeBindingsInView","updateOp","addPipeToCreationBlock","ir.createPipeOp","afterTargetXref","ir.hasConsumesSlotTrait","pipe","createVariadicPipes","ir.transformExpressionsInOp","ir.PipeBindingExpr","ir.PipeBindingVariadicExpr","propagateI18nBlocks","propagateI18nBlocksToTemplates","subTemplateIndex","i18nBlock","propagateI18nBlocksForView","forView","i18nPlaceholder","wrapTemplateWithI18n","parentI18n","ir.createI18nStartOp","ir.createI18nEndOp","extractPureFunctions","ir.PureFunctionExpr","constantDef","PureFunctionConstant","GenericKeyFn","numArgs","ir.PureFunctionParameterExpr","declName","keyExpr","fnParams","idx","o.FnParam","returnExpr","ir.transformExpressionsInExpression","o.ArrowFunctionExpr","generatePureLiteralStructures","transformLiteralArray","o.LiteralMapExpr","transformLiteralMap","derivedEntries","nonConstantArgs","entry","o.LiteralMapEntry","slot","constIndex","localRefIndex","elementOrContainerBase","elementStart","instruction","call","templateBase","templateFnRef","decls","vars","o.NULL_EXPR","propertyBase","sanitizer","interpolationToExpression","elementEnd","elementContainerStart","elementContainer","elementContainerEnd","enableBindings","listener","handlerFn","eventTargetResolver","syntheticHost","twoWayBindingSet","twoWayListener","namespaceHTML","namespaceSVG","namespaceMath","advance","delta","reference","nextContext","steps","getCurrentView","restoreView","savedView","resetView","returnValue","initialValue","defer","selfSlot","primarySlot","dependencyResolverFn","loadingSlot","placeholderSlot","errorSlot","loadingConfig","placeholderConfig","enableTimerScheduling","o.LiteralExpr","deferTriggerToR3TriggerInstructionsMap","ir.DeferTriggerKind","deferOn","trigger","modifier","instructionToCall","a","projectionDef","def","projection","projectionSlotIndex","fallbackFnName","fallbackDecls","fallbackVars","i18nStart","conditionalCreate","conditionalBranchCreate","repeaterCreate","viewFnName","trackByFn","trackByUsesComponentInstance","emptyViewFnName","emptyDecls","emptyVars","emptyTag","emptyConstIndex","repeater","collection","deferWhen","declareLet","storeLet","readContextLet","i18nEnd","i18nAttributesConfig","ariaProperty","twoWayProperty","namespace","styleProp","classProp","styleMap","classMap","domElement","domElementStart","domElementEnd","domElementContainerStart","domElementContainer","domElementContainerEnd","domListener","domTemplate","PIPE_BINDINGS","pipeBind","varOffset","pipeBindV","textInterpolate","interpolationArgs","collateInterpolationArgs","callVariadicInstruction","TEXT_INTERPOLATE_CONFIG","i18nExp","i18nApply","domProperty","identifier","animationString","animationListener","syntheticHostProperty","pureFunction","fn","callVariadicInstructionExpr","PURE_FUNCTION_CONFIG","attachSourceLocation","templatePath","locations","VALUE_INTERPOLATE_CONFIG","ir.createStatementOp","conditional","contextValue","config","baseArgs","extraArgs","lastInterpolationArg","o\n            .importExpr","GLOBAL_TARGET_RESOLVERS","DOM_PROPERTY_REMAPPING","reify","reifyCreateOperations","reifyUpdateOperations","reifyIrExpression","ng.text","TemplateCompilationMode","ng.domElementStart","ng.elementStart","ng.domElement","ng.element","ng.domElementEnd","ng.elementEnd","ng.domElementContainerStart","ng.elementContainerStart","ng.domElementContainer","ng.elementContainer","ng.domElementContainerEnd","ng.elementContainerEnd","ng.i18nStart","ng.i18nEnd","ng.i18n","ng.i18nAttributes","ng.domTemplate","ng.template","ng.disableBindings","ng.enableBindings","ng.pipe","ng.declareLet","ng.animationString","animationCallbackFn","reifyListenerHandler","ng.animation","animationListenerFn","ng.animationListener","listenerFn","ng.domListener","ng.listener","ng.twoWayListener","ng.namespaceHTML","ng.namespaceSVG","ng.namespaceMath","timerScheduling","ng.defer","ng.deferOn","ng.projectionDef","fallbackViewFnName","ng.projection","conditionalCreateChildView","ng.conditionalCreate","conditionalBranchCreateChildView","ng.conditionalBranchCreate","repeaterView","ng.repeaterCreate","reifyTrackBy","locationsLiteral","targetSlot","line","column","ng.attachSourceLocation","ng.advance","reifyDomProperty","reifyProperty","ng.twoWayProperty","ng.styleProp","ng.classProp","ng.styleMap","ng.classMap","ng.i18nExp","ng.i18nApply","ng.textInterpolate","ng.attribute","ng.syntheticHostProperty","ng.conditional","ng.repeater","ng.deferWhen","ng.domProperty","isAriaAttribute","ng.ariaProperty","ng.property","ng.nextContext","ng.reference","ng.restoreView","ng.resetView","ng.getCurrentView","ng.pureFunction","ng.pipeBind","ng.pipeBindV","ng.readContextLet","ng.storeLet","handlerOps","consumesDollarEvent","handlerStmts","o.fn","o.ReturnStatement","o.arrowFn","trackOp","removeEmptyBindings","ir.EmptyExpr","removeI18nContexts","removeIllegalLetReferences","ir.StoreLetExpr","ir.LexicalReadExpr","removeUnusedI18nAttributesOps","ownersWithI18nExpressions","resolveContexts","processLexicalScope","scope","ir.ContextExpr","resolveDeferDepsFns","fullPathName","resolveDollarEvent","transformDollarEvent","o.ReadVarExpr","resolveI18nElementPlaceholders","i18nContexts","resolvePlaceholdersForView","pendingStructuralDirective","currentOps","pendingStructuralDirectiveCloses","recordElementStart","startOp","recordElementClose","recordTemplateStart","recordTemplateClose","forSlot","emptySlot","i18nContext","structuralDirective","startName","closeName","ir.I18nParamValueFlags","addParam","getSubTemplateIndexForTemplateTag","childOp","resolveI18nExpressionPlaceholders","subTemplateIndices","icuPlaceholders","expressionIndices","referenceIndex","updatePlaceholder","resolveNames","localDefinitions","o.ReadPropExpr","ir.RestoreViewExpr","sanitizerFns","trustedValueFns","resolveSanitizers","trustedValueFn","getOnlySecurityContext","sanitizerFn","isIframe","ownerOp","isIframeElement","securityContext","saveAndRestoreView","ir.createVariableOp","ir.GetCurrentViewExpr","ir.VariableFlags","needsRestoreView","handlerOp","ir.ReferenceExpr","ir.ContextLetReferenceExpr","addSaveRestoreViewOperationToListener","ir.ResetViewExpr","allocateSlots","slotMap","slotCount","optimizeStoreLet","letUsedExternally","declareLetOps","hasPipe","root","stripNonrequiredParentheses","requiredParens","o.BinaryOperatorExpr","o.BinaryOperator","checkExponentiationParens","checkNullishCoalescingParens","checkAndOrParens","o.ParenthesizedExpr","o.UnaryOperatorExpr","isLogicalAndOr","o.ConditionalExpr","specializeStyleBindings","ir.createClassPropOp","ir.createStylePropOp","ir.createStyleMapOp","ir.createClassMapOp","generateTemporaryVariables","generateTemporaries","opCount","generatedStatements","finalReads","flag","ir.ReadTemporaryExpr","count","assigned","released","defs","ir.AssignTemporaryExpr","assignName","names","optimizeTrackFns","isTrackByFunctionCall","o\n                        .importExpr","ir.TrackContextExpr","trackOpList","rootView","o.InvokeFunctionExpr","arg0","arg1","generateTrackVariables","transformTwoWayBindingSet","ir.TwoWayBindingSetExpr","o.ReadKeyExpr","ng.twoWayBindingSet","countVariables","varCount","ir.hasConsumesVarsTrait","varsUsedByOp","ir.hasUsesVarOffsetTrait","varsUsedByIrExpression","ComponentCompilationJob","slots","isSingletonInterpolation","optimizeVariables","inlineAlwaysInlineVariables","optimizeVariablesInOpList","Fence","fencesForIrExpression","varDecls","varUsages","varRemoteUsages","opMap","collectOpInfo","countVariableUsages","contextIsUsed","opInfo","stmtOp","uncountVariableUsages","toInline","isAlwaysInline","varInfo","targetOp","allowConservativeInlining","tryInlineVariableInitializer","safeToInlinePastFences","fences","variablesUsed","varRemoteUsage","declFences","initializer","inlined","inliningAllowed","exprFences","wrapI18nIcus","currentI18nOp","addedI18nId","phases","Kind","parseHostStyleProperties","deduplicateTextBindings","specializeBindings","convertAnimations","extractAttributes","createI18nContexts","collapseSingletonInterpolations","generateConditionalExpressions","configureDeferInstructions","generateProjectionDefs","generateLocalLetReferences","generateVariables","deleteAnyCasts","resolveDeferTargetNames","expandSafeReads","convertI18nBindings","assignI18nSlotDependencies","applyI18nExpressions","extractI18nMessages","collectConstExpressions","collectElementConsts","generateAdvance","collapseEmptyInstructions","attachSourceLocations","chain","phase","emitTemplateFn","tpl","rootFn","emitView","emitChildViews","viewFn","createStatements","updateStatements","createCond","maybeGenerateRfBlock","updateCond","emitHostBindingFunction","compatibilityMode","domSchema","NG_TEMPLATE_TAG_NAME","ANIMATE_PREFIX","isI18nRootNode","isSingleI18nIcu","ingestComponent","constantPool","compilationMode","relativeContextFilePath","i18nUseExternalIds","deferMeta","allDeferrableDepsFn","relativeTemplatePath","enableDebugLocations","ingestNodes","ingestHostBinding","bindingParser","HostBindingCompilationJob","bindingKind","securityContexts","ingestDomProperty","ingestHostAttribute","event","ingestHostEvent","e.Interpolation","convertAst","ir.createBindingOp","attrBinding","eventBinding","e.ParsedEventType","ir.createAnimationListenerOp","ir.SlotHandle","makeListenerHandlerOps","ir.createListenerOp","t.Element","ingestElement","t.Template","ingestTemplate","t.Content","ingestContent","t.Text","ingestText","t.BoundText","ingestBoundText","t.IfBlock","ingestIfBlock","t.SwitchBlock","ingestSwitchBlock","t.DeferredBlock","ingestDeferBlock","t.Icu","ingestIcu","t.ForLoopBlock","ingestForBlock","t.LetDeclaration","ingestLetDeclaration","t.Component","namespaceKey","ir.createElementStartOp","namespaceForKey","ingestElementBindings","ingestReferences","i18nBlockId","endOp","ir.createElementEndOp","tmpl","tagNameWithoutNamespace","namespacePrefix","functionNameSuffix","prefixWithNamespace","templateKind","isPlainTemplate","templateOp","ir.createTemplateOp","ingestTemplateBindings","t.Comment","ir.createProjectionOp","asMessage","ir.createTextOp","e.ASTWithSource","i18nPlaceholders","textXref","baseSourceSpan","ir.createInterpolateTextOp","ifBlock","firstXref","conditions","ifCase","cView","ingestControlFlowInsertionPoint","ir.CTX_REF","ifCaseI18nMeta","conditionalCreateOp","ir.createConditionalCreateOp","ir.createConditionalBranchCreateOp","caseExpr","conditionalCaseExpr","ir.ConditionalCaseExpr","ir.createConditionalOp","switchBlock","switchCase","switchCaseI18nMeta","ingestDeferView","i18nMeta","secondaryView","deferBlock","ownResolverFn","main","loading","deferXref","deferOp","ir.createDeferOp","calcDeferBlockFlags","deferOnOps","deferWhenOps","ingestDeferTriggers","ir.createDeferOnOp","deferBlockDetails","triggers","onOps","whenOps","deferOnOp","ir.createDeferWhenOp","ir.createIcuStartOp","ir.createIcuEndOp","forBlock","indexName","countName","indexVarNames","getComputedForLoopVariableExpression","convertSourceSpan","track","emptyTagName","emptyI18nPlaceholder","ir.createRepeaterCreateOp","ir.createRepeaterOp","ir.createDeclareLetOp","ir.createStoreLetOp","e.PropertyRead","e.ImplicitReceiver","e.ThisReceiver","e.Call","arg","e.LiteralPrimitive","e.Unary","o.UnaryOperator","e.Binary","BINARY_OPERATORS","e.KeyedRead","e.Chain","e.LiteralMap","entries","e.LiteralArray","e.Conditional","e.NonNullAssert","e.BindingPipe","e.SafeKeyedRead","ir.SafeKeyedReadExpr","e.SafePropertyRead","ir.SafePropertyReadExpr","e.SafeCall","ir.SafeInvokeFunctionExpr","e.EmptyExpr","e.PrefixNot","o.not","e.TypeofExpression","o.typeofExpr","e.VoidExpression","o.VoidExpr","e.TemplateLiteral","convertTemplateLiteral","e.TaggedTemplateLiteral","o.TaggedTemplateLiteralExpr","e.ParenthesizedExpression","o.TemplateLiteralExpr","o.TemplateLiteralElementExpr","convertAstWithInterpolation","e.AST","BINDING_KINDS","e.BindingType","i18nAttributeBindingNames","astOf","b","output","ir.createTwoWayListenerOp","makeTwoWayListenerHandlerOps","ir.createI18nAttributesOp","t.TextAttribute","createTemplateBinding","isStructuralTemplateAttribute","i18nMessage","isTextBinding","bindingType","handler","handlerSpan","handlerExprs","handlerExpr","eventReference","twoWaySetExpr","assertIsArray","ENABLE_TEMPLATE_SOURCE_LOCATIONS","getTemplateSourceLocationsEnabled","ENABLE_TEMPLATE_SOURCE_LOCATIONS","renderFlagCheckIfStmt","flags","statements","o.ifStmt","o.variable","RENDER_FLAGS","o.literal","toQueryFlags","query","getQueryPredicate","constantPool","predicate","selector","selectors","token","o.literalArr","o.importExpr","R3","createQueryCreateCall","queryTypeFns","prependParams","parameters","o.ReadPropExpr","CONTEXT_NAME","queryCreateFn","queryAdvancePlaceholder","collapseAdvanceStatements","result","advanceCollapseCount","flushAdvanceCount","o\n                .importExpr","i","st","createViewQueriesFunction","viewQueries","name","createStatements","updateStatements","tempAllocator","temporaryAllocator","TEMPORARY_NAME","queryDefinitionCall","temporary","getQueryList","refresh","updateDirective","o\n            .variable","viewQueryFnName","o.fn","o.FnParam","o.NUMBER_TYPE","o.INFERRED_TYPE","createContentQueriesFunction","queries","contentQueriesFnName","HtmlParser","Parser","getHtmlTagDefinition","source","url","options","PROPERTY_PARTS_SEPARATOR","ATTRIBUTE_PREFIX","ANIMATE_PREFIX","CLASS_PREFIX","STYLE_PREFIX","TEMPLATE_ATTR_PREFIX","LEGACY_ANIMATE_PROP_PREFIX","BindingParser","_exprParser","_interpolationConfig","_schemaRegistry","errors","properties","sourceSpan","boundProps","propName","expression","hostListeners","targetEvents","value","interpolatedTokens","absoluteOffset","ast","e","tplKey","tplValue","absoluteValueOffset","targetMatchableAttrs","targetProps","targetVars","isIvyAst","absoluteKeyOffset","bindings","binding","bindingSpan","moveParseSourceSpan","key","keySpan","VariableBinding","valueSpan","ParsedVariable","srcSpan","bindingsResult","warning","ParseErrorLevel","isLegacyAnimationLabel","AbsoluteSourceSpan","ParsedProperty","ParsedPropertyType","isHost","isPartOfAssignmentBinding","isLegacyAnimationProp","expr","isHostBinding","elementSelector","boundProp","skipValidation","mapPropertyName","BoundElementProperty","BindingType","SecurityContext","unit","bindingType","boundPropertyName","parts","securityContexts","calcPossibleSecurityContexts","nsSeparatorIdx","ns","mergeNsAndName","mappedPropName","isAssignmentEvent","handlerSpan","isAttribute","prop","rawName","target","eventName","splitAtColon","matches","splitAtPeriod","phase","ParsedEvent","ParsedEventType","prevErrorCount","isValid","eventType","EmptyExpr","message","level","ParseError","isAttr","report","ASTWithSource","NonNullAssert","Call","PropertyRead","ImplicitReceiver","ThisReceiver","KeyedRead","hasRecursiveSafeReceiver","SafePropertyRead","SafeKeyedRead","ParenthesizedExpression","registry","ctxs","nameToContext","elName","CssSelector","elementNames","notElementNames","possibleElementNames","absoluteSpan","startDiff","endDiff","ParseSourceSpan","isStyleUrlResolvable","schemeMatch","URL_WITH_SCHEMA_REGEXP","NG_CONTENT_SELECT_ATTR","LINK_ELEMENT","LINK_STYLE_REL_ATTR","LINK_STYLE_HREF_ATTR","LINK_STYLE_REL_VALUE","STYLE_ELEMENT","SCRIPT_ELEMENT","NG_NON_BINDABLE_ATTR","NG_PROJECT_AS","preparseElement","selectAttr","hrefAttr","relAttr","nonBindable","projectAs","attr","lcAttrName","normalizeNgContentSelect","nodeName","type","PreparsedElementType","isNgContent","PreparsedElement","FOR_LOOP_EXPRESSION_PATTERN","FOR_LOOP_TRACK_PATTERN","CONDITIONAL_ALIAS_PATTERN","ELSE_IF_PATTERN","FOR_LOOP_LET_PATTERN","IDENTIFIER_PATTERN","CHARACTERS_IN_SURROUNDING_WHITESPACE_PATTERN","ALLOWED_FOR_LOOP_LET_VARIABLES","isConnectedForLoopBlock","isConnectedIfLoopBlock","createIfBlock","connectedBlocks","visitor","bindingParser","validateIfConnectedBlocks","branches","mainBlockParams","parseConditionalBlockParameters","t.IfBlockBranch","html.visitAll","block","params","children","ifBlockStartSourceSpan","ifBlockEndSourceSpan","wholeSourceSpan","lastBranch","t.IfBlock","createForLoop","parseForLoopParameters","node","empty","t.ForLoopBlockEmpty","endSpan","validateTrackByExpression","t.ForLoopBlock","createSwitchBlock","validateSwitchBlock","primaryExpression","parseBlockParameterToBinding","cases","unknownBlocks","defaultCase","html.Block","t.UnknownBlock","t.SwitchBlockCase","t.SwitchBlock","expressionParam","secondaryParams","match","stripOptionalParentheses","itemName","rawExpression","variableName","variableSpan","t.Variable","emptySpanAfterForBlockStart","param","letMatch","variablesSpan","parseLetParameter","trackMatch","keywordSpan","parseSourceSpan","PipeVisitor","span","loopItemName","context","startSpan","part","expressionParts","v","keyLeadingWhitespace","keyName","valueLeadingWhitespace","implicit","hasElse","hasDefault","html.Comment","html.Text","start","end","expressionAlias","aliasMatch","variableStart","spaceRegex","openParens","char","RecursiveAstVisitor","TIME_PATTERN","SEPARATOR_PATTERN","COMMA_DELIMITED_SYNTAX","chars.$LBRACE","chars.$RBRACE","chars.$LBRACKET","chars.$RBRACKET","chars.$LPAREN","chars.$RPAREN","OnTriggerType","parseNeverTrigger","triggers","neverIndex","neverSourceSpan","prefetchSpan","getPrefetchSpan","hydrateSpan","getHydrateSpan","trackTrigger","t.NeverDeferredTrigger","parseWhenTrigger","whenIndex","whenSourceSpan","getTriggerParametersStart","parsed","t.BoundDeferredTrigger","parseOnTrigger","placeholder","onIndex","onSourceSpan","OnTriggerParser","validateHydrateReferenceBasedTrigger","validatePlainReferenceBasedTrigger","validator","Lexer","chars.$COMMA","prevErrors","identifier","triggerNameStartSpan","nameSpan","isFirstTrigger","prefetchSourceSpan","hydrateSourceSpan","createIdleTrigger","createTimerTrigger","createInteractionTrigger","createImmediateTrigger","createHoverTrigger","createViewportTrigger","commaDelimStack","current","TokenType","trigger","newStart","newEnd","allTriggers","t.IdleDeferredTrigger","delay","parseDeferredTime","t.TimerDeferredTrigger","t.ImmediateDeferredTrigger","t.HoverDeferredTrigger","t.InteractionDeferredTrigger","t.ViewportDeferredTrigger","startPosition","hasFoundSeparator","time","units","PREFETCH_WHEN_PATTERN","PREFETCH_ON_PATTERN","HYDRATE_WHEN_PATTERN","HYDRATE_ON_PATTERN","HYDRATE_NEVER_PATTERN","MINIMUM_PARAMETER_PATTERN","AFTER_PARAMETER_PATTERN","WHEN_PARAMETER_PATTERN","ON_PARAMETER_PATTERN","isConnectedDeferLoopBlock","createDeferredBlock","loading","error","parseConnectedBlocks","prefetchTriggers","hydrateTriggers","parsePrimaryTriggers","lastEndSourceSpan","endOfLastSourceSpan","lastConnectedBlock","sourceSpanWithConnectedBlocks","t.DeferredBlock","parsePlaceholderBlock","parseLoadingBlock","parseErrorBlock","minimumTime","parsedTime","t.DeferredBlockPlaceholder","afterTime","t.DeferredBlockLoading","t.DeferredBlockError","BIND_NAME_REGEXP","KW_BIND_IDX","KW_LET_IDX","KW_REF_IDX","KW_ON_IDX","KW_BINDON_IDX","KW_AT_IDX","IDENT_KW_IDX","BINDING_DELIMS","UNSUPPORTED_SELECTORLESS_TAGS","UNSUPPORTED_SELECTORLESS_DIRECTIVE_ATTRS","htmlAstToRender3Ast","htmlNodes","transformer","HtmlAstToIvyAst","ivyNodes","allErrors","element","isI18nRootElement","isI18nRootNode","preparsedElement","contents","textContents","isTemplateElement","isNgTemplate","attributes","boundEvents","references","variables","templateVariables","elementHasInlineTemplate","parsedProperties","templateParsedProperties","i18nAttrsMeta","directives","NON_BINDABLE_VISITOR","parsedElement","attrs","t.Content","t.Template","bound","t.Element","attribute","t.TextAttribute","text","expansion","vars","placeholders","I18N_ICU_VAR_PREFIX","formattedKey","t.BoundText","t.Icu","expansionCase","comment","t.Comment","decl","t.LetDeclaration","component","t.Component","index","errorMessage","primaryBlockIndex","siblings","relatedBlocks","elementName","i18nPropsMeta","literal","i18n","bep","t.BoundAttribute","hasBinding","normalizedName","normalizeAttributeName","isTemplateBinding","templateValue","templateKey","parsedVariables","matchableAttributes","createKeySpan","prefix","normalizationAdjustment","keySpanStart","keySpanEnd","bindParts","events","addEvents","delims","html.Component","seenDirectives","directive","invalid","inputs","input","t.Directive","a","templateProperties","templateAttrs","hoistedAttrs","valueNoNgsp","replaceNgsp","t.Text","reference","t.Reference","seenNames","ref","NonBindableVisitor","nodes","parameter","attrName","t.BoundEvent","LEADING_TRIVIA_CHARS","parseTemplate","template","templateUrl","interpolationConfig","preserveWhitespaces","enableI18nLegacyMessageIdFormat","selectorlessEnabled","makeBindingParser","parseResult","parsedTemplate","rootNodes","retainEmptyTokens","i18nMetaVisitor","I18nMetaVisitor","i18nMetaResult","WhitespaceVisitor","styleUrls","styles","ngContentSelectors","commentNodes","elementRegistry","DomElementSchemaRegistry","DEFAULT_INTERPOLATION_CONFIG","COMPONENT_VARIABLE","HOST_ATTR","CONTENT_ATTR","baseDirectiveFields","meta","definitionMap","DefinitionMap","core.parseSelectorToR3Selector","asLiteral","createHostBindingsFunction","conditionallyCreateDirectiveBindingLiteral","addFeatures","features","providers","viewProviders","args","o.LiteralArrayExpr","o\n            .importExpr","createHostDirectivesFeatureArg","externalStyleNodes","externalStyle","compileDirectiveFromMetadata","o\n        .importExpr","createDirectiveType","compileComponentFromMetadata","firstSelector","selectorAttributes","templateTypeName","allDeferrableDepsFn","fnName","o.DeclareVarStmt","o.StmtModifier","compilationMode","TemplateCompilationMode","tpl","ingestComponent","transform","CompilationJobKind","templateFn","emitTemplateFn","o.arrowFn","o.ReturnStatement","compileDeclarationList","core.ViewEncapsulation","hasStyles","styleNodes","compileStyles","style","o.literalMap","core.ChangeDetectionStrategy","createComponentType","typeParams","createBaseDirectiveTypeParams","stringArrayAsType","o.expressionType","createHostDirectivesType","list","mode","resolvedList","stringAsType","str","stringMapAsLiteralExpression","map","mapValues","arr","o.NONE_TYPE","selectorForType","typeWithParameters","getInputsTypeExpression","q","values","hostBindingsMetadata","typeSourceSpan","eventBindings","hostJob","ingestHostBinding","varCount","emitHostBindingFunction","HOST_REG_EXP","parseHostBindings","host","listeners","specialAttributes","verifyHostBindings","hostSelector","shadowCss","ShadowCss","createHostDirectivesType","meta","o.expressionType","o.literalArr","hostMeta","o.literalMap","o.typeofExpr","stringMapAsLiteralExpression","o.NONE_TYPE","createHostDirectivesFeatureArg","hostDirectives","expressions","hasForwardRef","current","keys","inputsLiteral","createHostDirectivesMappingArray","outputsLiteral","o.FunctionExpr","o.ReturnStatement","mapping","elements","publicName","o.literal","CombinedRecursiveAstVisitor","RecursiveAstVisitor","node","ASTWithSource","element","template","content","attribute","text","icu","key","deferred","trigger","t.BoundDeferredTrigger","block","decl","component","directive","variable","reference","nodes","R3TargetBinder","directiveMatcher","target","directives","eagerDirectives","missingDirectives","bindings","references","scopedNodeEntities","expressions","symbols","nestingLevel","usedPipes","eagerPipes","deferBlocks","scope","Scope","extractScopedNodeEntities","DirectiveBinder","TemplateBinder","R3BoundTarget","_Scope","parentScope","rootNode","DeferredBlock","template","nodeOrNodes","Template","node","IfBlockBranch","ForLoopBlock","v","SwitchBlockCase","ForLoopBlockEmpty","DeferredBlockError","DeferredBlockPlaceholder","DeferredBlockLoading","Content","HostElement","element","variable","reference","deferred","block","content","decl","component","directive","current","attr","event","text","icu","trigger","thing","name","res","_DirectiveBinder","wasInDeferBlock","child","SelectorlessMatcher","componentMatches","SelectorMatcher","cssSelector","createCssSelectorFromNode","_","results","ref","setBinding","meta","attribute","ioType","input","output","dirTarget","dir","value","setAttributeBinding","binding","_TemplateBinder","CombinedRecursiveAstVisitor","level","ast","context","childScope","ImplicitReceiver","ThisReceiver","exprTargets","rawDeferred","expr","symbol","set","dirs","InteractionDeferredTrigger","ViewportDeferredTrigger","HoverDeferredTrigger","Comment","Element","outsideRef","Reference","refInPlaceholder","targetInPlaceholder","stack","entities","entity","Component","Directive","rootScope","templateEntities","entityMap","extractScopeEntities","currentEntities","scopesToProcess","ResourceLoader","CompilerFacadeImpl","FactoryTarget","DomElementSchemaRegistry","jitEvaluator","JitEvaluator","angularCoreEnv","sourceMapUrl","facade","metadata","wrapReference","compilePipeFromMetadata","declaration","convertDeclarePipeFacadeToMetadata","expression","statements","compileInjectable","computeProvidedIn","convertToProviderExpression","wrapExpression","convertR3DependencyMetadata","convertR3DeclareDependencyMetadata","WrappedNodeExpr","i","compileInjector","convertDeclareInjectorFacadeToMetadata","R3NgModuleMetadataKind","R3SelectorScopeMode","compileNgModule","compileNgModuleDeclarationExpression","convertDirectiveFacadeToMetadata","typeSourceSpan","convertDeclareDirectiveFacadeToMetadata","constantPool","ConstantPool","bindingParser","makeBindingParser","compileDirectiveFromMetadata","interpolation","defer","parseJitTemplate","convertDeclarationFacadeToMetadata","jitExpressionSourceMap","convertDeclareComponentFacadeToMetadata","compileComponentFromMetadata","factoryRes","compileFactoryFunction","convertR3DependencyMetadataArray","kind","typeName","sourceUrl","r3JitTypeSourceSpan","def","preStatements","DeclareVarStmt","StmtModifier","R3JitReflector","convertToR3QueryMetadata","convertQueryPredicate","convertQueryDeclarationToMetadata","predicate","createMayBeForwardRefExpression","inputsFromMetadata","parseInputsArray","outputsFromMetadata","parseMappingStringArray","propMetadata","inputsFromType","outputsFromType","field","ann","isInput","isOutput","hostDirectives","hostDirective","extractHostBindings","getHostDirectiveBindingMapping","inputsPartialMetadataToInputMetadata","convertHostDeclarationToMetadata","getJitStandaloneDefaultForVersion","host","convertOpaqueValuesToExpressions","array","result","obj","key","declarations","innerDep","convertDirectiveDeclarationToMetadata","convertPipeDeclarationToMetadata","convertPipeMapToMetadata","hasDirectiveDependencies","R3TemplateDependencyKind","ChangeDetectionStrategy","ViewEncapsulation","isComponent","pipes","pipe","preserveWhitespaces","deferBlockDependencies","interpolationConfig","InterpolationConfig","DEFAULT_INTERPOLATION_CONFIG","parsed","parseTemplate","errors","err","boundTarget","createR3ComponentDeferMetadata","property","providedIn","LiteralExpr","facades","isAttributeDep","rawToken","token","createR3DependencyMetadata","optional","self","skipSelf","attributeNameType","literal","deferredBlocks","blocks","dependencyFn","sourceSpan","parseHostBindings","verifyHostBindings","error","isHostBinding","getSafePropertyAccessString","isHostListener","inputs","minifiedClassName","parseLegacyInputPartialOutput","values","bindingPropertyName","classPropertyName","parseMappingString","alias","fieldName","str","publishFacade","global","ng","_VisitorMode","XmlTagDefinition","currentParent","name","TagContentType","_TAG_DEFINITION","VERSION","Version","publishFacade","global","global","__symbol__","name","initZone","performance","mark","performanceMeasure","label","ZoneImpl","patches","zone","_currentZoneFrame","_currentTask","fn","ignoreDuplicate","checkDuplicate","perfName","_api","parent","zoneSpec","_ZoneDelegate","key","current","callback","source","_callback","applyThis","applyArgs","error","task","NO_ZONE","zoneTask","type","isPeriodic","isRefreshable","notScheduled","eventTask","macroTask","reEntryGuard","running","scheduled","previousTask","state","unknown","scheduling","zoneDelegates","newZone","err","data","customSchedule","ZoneTask","microTask","customCancel","canceling","count","i","DELEGATE_ZS","delegate","_","target","hasTaskState","parentDelegate","zoneSpecHasTask","parentHasTask","targetZone","returnTask","scheduleMicroTask","value","isEmpty","counts","prev","next","options","scheduleFn","cancelFn","self","args","_numberOfNestedTaskFrames","drainMicroTaskQueue","toState","fromState1","fromState2","symbolSetTimeout","symbolPromise","symbolThen","_microTaskQueue","_isDrainingMicrotaskQueue","nativeMicroTaskQueuePromise","nativeScheduleMicroTask","func","nativeThen","queue","noop","loadZone","ObjectGetOwnPropertyDescriptor","ObjectDefineProperty","ObjectGetPrototypeOf","ObjectCreate","ArraySlice","ADD_EVENT_LISTENER_STR","REMOVE_EVENT_LISTENER_STR","ZONE_SYMBOL_ADD_EVENT_LISTENER","ZONE_SYMBOL_REMOVE_EVENT_LISTENER","TRUE_STR","FALSE_STR","ZONE_SYMBOL_PREFIX","wrapWithCurrentZone","scheduleMacroTaskWithCurrentZone","zoneSymbol","isWindowExists","internalWindow","_global","REMOVE_ATTRIBUTE","bindArguments","patchPrototype","prototype","fnNames","prototypeDesc","isPropertyWritable","patched","attachOriginToPatched","propertyDesc","isWebWorker","isNode","isBrowser","isMix","zoneSymbolEventNames$1","enableBeforeunloadSymbol","wrapFn","event","eventNameSymbol","listener","result","errorEvent","patchProperty","obj","prop","desc","onPropPatchedSymbol","originalDescGet","originalDescSet","eventName","newValue","patchOnProperties","properties","onProperties","j","originalInstanceKey","patchClass","className","OriginalClass","a","instance","patchMethod","patchFn","proto","delegateName","patchDelegate","patchMacroTask","funcName","metaCreator","setNative","scheduleTask","meta","original","isDetectedIEOrEdge","ieOrEdge","isIEOrEdge","ua","isFunction","isNumber","OPTIMIZED_ZONE_EVENT_TASK_DATA","zoneSymbolEventNames","globalSources","EVENT_NAME_SYMBOL_REGX","IMMEDIATE_PROPAGATION_SYMBOL","prepareEventNames","eventNameToString","falseEventName","trueEventName","symbol","symbolCapture","patchEventTarget","api","apis","patchOptions","ADD_EVENT_LISTENER","REMOVE_EVENT_LISTENER","LISTENERS_EVENT_LISTENER","REMOVE_ALL_LISTENERS_EVENT_LISTENER","zoneSymbolAddEventListener","ADD_EVENT_LISTENER_SOURCE","PREPEND_EVENT_LISTENER","PREPEND_EVENT_LISTENER_SOURCE","invokeTask","globalCallback","context","isCapture","tasks","errors","copyTasks","globalZoneAwareCallback","globalZoneAwareCaptureCallback","patchEventTargetMethods","useGlobalCallback","validateHandler","returnTarget","taskData","nativeAddEventListener","nativeRemoveEventListener","nativeListeners","nativeRemoveAllListeners","nativePrependEventListener","buildEventListenerOptions","passive","customScheduleGlobal","customCancelGlobal","symbolEventNames","symbolEventName","existingTasks","customScheduleNonGlobal","customSchedulePrepend","customCancelNonGlobal","compareTaskCallbackVsDelegate","typeOfDelegate","compare","unpatchedEvents","passiveEvents","copyEventListenerOptions","newOptions","makeAddListener","nativeListener","addSource","customScheduleFn","customCancelFn","prepend","isEventListenerObject","signal","capture","once","isExisting","constructorName","targetSource","onAbort","existingTask","onPropertySymbol","listeners","findEventTasks","symbolCaptureEventName","captureTasks","removeTasks","keys","match","evtName","results","foundTasks","captureFalseTasks","captureTrueTasks","patchEventPrototype","Event","patchQueueMicrotask","taskSymbol","patchTimer","window","setName","cancelName","nameSuffix","clearNative","tasksByHandleId","handleOrId","clearTask","handle","handleId","originalRefresh","id","patchCustomElements","callbacks","eventTargetPatch","eventNames","EVENT_TARGET","patchEvent","filterProperties","ignoreProperties","tip","ip","targetIgnoreProperties","op","patchFilteredProperties","filteredProperties","getOnEventNames","propertyDescriptorPatch","patchTargets","ignoreErrorProperties","patchBrowser","Zone","legacyPatch","clear","blockingMethods","s","XMLHttpRequestEventTarget","patchXHR","XHR_TASK","XHR_SYNC","XHR_LISTENER","XHR_SCHEDULED","XHR_URL","XHR_ERROR_BEFORE_SCHEDULED","XMLHttpRequest","XMLHttpRequestPrototype","findPendingTask","oriAddListener","oriRemoveListener","XMLHttpRequestEventTargetPrototype","READY_STATE_CHANGE","SCHEDULED","newListener","loadTasks","oriInvoke","sendNative","placeholderCallback","abortNative","openNative","XMLHTTPREQUEST_SOURCE","fetchTaskAborting","fetchTaskScheduling","findPromiseRejectionHandler","e","PromiseRejectionEvent","evt","patchPromise","readableObjectToString","_uncaughtPromiseErrors","isDisableWrappingUncaughtPromiseRejection","creationTrace","rejection","uncaughtPromiseError","handleUnhandledRejection","UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL","handler","isThenable","forwardResolution","forwardRejection","ZoneAwarePromise","symbolState","symbolValue","symbolFinally","symbolParentPromiseValue","symbolParentPromiseState","UNRESOLVED","RESOLVED","REJECTED","REJECTED_NO_CATCH","makeResolver","promise","v","resolvePromise","wasCalled","wrappedFunction","TYPE_ERROR","CURRENT_TASK_TRACE_SYMBOL","onceWrapper","then","clearRejectedNoCatch","trace","scheduleResolveOrReject","REJECTION_HANDLED_HANDLER","chainPromise","onFulfilled","onRejected","promiseState","parentPromiseValue","isFinallyPromise","ZONE_AWARE_PROMISE_TO_STRING","AggregateError","res","rej","values","promises","finished","resolve","reject","onResolve","onReject","unresolvedCount","valueIndex","resolvedValues","curValueIndex","thenErr","executor","C","onFinally","NativePromise","symbolThenPatched","patchThen","Ctor","originalThen","zoneify","resultPromise","ctor","patchToString","originalFunctionToString","ORIGINAL_DELEGATE_SYMBOL","PROMISE_SYMBOL","ERROR_SYMBOL","newFunctionToString","originalDelegate","nativePromise","nativeError","originalObjectToString","PROMISE_OBJECT_TO_STRING","patchCallbacks","targetName","method","nativeDelegate","opts","descriptor","patchUtil","SYMBOL_BLACK_LISTED_EVENTS","SYMBOL_UNPATCHED_EVENTS","patchCommon","Zone$1"],"x_google_ignoreList":[177]}